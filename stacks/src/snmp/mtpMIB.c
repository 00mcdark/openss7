/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>

/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */

/* These are messed up on both. */
#include "ds_agent.h"

#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */

#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */

/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */

#include "mtpMIB_openss7.h"

#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */

#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>

#ifdef _GNU_SOURCE
#include <getopt.h>
#endif

static const char sa_program[] = "mtpmib";

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))

#if !defined MODULE
static int sa_dump = 0;			/* default packet dump */
static int sa_debug = 0;		/* default no debug */
static int sa_nomead = 1;		/* default daemon mode */
static int sa_output = 1;		/* default normal output */
static int sa_agentx = 1;		/* default agentx mode */
static int sa_alarms = 1;		/* default application alarms */
static int sa_fclose = 1;		/* default close files between requests */

static int sa_logaddr = 0;		/* log addresses */
static int sa_logfillog = 0;		/* log to sa_logfile */
static int sa_logstderr = 0;		/* log to standard error */
static int sa_logstdout = 0;		/* log to standard output */
static int sa_logsyslog = 0;		/* log to system logs */
static int sa_logcallog = 0;		/* log to callback logs */
static int sa_appendlog = 0;		/* append to log file without truncating */

static char sa_logfile[256] = "/var/log/mtpmib.log";
static char sa_pidfile[256] = "/var/run/mtpmib.pid";
static char sa_sysctlf[256] = "/etc/mtpmib.conf";

int allow_severity = LOG_ERR;
int deny_severity = LOG_ERR;

/* file stream for log file */
static FILE *stdlog = NULL;

/* file descriptor for MIB use */
static int sa_fd = 0;

/* indication to reread MIB configuration */
static int sa_changed = 1;

/* indications that statistics, the mib or its tables need to be refreshed */
static int sa_stats_refresh = 1;
#endif				/* !defined MODULE */

/* request number for per-request actions */
static int sa_request = 1;

static volatile int mtpMIB_refresh = 1;
static volatile int mtpSapTable_refresh = 1;
static volatile int mtpSap2AddressTable_refresh = 1;
static volatile int mtpSapUserEntityNamesTable_refresh = 1;
static volatile int mtpSapProviderEntityNamesTable_refresh = 1;
static volatile int mtpNaTable_refresh = 1;
static volatile int mtpGsTable_refresh = 1;
static volatile int mtpGsLineTable_refresh = 1;
static volatile int mtpGsLineContentTable_refresh = 1;
static volatile int mtpSpProfileTable_refresh = 1;
static volatile int mtpSpTable_refresh = 1;
static volatile int mtpSpCurrentTable_refresh = 1;
static volatile int mtpSpInt5minTable_refresh = 1;
static volatile int mtpSpInt15minTable_refresh = 1;
static volatile int mtpSpSiTable_refresh = 1;
static volatile int mtpSpSiInt5minTable_refresh = 1;
static volatile int mtpSpSiInt15minTable_refresh = 1;
static volatile int mtpSpStudyTable_refresh = 1;
static volatile int mtpSpStudyInt5minTable_refresh = 1;
static volatile int mtpSpStudyInt15minTable_refresh = 1;
static volatile int mtpSpStudyMapTable_refresh = 1;
static volatile int mtpL3Table_refresh = 1;
static volatile int mtpRsTable_refresh = 1;
static volatile int mtpRsCurrentTable_refresh = 1;
static volatile int mtpRsInt5minTable_refresh = 1;
static volatile int mtpRsInt15minTable_refresh = 1;
static volatile int mtpRsSiTable_refresh = 1;
static volatile int mtpRsSiInt5minTable_refresh = 1;
static volatile int mtpRsSiInt15minTable_refresh = 1;
static volatile int mtpRtTable_refresh = 1;
static volatile int mtpRtLsaTable_refresh = 1;
static volatile int mtpLsProfileTable_refresh = 1;
static volatile int mtpLsTable_refresh = 1;
static volatile int mtpLsCurrentTable_refresh = 1;
static volatile int mtpLsInt5minTable_refresh = 1;
static volatile int mtpLsInt15minTable_refresh = 1;
static volatile int mtpSlProfileTable_refresh = 1;
static volatile int mtpSlTable_refresh = 1;
static volatile int mtpSlSdlListTable_refresh = 1;
static volatile int mtpSlSdtListTable_refresh = 1;
static volatile int mtpSlCurrentTable_refresh = 1;
static volatile int mtpSlInt5minTable_refresh = 1;
static volatile int mtpSlInt15minTable_refresh = 1;
static volatile int mtpL2ProfileTable_refresh = 1;
static volatile int mtpNbandTable_refresh = 1;
static volatile int mtpSaalTable_refresh = 1;
static volatile int mtpM2paTable_refresh = 1;
static volatile int mtpSdtTable_refresh = 1;
static volatile int mtpSdlTable_refresh = 1;

/* 
 * mtpMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid mtpMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1 };
oid mtpSapTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 1, 1, 1 };
oid mtpNaTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 2, 1, 1 };
oid mtpGsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 3, 1, 1 };
oid mtpGsLineTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 3, 2, 1 };
oid mtpGsLineContentTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 3, 3, 1 };
oid mtpSpProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 4, 1, 1 };
oid mtpSpTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 4, 2, 1 };
oid mtpSpSiTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 4, 6, 1 };
oid mtpSpStudyTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 4, 9, 1 };
oid mtpSpStudyMapTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 4, 12, 1 };
oid mtpL3Table_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 5, 1, 1 };
oid mtpRsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 1, 1 };
oid mtpRsSiTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 5, 1 };
oid mtpRtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 7, 1, 1 };
oid mtpLsProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 8, 1, 1 };
oid mtpLsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 8, 2, 1 };
oid mtpSlProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 9, 1, 1 };
oid mtpSlTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 9, 2, 1 };
oid mtpSlSdlListTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 9, 3, 1 };
oid mtpSlSdtListTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 9, 4, 1 };
oid mtpL2ProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 1, 1 };
oid mtpNbandTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 2, 1 };
oid mtpSaalTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 3, 1 };
oid mtpM2paTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 4, 1 };
oid mtpSdtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 1, 1 };
oid mtpSdlTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 12, 1, 1 };

/* 
 * variable7 mtpMIB_variables:
 *   this variable defines function callbacks and type return information 
 *   for the mtpMIB mib section 
 */

struct variable7 mtpMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   MTPSAP2ADDRESS        5
	{MTPSAP2ADDRESS, ASN_UNSIGNED, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 2}},
#define   MTPSAPUSERENTITYNAMES  6
	{MTPSAPUSERENTITYNAMES, ASN_UNSIGNED, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 3}},
#define   MTPSAPPROVIDERENTITYNAMES  7
	{MTPSAPPROVIDERENTITYNAMES, ASN_UNSIGNED, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 4}},
#define   MTPSAPASAPROFILEPOINTER  8
	{MTPSAPASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 5}},
#define   MTPSAPNAME            9
	{MTPSAPNAME, ASN_OCTET_STR, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 6}},
#define   MTPSAPLONGMESSAGESUPPORTED  10
	{MTPSAPLONGMESSAGESUPPORTED, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 7}},
#define   MTPSAPROWSTATUS       11
	{MTPSAPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 8}},
#define   MTPSAP2ADDRESSCOMPONENT  17
	{MTPSAP2ADDRESSCOMPONENT, ASN_OCTET_STR, RONLY, var_mtpSap2AddressTable, 6, {1, 1, 1, 2, 1, 2}},
#define   MTPSAPUSERENTITYNAME  23
	{MTPSAPUSERENTITYNAME, ASN_OBJECT_ID, RONLY, var_mtpSapUserEntityNamesTable, 6, {1, 1, 1, 3, 1, 2}},
#define   MTPSAPPROVIDERENTITYNAME  29
	{MTPSAPPROVIDERENTITYNAME, ASN_OBJECT_ID, RONLY, var_mtpSapProviderEntityNamesTable, 6, {1, 1, 1, 4, 1, 2}},
#define   MTPNAPROTOCOLVARIANT  33
	{MTPNAPROTOCOLVARIANT, ASN_OBJECT_ID, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 2}},
#define   MTPNAPROTOCOLYEAR     34
	{MTPNAPROTOCOLYEAR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 3}},
#define   MTPNAPROTOCOLOPTIONS  35
	{MTPNAPROTOCOLOPTIONS, ASN_BIT_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 4}},
#define   MTPNANETWORKINDICATOR  36
	{MTPNANETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 5}},
#define   MTPNAPOINTCODEFORMAT  37
	{MTPNAPOINTCODEFORMAT, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 6}},
#define   MTPNASLSLENGTH        38
	{MTPNASLSLENGTH, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 7}},
#define   MTPNASPPROFILEPOINTER  39
	{MTPNASPPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 8}},
#define   MTPNANAME             40
	{MTPNANAME, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 9}},
#define   MTPNAROWSTATUS        41
	{MTPNAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 10}},
#define   MTPGSADMINISTRATIVESTATE  46
	{MTPGSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 3, 1, 1, 2}},
#define   MTPGSTREATMENTOFOUTSIDERANGES  47
	{MTPGSTREATMENTOFOUTSIDERANGES, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 3, 1, 1, 3}},
#define   MTPGSLISTMODE         48
	{MTPGSLISTMODE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 3, 1, 1, 4}},
#define   MTPGSSCREENINGBYLINKSETORBYOPC  49
	{MTPGSSCREENINGBYLINKSETORBYOPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 3, 1, 1, 5}},
#define   MTPGSGETSCREENEDOPCSORLINKSETSBYDPC  50
	{MTPGSGETSCREENEDOPCSORLINKSETSBYDPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 3, 1, 1, 6}},
#define   MTPGSNAME             51
	{MTPGSNAME, ASN_OCTET_STR, RWRITE, var_mtpGsTable, 6, {1, 1, 3, 1, 1, 7}},
#define   MTPGSROWSTATUS        52
	{MTPGSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 3, 1, 1, 8}},
#define   MTPGSLINECONTENT      58
	{MTPGSLINECONTENT, ASN_UNSIGNED, RONLY, var_mtpGsLineTable, 6, {1, 1, 3, 2, 1, 2}},
#define   MTPGSLINEROWSTATUS    59
	{MTPGSLINEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineTable, 6, {1, 1, 3, 2, 1, 3}},
#define   MTPGSLINECONTENTDESIGNATEDDPCLAST  66
	{MTPGSLINECONTENTDESIGNATEDDPCLAST, ASN_UNSIGNED, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 3, 3, 1, 2}},
#define   MTPGSLINECONTENTMESSAGETREATMENT  67
	{MTPGSLINECONTENTMESSAGETREATMENT, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 3, 3, 1, 3}},
#define   MTPGSLINECONTENTROWSTATUS  68
	{MTPGSLINECONTENTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 3, 3, 1, 4}},
#define   MTPSPPROFILEMTPT2     72
	{MTPSPPROFILEMTPT2, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 2}},
#define   MTPSPPROFILEMTPT4     73
	{MTPSPPROFILEMTPT4, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 3}},
#define   MTPSPPROFILEMTPT5     74
	{MTPSPPROFILEMTPT5, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 4}},
#define   MTPSPPROFILEMTPT7     75
	{MTPSPPROFILEMTPT7, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 5}},
#define   MTPSPPROFILEMTPT11    76
	{MTPSPPROFILEMTPT11, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 6}},
#define   MTPSPPROFILEMTPT12    77
	{MTPSPPROFILEMTPT12, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 7}},
#define   MTPSPPROFILEMTPT13    78
	{MTPSPPROFILEMTPT13, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 8}},
#define   MTPSPPROFILEMTPT14    79
	{MTPSPPROFILEMTPT14, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 9}},
#define   MTPSPPROFILEMTPT15    80
	{MTPSPPROFILEMTPT15, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 10}},
#define   MTPSPPROFILEMTPT16    81
	{MTPSPPROFILEMTPT16, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 11}},
#define   MTPSPPROFILEMTPT18    82
	{MTPSPPROFILEMTPT18, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 12}},
#define   MTPSPPROFILEMTPT19    83
	{MTPSPPROFILEMTPT19, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 13}},
#define   MTPSPPROFILEMTPT20    84
	{MTPSPPROFILEMTPT20, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 14}},
#define   MTPSPPROFILEMTPT21    85
	{MTPSPPROFILEMTPT21, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 15}},
#define   MTPSPPROFILEMTPT22    86
	{MTPSPPROFILEMTPT22, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 16}},
#define   MTPSPPROFILEMTPT23    87
	{MTPSPPROFILEMTPT23, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 17}},
#define   MTPSPPROFILEMTPT20A   88
	{MTPSPPROFILEMTPT20A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 18}},
#define   MTPSPPROFILEMTPT21A   89
	{MTPSPPROFILEMTPT21A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 19}},
#define   MTPSPPROFILEMTPT1T    90
	{MTPSPPROFILEMTPT1T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 20}},
#define   MTPSPPROFILEMTPT2T    91
	{MTPSPPROFILEMTPT2T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 21}},
#define   MTPSPPROFILENAME      92
	{MTPSPPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 22}},
#define   MTPSPPROFILEROWSTATUS  93
	{MTPSPPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 23}},
#define   MTPSPPOINTCODE        97
	{MTPSPPOINTCODE, ASN_UNSIGNED, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 2}},
#define   MTPSPTYPE             98
	{MTPSPTYPE, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 3}},
#define   MTPSPOPERATIONALSTATE  99
	{MTPSPOPERATIONALSTATE, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 4}},
#define   MTPSPPROCEDURALSTATUS  100
	{MTPSPPROCEDURALSTATUS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 5}},
#define   MTPSPAVAILABILITYSTATUS  101
	{MTPSPAVAILABILITYSTATUS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 6}},
#define   MTPSPVERSION          102
	{MTPSPVERSION, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 7}},
#define   MTPSPNETWORKINDICATOR  103
	{MTPSPNETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 8}},
#define   MTPSPNAME             104
	{MTPSPNAME, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 9}},
#define   MTPSPMTPT1            105
	{MTPSPMTPT1, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 10}},
#define   MTPSPMTPT2            106
	{MTPSPMTPT2, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 11}},
#define   MTPSPMTPT3            107
	{MTPSPMTPT3, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 12}},
#define   MTPSPMTPT4            108
	{MTPSPMTPT4, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 13}},
#define   MTPSPMTPT5            109
	{MTPSPMTPT5, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 14}},
#define   MTPSPMTPT6            110
	{MTPSPMTPT6, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 15}},
#define   MTPSPMTPT7            111
	{MTPSPMTPT7, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 16}},
#define   MTPSPMTPT8            112
	{MTPSPMTPT8, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 17}},
#define   MTPSPMTPT10           113
	{MTPSPMTPT10, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 18}},
#define   MTPSPMTPT11           114
	{MTPSPMTPT11, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 19}},
#define   MTPSPMTPT12           115
	{MTPSPMTPT12, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 20}},
#define   MTPSPMTPT13           116
	{MTPSPMTPT13, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 21}},
#define   MTPSPMTPT14           117
	{MTPSPMTPT14, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 22}},
#define   MTPSPMTPT15           118
	{MTPSPMTPT15, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 23}},
#define   MTPSPMTPT16           119
	{MTPSPMTPT16, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 24}},
#define   MTPSPMTPT17           120
	{MTPSPMTPT17, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 25}},
#define   MTPSPMTPT19A          121
	{MTPSPMTPT19A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 26}},
#define   MTPSPMTPT31A          122
	{MTPSPMTPT31A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 27}},
#define   MTPSPMTPT32A          123
	{MTPSPMTPT32A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 28}},
#define   MTPSPMTPT33A          124
	{MTPSPMTPT33A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 29}},
#define   MTPSPMTPT34A          125
	{MTPSPMTPT34A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 30}},
#define   MTPSPMTPT18           126
	{MTPSPMTPT18, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 31}},
#define   MTPSPMTPT19           127
	{MTPSPMTPT19, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 32}},
#define   MTPSPMTPT20           128
	{MTPSPMTPT20, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 33}},
#define   MTPSPMTPT21           129
	{MTPSPMTPT21, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 34}},
#define   MTPSPMTPT22           130
	{MTPSPMTPT22, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 35}},
#define   MTPSPMTPT23           131
	{MTPSPMTPT23, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 36}},
#define   MTPSPMTPT20A          132
	{MTPSPMTPT20A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 37}},
#define   MTPSPMTPT21A          133
	{MTPSPMTPT21A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 38}},
#define   MTPSPMTPT24           134
	{MTPSPMTPT24, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 39}},
#define   MTPSPMTPT1T           135
	{MTPSPMTPT1T, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 40}},
#define   MTPSPMTPT2T           136
	{MTPSPMTPT2T, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 41}},
#define   MTPSPMTPT1S           137
	{MTPSPMTPT1S, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 42}},
#define   MTPSPPROFILEPOINTER   138
	{MTPSPPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 43}},
#define   MTPSPNAPOINTER        139
	{MTPSPNAPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 44}},
#define   MTPSPROWSTATUS        140
	{MTPSPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 45}},
#define   MTPSPCURRENTVALIDINTERVALS  143
	{MTPSPCURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 4, 3, 1, 1}},
#define   MTPSPCURRENTTIMEDISCONTINUITY  144
	{MTPSPCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 4, 3, 1, 2}},
#define   MTPSPCURRENTDISCARDEDMSUS  145
	{MTPSPCURRENTDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 4, 3, 1, 3}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS0  146
	{MTPSPCURRENTRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 4, 3, 1, 4}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS1  147
	{MTPSPCURRENTRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 4, 3, 1, 5}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS2  148
	{MTPSPCURRENTRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 4, 3, 1, 6}},
#define   MTPSPCURRENTOCTETSXFERRED  149
	{MTPSPCURRENTOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 4, 3, 1, 7}},
#define   MTPSPINT5MINTIMESTAMP  153
	{MTPSPINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 4, 4, 1, 2}},
#define   MTPSPINT5MINDISCARDEDMSUS  154
	{MTPSPINT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 4, 4, 1, 3}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS0  155
	{MTPSPINT5MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 4, 4, 1, 4}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS1  156
	{MTPSPINT5MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 4, 4, 1, 5}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS2  157
	{MTPSPINT5MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 4, 4, 1, 6}},
#define   MTPSPINT5MINOCTETSXFERRED  158
	{MTPSPINT5MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 4, 4, 1, 7}},
#define   MTPSPINT15MINTIMESTAMP  162
	{MTPSPINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 4, 5, 1, 2}},
#define   MTPSPINT15MINDISCARDEDMSUS  163
	{MTPSPINT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 4, 5, 1, 3}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS0  164
	{MTPSPINT15MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 4, 5, 1, 4}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS1  165
	{MTPSPINT15MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 4, 5, 1, 5}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS2  166
	{MTPSPINT15MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 4, 5, 1, 6}},
#define   MTPSPINT15MINOCTETSXFERRED  167
	{MTPSPINT15MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 4, 5, 1, 7}},
#define   MTPSPSIVALIDINTERVALS  171
	{MTPSPSIVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpSiTable, 6, {1, 1, 4, 6, 1, 2}},
#define   MTPSPSITIMEDISCONTINUITY  172
	{MTPSPSITIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpSiTable, 6, {1, 1, 4, 6, 1, 3}},
#define   MTPSPSITRANSMITTEDUPUNAVAILABLE  173
	{MTPSPSITRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 4, 6, 1, 4}},
#define   MTPSPSIRECEIVEDUPUNAVAILABLE  174
	{MTPSPSIRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 4, 6, 1, 5}},
#define   MTPSPSIHANDLEDOCTETSSIO  175
	{MTPSPSIHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 4, 6, 1, 6}},
#define   MTPSPSISTATUS         176
	{MTPSPSISTATUS, ASN_INTEGER, RWRITE, var_mtpSpSiTable, 6, {1, 1, 4, 6, 1, 7}},
#define   MTPSPSIINT5MINTIMESTAMP  181
	{MTPSPSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 4, 7, 1, 2}},
#define   MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE  182
	{MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 4, 7, 1, 3}},
#define   MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE  183
	{MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 4, 7, 1, 4}},
#define   MTPSPSIINT5MINHANDLEDOCTETSSIO  184
	{MTPSPSIINT5MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 4, 7, 1, 5}},
#define   MTPSPSIINT15MINTIMESTAMP  189
	{MTPSPSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 4, 8, 1, 2}},
#define   MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE  190
	{MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 4, 8, 1, 3}},
#define   MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE  191
	{MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 4, 8, 1, 4}},
#define   MTPSPSIINT15MINHANDLEDOCTETSSIO  192
	{MTPSPSIINT15MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 4, 8, 1, 5}},
#define   MTPSPSTUDYVALIDINTERVALS  196
	{MTPSPSTUDYVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpStudyTable, 6, {1, 1, 4, 9, 1, 2}},
#define   MTPSPSTUDYTIMEDISCONTINUITY  197
	{MTPSPSTUDYTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpStudyTable, 6, {1, 1, 4, 9, 1, 3}},
#define   MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO  198
	{MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyTable, 6, {1, 1, 4, 9, 1, 4}},
#define   MTPSPSTUDYHANDLEDMSUSOPCDPCSIO  199
	{MTPSPSTUDYHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyTable, 6, {1, 1, 4, 9, 1, 5}},
#define   MTPSPSTUDYSTATUS      200
	{MTPSPSTUDYSTATUS, ASN_INTEGER, RWRITE, var_mtpSpStudyTable, 6, {1, 1, 4, 9, 1, 6}},
#define   MTPSPSTUDYINT5MINTIMESTAMP  205
	{MTPSPSTUDYINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 4, 10, 1, 2}},
#define   MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO  206
	{MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 4, 10, 1, 3}},
#define   MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO  207
	{MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 4, 10, 1, 4}},
#define   MTPSPSTUDYINT15MININTERVAL  212
	{MTPSPSTUDYINT15MININTERVAL, ASN_TIMETICKS, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 4, 11, 1, 2}},
#define   MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO  213
	{MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 4, 11, 1, 3}},
#define   MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO  214
	{MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 4, 11, 1, 4}},
#define   MTPSPSTUDYMAPSTATUS   219
	{MTPSPSTUDYMAPSTATUS, ASN_INTEGER, RWRITE, var_mtpSpStudyMapTable, 6, {1, 1, 4, 12, 1, 1}},
#define   MTPL3ADMINISTRATIVESTATE  223
	{MTPL3ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 2}},
#define   MTPL3OPERATIONALSTATE  224
	{MTPL3OPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 3}},
#define   MTPL3USAGESTATE       225
	{MTPL3USAGESTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 4}},
#define   MTPL3PROCEDURALSTATUS  226
	{MTPL3PROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 5}},
#define   MTPL3ASAPROFILEPOINTER  227
	{MTPL3ASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 6}},
#define   MTPL3NAME             228
	{MTPL3NAME, ASN_OCTET_STR, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 7}},
#define   MTPL3ROWSTATUS        229
	{MTPL3ROWSTATUS, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 8}},
#define   MTPRSADMINISTRATIVESTATE  234
	{MTPRSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 1, 1, 2}},
#define   MTPRSOPERATIONALSTATE  235
	{MTPRSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 6, 1, 1, 3}},
#define   MTPRSASAPROFILEPOINTER  236
	{MTPRSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 1, 1, 4}},
#define   MTPRSCONGESTEDSTATE   237
	{MTPRSCONGESTEDSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 6, 1, 1, 5}},
#define   MTPRSCONGESTIONLEVEL  238
	{MTPRSCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 6, 1, 1, 6}},
#define   MTPRSLOADSHARINGINFORMATION  239
	{MTPRSLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 1, 1, 7}},
#define   MTPRSLOADSHARINGOBJECT  240
	{MTPRSLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 1, 1, 8}},
#define   MTPRSREMOTEEXCHANGELABEL  241
	{MTPRSREMOTEEXCHANGELABEL, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 1, 1, 9}},
#define   MTPRSNAME             242
	{MTPRSNAME, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 1, 1, 10}},
#define   MTPRSROWSTATUS        243
	{MTPRSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 1, 1, 11}},
#define   MTPRSCURRENTVALIDINTERVALS  246
	{MTPRSCURRENTVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 2, 1, 1}},
#define   MTPRSCURRENTTIMEDISCONTINUITY  247
	{MTPRSCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 2, 1, 2}},
#define   MTPRSCURRENTRECEIVEDOCTETSOPC  248
	{MTPRSCURRENTRECEIVEDOCTETSOPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 2, 1, 3}},
#define   MTPRSCURRENTTRANSMITTEDOCTETSDPC  249
	{MTPRSCURRENTTRANSMITTEDOCTETSDPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 2, 1, 4}},
#define   MTPRSCURRENTRECEIVEDMSUSOPC  250
	{MTPRSCURRENTRECEIVEDMSUSOPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 2, 1, 5}},
#define   MTPRSCURRENTTRANSMITTEDMSUSDPC  251
	{MTPRSCURRENTTRANSMITTEDMSUSDPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 2, 1, 6}},
#define   MTPRSCURRENTROUTESETUNAVAILABLE  252
	{MTPRSCURRENTROUTESETUNAVAILABLE, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 2, 1, 7}},
#define   MTPRSCURRENTROUTESETUNAVAILABLEDURATION  253
	{MTPRSCURRENTROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 2, 1, 8}},
#define   MTPRSINT5MINTIMESTAMP  257
	{MTPRSINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 3, 1, 2}},
#define   MTPRSINT5MINRECEIVEDOCTETSOPC  258
	{MTPRSINT5MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 3, 1, 3}},
#define   MTPRSINT5MINTRANSMITTEDOCTETSDPC  259
	{MTPRSINT5MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 3, 1, 4}},
#define   MTPRSINT5MINRECEIVEDMSUSOPC  260
	{MTPRSINT5MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 3, 1, 5}},
#define   MTPRSINT5MINTRANSMITTEDMSUSDPC  261
	{MTPRSINT5MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 3, 1, 6}},
#define   MTPRSINT5MINROUTESETUNAVAILABLE  262
	{MTPRSINT5MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 3, 1, 7}},
#define   MTPRSINT5MINROUTESETUNAVAILABLEDURATION  263
	{MTPRSINT5MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 3, 1, 8}},
#define   MTPRSINT15MINTIMESTAMP  267
	{MTPRSINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 4, 1, 2}},
#define   MTPRSINT15MINRECEIVEDOCTETSOPC  268
	{MTPRSINT15MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 4, 1, 3}},
#define   MTPRSINT15MINTRANSMITTEDOCTETSDPC  269
	{MTPRSINT15MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 4, 1, 4}},
#define   MTPRSINT15MINRECEIVEDMSUSOPC  270
	{MTPRSINT15MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 4, 1, 5}},
#define   MTPRSINT15MINTRANSMITTEDMSUSDPC  271
	{MTPRSINT15MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 4, 1, 6}},
#define   MTPRSINT15MINROUTESETUNAVAILABLE  272
	{MTPRSINT15MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 4, 1, 7}},
#define   MTPRSINT15MINROUTESETUNAVAILABLEDURATION  273
	{MTPRSINT15MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 4, 1, 8}},
#define   MTPRSSIVALIDINTERVALS  277
	{MTPRSSIVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 5, 1, 2}},
#define   MTPRSSITIMEDISCONTINUITY  278
	{MTPRSSITIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 5, 1, 3}},
#define   MTPRSSIRECEIVEDOCTETSOPCSIO  279
	{MTPRSSIRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 5, 1, 4}},
#define   MTPRSSITRANSMITTEDOCTETSDPCSIO  280
	{MTPRSSITRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 5, 1, 5}},
#define   MTPRSSIRECEIVEDMSUSOPCSIO  281
	{MTPRSSIRECEIVEDMSUSOPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 5, 1, 6}},
#define   MTPRSSITRANSMITTEDMSUSDPCSIO  282
	{MTPRSSITRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 5, 1, 7}},
#define   MTPRSSISTATUS         283
	{MTPRSSISTATUS, ASN_INTEGER, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 5, 1, 8}},
#define   MTPRSSIINT5MINTIMESTAMP  288
	{MTPRSSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 6, 6, 1, 3}},
#define   MTPRSSIINT5MINTIMESTAMP  289
	{MTPRSSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 6, 6, 1, 3}},
#define   MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO  290
	{MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 6, 6, 1, 4}},
#define   MTPRSSIINT5MINRECEIVEDMSUSOPCSIO  291
	{MTPRSSIINT5MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 6, 6, 1, 5}},
#define   MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO  292
	{MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 6, 6, 1, 6}},
#define   MTPRSSIINT15MINTIMESTAMP  297
	{MTPRSSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 6, 7, 1, 2}},
#define   MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO  298
	{MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 6, 7, 1, 3}},
#define   MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO  299
	{MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 6, 7, 1, 4}},
#define   MTPRSSIINT15MINRECEIVEDMSUSOPCSIO  300
	{MTPRSSIINT15MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 6, 7, 1, 5}},
#define   MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO  301
	{MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 6, 7, 1, 6}},
#define   MTPRTLSPOINTER        307
	{MTPRTLSPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 2}},
#define   MTPRTADMINISTRATIVESTATE  308
	{MTPRTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 3}},
#define   MTPRTOPERATIONALSTATE  309
	{MTPRTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 4}},
#define   MTPRTAVAILABILITYSTATUS  310
	{MTPRTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 5}},
#define   MTPRTINCLSLOADSHARINGALGORITHM  311
	{MTPRTINCLSLOADSHARINGALGORITHM, ASN_UNSIGNED, RONLY, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 6}},
#define   MTPRTFIXEDPRIORITY    312
	{MTPRTFIXEDPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 7}},
#define   MTPRTFLEXIBLEPRIORITY  313
	{MTPRTFLEXIBLEPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 8}},
#define   MTPRTPRIORITYMODE     314
	{MTPRTPRIORITYMODE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 9}},
#define   MTPRTLOADSHARINGINFORMATION  315
	{MTPRTLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 10}},
#define   MTPRTLOADSHARINGOBJECT  316
	{MTPRTLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 11}},
#define   MTPRTNAME             317
	{MTPRTNAME, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 12}},
#define   MTPRTSLSLIST          318
	{MTPRTSLSLIST, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 13}},
#define   MTPRTUSAGESTATE       319
	{MTPRTUSAGESTATE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 14}},
#define   MTPRTROWSTATUS        320
	{MTPRTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 7, 1, 1, 15}},
#define   MTPRTLSANORMALSLCODE  327
	{MTPRTLSANORMALSLCODE, ASN_UNSIGNED, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 7, 2, 1, 2}},
#define   MTPRTLSAALTERNATIVESLCODELIST  328
	{MTPRTLSAALTERNATIVESLCODELIST, ASN_OCTET_STR, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 7, 2, 1, 3}},
#define   MTPLSPROFILEMTPT6     332
	{MTPLSPROFILEMTPT6, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 8, 1, 1, 2}},
#define   MTPLSPROFILEMTPT8     333
	{MTPLSPROFILEMTPT8, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 8, 1, 1, 3}},
#define   MTPLSPROFILEMTPT10    334
	{MTPLSPROFILEMTPT10, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 8, 1, 1, 4}},
#define   MTPLSPROFILENAME      335
	{MTPLSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 8, 1, 1, 5}},
#define   MTPLSPROFILEROWSTATUS  336
	{MTPLSPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 8, 1, 1, 6}},
#define   MTPLSADJPC            341
	{MTPLSADJPC, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 2}},
#define   MTPLSMAXCAPACITY      342
	{MTPLSMAXCAPACITY, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 3}},
#define   MTPLSCURRENTCAPACITY  343
	{MTPLSCURRENTCAPACITY, ASN_GAUGE, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 4}},
#define   MTPLSCONGESTIONCONTROLMETHOD  344
	{MTPLSCONGESTIONCONTROLMETHOD, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 5}},
#define   MTPLSUSAGESTATE       345
	{MTPLSUSAGESTATE, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 6}},
#define   MTPLSOPERATIONALSTATE  346
	{MTPLSOPERATIONALSTATE, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 7}},
#define   MTPLSAVAILABILITYSTATUS  347
	{MTPLSAVAILABILITYSTATUS, ASN_BIT_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 8}},
#define   MTPLSPERIODICLINKTESTFLAG  348
	{MTPLSPERIODICLINKTESTFLAG, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 9}},
#define   MTPLSADMINISTRATIVESTATE  349
	{MTPLSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 10}},
#define   MTPLSINLSLOADSHAREALGORITHM  350
	{MTPLSINLSLOADSHAREALGORITHM, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 11}},
#define   MTPLSPROFILEPOINTER   351
	{MTPLSPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 12}},
#define   MTPLSNUMNORMACTSLS    352
	{MTPLSNUMNORMACTSLS, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 13}},
#define   MTPLSNAME             353
	{MTPLSNAME, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 14}},
#define   MTPLSASAPROFILEPOINTER  354
	{MTPLSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 15}},
#define   MTPLSROWSTATUS        355
	{MTPLSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 8, 2, 1, 16}},
#define   MTPLSCURRENTVALIDINTERVALS  358
	{MTPLSCURRENTVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpLsCurrentTable, 6, {1, 1, 8, 3, 1, 1}},
#define   MTPLSCURRENTTIMEDISCONTINUITY  359
	{MTPLSCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpLsCurrentTable, 6, {1, 1, 8, 3, 1, 2}},
#define   MTPLSCURRENTADJACENTINACCESSIBLEEVENTS  360
	{MTPLSCURRENTADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RWRITE, var_mtpLsCurrentTable, 6, {1, 1, 8, 3, 1, 3}},
#define   MTPLSCURRENTADJACENTINACCESSIBLEDURATION  361
	{MTPLSCURRENTADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RWRITE, var_mtpLsCurrentTable, 6, {1, 1, 8, 3, 1, 4}},
#define   MTPLSCURRENTSLSUNAVAILABLE  362
	{MTPLSCURRENTSLSUNAVAILABLE, ASN_GAUGE, RWRITE, var_mtpLsCurrentTable, 6, {1, 1, 8, 3, 1, 5}},
#define   MTPLSINT15MINTIMESTAMP  373
	{MTPLSINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 8, 5, 1, 2}},
#define   MTPLSINT15MINADJACENTINACCESSIBLEEVENTS  374
	{MTPLSINT15MINADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 8, 5, 1, 3}},
#define   MTPLSINT15MINADJACENTINACCESSIBLEDURATION  375
	{MTPLSINT15MINADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 8, 5, 1, 4}},
#define   MTPLSINT15MINSLSUNAVAILABLE  376
	{MTPLSINT15MINSLSUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 8, 5, 1, 5}},
#define   MTPSLPROFILETIMERT1   380
	{MTPSLPROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 2}},
#define   MTPSLPROFILETIMERT3   381
	{MTPSLPROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 3}},
#define   MTPSLPROFILETIMERT17  382
	{MTPSLPROFILETIMERT17, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 4}},
#define   MTPSLPROFILETIMERT24  383
	{MTPSLPROFILETIMERT24, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 5}},
#define   MTPSLPROFILENAME      384
	{MTPSLPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 6}},
#define   MTPSLPROFILETIMERT2   385
	{MTPSLPROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 7}},
#define   MTPSLPROFILETIMERT4   386
	{MTPSLPROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 8}},
#define   MTPSLPROFILETIMERT5   387
	{MTPSLPROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 9}},
#define   MTPSLPROFILETIMERT12  388
	{MTPSLPROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 10}},
#define   MTPSLPROFILETIMERT13  389
	{MTPSLPROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 11}},
#define   MTPSLPROFILETIMERT14  390
	{MTPSLPROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 12}},
#define   MTPSLPROFILETIMERT19A  391
	{MTPSLPROFILETIMERT19A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 13}},
#define   MTPSLPROFILETIMERT20A  392
	{MTPSLPROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 14}},
#define   MTPSLPROFILETIMERT21A  393
	{MTPSLPROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 15}},
#define   MTPSLPROFILETIMERT22  394
	{MTPSLPROFILETIMERT22, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 16}},
#define   MTPSLPROFILETIMERT23  395
	{MTPSLPROFILETIMERT23, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 17}},
#define   MTPSLPROFILETIMERT31A  396
	{MTPSLPROFILETIMERT31A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 18}},
#define   MTPSLPROFILETIMERT32A  397
	{MTPSLPROFILETIMERT32A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 19}},
#define   MTPSLPROFILETIMERT33A  398
	{MTPSLPROFILETIMERT33A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 20}},
#define   MTPSLPROFILETIMERT34A  399
	{MTPSLPROFILETIMERT34A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 21}},
#define   MTPSLPROFILETIMERT1T  400
	{MTPSLPROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 22}},
#define   MTPSLPROFILETIMERT2T  401
	{MTPSLPROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 23}},
#define   MTPSLPROFILETIMERT1S  402
	{MTPSLPROFILETIMERT1S, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 24}},
#define   MTPSLPROFILEROWSTATUS  403
	{MTPSLPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 9, 1, 1, 25}},
#define   MTPSLSLSCODECURRENTLIST  409
	{MTPSLSLSCODECURRENTLIST, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 2}},
#define   MTPSLMAXCAPACITY      410
	{MTPSLMAXCAPACITY, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 3}},
#define   MTPSLCURRENTCAPACITY  411
	{MTPSLCURRENTCAPACITY, ASN_GAUGE, RONLY, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 4}},
#define   MTPSLLINKSTATUS       412
	{MTPSLLINKSTATUS, ASN_BIT_STR, RONLY, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 5}},
#define   MTPSLADMINISTRATIVESTATE  413
	{MTPSLADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 6}},
#define   MTPSLOPERATIONALSTATE  414
	{MTPSLOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 7}},
#define   MTPSLUSAGESTATE       415
	{MTPSLUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 8}},
#define   MTPSLPROCEDURALSTATUS  416
	{MTPSLPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 9}},
#define   MTPSLL2PROFILEPOINTER  417
	{MTPSLL2PROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 10}},
#define   MTPSLSDTPOINTER       418
	{MTPSLSDTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 11}},
#define   MTPSLSDLPOINTER       419
	{MTPSLSDLPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 12}},
#define   MTPSLLOCALINHIBIT     420
	{MTPSLLOCALINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 13}},
#define   MTPSLLOCALUNINHIBIT   421
	{MTPSLLOCALUNINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 14}},
#define   MTPSLREPLACEST        422
	{MTPSLREPLACEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 15}},
#define   MTPSLASAPROFILEPOINTER  423
	{MTPSLASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 16}},
#define   MTPSLCONGESTIONLEVEL  424
	{MTPSLCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 17}},
#define   MTPSLRELATEDLINKGROUPNUMBER  425
	{MTPSLRELATEDLINKGROUPNUMBER, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 18}},
#define   MTPSLSDLLIST          426
	{MTPSLSDLLIST, ASN_UNSIGNED, RONLY, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 19}},
#define   MTPSLTEST             427
	{MTPSLTEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 20}},
#define   MTPSLNAME             428
	{MTPSLNAME, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 21}},
#define   MTPSLSDTLIST          429
	{MTPSLSDTLIST, ASN_UNSIGNED, RONLY, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 22}},
#define   MTPSLSLSCODENORMALLIST  430
	{MTPSLSLSCODENORMALLIST, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 23}},
#define   MTPSLPROFILEPOINTER   431
	{MTPSLPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 24}},
#define   MTPSLROWSTATUS        432
	{MTPSLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 9, 2, 1, 25}},
#define   MTPSLSDLLISTPOINTER   439
	{MTPSLSDLLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 9, 3, 1, 2}},
#define   MTPSLSDLLISTROWSTATUS  440
	{MTPSLSDLLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 9, 3, 1, 3}},
#define   MTPSLSDTLISTPOINTER   447
	{MTPSLSDTLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 9, 4, 1, 2}},
#define   MTPSLSDTLISTROWSTATUS  448
	{MTPSLSDTLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 9, 4, 1, 3}},
#define   MTPSLCURRENTVALIDINTERVALS  451
	{MTPSLCURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 1}},
#define   MTPSLCURRENTTIMEDISCONTINUITY  452
	{MTPSLCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 2}},
#define   MTPSLCURRENTSLUNAVAILABILITYDURATION  453
	{MTPSLCURRENTSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 3}},
#define   MTPSLCURRENTSLLOCALINHIBITION  454
	{MTPSLCURRENTSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 4}},
#define   MTPSLCURRENTSLREMOTEINHIBITION  455
	{MTPSLCURRENTSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 5}},
#define   MTPSLCURRENTSLFAILED  456
	{MTPSLCURRENTSLFAILED, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 6}},
#define   MTPSLCURRENTSLREMOTEPROCOUTAGE  457
	{MTPSLCURRENTSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 7}},
#define   MTPSLCURRENTLOCALMGMTINHIBIT  458
	{MTPSLCURRENTLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 8}},
#define   MTPSLCURRENTLOCALMGMTUNINHIBIT  459
	{MTPSLCURRENTLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 9}},
#define   MTPSLCURRENTLOCALBUSY  460
	{MTPSLCURRENTLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 10}},
#define   MTPSLCURRENTSLCONGESTEDSTARTS  461
	{MTPSLCURRENTSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 11}},
#define   MTPSLCURRENTSLCONGESTEDDURATION  462
	{MTPSLCURRENTSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 12}},
#define   MTPSLCURRENTSLCONGESTIONSTOPS  463
	{MTPSLCURRENTSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 13}},
#define   MTPSLCURRENTDISCARDEDMSUS  464
	{MTPSLCURRENTDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 14}},
#define   MTPSLCURRENTCONGESTIONEVENTSMSULOSS  465
	{MTPSLCURRENTCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 15}},
#define   MTPSLCURRENTCHANGEOVERS  466
	{MTPSLCURRENTCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 16}},
#define   MTPSLCURRENTCHANGEBACKS  467
	{MTPSLCURRENTCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 17}},
#define   MTPSLCURRENTRESTORATIONS  468
	{MTPSLCURRENTRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 9, 5, 1, 18}},
#define   MTPSLINT5MINTIMESTAMP  472
	{MTPSLINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 2}},
#define   MTPSLINT5MINSLUNAVAILABILITYDURATION  473
	{MTPSLINT5MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 3}},
#define   MTPSLINT5MINSLLOCALINHIBITION  474
	{MTPSLINT5MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 4}},
#define   MTPSLINT5MINSLREMOTEINHIBITION  475
	{MTPSLINT5MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 5}},
#define   MTPSLINT5MINSLFAILED  476
	{MTPSLINT5MINSLFAILED, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 6}},
#define   MTPSLINT5MINSLREMOTEPROCOUTAGE  477
	{MTPSLINT5MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 7}},
#define   MTPSLINT5MINLOCALMGMTINHIBIT  478
	{MTPSLINT5MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 8}},
#define   MTPSLINT5MINLOCALMGMTUNINHIBIT  479
	{MTPSLINT5MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 9}},
#define   MTPSLINT5MINLOCALBUSY  480
	{MTPSLINT5MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 10}},
#define   MTPSLINT5MINSLCONGESTEDSTARTS  481
	{MTPSLINT5MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 11}},
#define   MTPSLINT5MINSLCONGESTEDDURATION  482
	{MTPSLINT5MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 12}},
#define   MTPSLINT5MINSLCONGESTIONSTOPS  483
	{MTPSLINT5MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 13}},
#define   MTPSLINT5MINDISCARDEDMSUS  484
	{MTPSLINT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 14}},
#define   MTPSLINT5MINCONGESTIONEVENTSMSULOSS  485
	{MTPSLINT5MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 15}},
#define   MTPSLINT5MINCHANGEOVERS  486
	{MTPSLINT5MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 16}},
#define   MTPSLINT5MINCHANGEBACKS  487
	{MTPSLINT5MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 17}},
#define   MTPSLINT5MINRESTORATIONS  488
	{MTPSLINT5MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 9, 6, 1, 18}},
#define   MTPSLINT15MINTIMESTAMP  492
	{MTPSLINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 2}},
#define   MTPSLINT15MINSLUNAVAILABILITYDURATION  493
	{MTPSLINT15MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 3}},
#define   MTPSLINT15MINSLLOCALINHIBITION  494
	{MTPSLINT15MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 4}},
#define   MTPSLINT15MINSLREMOTEINHIBITION  495
	{MTPSLINT15MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 5}},
#define   MTPSLINT15MINSLFAILED  496
	{MTPSLINT15MINSLFAILED, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 6}},
#define   MTPSLINT15MINSLREMOTEPROCOUTAGE  497
	{MTPSLINT15MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 7}},
#define   MTPSLINT15MINLOCALMGMTINHIBIT  498
	{MTPSLINT15MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 8}},
#define   MTPSLINT15MINLOCALMGMTUNINHIBIT  499
	{MTPSLINT15MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 9}},
#define   MTPSLINT15MINLOCALBUSY  500
	{MTPSLINT15MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 10}},
#define   MTPSLINT15MINSLCONGESTEDSTARTS  501
	{MTPSLINT15MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 11}},
#define   MTPSLINT15MINSLCONGESTEDDURATION  502
	{MTPSLINT15MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 12}},
#define   MTPSLINT15MINSLCONGESTIONSTOPS  503
	{MTPSLINT15MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 13}},
#define   MTPSLINT15MINDISCARDEDMSUS  504
	{MTPSLINT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 14}},
#define   MTPSLINT15MINCONGESTIONEVENTSMSULOSS  505
	{MTPSLINT15MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 15}},
#define   MTPSLINT15MINCHANGEOVERS  506
	{MTPSLINT15MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 16}},
#define   MTPSLINT15MINCHANGEBACKS  507
	{MTPSLINT15MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 17}},
#define   MTPSLINT15MINRESTORATIONS  508
	{MTPSLINT15MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 9, 7, 1, 18}},
#define   MTPL2PROFILEERRORCORRECTIONMETHOD  512
	{MTPL2PROFILEERRORCORRECTIONMETHOD, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 2}},
#define   MTPL2PROFILETIMERT1   513
	{MTPL2PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 3}},
#define   MTPL2PROFILETIMERT2   514
	{MTPL2PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 4}},
#define   MTPL2PROFILETIMERT3   515
	{MTPL2PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 5}},
#define   MTPL2PROFILETIMERT4N  516
	{MTPL2PROFILETIMERT4N, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 6}},
#define   MTPL2PROFILETIMERT4E  517
	{MTPL2PROFILETIMERT4E, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 7}},
#define   MTPL2PROFILETIMERT5   518
	{MTPL2PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 8}},
#define   MTPL2PROFILETIMERT6   519
	{MTPL2PROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 9}},
#define   MTPL2PROFILETIMERT7   520
	{MTPL2PROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 10}},
#define   MTPL2PROFILETRANSCONGTHRESHONSETLEVEL1MSGS  521
	{MTPL2PROFILETRANSCONGTHRESHONSETLEVEL1MSGS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 11}},
#define   MTPL2PROFILETRANSCONGTHRESHONSETLEVEL1OCTS  522
	{MTPL2PROFILETRANSCONGTHRESHONSETLEVEL1OCTS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 12}},
#define   MTPL2PROFILETRANSCONGTHRESHABATELEVEL1MSGS  523
	{MTPL2PROFILETRANSCONGTHRESHABATELEVEL1MSGS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 13}},
#define   MTPL2PROFILETRANSCONGTHRESHABATELEVEL1OCTS  524
	{MTPL2PROFILETRANSCONGTHRESHABATELEVEL1OCTS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 14}},
#define   MTPL2PROFILENUMBEROFTHRESHOLDLEVELS  525
	{MTPL2PROFILENUMBEROFTHRESHOLDLEVELS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 15}},
#define   MTPL2PROFILECONGESTIONCOUNTING  526
	{MTPL2PROFILECONGESTIONCOUNTING, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 16}},
#define   MTPL2PROFILECONGESTIONREPORTINGBASEOBJECT  527
	{MTPL2PROFILECONGESTIONREPORTINGBASEOBJECT, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 17}},
#define   MTPL2PROFILELOOPDELAY  528
	{MTPL2PROFILELOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 18}},
#define   MTPL2PROFILENAME      529
	{MTPL2PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 19}},
#define   MTPL2PROFILETRANSCONGTHRESHONSETLEVEL2MSGS  530
	{MTPL2PROFILETRANSCONGTHRESHONSETLEVEL2MSGS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 20}},
#define   MTPL2PROFILETRANSCONGTHRESHONSETLEVEL2OCTS  531
	{MTPL2PROFILETRANSCONGTHRESHONSETLEVEL2OCTS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 21}},
#define   MTPL2PROFILETRANSCONGTHRESHABATELEVEL2MSGS  532
	{MTPL2PROFILETRANSCONGTHRESHABATELEVEL2MSGS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 22}},
#define   MTPL2PROFILETRANSCONGTHRESHABATELEVEL2OCTS  533
	{MTPL2PROFILETRANSCONGTHRESHABATELEVEL2OCTS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 23}},
#define   MTPL2PROFILETRANSCONGTHRESHONSETLEVEL3MSGS  534
	{MTPL2PROFILETRANSCONGTHRESHONSETLEVEL3MSGS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 24}},
#define   MTPL2PROFILETRANSCONGTHRESHONSETLEVEL3OCTS  535
	{MTPL2PROFILETRANSCONGTHRESHONSETLEVEL3OCTS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 25}},
#define   MTPL2PROFILETRANSCONGTHRESHABATELEVEL3MSGS  536
	{MTPL2PROFILETRANSCONGTHRESHABATELEVEL3MSGS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 26}},
#define   MTPL2PROFILETRANSCONGTHRESHABATELEVEL3OCTS  537
	{MTPL2PROFILETRANSCONGTHRESHABATELEVEL3OCTS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 27}},
#define   MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL1MSGS  538
	{MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL1MSGS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 28}},
#define   MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL1OCTS  539
	{MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL1OCTS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 29}},
#define   MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL2MSGS  540
	{MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL2MSGS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 30}},
#define   MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL2OCTS  541
	{MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL2OCTS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 31}},
#define   MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL3MSGS  542
	{MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL3MSGS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 32}},
#define   MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL3OCTS  543
	{MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL3OCTS, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 33}},
#define   MTPL2PROFILETIMERTX   544
	{MTPL2PROFILETIMERTX, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 34}},
#define   MTPL2PROFILETIMERTY   545
	{MTPL2PROFILETIMERTY, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 35}},
#define   MTPL2PROFILENUMBEROFCONGESTIONSTATES  546
	{MTPL2PROFILENUMBEROFCONGESTIONSTATES, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 36}},
#define   MTPL2PROFILEINITIALLEVELOFCONGESTION  547
	{MTPL2PROFILEINITIALLEVELOFCONGESTION, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 37}},
#define   MTPL2PROFILEMAXMSUSRETRANSN1  548
	{MTPL2PROFILEMAXMSUSRETRANSN1, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 38}},
#define   MTPL2PROFILEMAXOCTRETRANSN2  549
	{MTPL2PROFILEMAXOCTRETRANSN2, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 39}},
#define   MTPL2PROFILERECEIVECONGTHRESHONSET  550
	{MTPL2PROFILERECEIVECONGTHRESHONSET, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 40}},
#define   MTPL2PROFILERECEIVECONGTHRESHABATE  551
	{MTPL2PROFILERECEIVECONGTHRESHABATE, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 41}},
#define   MTPL2PROFILEROWSTATUS  552
	{MTPL2PROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 10, 1, 1, 42}},
#define   MTPNBTRANSMISSIONRATE  556
	{MTPNBTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpNbandTable, 6, {1, 1, 10, 2, 1, 1}},
#define   MTPNBANDROWSTATUS     557
	{MTPNBANDROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNbandTable, 6, {1, 1, 10, 2, 1, 2}},
#define   MTPSAALBUFFERRELEASE  561
	{MTPSAALBUFFERRELEASE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 1}},
#define   MTPSAALMAXCC          562
	{MTPSAALMAXCC, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 2}},
#define   MTPSAALMAXNRP         563
	{MTPSAALMAXNRP, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 3}},
#define   MTPSAALMAXINFORMATIONFIELDLENGTH  564
	{MTPSAALMAXINFORMATIONFIELDLENGTH, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 4}},
#define   MTPSAALMAXLENGTHSSCOPUUFIELD  565
	{MTPSAALMAXLENGTHSSCOPUUFIELD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 5}},
#define   MTPSAALMAXPD          566
	{MTPSAALMAXPD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 6}},
#define   MTPSAALMAXSSCOPCREDITTOPEER  567
	{MTPSAALMAXSSCOPCREDITTOPEER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 7}},
#define   MTPSAALMAXSTAT        568
	{MTPSAALMAXSTAT, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 8}},
#define   MTPSAALN1             569
	{MTPSAALN1, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 9}},
#define   MTPSAALNNILAYERMANAGEMENTPROVINGSTATE  570
	{MTPSAALNNILAYERMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 10}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT  571
	{MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 11}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC  572
	{MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 12}},
#define   MTPSAALNNITIMERT1     573
	{MTPSAALNNITIMERT1, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 13}},
#define   MTPSAALNNITIMERT2     574
	{MTPSAALNNITIMERT2, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 14}},
#define   MTPSAALNNITIMERT3     575
	{MTPSAALNNITIMERT3, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 15}},
#define   MTPSAALSSCOPTIMERCC   576
	{MTPSAALSSCOPTIMERCC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 16}},
#define   MTPSAALSSCOPTIMERIDLE  577
	{MTPSAALSSCOPTIMERIDLE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 17}},
#define   MTPSAALSSCOPTIMERKEEPALIVE  578
	{MTPSAALSSCOPTIMERKEEPALIVE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 18}},
#define   MTPSAALSSCOPTIMERNORESPONSE  579
	{MTPSAALSSCOPTIMERNORESPONSE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 19}},
#define   MTPSAALSSCOPTIMERPOLL  580
	{MTPSAALSSCOPTIMERPOLL, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 20}},
#define   MTPSAALTRANSMISSIONRATEINTERVALLOWER  581
	{MTPSAALTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 21}},
#define   MTPSAALTRANSMISSIONRATEINTERVALUPPER  582
	{MTPSAALTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 22}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER  583
	{MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 23}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER  584
	{MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 24}},
#define   MTPSAALPOLLAFTERRETRANSMISSION  585
	{MTPSAALPOLLAFTERRETRANSMISSION, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 25}},
#define   MTPSAALROWSTATUS      586
	{MTPSAALROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 10, 3, 1, 26}},
#define   MTPM2PAN1             590
	{MTPM2PAN1, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 1}},
#define   MTPM2PAPROVING        591
	{MTPM2PAPROVING, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 2}},
#define   MTPM2PAMANAGEMENTPROVINGSTATE  592
	{MTPM2PAMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 3}},
#define   MTPM2PALOOPDELAYLOWER  593
	{MTPM2PALOOPDELAYLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 4}},
#define   MTPM2PALOOPDELAYUPPER  594
	{MTPM2PALOOPDELAYUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 5}},
#define   MTPM2PATRANSMISSIONRATEINTERVALLOWER  595
	{MTPM2PATRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 6}},
#define   MTPM2PATRANSMISSIONRATEINTERVALUPPER  596
	{MTPM2PATRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 7}},
#define   MTPM2PASCTPNODELAY    597
	{MTPM2PASCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 8}},
#define   MTPM2PASCTPMAXSEG     598
	{MTPM2PASCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 9}},
#define   MTPM2PASCTPHEARTBEATITVL  599
	{MTPM2PASCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 10}},
#define   MTPM2PASCTPHEARTBEAT  600
	{MTPM2PASCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 11}},
#define   MTPM2PASCTPRTOINITIAL  601
	{MTPM2PASCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 12}},
#define   MTPM2PASCTPRTOMIN     602
	{MTPM2PASCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 13}},
#define   MTPM2PASCTPRTOMAX     603
	{MTPM2PASCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 14}},
#define   MTPM2PASCTPPATHMAXRETRANS  604
	{MTPM2PASCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 15}},
#define   MTPM2PASCTPCOOKIELIFE  605
	{MTPM2PASCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 16}},
#define   MTPM2PASCTPCOOKIEINC  606
	{MTPM2PASCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 17}},
#define   MTPM2PASCTPMAXINITRETRIES  607
	{MTPM2PASCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 18}},
#define   MTPM2PASCTPMAXBURST   608
	{MTPM2PASCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 19}},
#define   MTPM2PASCTPASSOCMAXRETRANS  609
	{MTPM2PASCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 20}},
#define   MTPM2PASCTPSACKDELAY  610
	{MTPM2PASCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 21}},
#define   MTPM2PASCTPLIFETIME   611
	{MTPM2PASCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 22}},
#define   MTPM2PAPROVINGATTEMPTS  612
	{MTPM2PAPROVINGATTEMPTS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 23}},
#define   MTPM2PAROWSTATUS      613
	{MTPM2PAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 10, 4, 1, 24}},
#define   MTPSDTADMINSTATE      617
	{MTPSDTADMINSTATE, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 1, 1, 2}},
#define   MTPSDTOPERSTATE       618
	{MTPSDTOPERSTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 1, 1, 3}},
#define   MTPSDTUSAGESTATE      619
	{MTPSDTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 1, 1, 4}},
#define   MTPSDTPROCSTATUS      620
	{MTPSDTPROCSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 1, 1, 5}},
#define   MTPSDTAVAILSTATUS     621
	{MTPSDTAVAILSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 1, 1, 6}},
#define   MTPSDTEQUIPMENTPOINTER  622
	{MTPSDTEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 1, 1, 7}},
#define   MTPSDTNAME            623
	{MTPSDTNAME, ASN_OCTET_STR, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 1, 1, 8}},
#define   MTPSDTROWSTATUS       624
	{MTPSDTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 1, 1, 9}},
#define   MTPSDLADJPC           628
	{MTPSDLADJPC, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 2}},
#define   MTPSDLTRANSMISSIONRATE  629
	{MTPSDLTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 3}},
#define   MTPSDLLOOPDELAY       630
	{MTPSDLLOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 4}},
#define   MTPSDLOPERSTATE       631
	{MTPSDLOPERSTATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 5}},
#define   MTPSDLEQUIPMENTPOINTER  632
	{MTPSDLEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 6}},
#define   MTPSDLCIC             633
	{MTPSDLCIC, ASN_UNSIGNED, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 7}},
#define   MTPSDLNAME            634
	{MTPSDLNAME, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 8}},
#define   MTPSDLSTMCHANNEL      635
	{MTPSDLSTMCHANNEL, ASN_UNSIGNED, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 9}},
#define   MTPSDLVCTTPPOINTER    636
	{MTPSDLVCTTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 10}},
#define   MTPSDLROWSTATUS       637
	{MTPSDLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 11}},
#define   MTPM2PADEFAULTSCTPNODELAY  638
	{MTPM2PADEFAULTSCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpMIB, 4, {1, 2, 1, 1}},
#define   MTPM2PADEFAULTSCTPMAXSEG  639
	{MTPM2PADEFAULTSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 2}},
#define   MTPM2PADEFAULTSCTPHEARTBEATITVL  640
	{MTPM2PADEFAULTSCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 3}},
#define   MTPM2PADEFAULTSCTPHEARTBEAT  641
	{MTPM2PADEFAULTSCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpMIB, 4, {1, 2, 1, 4}},
#define   MTPM2PADEFAULTSCTPRTOINITIAL  642
	{MTPM2PADEFAULTSCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 5}},
#define   MTPM2PADEFAULTSCTPRTOMIN  643
	{MTPM2PADEFAULTSCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 6}},
#define   MTPM2PADEFAULTSCTPRTOMAX  644
	{MTPM2PADEFAULTSCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 7}},
#define   MTPM2PADEFAULTSCTPPATHMAXRETRANS  645
	{MTPM2PADEFAULTSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 8}},
#define   MTPM2PADEFAULTSCTPCOOKIELIFE  646
	{MTPM2PADEFAULTSCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 9}},
#define   MTPM2PADEFAULTSCTPCOOKIEINC  647
	{MTPM2PADEFAULTSCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 10}},
#define   MTPM2PADEFAULTSCTPMAXINITRETRIES  648
	{MTPM2PADEFAULTSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 11}},
#define   MTPM2PADEFAULTSCTPMAXBURST  649
	{MTPM2PADEFAULTSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 12}},
#define   MTPM2PADEFAULTSCTPASSOCMAXRETRANS  650
	{MTPM2PADEFAULTSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 13}},
#define   MTPM2PADEFAULTSCTPSACKDELAY  651
	{MTPM2PADEFAULTSCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 14}},
#define   MTPM2PADEFAULTSCTPLIFETIME  652
	{MTPM2PADEFAULTSCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 15}},

};

/*    (L = length of the oidsuffix) */

static struct mtpMIB_data *mtpMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
static struct header_complex_index *mtpSapTableStorage = NULL;
static struct header_complex_index *mtpSap2AddressTableStorage = NULL;
static struct header_complex_index *mtpSapUserEntityNamesTableStorage = NULL;
static struct header_complex_index *mtpSapProviderEntityNamesTableStorage = NULL;
static struct header_complex_index *mtpNaTableStorage = NULL;
static struct header_complex_index *mtpGsTableStorage = NULL;
static struct header_complex_index *mtpGsLineTableStorage = NULL;
static struct header_complex_index *mtpGsLineContentTableStorage = NULL;
static struct header_complex_index *mtpSpProfileTableStorage = NULL;
static struct header_complex_index *mtpSpTableStorage = NULL;
static struct header_complex_index *mtpSpCurrentTableStorage = NULL;
static struct header_complex_index *mtpSpInt5minTableStorage = NULL;
static struct header_complex_index *mtpSpInt15minTableStorage = NULL;
static struct header_complex_index *mtpSpSiTableStorage = NULL;
static struct header_complex_index *mtpSpSiInt5minTableStorage = NULL;
static struct header_complex_index *mtpSpSiInt15minTableStorage = NULL;
static struct header_complex_index *mtpSpStudyTableStorage = NULL;
static struct header_complex_index *mtpSpStudyInt5minTableStorage = NULL;
static struct header_complex_index *mtpSpStudyInt15minTableStorage = NULL;
static struct header_complex_index *mtpSpStudyMapTableStorage = NULL;
static struct header_complex_index *mtpL3TableStorage = NULL;
static struct header_complex_index *mtpRsTableStorage = NULL;
static struct header_complex_index *mtpRsCurrentTableStorage = NULL;
static struct header_complex_index *mtpRsInt5minTableStorage = NULL;
static struct header_complex_index *mtpRsInt15minTableStorage = NULL;
static struct header_complex_index *mtpRsSiTableStorage = NULL;
static struct header_complex_index *mtpRsSiInt5minTableStorage = NULL;
static struct header_complex_index *mtpRsSiInt15minTableStorage = NULL;
static struct header_complex_index *mtpRtTableStorage = NULL;
static struct header_complex_index *mtpRtLsaTableStorage = NULL;
static struct header_complex_index *mtpLsProfileTableStorage = NULL;
static struct header_complex_index *mtpLsTableStorage = NULL;
static struct header_complex_index *mtpLsCurrentTableStorage = NULL;
static struct header_complex_index *mtpLsInt5minTableStorage = NULL;
static struct header_complex_index *mtpLsInt15minTableStorage = NULL;
static struct header_complex_index *mtpSlProfileTableStorage = NULL;
static struct header_complex_index *mtpSlTableStorage = NULL;
static struct header_complex_index *mtpSlSdlListTableStorage = NULL;
static struct header_complex_index *mtpSlSdtListTableStorage = NULL;
static struct header_complex_index *mtpSlCurrentTableStorage = NULL;
static struct header_complex_index *mtpSlInt5minTableStorage = NULL;
static struct header_complex_index *mtpSlInt15minTableStorage = NULL;
static struct header_complex_index *mtpL2ProfileTableStorage = NULL;
static struct header_complex_index *mtpNbandTableStorage = NULL;
static struct header_complex_index *mtpSaalTableStorage = NULL;
static struct header_complex_index *mtpM2paTableStorage = NULL;
static struct header_complex_index *mtpSdtTableStorage = NULL;
static struct header_complex_index *mtpSdlTableStorage = NULL;

/*
 * init_mtpMIB():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_mtpMIB(void)
{
	DEBUGMSGTL(("mtpMIB", "initializing...  "));

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("mtpMIB", mtpMIB_variables, variable7, mtpMIB_variables_oid);

	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_mtpMIB, NULL);

	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("mtpMIB", parse_mtpMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSapTable", parse_mtpSapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSap2AddressTable", parse_mtpSap2AddressTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSapUserEntityNamesTable", parse_mtpSapUserEntityNamesTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSapProviderEntityNamesTable", parse_mtpSapProviderEntityNamesTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNaTable", parse_mtpNaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsTable", parse_mtpGsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineTable", parse_mtpGsLineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineContentTable", parse_mtpGsLineContentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpProfileTable", parse_mtpSpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpTable", parse_mtpSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpCurrentTable", parse_mtpSpCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpInt5minTable", parse_mtpSpInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpInt15minTable", parse_mtpSpInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiTable", parse_mtpSpSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiInt5minTable", parse_mtpSpSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiInt15minTable", parse_mtpSpSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyTable", parse_mtpSpStudyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyInt5minTable", parse_mtpSpStudyInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyInt15minTable", parse_mtpSpStudyInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyMapTable", parse_mtpSpStudyMapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL3Table", parse_mtpL3Table, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsTable", parse_mtpRsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsCurrentTable", parse_mtpRsCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsInt5minTable", parse_mtpRsInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsInt15minTable", parse_mtpRsInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiTable", parse_mtpRsSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiInt5minTable", parse_mtpRsSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiInt15minTable", parse_mtpRsSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtTable", parse_mtpRtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtLsaTable", parse_mtpRtLsaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsProfileTable", parse_mtpLsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsTable", parse_mtpLsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsCurrentTable", parse_mtpLsCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsInt5minTable", parse_mtpLsInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsInt15minTable", parse_mtpLsInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlProfileTable", parse_mtpSlProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlTable", parse_mtpSlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdlListTable", parse_mtpSlSdlListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdtListTable", parse_mtpSlSdtListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlCurrentTable", parse_mtpSlCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlInt5minTable", parse_mtpSlInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlInt15minTable", parse_mtpSlInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL2ProfileTable", parse_mtpL2ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNbandTable", parse_mtpNbandTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSaalTable", parse_mtpSaalTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM2paTable", parse_mtpM2paTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdtTable", parse_mtpSdtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdlTable", parse_mtpSdlTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSap2AddressTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSapUserEntityNamesTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSapProviderEntityNamesTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineContentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyMapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL3Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtLsaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdlListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdtListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL2ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNbandTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSaalTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM2paTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdlTable, NULL);

	/* place any other initialization junk you need here */

	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * deinit_mtpMIB():
 *   Deinitialization routine.  This is called before the agent is unloaded.
 *   At a minimum, deregistration of your variables should take place here.
 */
void
deinit_mtpMIB(void)
{
	DEBUGMSGTL(("mtpMIB", "deinitializating...  "));

	unregister_mib(mtpMIB_variables_oid, sizeof(mtpMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("mtpMIB");
	snmpd_unregister_config_handler("mtpSapTable");
	snmpd_unregister_config_handler("mtpSap2AddressTable");
	snmpd_unregister_config_handler("mtpSapUserEntityNamesTable");
	snmpd_unregister_config_handler("mtpSapProviderEntityNamesTable");
	snmpd_unregister_config_handler("mtpNaTable");
	snmpd_unregister_config_handler("mtpGsTable");
	snmpd_unregister_config_handler("mtpGsLineTable");
	snmpd_unregister_config_handler("mtpGsLineContentTable");
	snmpd_unregister_config_handler("mtpSpProfileTable");
	snmpd_unregister_config_handler("mtpSpTable");
	snmpd_unregister_config_handler("mtpSpCurrentTable");
	snmpd_unregister_config_handler("mtpSpInt5minTable");
	snmpd_unregister_config_handler("mtpSpInt15minTable");
	snmpd_unregister_config_handler("mtpSpSiTable");
	snmpd_unregister_config_handler("mtpSpSiInt5minTable");
	snmpd_unregister_config_handler("mtpSpSiInt15minTable");
	snmpd_unregister_config_handler("mtpSpStudyTable");
	snmpd_unregister_config_handler("mtpSpStudyInt5minTable");
	snmpd_unregister_config_handler("mtpSpStudyInt15minTable");
	snmpd_unregister_config_handler("mtpSpStudyMapTable");
	snmpd_unregister_config_handler("mtpL3Table");
	snmpd_unregister_config_handler("mtpRsTable");
	snmpd_unregister_config_handler("mtpRsCurrentTable");
	snmpd_unregister_config_handler("mtpRsInt5minTable");
	snmpd_unregister_config_handler("mtpRsInt15minTable");
	snmpd_unregister_config_handler("mtpRsSiTable");
	snmpd_unregister_config_handler("mtpRsSiInt5minTable");
	snmpd_unregister_config_handler("mtpRsSiInt15minTable");
	snmpd_unregister_config_handler("mtpRtTable");
	snmpd_unregister_config_handler("mtpRtLsaTable");
	snmpd_unregister_config_handler("mtpLsProfileTable");
	snmpd_unregister_config_handler("mtpLsTable");
	snmpd_unregister_config_handler("mtpLsCurrentTable");
	snmpd_unregister_config_handler("mtpLsInt5minTable");
	snmpd_unregister_config_handler("mtpLsInt15minTable");
	snmpd_unregister_config_handler("mtpSlProfileTable");
	snmpd_unregister_config_handler("mtpSlTable");
	snmpd_unregister_config_handler("mtpSlSdlListTable");
	snmpd_unregister_config_handler("mtpSlSdtListTable");
	snmpd_unregister_config_handler("mtpSlCurrentTable");
	snmpd_unregister_config_handler("mtpSlInt5minTable");
	snmpd_unregister_config_handler("mtpSlInt15minTable");
	snmpd_unregister_config_handler("mtpL2ProfileTable");
	snmpd_unregister_config_handler("mtpNbandTable");
	snmpd_unregister_config_handler("mtpSaalTable");
	snmpd_unregister_config_handler("mtpM2paTable");
	snmpd_unregister_config_handler("mtpSdtTable");
	snmpd_unregister_config_handler("mtpSdlTable");

	/* place any other de-initialization junk you need here */

	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

int
term_mtpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_mtpMIB();
	return 0;
}

/*
 * mtpMIB_add(): adds a structure node for scalars
 */
int
mtpMIB_add(struct mtpMIB_data *thedata)
{
	DEBUGMSGTL(("mtpMIB", "adding data...  "));

	mtpMIBStorage = thedata;

	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpMIB():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpMIB(const char *token, char *line)
{
	size_t tmpint;
	struct mtpMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpMIB_data);

	DEBUGMSGTL(("mtpMIB", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paDefaultSctpNoDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxseg, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paDefaultSctpHeartbeat, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoInitial, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoMin, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoMax, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpCookieLife, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpCookieInc, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxInitRetries, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxBurst, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpSackDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpLifetime, &tmpint);

	mtpMIB_add(StorageTmp);

	(void) tmpint;

	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpMIB():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpMIB_data *StorageTmp;

	DEBUGMSGTL(("mtpMIB", "storing data...  "));

	refresh_mtpMIB();

	if ((StorageTmp = mtpMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpMIB", "error.\n"));
		return SNMPERR_GENERR;
	}

	(void) tmpint;

	/* XXX: if (StorageTmp->mtpMIBStorageType == ST_NONVOLATILE) { */

	memset(line, 0, sizeof(line));
	strcat(line, "mtpMIB ");
	cptr = line + strlen(line);

	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paDefaultSctpNoDelay, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxseg, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl, &tmpint);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paDefaultSctpHeartbeat, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoInitial, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoMin, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoMax, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpCookieLife, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpCookieInc, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxInitRetries, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxBurst, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpSackDelay, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpLifetime, &tmpint);

	snmpd_store_config(line);
	/* } */
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpMIB: refresh mtpMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread scalars and tables from the STREAMS susbystem.  This function
 * is used when the agent starts for the first time, or after a SIGPOLL
 * has been received (and a scalar has been requested).
 */
void
refresh_mtpMIB(void)
{
	if (mtpMIBStorage == NULL) {
		if ((mtpMIBStorage = SNMP_MALLOC_STRUCT(mtpMIB_data)) == NULL)
			return;

		/* Update scalar defaults as required here... */

		mtpMIB_refresh = 1;
	}

	if (mtpMIB_refresh == 0)
		return;
	mtpMIB_refresh = 0;

	/* Update scalars as required here... */

}

/*
 * var_mtpMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
var_mtpMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* Refresh the MIB values if required. */
	refresh_mtpMIB();

	if ((StorageTmp = mtpMIBStorage) == NULL)
		return NULL;

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPM2PADEFAULTSCTPNODELAY:
		*write_method = write_mtpM2paDefaultSctpNoDelay;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpNoDelay);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpNoDelay;

	case MTPM2PADEFAULTSCTPMAXSEG:
		*write_method = write_mtpM2paDefaultSctpMaxseg;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxseg);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxseg;

	case MTPM2PADEFAULTSCTPHEARTBEATITVL:
		*write_method = write_mtpM2paDefaultSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpHeartbeatItvl);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl;

	case MTPM2PADEFAULTSCTPHEARTBEAT:
		*write_method = write_mtpM2paDefaultSctpHeartbeat;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpHeartbeat);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpHeartbeat;

	case MTPM2PADEFAULTSCTPRTOINITIAL:
		*write_method = write_mtpM2paDefaultSctpRtoInitial;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoInitial);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoInitial;

	case MTPM2PADEFAULTSCTPRTOMIN:
		*write_method = write_mtpM2paDefaultSctpRtoMin;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoMin);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoMin;

	case MTPM2PADEFAULTSCTPRTOMAX:
		*write_method = write_mtpM2paDefaultSctpRtoMax;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoMax);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoMax;

	case MTPM2PADEFAULTSCTPPATHMAXRETRANS:
		*write_method = write_mtpM2paDefaultSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpPathMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans;

	case MTPM2PADEFAULTSCTPCOOKIELIFE:
		*write_method = write_mtpM2paDefaultSctpCookieLife;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpCookieLife);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpCookieLife;

	case MTPM2PADEFAULTSCTPCOOKIEINC:
		*write_method = write_mtpM2paDefaultSctpCookieInc;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpCookieInc);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpCookieInc;

	case MTPM2PADEFAULTSCTPMAXINITRETRIES:
		*write_method = write_mtpM2paDefaultSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxInitRetries);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxInitRetries;

	case MTPM2PADEFAULTSCTPMAXBURST:
		*write_method = write_mtpM2paDefaultSctpMaxBurst;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxBurst);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxBurst;

	case MTPM2PADEFAULTSCTPASSOCMAXRETRANS:
		*write_method = write_mtpM2paDefaultSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans;

	case MTPM2PADEFAULTSCTPSACKDELAY:
		*write_method = write_mtpM2paDefaultSctpSackDelay;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpSackDelay);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpSackDelay;

	case MTPM2PADEFAULTSCTPLIFETIME:
		*write_method = write_mtpM2paDefaultSctpLifetime;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpLifetime);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpLifetime;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/* 
 * mtpSapTable_add(): adds a structure node to our data set 
 */
int
mtpSapTable_add(struct mtpSapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL3Id */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpL3Id, thedata->mtpL3IdLen);
	/* mtpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSapId, thedata->mtpSapIdLen);

	header_complex_add_data(&mtpSapTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSapTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSapTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSapTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSapTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSapTable_data);

	DEBUGMSGTL(("mtpSapTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
	if (StorageTmp->mtpL3Id == NULL) {
		config_perror("invalid specification for mtpL3Id");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSapId, &StorageTmp->mtpSapIdLen);
	if (StorageTmp->mtpSapId == NULL) {
		config_perror("invalid specification for mtpSapId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSap2Address, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSapUserEntityNames, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSapProviderEntityNames, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapAsaProfilePointer, &StorageTmp->mtpSapAsaProfilePointerLen);
	if (StorageTmp->mtpSapAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSapAsaProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSapName, &StorageTmp->mtpSapNameLen);
	if (StorageTmp->mtpSapName == NULL) {
		config_perror("invalid specification for mtpSapName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapLongMessageSupported, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapRowStatus, &tmpint);

	mtpSapTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSapTable", "done.\n"));
}

/*
 * store_mtpSapTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSapTable", "storing data...  "));

	refresh_mtpSapTable();

	for (hcindex = mtpSapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSapTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSapTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSapTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSapId, &StorageTmp->mtpSapIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSap2Address, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSapUserEntityNames, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSapProviderEntityNames, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapAsaProfilePointer, &StorageTmp->mtpSapAsaProfilePointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSapName, &StorageTmp->mtpSapNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapLongMessageSupported, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSap2AddressTable_add(): adds a structure node to our data set 
 */
int
mtpSap2AddressTable_add(struct mtpSap2AddressTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSap2AddressTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL3Id */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpL3Id, thedata->mtpL3IdLen);
	/* mtpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSapId, thedata->mtpSapIdLen);
	/* mtpSap2AddressId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSap2AddressId, sizeof(thedata->mtpSap2AddressId));

	header_complex_add_data(&mtpSap2AddressTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSap2AddressTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSap2AddressTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSap2AddressTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSap2AddressTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSap2AddressTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSap2AddressTable_data);

	DEBUGMSGTL(("mtpSap2AddressTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
	if (StorageTmp->mtpL3Id == NULL) {
		config_perror("invalid specification for mtpL3Id");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSapId, &StorageTmp->mtpSapIdLen);
	if (StorageTmp->mtpSapId == NULL) {
		config_perror("invalid specification for mtpSapId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSap2AddressId, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSap2AddressComponent, &StorageTmp->mtpSap2AddressComponentLen);
	if (StorageTmp->mtpSap2AddressComponent == NULL) {
		config_perror("invalid specification for mtpSap2AddressComponent");
		return;
	}

	mtpSap2AddressTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSap2AddressTable", "done.\n"));
}

/*
 * store_mtpSap2AddressTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSap2AddressTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSap2AddressTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSap2AddressTable", "storing data...  "));

	refresh_mtpSap2AddressTable();

	for (hcindex = mtpSap2AddressTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSap2AddressTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSap2AddressTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSap2AddressTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSapId, &StorageTmp->mtpSapIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSap2AddressId, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSap2AddressComponent, &StorageTmp->mtpSap2AddressComponentLen);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSap2AddressTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSapUserEntityNamesTable_add(): adds a structure node to our data set 
 */
int
mtpSapUserEntityNamesTable_add(struct mtpSapUserEntityNamesTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSapUserEntityNamesTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL3Id */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpL3Id, thedata->mtpL3IdLen);
	/* mtpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSapId, thedata->mtpSapIdLen);
	/* mtpSapUserEntityNameId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSapUserEntityNameId, sizeof(thedata->mtpSapUserEntityNameId));

	header_complex_add_data(&mtpSapUserEntityNamesTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSapUserEntityNamesTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSapUserEntityNamesTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSapUserEntityNamesTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSapUserEntityNamesTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSapUserEntityNamesTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSapUserEntityNamesTable_data);

	DEBUGMSGTL(("mtpSapUserEntityNamesTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
	if (StorageTmp->mtpL3Id == NULL) {
		config_perror("invalid specification for mtpL3Id");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSapId, &StorageTmp->mtpSapIdLen);
	if (StorageTmp->mtpSapId == NULL) {
		config_perror("invalid specification for mtpSapId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSapUserEntityNameId, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapUserEntityName, &StorageTmp->mtpSapUserEntityNameLen);
	if (StorageTmp->mtpSapUserEntityName == NULL) {
		config_perror("invalid specification for mtpSapUserEntityName");
		return;
	}

	mtpSapUserEntityNamesTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSapUserEntityNamesTable", "done.\n"));
}

/*
 * store_mtpSapUserEntityNamesTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSapUserEntityNamesTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSapUserEntityNamesTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSapUserEntityNamesTable", "storing data...  "));

	refresh_mtpSapUserEntityNamesTable();

	for (hcindex = mtpSapUserEntityNamesTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSapUserEntityNamesTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSapUserEntityNamesTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSapUserEntityNamesTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSapId, &StorageTmp->mtpSapIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSapUserEntityNameId, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapUserEntityName, &StorageTmp->mtpSapUserEntityNameLen);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSapUserEntityNamesTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSapProviderEntityNamesTable_add(): adds a structure node to our data set 
 */
int
mtpSapProviderEntityNamesTable_add(struct mtpSapProviderEntityNamesTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSapProviderEntityNamesTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL3Id */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpL3Id, thedata->mtpL3IdLen);
	/* mtpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSapId, thedata->mtpSapIdLen);
	/* mtpSapProviderEntityNameId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSapProviderEntityNameId, sizeof(thedata->mtpSapProviderEntityNameId));

	header_complex_add_data(&mtpSapProviderEntityNamesTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSapProviderEntityNamesTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSapProviderEntityNamesTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSapProviderEntityNamesTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSapProviderEntityNamesTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSapProviderEntityNamesTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSapProviderEntityNamesTable_data);

	DEBUGMSGTL(("mtpSapProviderEntityNamesTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
	if (StorageTmp->mtpL3Id == NULL) {
		config_perror("invalid specification for mtpL3Id");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSapId, &StorageTmp->mtpSapIdLen);
	if (StorageTmp->mtpSapId == NULL) {
		config_perror("invalid specification for mtpSapId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSapProviderEntityNameId, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapProviderEntityName, &StorageTmp->mtpSapProviderEntityNameLen);
	if (StorageTmp->mtpSapProviderEntityName == NULL) {
		config_perror("invalid specification for mtpSapProviderEntityName");
		return;
	}

	mtpSapProviderEntityNamesTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSapProviderEntityNamesTable", "done.\n"));
}

/*
 * store_mtpSapProviderEntityNamesTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSapProviderEntityNamesTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSapProviderEntityNamesTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSapProviderEntityNamesTable", "storing data...  "));

	refresh_mtpSapProviderEntityNamesTable();

	for (hcindex = mtpSapProviderEntityNamesTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSapProviderEntityNamesTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSapProviderEntityNamesTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSapProviderEntityNamesTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSapId, &StorageTmp->mtpSapIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSapProviderEntityNameId, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapProviderEntityName, &StorageTmp->mtpSapProviderEntityNameLen);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSapProviderEntityNamesTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpNaTable_add(): adds a structure node to our data set 
 */
int
mtpNaTable_add(struct mtpNaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpNaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpNaId, thedata->mtpNaIdLen);

	header_complex_add_data(&mtpNaTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNaTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpNaTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpNaTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpNaTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpNaTable_data);

	DEBUGMSGTL(("mtpNaTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaId, &StorageTmp->mtpNaIdLen);
	if (StorageTmp->mtpNaId == NULL) {
		config_perror("invalid specification for mtpNaId");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
	if (StorageTmp->mtpNaProtocolVariant == NULL) {
		config_perror("invalid specification for mtpNaProtocolVariant");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaProtocolYear, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
	if (StorageTmp->mtpNaProtocolOptions == NULL) {
		config_perror("invalid specification for mtpNaProtocolOptions");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaNetworkIndicator, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
	if (StorageTmp->mtpNaPointCodeFormat == NULL) {
		config_perror("invalid specification for mtpNaPointCodeFormat");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaSlsLength, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaSpProfilePointer, &StorageTmp->mtpNaSpProfilePointerLen);
	if (StorageTmp->mtpNaSpProfilePointer == NULL) {
		config_perror("invalid specification for mtpNaSpProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
	if (StorageTmp->mtpNaName == NULL) {
		config_perror("invalid specification for mtpNaName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaRowStatus, &tmpint);

	mtpNaTable_add(StorageTmp);

	DEBUGMSGTL(("mtpNaTable", "done.\n"));
}

/*
 * store_mtpNaTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpNaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpNaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNaTable", "storing data...  "));

	refresh_mtpNaTable();

	for (hcindex = mtpNaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNaTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpNaTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpNaTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaId, &StorageTmp->mtpNaIdLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaProtocolYear, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaNetworkIndicator, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaSlsLength, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaSpProfilePointer, &StorageTmp->mtpNaSpProfilePointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpGsTable_add(): adds a structure node to our data set 
 */
int
mtpGsTable_add(struct mtpGsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpId, thedata->mtpSpIdLen);
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpGsId, thedata->mtpGsIdLen);

	header_complex_add_data(&mtpGsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpGsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsTable_data);

	DEBUGMSGTL(("mtpGsTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
	if (StorageTmp->mtpSpId == NULL) {
		config_perror("invalid specification for mtpSpId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsId, &StorageTmp->mtpGsIdLen);
	if (StorageTmp->mtpGsId == NULL) {
		config_perror("invalid specification for mtpGsId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsListMode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
	if (StorageTmp->mtpGsName == NULL) {
		config_perror("invalid specification for mtpGsName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsRowStatus, &tmpint);

	mtpGsTable_add(StorageTmp);

	DEBUGMSGTL(("mtpGsTable", "done.\n"));
}

/*
 * store_mtpGsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpGsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsTable", "storing data...  "));

	refresh_mtpGsTable();

	for (hcindex = mtpGsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpGsTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpGsTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsId, &StorageTmp->mtpGsIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsListMode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpGsLineTable_add(): adds a structure node to our data set 
 */
int
mtpGsLineTable_add(struct mtpGsLineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsLineTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpId, thedata->mtpSpIdLen);
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpGsId, thedata->mtpGsIdLen);
	/* mtpGsLineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OBJECT_ID, (u_char *) thedata->mtpGsLineId, thedata->mtpGsLineIdLen);

	header_complex_add_data(&mtpGsLineTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsLineTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsLineTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsLineTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpGsLineTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsLineTable_data);

	DEBUGMSGTL(("mtpGsLineTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
	if (StorageTmp->mtpSpId == NULL) {
		config_perror("invalid specification for mtpSpId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsId, &StorageTmp->mtpGsIdLen);
	if (StorageTmp->mtpGsId == NULL) {
		config_perror("invalid specification for mtpGsId");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpGsLineId, &StorageTmp->mtpGsLineIdLen);
	if (StorageTmp->mtpGsLineId == NULL) {
		config_perror("invalid specification for mtpGsLineId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContent, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineRowStatus, &tmpint);

	mtpGsLineTable_add(StorageTmp);

	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
}

/*
 * store_mtpGsLineTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpGsLineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsLineTable", "storing data...  "));

	refresh_mtpGsLineTable();

	for (hcindex = mtpGsLineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpGsLineTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpGsLineTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsId, &StorageTmp->mtpGsIdLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpGsLineId, &StorageTmp->mtpGsLineIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContent, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpGsLineContentTable_add(): adds a structure node to our data set 
 */
int
mtpGsLineContentTable_add(struct mtpGsLineContentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsLineContentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpId, thedata->mtpSpIdLen);
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpGsId, thedata->mtpGsIdLen);
	/* mtpGsLineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OBJECT_ID, (u_char *) thedata->mtpGsLineId, thedata->mtpGsLineIdLen);
	/* mtpGsLineContentDesignatedDPCFirst */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineContentDesignatedDPCFirst, sizeof(thedata->mtpGsLineContentDesignatedDPCFirst));

	header_complex_add_data(&mtpGsLineContentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsLineContentTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsLineContentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsLineContentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpGsLineContentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data);

	DEBUGMSGTL(("mtpGsLineContentTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
	if (StorageTmp->mtpSpId == NULL) {
		config_perror("invalid specification for mtpSpId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsId, &StorageTmp->mtpGsIdLen);
	if (StorageTmp->mtpGsId == NULL) {
		config_perror("invalid specification for mtpGsId");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpGsLineId, &StorageTmp->mtpGsLineIdLen);
	if (StorageTmp->mtpGsLineId == NULL) {
		config_perror("invalid specification for mtpGsLineId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentRowStatus, &tmpint);

	mtpGsLineContentTable_add(StorageTmp);

	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
}

/*
 * store_mtpGsLineContentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineContentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpGsLineContentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsLineContentTable", "storing data...  "));

	refresh_mtpGsLineContentTable();

	for (hcindex = mtpGsLineContentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineContentTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpGsLineContentTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpGsLineContentTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsId, &StorageTmp->mtpGsIdLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpGsLineId, &StorageTmp->mtpGsLineIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpProfileTable_add(): adds a structure node to our data set 
 */
int
mtpSpProfileTable_add(struct mtpSpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpProfileId, thedata->mtpSpProfileIdLen);

	header_complex_add_data(&mtpSpProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpProfileTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);

	DEBUGMSGTL(("mtpSpProfileTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileId, &StorageTmp->mtpSpProfileIdLen);
	if (StorageTmp->mtpSpProfileId == NULL) {
		config_perror("invalid specification for mtpSpProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT4, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT5, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT7, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT11, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT12, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT13, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT14, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT15, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT16, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT18, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT19, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT20, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT21, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT22, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT23, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT20A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT21A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT1T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileMtpT2T, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
	if (StorageTmp->mtpSpProfileName == NULL) {
		config_perror("invalid specification for mtpSpProfileName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileRowStatus, &tmpint);

	mtpSpProfileTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
}

/*
 * store_mtpSpProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpProfileTable", "storing data...  "));

	refresh_mtpSpProfileTable();

	for (hcindex = mtpSpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpProfileTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpProfileTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpProfileTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileId, &StorageTmp->mtpSpProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT4, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT5, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT7, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT11, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT12, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT13, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT14, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT15, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT16, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT18, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT19, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT20, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT21, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT22, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT23, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT20A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT21A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT1T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileMtpT2T, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpTable_add(): adds a structure node to our data set 
 */
int
mtpSpTable_add(struct mtpSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpId, thedata->mtpSpIdLen);

	header_complex_add_data(&mtpSpTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpTable_data);

	DEBUGMSGTL(("mtpSpTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
	if (StorageTmp->mtpSpId == NULL) {
		config_perror("invalid specification for mtpSpId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpPointCode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpType, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpOperationalState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
	if (StorageTmp->mtpSpProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSpProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
	if (StorageTmp->mtpSpAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSpAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpVersion, &StorageTmp->mtpSpVersionLen);
	if (StorageTmp->mtpSpVersion == NULL) {
		config_perror("invalid specification for mtpSpVersion");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpNetworkIndicator, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
	if (StorageTmp->mtpSpName == NULL) {
		config_perror("invalid specification for mtpSpName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT4, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT5, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT6, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT7, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT8, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT10, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT11, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT12, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT13, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT14, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT15, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT16, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT17, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT19A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT31A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT32A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT33A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT34A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT18, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT19, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT20, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT21, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT22, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT23, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT20A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT21A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT24, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT2T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1S, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfilePointer, &StorageTmp->mtpSpProfilePointerLen);
	if (StorageTmp->mtpSpProfilePointer == NULL) {
		config_perror("invalid specification for mtpSpProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpNaPointer, &StorageTmp->mtpSpNaPointerLen);
	if (StorageTmp->mtpSpNaPointer == NULL) {
		config_perror("invalid specification for mtpSpNaPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpRowStatus, &tmpint);

	mtpSpTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpTable", "done.\n"));
}

/*
 * store_mtpSpTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpTable", "storing data...  "));

	refresh_mtpSpTable();

	for (hcindex = mtpSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpPointCode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpType, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpVersion, &StorageTmp->mtpSpVersionLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpNetworkIndicator, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT4, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT5, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT6, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT7, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT8, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT10, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT11, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT12, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT13, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT14, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT15, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT16, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT17, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT19A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT31A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT32A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT33A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT34A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT18, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT19, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT20, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT21, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT22, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT23, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT20A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT21A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT24, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT2T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1S, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfilePointer, &StorageTmp->mtpSpProfilePointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpNaPointer, &StorageTmp->mtpSpNaPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpCurrentTable_add(): adds a structure node to our data set 
 */
int
mtpSpCurrentTable_add(struct mtpSpCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	header_complex_add_data(&mtpSpCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpCurrentTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpCurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpCurrentTable_data);

	DEBUGMSGTL(("mtpSpCurrentTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpCurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpCurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus0, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus1, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus2, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentOctetsXferred, &tmpint);

	mtpSpCurrentTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
}

/*
 * store_mtpSpCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpCurrentTable", "storing data...  "));

	refresh_mtpSpCurrentTable();

	for (hcindex = mtpSpCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpCurrentTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpCurrentTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpCurrentTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpCurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpCurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus0, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus1, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus2, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentOctetsXferred, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpSpInt5minTable_add(struct mtpSpInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpInt5minInterval, sizeof(thedata->mtpSpInt5minInterval));

	header_complex_add_data(&mtpSpInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpInt5minTable_data);

	DEBUGMSGTL(("mtpSpInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus0, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus1, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus2, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minOctetsXferred, &tmpint);

	mtpSpInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
}

/*
 * store_mtpSpInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpInt5minTable", "storing data...  "));

	refresh_mtpSpInt5minTable();

	for (hcindex = mtpSpInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus0, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus1, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus2, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minOctetsXferred, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpSpInt15minTable_add(struct mtpSpInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpInt15minInterval, sizeof(thedata->mtpSpInt15minInterval));

	header_complex_add_data(&mtpSpInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpInt15minTable_data);

	DEBUGMSGTL(("mtpSpInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus0, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus1, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus2, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minOctetsXferred, &tmpint);

	mtpSpInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
}

/*
 * store_mtpSpInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpInt15minTable", "storing data...  "));

	refresh_mtpSpInt15minTable();

	for (hcindex = mtpSpInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus0, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus1, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus2, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minOctetsXferred, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpSiTable_add(): adds a structure node to our data set 
 */
int
mtpSpSiTable_add(struct mtpSpSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));

	header_complex_add_data(&mtpSpSiTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpSiTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiTable_data);

	DEBUGMSGTL(("mtpSpSiTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpSiValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiTransmittedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiReceivedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiHandledOctetsSIO, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpSiStatus, &tmpint);

	mtpSpSiTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
}

/*
 * store_mtpSpSiTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiTable", "storing data...  "));

	refresh_mtpSpSiTable();

	for (hcindex = mtpSpSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpSiTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpSiValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiTransmittedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiReceivedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiHandledOctetsSIO, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpSiStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpSiInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpSpSiInt5minTable_add(struct mtpSpSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpSiInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiInt5minInterval, sizeof(thedata->mtpSpSiInt5minInterval));

	header_complex_add_data(&mtpSpSiInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpSiInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiInt5minTable_data);

	DEBUGMSGTL(("mtpSpSiInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minHandledOctetsSIO, &tmpint);

	mtpSpSiInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
}

/*
 * store_mtpSpSiInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiInt5minTable", "storing data...  "));

	refresh_mtpSpSiInt5minTable();

	for (hcindex = mtpSpSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpSiInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minHandledOctetsSIO, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpSiInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpSpSiInt15minTable_add(struct mtpSpSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpSiInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiInt15minInterval, sizeof(thedata->mtpSpSiInt15minInterval));

	header_complex_add_data(&mtpSpSiInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpSiInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiInt15minTable_data);

	DEBUGMSGTL(("mtpSpSiInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minHandledOctetsSIO, &tmpint);

	mtpSpSiInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
}

/*
 * store_mtpSpSiInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiInt15minTable", "storing data...  "));

	refresh_mtpSpSiInt15minTable();

	for (hcindex = mtpSpSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpSiInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minHandledOctetsSIO, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpStudyTable_add(): adds a structure node to our data set 
 */
int
mtpSpStudyTable_add(struct mtpSpStudyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpStudyIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyIndex, sizeof(thedata->mtpSpStudyIndex));

	header_complex_add_data(&mtpSpStudyTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyTable_data);

	DEBUGMSGTL(("mtpSpStudyTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyStatus, &tmpint);

	mtpSpStudyTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
}

/*
 * store_mtpSpStudyTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyTable", "storing data...  "));

	refresh_mtpSpStudyTable();

	for (hcindex = mtpSpStudyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpStudyTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpStudyInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpSpStudyInt5minTable_add(struct mtpSpStudyInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpStudyIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyIndex, sizeof(thedata->mtpSpStudyIndex));
	/* mtpSpStudyInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyInt5minInterval, sizeof(thedata->mtpSpStudyInt5minInterval));

	header_complex_add_data(&mtpSpStudyInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyInt5minTable_data);

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio, &tmpint);

	mtpSpStudyInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
}

/*
 * store_mtpSpStudyInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "storing data...  "));

	refresh_mtpSpStudyInt5minTable();

	for (hcindex = mtpSpStudyInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpStudyInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpStudyInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpSpStudyInt15minTable_add(struct mtpSpStudyInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpStudyIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyIndex, sizeof(thedata->mtpSpStudyIndex));
	/* mtpSpStudyInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyInt15minInterval, sizeof(thedata->mtpSpStudyInt15minInterval));
	/* mtpSpStudyInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_TIMETICKS, (u_char *) &thedata->mtpSpStudyInt15minInterval, sizeof(thedata->mtpSpStudyInt15minInterval));

	header_complex_add_data(&mtpSpStudyInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyInt15minTable_data);

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio, &tmpint);

	mtpSpStudyInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
}

/*
 * store_mtpSpStudyInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "storing data...  "));

	refresh_mtpSpStudyInt15minTable();

	for (hcindex = mtpSpStudyInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpStudyInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpStudyMapTable_add(): adds a structure node to our data set 
 */
int
mtpSpStudyMapTable_add(struct mtpSpStudyMapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyMapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpStudyIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyIndex, sizeof(thedata->mtpSpStudyIndex));

	header_complex_add_data(&mtpSpStudyMapTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyMapTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyMapTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyMapTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyMapTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyMapTable_data);

	DEBUGMSGTL(("mtpSpStudyMapTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyMapStatus, &tmpint);

	mtpSpStudyMapTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
}

/*
 * store_mtpSpStudyMapTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyMapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyMapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyMapTable", "storing data...  "));

	refresh_mtpSpStudyMapTable();

	for (hcindex = mtpSpStudyMapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyMapTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpStudyMapTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyMapTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyMapStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpL3Table_add(): adds a structure node to our data set 
 */
int
mtpL3Table_add(struct mtpL3Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpL3Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL3Id */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpL3Id, thedata->mtpL3IdLen);

	header_complex_add_data(&mtpL3TableStorage, vars, thedata);
	DEBUGMSGTL(("mtpL3Table", "registered an entry\n"));

	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpL3Table():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpL3Table(const char *token, char *line)
{
	size_t tmpint;
	struct mtpL3Table_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpL3Table_data);

	DEBUGMSGTL(("mtpL3Table", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
	if (StorageTmp->mtpL3Id == NULL) {
		config_perror("invalid specification for mtpL3Id");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3AdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3OperationalState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3UsageState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpL3ProceduralStatus, &StorageTmp->mtpL3ProceduralStatusLen);
	if (StorageTmp->mtpL3ProceduralStatus == NULL) {
		config_perror("invalid specification for mtpL3ProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpL3AsaProfilePointer, &StorageTmp->mtpL3AsaProfilePointerLen);
	if (StorageTmp->mtpL3AsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpL3AsaProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Name, &StorageTmp->mtpL3NameLen);
	if (StorageTmp->mtpL3Name == NULL) {
		config_perror("invalid specification for mtpL3Name");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3RowStatus, &tmpint);

	mtpL3Table_add(StorageTmp);

	DEBUGMSGTL(("mtpL3Table", "done.\n"));
}

/*
 * store_mtpL3Table():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpL3Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpL3Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpL3Table", "storing data...  "));

	refresh_mtpL3Table();

	for (hcindex = mtpL3TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL3Table_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpL3TableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpL3Table ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3AdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3OperationalState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3UsageState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpL3ProceduralStatus, &StorageTmp->mtpL3ProceduralStatusLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpL3AsaProfilePointer, &StorageTmp->mtpL3AsaProfilePointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Name, &StorageTmp->mtpL3NameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3RowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsTable_add(): adds a structure node to our data set 
 */
int
mtpRsTable_add(struct mtpRsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpId, thedata->mtpSpIdLen);
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRsId, thedata->mtpRsIdLen);

	header_complex_add_data(&mtpRsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsTable_data);

	DEBUGMSGTL(("mtpRsTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
	if (StorageTmp->mtpSpId == NULL) {
		config_perror("invalid specification for mtpSpId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsId, &StorageTmp->mtpRsIdLen);
	if (StorageTmp->mtpRsId == NULL) {
		config_perror("invalid specification for mtpRsId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsOperationalState, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsAsaProfilePointer, &StorageTmp->mtpRsAsaProfilePointerLen);
	if (StorageTmp->mtpRsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpRsAsaProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestedState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestionLevel, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
	if (StorageTmp->mtpRsLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingInformation");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
	if (StorageTmp->mtpRsLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingObject");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
	if (StorageTmp->mtpRsRemoteExchangeLabel == NULL) {
		config_perror("invalid specification for mtpRsRemoteExchangeLabel");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
	if (StorageTmp->mtpRsName == NULL) {
		config_perror("invalid specification for mtpRsName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsRowStatus, &tmpint);

	mtpRsTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsTable", "done.\n"));
}

/*
 * store_mtpRsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsTable", "storing data...  "));

	refresh_mtpRsTable();

	for (hcindex = mtpRsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsId, &StorageTmp->mtpRsIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsAsaProfilePointer, &StorageTmp->mtpRsAsaProfilePointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestedState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestionLevel, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsCurrentTable_add(): adds a structure node to our data set 
 */
int
mtpRsCurrentTable_add(struct mtpRsCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	header_complex_add_data(&mtpRsCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsCurrentTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsCurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsCurrentTable_data);

	DEBUGMSGTL(("mtpRsCurrentTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsCurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentReceivedOctetsOPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentTransmittedOctetsDPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentReceivedMSUsOpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentTransmittedMSUsDpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentRouteSetUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration, &tmpint);

	mtpRsCurrentTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
}

/*
 * store_mtpRsCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsCurrentTable", "storing data...  "));

	refresh_mtpRsCurrentTable();

	for (hcindex = mtpRsCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsCurrentTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsCurrentTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsCurrentTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsCurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentReceivedOctetsOPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentTransmittedOctetsDPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentReceivedMSUsOpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentTransmittedMSUsDpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentRouteSetUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpRsInt5minTable_add(struct mtpRsInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsInt5minInterval, sizeof(thedata->mtpRsInt5minInterval));

	header_complex_add_data(&mtpRsInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsInt5minTable_data);

	DEBUGMSGTL(("mtpRsInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minReceivedOctetsOPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minTransmittedOctetsDPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minReceivedMSUsOpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minTransmittedMSUsDpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minRouteSetUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration, &tmpint);

	mtpRsInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
}

/*
 * store_mtpRsInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsInt5minTable", "storing data...  "));

	refresh_mtpRsInt5minTable();

	for (hcindex = mtpRsInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minReceivedOctetsOPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minTransmittedOctetsDPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minReceivedMSUsOpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minTransmittedMSUsDpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minRouteSetUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpRsInt15minTable_add(struct mtpRsInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsInt15minInterval, sizeof(thedata->mtpRsInt15minInterval));

	header_complex_add_data(&mtpRsInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsInt15minTable_data);

	DEBUGMSGTL(("mtpRsInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minReceivedOctetsOPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minTransmittedOctetsDPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minReceivedMSUsOpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minTransmittedMSUsDpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minRouteSetUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration, &tmpint);

	mtpRsInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
}

/*
 * store_mtpRsInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsInt15minTable", "storing data...  "));

	refresh_mtpRsInt15minTable();

	for (hcindex = mtpRsInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minReceivedOctetsOPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minTransmittedOctetsDPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minReceivedMSUsOpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minTransmittedMSUsDpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minRouteSetUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsSiTable_add(): adds a structure node to our data set 
 */
int
mtpRsSiTable_add(struct mtpRsSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));

	header_complex_add_data(&mtpRsSiTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsSiTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiTable_data);

	DEBUGMSGTL(("mtpRsSiTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsSiValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiReceivedOctetsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiTransmittedOctetsDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiReceivedMSUsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiTransmittedMSUsDpcSio, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsSiStatus, &tmpint);

	mtpRsSiTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
}

/*
 * store_mtpRsSiTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiTable", "storing data...  "));

	refresh_mtpRsSiTable();

	for (hcindex = mtpRsSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsSiTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsSiValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiReceivedOctetsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiTransmittedOctetsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiReceivedMSUsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiTransmittedMSUsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsSiStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsSiInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpRsSiInt5minTable_add(struct mtpRsSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));
	/* mtpRsSiInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsSiInt5minInterval, sizeof(thedata->mtpRsSiInt5minInterval));

	header_complex_add_data(&mtpRsSiInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsSiInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiInt5minTable_data);

	DEBUGMSGTL(("mtpRsSiInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio, &tmpint);

	mtpRsSiInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
}

/*
 * store_mtpRsSiInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiInt5minTable", "storing data...  "));

	refresh_mtpRsSiInt5minTable();

	for (hcindex = mtpRsSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsSiInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsSiInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpRsSiInt15minTable_add(struct mtpRsSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));
	/* mtpRsSiInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsSiInt15minInterval, sizeof(thedata->mtpRsSiInt15minInterval));

	header_complex_add_data(&mtpRsSiInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsSiInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiInt15minTable_data);

	DEBUGMSGTL(("mtpRsSiInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio, &tmpint);

	mtpRsSiInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
}

/*
 * store_mtpRsSiInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiInt15minTable", "storing data...  "));

	refresh_mtpRsSiInt15minTable();

	for (hcindex = mtpRsSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsSiInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRtTable_add(): adds a structure node to our data set 
 */
int
mtpRtTable_add(struct mtpRtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpId, thedata->mtpSpIdLen);
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRsId, thedata->mtpRsIdLen);
	/* mtpRtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRtId, thedata->mtpRtIdLen);

	header_complex_add_data(&mtpRtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRtTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRtTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRtTable_data);

	DEBUGMSGTL(("mtpRtTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
	if (StorageTmp->mtpSpId == NULL) {
		config_perror("invalid specification for mtpSpId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsId, &StorageTmp->mtpRsIdLen);
	if (StorageTmp->mtpRsId == NULL) {
		config_perror("invalid specification for mtpRsId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtId, &StorageTmp->mtpRtIdLen);
	if (StorageTmp->mtpRtId == NULL) {
		config_perror("invalid specification for mtpRtId");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRtLsPointer, &StorageTmp->mtpRtLsPointerLen);
	if (StorageTmp->mtpRtLsPointer == NULL) {
		config_perror("invalid specification for mtpRtLsPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtOperationalState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
	if (StorageTmp->mtpRtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpRtAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFixedPriority, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFlexiblePriority, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtPriorityMode, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
	if (StorageTmp->mtpRtLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingInformation");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
	if (StorageTmp->mtpRtLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingObject");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
	if (StorageTmp->mtpRtName == NULL) {
		config_perror("invalid specification for mtpRtName");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
	if (StorageTmp->mtpRtSlsList == NULL) {
		config_perror("invalid specification for mtpRtSlsList");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtUsageState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtRowStatus, &tmpint);

	mtpRtTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRtTable", "done.\n"));
}

/*
 * store_mtpRtTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtTable", "storing data...  "));

	refresh_mtpRtTable();

	for (hcindex = mtpRtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRtTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRtTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsId, &StorageTmp->mtpRsIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtId, &StorageTmp->mtpRtIdLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRtLsPointer, &StorageTmp->mtpRtLsPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFixedPriority, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFlexiblePriority, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtPriorityMode, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtUsageState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRtLsaTable_add(): adds a structure node to our data set 
 */
int
mtpRtLsaTable_add(struct mtpRtLsaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtLsaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpId, thedata->mtpSpIdLen);
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRsId, thedata->mtpRsIdLen);
	/* mtpRtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRtId, thedata->mtpRtIdLen);
	/* mtpRtLsaSlsCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtLsaSlsCode, sizeof(thedata->mtpRtLsaSlsCode));

	header_complex_add_data(&mtpRtLsaTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtLsaTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRtLsaTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRtLsaTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRtLsaTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRtLsaTable_data);

	DEBUGMSGTL(("mtpRtLsaTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
	if (StorageTmp->mtpSpId == NULL) {
		config_perror("invalid specification for mtpSpId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsId, &StorageTmp->mtpRsIdLen);
	if (StorageTmp->mtpRsId == NULL) {
		config_perror("invalid specification for mtpRsId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtId, &StorageTmp->mtpRtIdLen);
	if (StorageTmp->mtpRtId == NULL) {
		config_perror("invalid specification for mtpRtId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtLsaSlsCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtLsaNormalSlCode, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &StorageTmp->mtpRtLsaAlternativeSlCodeListLen);
	if (StorageTmp->mtpRtLsaAlternativeSlCodeList == NULL) {
		config_perror("invalid specification for mtpRtLsaAlternativeSlCodeList");
		return;
	}

	mtpRtLsaTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
}

/*
 * store_mtpRtLsaTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtLsaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRtLsaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtLsaTable", "storing data...  "));

	refresh_mtpRtLsaTable();

	for (hcindex = mtpRtLsaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtLsaTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRtLsaTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRtLsaTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsId, &StorageTmp->mtpRsIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtId, &StorageTmp->mtpRtIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtLsaSlsCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtLsaNormalSlCode, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &StorageTmp->mtpRtLsaAlternativeSlCodeListLen);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpLsProfileTable_add(): adds a structure node to our data set 
 */
int
mtpLsProfileTable_add(struct mtpLsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	header_complex_add_data(&mtpLsProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsProfileTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data);

	DEBUGMSGTL(("mtpLsProfileTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsTimersProfileId, &StorageTmp->mtpLsTimersProfileIdLen);
	if (StorageTmp->mtpLsTimersProfileId == NULL) {
		config_perror("invalid specification for mtpLsTimersProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileMtpT6, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileMtpT8, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileMtpT10, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileName, &StorageTmp->mtpLsProfileNameLen);
	if (StorageTmp->mtpLsProfileName == NULL) {
		config_perror("invalid specification for mtpLsProfileName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileRowStatus, &tmpint);

	mtpLsProfileTable_add(StorageTmp);

	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
}

/*
 * store_mtpLsProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsProfileTable", "storing data...  "));

	refresh_mtpLsProfileTable();

	for (hcindex = mtpLsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsProfileTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpLsProfileTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsProfileTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsTimersProfileId, &StorageTmp->mtpLsTimersProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileMtpT6, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileMtpT8, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileMtpT10, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileName, &StorageTmp->mtpLsProfileNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpLsTable_add(): adds a structure node to our data set 
 */
int
mtpLsTable_add(struct mtpLsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpId, thedata->mtpSpIdLen);
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpLsId, thedata->mtpLsIdLen);

	header_complex_add_data(&mtpLsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsTable_data);

	DEBUGMSGTL(("mtpLsTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
	if (StorageTmp->mtpSpId == NULL) {
		config_perror("invalid specification for mtpSpId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsId, &StorageTmp->mtpLsIdLen);
	if (StorageTmp->mtpLsId == NULL) {
		config_perror("invalid specification for mtpLsId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
	if (StorageTmp->mtpLsAdjPc == NULL) {
		config_perror("invalid specification for mtpLsAdjPc");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsMaxCapacity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsCurrentCapacity, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsCongestionControlMethod, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsUsageState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsOperationalState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
	if (StorageTmp->mtpLsAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpLsAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
	if (StorageTmp->mtpLsInLsLoadShareAlgorithm == NULL) {
		config_perror("invalid specification for mtpLsInLsLoadShareAlgorithm");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsProfilePointer, &StorageTmp->mtpLsProfilePointerLen);
	if (StorageTmp->mtpLsProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsNumNormActSls, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
	if (StorageTmp->mtpLsName == NULL) {
		config_perror("invalid specification for mtpLsName");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsAsaProfilePointer, &StorageTmp->mtpLsAsaProfilePointerLen);
	if (StorageTmp->mtpLsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsAsaProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsRowStatus, &tmpint);

	mtpLsTable_add(StorageTmp);

	DEBUGMSGTL(("mtpLsTable", "done.\n"));
}

/*
 * store_mtpLsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsTable", "storing data...  "));

	refresh_mtpLsTable();

	for (hcindex = mtpLsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpLsTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsId, &StorageTmp->mtpLsIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsMaxCapacity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsCurrentCapacity, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsCongestionControlMethod, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsUsageState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsProfilePointer, &StorageTmp->mtpLsProfilePointerLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsNumNormActSls, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsAsaProfilePointer, &StorageTmp->mtpLsAsaProfilePointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpLsCurrentTable_add(): adds a structure node to our data set 
 */
int
mtpLsCurrentTable_add(struct mtpLsCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	header_complex_add_data(&mtpLsCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsCurrentTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpLsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsCurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsCurrentTable_data);

	DEBUGMSGTL(("mtpLsCurrentTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsCurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpLsCurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsCurrentSlsUnavailable, &tmpint);

	mtpLsCurrentTable_add(StorageTmp);

	DEBUGMSGTL(("mtpLsCurrentTable", "done.\n"));
}

/*
 * store_mtpLsCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsCurrentTable", "storing data...  "));

	refresh_mtpLsCurrentTable();

	for (hcindex = mtpLsCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsCurrentTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpLsCurrentTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsCurrentTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsCurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpLsCurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsCurrentSlsUnavailable, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpLsInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpLsInt5minTable_add(struct mtpLsInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsInt5minInterval, sizeof(thedata->mtpLsInt5minInterval));
	/* mtpLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsInt5minInterval, sizeof(thedata->mtpLsInt5minInterval));
	/* mtpLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsInt5minInterval, sizeof(thedata->mtpLsInt5minInterval));
	/* mtpLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsInt5minInterval, sizeof(thedata->mtpLsInt5minInterval));
	/* mtpLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsInt5minInterval, sizeof(thedata->mtpLsInt5minInterval));

	header_complex_add_data(&mtpLsInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpLsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsInt5minTable_data);

	DEBUGMSGTL(("mtpLsInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt5minInterval, &tmpint);

	mtpLsInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpLsInt5minTable", "done.\n"));
}

/*
 * store_mtpLsInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsInt5minTable", "storing data...  "));

	refresh_mtpLsInt5minTable();

	for (hcindex = mtpLsInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpLsInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt5minInterval, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpLsInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpLsInt15minTable_add(struct mtpLsInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpLsInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsInt15minInterval, sizeof(thedata->mtpLsInt15minInterval));

	header_complex_add_data(&mtpLsInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpLsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsInt15minTable_data);

	DEBUGMSGTL(("mtpLsInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpLsInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt15minSlsUnavailable, &tmpint);

	mtpLsInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpLsInt15minTable", "done.\n"));
}

/*
 * store_mtpLsInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsInt15minTable", "storing data...  "));

	refresh_mtpLsInt15minTable();

	for (hcindex = mtpLsInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpLsInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpLsInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt15minSlsUnavailable, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlProfileTable_add(): adds a structure node to our data set 
 */
int
mtpSlProfileTable_add(struct mtpSlProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSlProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSlProfileId, thedata->mtpSlProfileIdLen);

	header_complex_add_data(&mtpSlProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlProfileTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlProfileTable_data);

	DEBUGMSGTL(("mtpSlProfileTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlProfileId, &StorageTmp->mtpSlProfileIdLen);
	if (StorageTmp->mtpSlProfileId == NULL) {
		config_perror("invalid specification for mtpSlProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT17, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT24, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlProfileName, &StorageTmp->mtpSlProfileNameLen);
	if (StorageTmp->mtpSlProfileName == NULL) {
		config_perror("invalid specification for mtpSlProfileName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT4, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT5, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT12, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT13, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT14, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT19A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT20A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT21A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT22, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT23, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT31A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT32A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT33A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT34A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT1T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT2T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT1S, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileRowStatus, &tmpint);

	mtpSlProfileTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlProfileTable", "done.\n"));
}

/*
 * store_mtpSlProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlProfileTable", "storing data...  "));

	refresh_mtpSlProfileTable();

	for (hcindex = mtpSlProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlProfileTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlProfileTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlProfileTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlProfileId, &StorageTmp->mtpSlProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT17, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT24, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlProfileName, &StorageTmp->mtpSlProfileNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT4, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT5, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT12, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT13, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT14, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT19A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT20A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT21A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT22, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT23, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT31A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT32A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT33A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT34A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT1T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT2T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT1S, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlTable_add(): adds a structure node to our data set 
 */
int
mtpSlTable_add(struct mtpSlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpId, thedata->mtpSpIdLen);
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpLsId, thedata->mtpLsIdLen);
	/* mtpSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlCode, sizeof(thedata->mtpSlCode));

	header_complex_add_data(&mtpSlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlTable_data);

	DEBUGMSGTL(("mtpSlTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
	if (StorageTmp->mtpSpId == NULL) {
		config_perror("invalid specification for mtpSpId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsId, &StorageTmp->mtpLsIdLen);
	if (StorageTmp->mtpLsId == NULL) {
		config_perror("invalid specification for mtpLsId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCode, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
	if (StorageTmp->mtpSlSlsCodeCurrentList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeCurrentList");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlMaxCapacity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentCapacity, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlLinkStatus, &StorageTmp->mtpSlLinkStatusLen);
	if (StorageTmp->mtpSlLinkStatus == NULL) {
		config_perror("invalid specification for mtpSlLinkStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlOperationalState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlUsageState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
	if (StorageTmp->mtpSlProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSlProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlL2ProfilePointer, &StorageTmp->mtpSlL2ProfilePointerLen);
	if (StorageTmp->mtpSlL2ProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlL2ProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdtPointer, &StorageTmp->mtpSlSdtPointerLen);
	if (StorageTmp->mtpSlSdtPointer == NULL) {
		config_perror("invalid specification for mtpSlSdtPointer");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdlPointer, &StorageTmp->mtpSlSdlPointerLen);
	if (StorageTmp->mtpSlSdlPointer == NULL) {
		config_perror("invalid specification for mtpSlSdlPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalInhibit, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalUninhibit, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlReplaceSt, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlAsaProfilePointer, &StorageTmp->mtpSlAsaProfilePointerLen);
	if (StorageTmp->mtpSlAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlAsaProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlCongestionLevel, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlList, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlTest, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
	if (StorageTmp->mtpSlName == NULL) {
		config_perror("invalid specification for mtpSlName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtList, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
	if (StorageTmp->mtpSlSlsCodeNormalList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeNormalList");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlProfilePointer, &StorageTmp->mtpSlProfilePointerLen);
	if (StorageTmp->mtpSlProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlRowStatus, &tmpint);

	mtpSlTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlTable", "done.\n"));
}

/*
 * store_mtpSlTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlTable", "storing data...  "));

	refresh_mtpSlTable();

	for (hcindex = mtpSlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsId, &StorageTmp->mtpLsIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCode, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlMaxCapacity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentCapacity, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlLinkStatus, &StorageTmp->mtpSlLinkStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlUsageState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlL2ProfilePointer, &StorageTmp->mtpSlL2ProfilePointerLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdtPointer, &StorageTmp->mtpSlSdtPointerLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdlPointer, &StorageTmp->mtpSlSdlPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalInhibit, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlReplaceSt, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlAsaProfilePointer, &StorageTmp->mtpSlAsaProfilePointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlCongestionLevel, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlList, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlTest, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtList, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlProfilePointer, &StorageTmp->mtpSlProfilePointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlSdlListTable_add(): adds a structure node to our data set 
 */
int
mtpSlSdlListTable_add(struct mtpSlSdlListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdlListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpId, thedata->mtpSpIdLen);
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpLsId, thedata->mtpLsIdLen);
	/* mtpSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlCode, sizeof(thedata->mtpSlCode));
	/* mtpSlSdlListId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdlListId, sizeof(thedata->mtpSlSdlListId));

	header_complex_add_data(&mtpSlSdlListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdlListTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlSdlListTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlSdlListTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlSdlListTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);

	DEBUGMSGTL(("mtpSlSdlListTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
	if (StorageTmp->mtpSpId == NULL) {
		config_perror("invalid specification for mtpSpId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsId, &StorageTmp->mtpLsIdLen);
	if (StorageTmp->mtpLsId == NULL) {
		config_perror("invalid specification for mtpLsId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlListId, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
	if (StorageTmp->mtpSlSdlListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdlListPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdlListRowStatus, &tmpint);

	mtpSlSdlListTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
}

/*
 * store_mtpSlSdlListTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdlListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlSdlListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdlListTable", "storing data...  "));

	refresh_mtpSlSdlListTable();

	for (hcindex = mtpSlSdlListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdlListTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlSdlListTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlSdlListTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsId, &StorageTmp->mtpLsIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlListId, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdlListRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlSdtListTable_add(): adds a structure node to our data set 
 */
int
mtpSlSdtListTable_add(struct mtpSlSdtListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdtListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpId, thedata->mtpSpIdLen);
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpLsId, thedata->mtpLsIdLen);
	/* mtpSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlCode, sizeof(thedata->mtpSlCode));
	/* mtpSlSdtListId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdtListId, sizeof(thedata->mtpSlSdtListId));

	header_complex_add_data(&mtpSlSdtListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdtListTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlSdtListTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlSdtListTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlSdtListTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);

	DEBUGMSGTL(("mtpSlSdtListTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
	if (StorageTmp->mtpSpId == NULL) {
		config_perror("invalid specification for mtpSpId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsId, &StorageTmp->mtpLsIdLen);
	if (StorageTmp->mtpLsId == NULL) {
		config_perror("invalid specification for mtpLsId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtListId, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
	if (StorageTmp->mtpSlSdtListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdtListPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdtListRowStatus, &tmpint);

	mtpSlSdtListTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
}

/*
 * store_mtpSlSdtListTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdtListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlSdtListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdtListTable", "storing data...  "));

	refresh_mtpSlSdtListTable();

	for (hcindex = mtpSlSdtListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdtListTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlSdtListTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlSdtListTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpId, &StorageTmp->mtpSpIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsId, &StorageTmp->mtpLsIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtListId, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdtListRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlCurrentTable_add(): adds a structure node to our data set 
 */
int
mtpSlCurrentTable_add(struct mtpSlCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	header_complex_add_data(&mtpSlCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlCurrentTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlCurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlCurrentTable_data);

	DEBUGMSGTL(("mtpSlCurrentTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlCurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlCurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlUnavailabilityDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlLocalInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlRemoteInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlFailed, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlRemoteProcOutage, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentLocalMgmtInhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentLocalMgmtUninhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentLocalBusy, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlCongestedStarts, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlCongestedDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlCongestionStops, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentCongestionEventsMSULoss, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentChangeovers, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentChangebacks, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentRestorations, &tmpint);

	mtpSlCurrentTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlCurrentTable", "done.\n"));
}

/*
 * store_mtpSlCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlCurrentTable", "storing data...  "));

	refresh_mtpSlCurrentTable();

	for (hcindex = mtpSlCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlCurrentTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlCurrentTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlCurrentTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlCurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlCurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlUnavailabilityDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlLocalInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlRemoteInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlFailed, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlRemoteProcOutage, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentLocalMgmtInhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentLocalMgmtUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentLocalBusy, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlCongestedStarts, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlCongestedDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlCongestionStops, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentCongestionEventsMSULoss, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentChangeovers, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentChangebacks, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentRestorations, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpSlInt5minTable_add(struct mtpSlInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSlInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlInt5minInterval, sizeof(thedata->mtpSlInt5minInterval));

	header_complex_add_data(&mtpSlInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlInt5minTable_data);

	DEBUGMSGTL(("mtpSlInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlUnavailabilityDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlLocalInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlRemoteInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlFailed, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlRemoteProcOutage, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minLocalMgmtInhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minLocalMgmtUninhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minLocalBusy, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlCongestedStarts, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlCongestedDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlCongestionStops, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minCongestionEventsMSULoss, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minChangeovers, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minChangebacks, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minRestorations, &tmpint);

	mtpSlInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlInt5minTable", "done.\n"));
}

/*
 * store_mtpSlInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlInt5minTable", "storing data...  "));

	refresh_mtpSlInt5minTable();

	for (hcindex = mtpSlInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlUnavailabilityDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlLocalInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlRemoteInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlFailed, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlRemoteProcOutage, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minLocalMgmtInhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minLocalMgmtUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minLocalBusy, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlCongestedStarts, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlCongestedDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlCongestionStops, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minCongestionEventsMSULoss, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minChangeovers, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minChangebacks, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minRestorations, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpSlInt15minTable_add(struct mtpSlInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSlInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlInt15minInterval, sizeof(thedata->mtpSlInt15minInterval));

	header_complex_add_data(&mtpSlInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlInt15minTable_data);

	DEBUGMSGTL(("mtpSlInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlUnavailabilityDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlLocalInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlRemoteInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlFailed, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlRemoteProcOutage, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minLocalMgmtInhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minLocalMgmtUninhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minLocalBusy, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlCongestedStarts, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlCongestedDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlCongestionStops, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minCongestionEventsMSULoss, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minChangeovers, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minChangebacks, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minRestorations, &tmpint);

	mtpSlInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlInt15minTable", "done.\n"));
}

/*
 * store_mtpSlInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlInt15minTable", "storing data...  "));

	refresh_mtpSlInt15minTable();

	for (hcindex = mtpSlInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlUnavailabilityDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlLocalInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlRemoteInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlFailed, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlRemoteProcOutage, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minLocalMgmtInhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minLocalMgmtUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minLocalBusy, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlCongestedStarts, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlCongestedDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlCongestionStops, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minCongestionEventsMSULoss, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minChangeovers, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minChangebacks, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minRestorations, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpL2ProfileTable_add(): adds a structure node to our data set 
 */
int
mtpL2ProfileTable_add(struct mtpL2ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpL2ProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpL2ProfileId, thedata->mtpL2ProfileIdLen);

	header_complex_add_data(&mtpL2ProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpL2ProfileTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpL2ProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpL2ProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpL2ProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpL2ProfileTable_data);

	DEBUGMSGTL(("mtpL2ProfileTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL2ProfileId, &StorageTmp->mtpL2ProfileIdLen);
	if (StorageTmp->mtpL2ProfileId == NULL) {
		config_perror("invalid specification for mtpL2ProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileErrorCorrectionMethod, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT4N, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT4E, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT5, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT6, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT7, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Msgs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Octs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Msgs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Octs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileNumberOfThresholdLevels, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileCongestionCounting, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileCongestionReportingBaseObject, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileLoopDelay, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL2ProfileName, &StorageTmp->mtpL2ProfileNameLen);
	if (StorageTmp->mtpL2ProfileName == NULL) {
		config_perror("invalid specification for mtpL2ProfileName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Msgs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Octs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Msgs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Octs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Msgs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Octs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Msgs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Octs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Msgs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Octs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Msgs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Octs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Msgs, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Octs, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerTx, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerTy, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileNumberOfCongestionStates, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileInitialLevelOfCongestion, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileMaxMSUsRetransN1, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileMaxOctRetransN2, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileReceiveCongThreshOnset, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileReceiveCongThreshAbate, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileRowStatus, &tmpint);

	mtpL2ProfileTable_add(StorageTmp);

	DEBUGMSGTL(("mtpL2ProfileTable", "done.\n"));
}

/*
 * store_mtpL2ProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpL2ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpL2ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpL2ProfileTable", "storing data...  "));

	refresh_mtpL2ProfileTable();

	for (hcindex = mtpL2ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL2ProfileTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpL2ProfileTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpL2ProfileTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL2ProfileId, &StorageTmp->mtpL2ProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileErrorCorrectionMethod, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT4N, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT4E, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT5, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT6, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT7, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Msgs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Octs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Msgs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Octs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileNumberOfThresholdLevels, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileCongestionCounting, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileCongestionReportingBaseObject, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileLoopDelay, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL2ProfileName, &StorageTmp->mtpL2ProfileNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Msgs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Octs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Msgs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Octs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Msgs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Octs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Msgs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Octs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Msgs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Octs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Msgs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Octs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Msgs, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Octs, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerTx, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerTy, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileNumberOfCongestionStates, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileInitialLevelOfCongestion, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileMaxMSUsRetransN1, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileMaxOctRetransN2, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileReceiveCongThreshOnset, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileReceiveCongThreshAbate, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpNbandTable_add(): adds a structure node to our data set 
 */
int
mtpNbandTable_add(struct mtpNbandTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNbandTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpL2ProfileId, thedata->mtpL2ProfileIdLen);

	header_complex_add_data(&mtpNbandTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNbandTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpNbandTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpNbandTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpNbandTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpNbandTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpNbandTable_data);

	DEBUGMSGTL(("mtpNbandTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL2ProfileId, &StorageTmp->mtpL2ProfileIdLen);
	if (StorageTmp->mtpL2ProfileId == NULL) {
		config_perror("invalid specification for mtpL2ProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbTransmissionRate, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbandRowStatus, &tmpint);

	mtpNbandTable_add(StorageTmp);

	DEBUGMSGTL(("mtpNbandTable", "done.\n"));
}

/*
 * store_mtpNbandTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpNbandTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpNbandTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNbandTable", "storing data...  "));

	refresh_mtpNbandTable();

	for (hcindex = mtpNbandTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNbandTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpNbandTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpNbandTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL2ProfileId, &StorageTmp->mtpL2ProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbTransmissionRate, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbandRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpNbandTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSaalTable_add(): adds a structure node to our data set 
 */
int
mtpSaalTable_add(struct mtpSaalTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSaalTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpL2ProfileId, thedata->mtpL2ProfileIdLen);

	header_complex_add_data(&mtpSaalTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSaalTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSaalTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSaalTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSaalTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSaalTable_data);

	DEBUGMSGTL(("mtpSaalTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL2ProfileId, &StorageTmp->mtpL2ProfileIdLen);
	if (StorageTmp->mtpL2ProfileId == NULL) {
		config_perror("invalid specification for mtpL2ProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalBufferRelease, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxCc, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxNrp, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxPd, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxStat, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalN1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerCc, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerIdle, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerPoll, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalRowStatus, &tmpint);

	mtpSaalTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
}

/*
 * store_mtpSaalTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSaalTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSaalTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSaalTable", "storing data...  "));

	refresh_mtpSaalTable();

	for (hcindex = mtpSaalTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSaalTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSaalTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSaalTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL2ProfileId, &StorageTmp->mtpL2ProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalBufferRelease, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxCc, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxNrp, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxPd, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxStat, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalN1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerCc, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerIdle, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerPoll, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpM2paTable_add(): adds a structure node to our data set 
 */
int
mtpM2paTable_add(struct mtpM2paTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpM2paTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpL2ProfileId, thedata->mtpL2ProfileIdLen);

	header_complex_add_data(&mtpM2paTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpM2paTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpM2paTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpM2paTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpM2paTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpM2paTable_data);

	DEBUGMSGTL(("mtpM2paTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL2ProfileId, &StorageTmp->mtpL2ProfileIdLen);
	if (StorageTmp->mtpL2ProfileId == NULL) {
		config_perror("invalid specification for mtpL2ProfileId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paN1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paProving, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paManagementProvingState, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayUpper, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpNoDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxseg, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpHeartbeat, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoInitial, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMin, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMax, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieLife, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieInc, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxBurst, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpSackDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpLifetime, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paProvingAttempts, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paRowStatus, &tmpint);

	mtpM2paTable_add(StorageTmp);

	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
}

/*
 * store_mtpM2paTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpM2paTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpM2paTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpM2paTable", "storing data...  "));

	refresh_mtpM2paTable();

	for (hcindex = mtpM2paTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM2paTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpM2paTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpM2paTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL2ProfileId, &StorageTmp->mtpL2ProfileIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paN1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paProving, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paManagementProvingState, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayUpper, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpNoDelay, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxseg, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpHeartbeat, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoInitial, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMin, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMax, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieLife, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieInc, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxBurst, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpSackDelay, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpLifetime, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paProvingAttempts, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSdtTable_add(): adds a structure node to our data set 
 */
int
mtpSdtTable_add(struct mtpSdtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSdtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtId, thedata->mtpSdtIdLen);

	header_complex_add_data(&mtpSdtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdtTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdtTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdtTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSdtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdtTable_data);

	DEBUGMSGTL(("mtpSdtTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtId, &StorageTmp->mtpSdtIdLen);
	if (StorageTmp->mtpSdtId == NULL) {
		config_perror("invalid specification for mtpSdtId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtAdminState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtOperState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtUsageState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtProcStatus, &StorageTmp->mtpSdtProcStatusLen);
	if (StorageTmp->mtpSdtProcStatus == NULL) {
		config_perror("invalid specification for mtpSdtProcStatus");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtAvailStatus, &StorageTmp->mtpSdtAvailStatusLen);
	if (StorageTmp->mtpSdtAvailStatus == NULL) {
		config_perror("invalid specification for mtpSdtAvailStatus");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
	if (StorageTmp->mtpSdtEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdtEquipmentPointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
	if (StorageTmp->mtpSdtName == NULL) {
		config_perror("invalid specification for mtpSdtName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtRowStatus, &tmpint);

	mtpSdtTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
}

/*
 * store_mtpSdtTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSdtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdtTable", "storing data...  "));

	refresh_mtpSdtTable();

	for (hcindex = mtpSdtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdtTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSdtTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSdtTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtId, &StorageTmp->mtpSdtIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtAdminState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtOperState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtUsageState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtProcStatus, &StorageTmp->mtpSdtProcStatusLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtAvailStatus, &StorageTmp->mtpSdtAvailStatusLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSdlTable_add(): adds a structure node to our data set 
 */
int
mtpSdlTable_add(struct mtpSdlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSdlId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdlId, thedata->mtpSdlIdLen);

	header_complex_add_data(&mtpSdlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdlTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdlTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdlTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSdlTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdlTable_data);

	DEBUGMSGTL(("mtpSdlTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlId, &StorageTmp->mtpSdlIdLen);
	if (StorageTmp->mtpSdlId == NULL) {
		config_perror("invalid specification for mtpSdlId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
	if (StorageTmp->mtpSdlAdjPc == NULL) {
		config_perror("invalid specification for mtpSdlAdjPc");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlTransmissionRate, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlLoopDelay, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlOperState, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
	if (StorageTmp->mtpSdlEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdlEquipmentPointer");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlCIC, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
	if (StorageTmp->mtpSdlName == NULL) {
		config_perror("invalid specification for mtpSdlName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlStmChannel, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
	if (StorageTmp->mtpSdlVcTTpPointer == NULL) {
		config_perror("invalid specification for mtpSdlVcTTpPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlRowStatus, &tmpint);

	mtpSdlTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
}

/*
 * store_mtpSdlTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSdlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdlTable", "storing data...  "));

	refresh_mtpSdlTable();

	for (hcindex = mtpSdlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdlTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSdlTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSdlTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlId, &StorageTmp->mtpSdlIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlTransmissionRate, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlLoopDelay, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlOperState, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlCIC, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlStmChannel, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpSapTable(): refresh mtpSapTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSapTable(void)
{
	if (mtpSapTable_refresh == 0)
		return;
	mtpSapTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSapTable_row(): refresh mtpSapTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
{
	if (StorageTmp->mtpSapTable_request == sa_request)
		return;
	StorageTmp->mtpSapTable_request = sa_request;
}

/*
 * var_mtpSapTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSapTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSapTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSapTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSapTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSapTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSAP2ADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSap2Address);
		return (u_char *) &StorageTmp->mtpSap2Address;

	case MTPSAPUSERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSapUserEntityNames);
		return (u_char *) &StorageTmp->mtpSapUserEntityNames;

	case MTPSAPPROVIDERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSapProviderEntityNames);
		return (u_char *) &StorageTmp->mtpSapProviderEntityNames;

	case MTPSAPASAPROFILEPOINTER:
		*write_method = write_mtpSapAsaProfilePointer;
		*var_len = StorageTmp->mtpSapAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpSapAsaProfilePointer;

	case MTPSAPNAME:
		*write_method = write_mtpSapName;
		*var_len = StorageTmp->mtpSapNameLen;
		return (u_char *) StorageTmp->mtpSapName;

	case MTPSAPLONGMESSAGESUPPORTED:
		*write_method = write_mtpSapLongMessageSupported;
		*var_len = sizeof(StorageTmp->mtpSapLongMessageSupported);
		return (u_char *) &StorageTmp->mtpSapLongMessageSupported;

	case MTPSAPROWSTATUS:
		*write_method = write_mtpSapRowStatus;
		*var_len = sizeof(StorageTmp->mtpSapRowStatus);
		return (u_char *) &StorageTmp->mtpSapRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSap2AddressTable(): refresh mtpSap2AddressTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSap2AddressTable(void)
{
	if (mtpSap2AddressTable_refresh == 0)
		return;
	mtpSap2AddressTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSap2AddressTable_row(): refresh mtpSap2AddressTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSap2AddressTable_row(struct mtpSap2AddressTable_data *StorageTmp)
{
	if (StorageTmp->mtpSap2AddressTable_request == sa_request)
		return;
	StorageTmp->mtpSap2AddressTable_request = sa_request;
}

/*
 * var_mtpSap2AddressTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSap2AddressTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSap2AddressTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSap2AddressTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSap2AddressTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSap2AddressTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSap2AddressTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSAP2ADDRESSCOMPONENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSap2AddressComponentLen;
		return (u_char *) StorageTmp->mtpSap2AddressComponent;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSapUserEntityNamesTable(): refresh mtpSapUserEntityNamesTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSapUserEntityNamesTable(void)
{
	if (mtpSapUserEntityNamesTable_refresh == 0)
		return;
	mtpSapUserEntityNamesTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSapUserEntityNamesTable_row(): refresh mtpSapUserEntityNamesTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSapUserEntityNamesTable_row(struct mtpSapUserEntityNamesTable_data *StorageTmp)
{
	if (StorageTmp->mtpSapUserEntityNamesTable_request == sa_request)
		return;
	StorageTmp->mtpSapUserEntityNamesTable_request = sa_request;
}

/*
 * var_mtpSapUserEntityNamesTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSapUserEntityNamesTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSapUserEntityNamesTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSapUserEntityNamesTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSapUserEntityNamesTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSapUserEntityNamesTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSapUserEntityNamesTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSAPUSERENTITYNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSapUserEntityNameLen;
		return (u_char *) StorageTmp->mtpSapUserEntityName;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSapProviderEntityNamesTable(): refresh mtpSapProviderEntityNamesTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSapProviderEntityNamesTable(void)
{
	if (mtpSapProviderEntityNamesTable_refresh == 0)
		return;
	mtpSapProviderEntityNamesTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSapProviderEntityNamesTable_row(): refresh mtpSapProviderEntityNamesTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSapProviderEntityNamesTable_row(struct mtpSapProviderEntityNamesTable_data *StorageTmp)
{
	if (StorageTmp->mtpSapProviderEntityNamesTable_request == sa_request)
		return;
	StorageTmp->mtpSapProviderEntityNamesTable_request = sa_request;
}

/*
 * var_mtpSapProviderEntityNamesTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSapProviderEntityNamesTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSapProviderEntityNamesTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSapProviderEntityNamesTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSapProviderEntityNamesTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSapProviderEntityNamesTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSapProviderEntityNamesTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSAPPROVIDERENTITYNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSapProviderEntityNameLen;
		return (u_char *) StorageTmp->mtpSapProviderEntityName;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpNaTable(): refresh mtpNaTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpNaTable(void)
{
	if (mtpNaTable_refresh == 0)
		return;
	mtpNaTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpNaTable_row(): refresh mtpNaTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
{
	if (StorageTmp->mtpNaTable_request == sa_request)
		return;
	StorageTmp->mtpNaTable_request = sa_request;
}

/*
 * var_mtpNaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpNaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpNaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpNaTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpNaTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpNaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpNaTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPNAPROTOCOLVARIANT:
		*write_method = write_mtpNaProtocolVariant;
		*var_len = StorageTmp->mtpNaProtocolVariantLen;
		return (u_char *) StorageTmp->mtpNaProtocolVariant;

	case MTPNAPROTOCOLYEAR:
		*write_method = write_mtpNaProtocolYear;
		*var_len = sizeof(StorageTmp->mtpNaProtocolYear);
		return (u_char *) &StorageTmp->mtpNaProtocolYear;

	case MTPNAPROTOCOLOPTIONS:
		*write_method = write_mtpNaProtocolOptions;
		*var_len = StorageTmp->mtpNaProtocolOptionsLen;
		return (u_char *) StorageTmp->mtpNaProtocolOptions;

	case MTPNANETWORKINDICATOR:
		*write_method = write_mtpNaNetworkIndicator;
		*var_len = sizeof(StorageTmp->mtpNaNetworkIndicator);
		return (u_char *) &StorageTmp->mtpNaNetworkIndicator;

	case MTPNAPOINTCODEFORMAT:
		*write_method = write_mtpNaPointCodeFormat;
		*var_len = StorageTmp->mtpNaPointCodeFormatLen;
		return (u_char *) StorageTmp->mtpNaPointCodeFormat;

	case MTPNASLSLENGTH:
		*write_method = write_mtpNaSlsLength;
		*var_len = sizeof(StorageTmp->mtpNaSlsLength);
		return (u_char *) &StorageTmp->mtpNaSlsLength;

	case MTPNASPPROFILEPOINTER:
		*write_method = write_mtpNaSpProfilePointer;
		*var_len = StorageTmp->mtpNaSpProfilePointerLen;
		return (u_char *) StorageTmp->mtpNaSpProfilePointer;

	case MTPNANAME:
		*write_method = write_mtpNaName;
		*var_len = StorageTmp->mtpNaNameLen;
		return (u_char *) StorageTmp->mtpNaName;

	case MTPNAROWSTATUS:
		*write_method = write_mtpNaRowStatus;
		*var_len = sizeof(StorageTmp->mtpNaRowStatus);
		return (u_char *) &StorageTmp->mtpNaRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsTable(): refresh mtpGsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpGsTable(void)
{
	if (mtpGsTable_refresh == 0)
		return;
	mtpGsTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpGsTable_row(): refresh mtpGsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsTable_request == sa_request)
		return;
	StorageTmp->mtpGsTable_request = sa_request;
}

/*
 * var_mtpGsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpGsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpGsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpGsTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPGSADMINISTRATIVESTATE:
		*write_method = write_mtpGsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpGsAdministrativeState);
		return (u_char *) &StorageTmp->mtpGsAdministrativeState;

	case MTPGSTREATMENTOFOUTSIDERANGES:
		*write_method = write_mtpGsTreatmentOfOutsideRanges;
		*var_len = sizeof(StorageTmp->mtpGsTreatmentOfOutsideRanges);
		return (u_char *) &StorageTmp->mtpGsTreatmentOfOutsideRanges;

	case MTPGSLISTMODE:
		*write_method = write_mtpGsListMode;
		*var_len = sizeof(StorageTmp->mtpGsListMode);
		return (u_char *) &StorageTmp->mtpGsListMode;

	case MTPGSSCREENINGBYLINKSETORBYOPC:
		*write_method = write_mtpGsScreeningByLinkSetOrByOpc;
		*var_len = sizeof(StorageTmp->mtpGsScreeningByLinkSetOrByOpc);
		return (u_char *) &StorageTmp->mtpGsScreeningByLinkSetOrByOpc;

	case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC:
		*write_method = write_mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		*var_len = sizeof(StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc);
		return (u_char *) &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;

	case MTPGSNAME:
		*write_method = write_mtpGsName;
		*var_len = StorageTmp->mtpGsNameLen;
		return (u_char *) StorageTmp->mtpGsName;

	case MTPGSROWSTATUS:
		*write_method = write_mtpGsRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsRowStatus);
		return (u_char *) &StorageTmp->mtpGsRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsLineTable(): refresh mtpGsLineTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpGsLineTable(void)
{
	if (mtpGsLineTable_refresh == 0)
		return;
	mtpGsLineTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpGsLineTable_row(): refresh mtpGsLineTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsLineTable_request == sa_request)
		return;
	StorageTmp->mtpGsLineTable_request = sa_request;
}

/*
 * var_mtpGsLineTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpGsLineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpGsLineTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsLineTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsLineTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsLineTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpGsLineTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPGSLINECONTENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpGsLineContent);
		return (u_char *) &StorageTmp->mtpGsLineContent;

	case MTPGSLINEROWSTATUS:
		*write_method = write_mtpGsLineRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsLineRowStatus);
		return (u_char *) &StorageTmp->mtpGsLineRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsLineContentTable(): refresh mtpGsLineContentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpGsLineContentTable(void)
{
	if (mtpGsLineContentTable_refresh == 0)
		return;
	mtpGsLineContentTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpGsLineContentTable_row(): refresh mtpGsLineContentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsLineContentTable_request == sa_request)
		return;
	StorageTmp->mtpGsLineContentTable_request = sa_request;
}

/*
 * var_mtpGsLineContentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpGsLineContentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpGsLineContentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsLineContentTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsLineContentTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpGsLineContentTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPGSLINECONTENTDESIGNATEDDPCLAST:
		*write_method = write_mtpGsLineContentDesignatedDPCLast;
		*var_len = sizeof(StorageTmp->mtpGsLineContentDesignatedDPCLast);
		return (u_char *) &StorageTmp->mtpGsLineContentDesignatedDPCLast;

	case MTPGSLINECONTENTMESSAGETREATMENT:
		*write_method = write_mtpGsLineContentMessageTreatment;
		*var_len = sizeof(StorageTmp->mtpGsLineContentMessageTreatment);
		return (u_char *) &StorageTmp->mtpGsLineContentMessageTreatment;

	case MTPGSLINECONTENTROWSTATUS:
		*write_method = write_mtpGsLineContentRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsLineContentRowStatus);
		return (u_char *) &StorageTmp->mtpGsLineContentRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpProfileTable(): refresh mtpSpProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpProfileTable(void)
{
	if (mtpSpProfileTable_refresh == 0)
		return;
	mtpSpProfileTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpProfileTable_row(): refresh mtpSpProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSpProfileTable_request = sa_request;
}

/*
 * var_mtpSpProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpProfileTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpProfileTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpProfileTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPPROFILEMTPT2:
		*write_method = write_mtpSpProfileMtpT2;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT2);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT2;

	case MTPSPPROFILEMTPT4:
		*write_method = write_mtpSpProfileMtpT4;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT4);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT4;

	case MTPSPPROFILEMTPT5:
		*write_method = write_mtpSpProfileMtpT5;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT5);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT5;

	case MTPSPPROFILEMTPT7:
		*write_method = write_mtpSpProfileMtpT7;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT7);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT7;

	case MTPSPPROFILEMTPT11:
		*write_method = write_mtpSpProfileMtpT11;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT11);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT11;

	case MTPSPPROFILEMTPT12:
		*write_method = write_mtpSpProfileMtpT12;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT12);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT12;

	case MTPSPPROFILEMTPT13:
		*write_method = write_mtpSpProfileMtpT13;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT13);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT13;

	case MTPSPPROFILEMTPT14:
		*write_method = write_mtpSpProfileMtpT14;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT14);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT14;

	case MTPSPPROFILEMTPT15:
		*write_method = write_mtpSpProfileMtpT15;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT15);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT15;

	case MTPSPPROFILEMTPT16:
		*write_method = write_mtpSpProfileMtpT16;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT16);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT16;

	case MTPSPPROFILEMTPT18:
		*write_method = write_mtpSpProfileMtpT18;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT18);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT18;

	case MTPSPPROFILEMTPT19:
		*write_method = write_mtpSpProfileMtpT19;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT19);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT19;

	case MTPSPPROFILEMTPT20:
		*write_method = write_mtpSpProfileMtpT20;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT20);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT20;

	case MTPSPPROFILEMTPT21:
		*write_method = write_mtpSpProfileMtpT21;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT21);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT21;

	case MTPSPPROFILEMTPT22:
		*write_method = write_mtpSpProfileMtpT22;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT22);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT22;

	case MTPSPPROFILEMTPT23:
		*write_method = write_mtpSpProfileMtpT23;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT23);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT23;

	case MTPSPPROFILEMTPT20A:
		*write_method = write_mtpSpProfileMtpT20A;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT20A);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT20A;

	case MTPSPPROFILEMTPT21A:
		*write_method = write_mtpSpProfileMtpT21A;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT21A);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT21A;

	case MTPSPPROFILEMTPT1T:
		*write_method = write_mtpSpProfileMtpT1T;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT1T);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT1T;

	case MTPSPPROFILEMTPT2T:
		*write_method = write_mtpSpProfileMtpT2T;
		*var_len = sizeof(StorageTmp->mtpSpProfileMtpT2T);
		return (u_char *) &StorageTmp->mtpSpProfileMtpT2T;

	case MTPSPPROFILENAME:
		*write_method = write_mtpSpProfileName;
		*var_len = StorageTmp->mtpSpProfileNameLen;
		return (u_char *) StorageTmp->mtpSpProfileName;

	case MTPSPPROFILEROWSTATUS:
		*write_method = write_mtpSpProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpSpProfileRowStatus);
		return (u_char *) &StorageTmp->mtpSpProfileRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpTable(): refresh mtpSpTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpTable(void)
{
	if (mtpSpTable_refresh == 0)
		return;
	mtpSpTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpTable_row(): refresh mtpSpTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpTable_request == sa_request)
		return;
	StorageTmp->mtpSpTable_request = sa_request;
}

/*
 * var_mtpSpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPPOINTCODE:
		*write_method = write_mtpSpPointCode;
		*var_len = sizeof(StorageTmp->mtpSpPointCode);
		return (u_char *) &StorageTmp->mtpSpPointCode;

	case MTPSPTYPE:
		*write_method = write_mtpSpType;
		*var_len = sizeof(StorageTmp->mtpSpType);
		return (u_char *) &StorageTmp->mtpSpType;

	case MTPSPOPERATIONALSTATE:
		*write_method = write_mtpSpOperationalState;
		*var_len = sizeof(StorageTmp->mtpSpOperationalState);
		return (u_char *) &StorageTmp->mtpSpOperationalState;

	case MTPSPPROCEDURALSTATUS:
		*write_method = write_mtpSpProceduralStatus;
		*var_len = StorageTmp->mtpSpProceduralStatusLen;
		return (u_char *) StorageTmp->mtpSpProceduralStatus;

	case MTPSPAVAILABILITYSTATUS:
		*write_method = write_mtpSpAvailabilityStatus;
		*var_len = StorageTmp->mtpSpAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpSpAvailabilityStatus;

	case MTPSPVERSION:
		*write_method = write_mtpSpVersion;
		*var_len = StorageTmp->mtpSpVersionLen;
		return (u_char *) StorageTmp->mtpSpVersion;

	case MTPSPNETWORKINDICATOR:
		*write_method = write_mtpSpNetworkIndicator;
		*var_len = sizeof(StorageTmp->mtpSpNetworkIndicator);
		return (u_char *) &StorageTmp->mtpSpNetworkIndicator;

	case MTPSPNAME:
		*write_method = write_mtpSpName;
		*var_len = StorageTmp->mtpSpNameLen;
		return (u_char *) StorageTmp->mtpSpName;

	case MTPSPMTPT1:
		*write_method = write_mtpSpMtpT1;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1);
		return (u_char *) &StorageTmp->mtpSpMtpT1;

	case MTPSPMTPT2:
		*write_method = write_mtpSpMtpT2;
		*var_len = sizeof(StorageTmp->mtpSpMtpT2);
		return (u_char *) &StorageTmp->mtpSpMtpT2;

	case MTPSPMTPT3:
		*write_method = write_mtpSpMtpT3;
		*var_len = sizeof(StorageTmp->mtpSpMtpT3);
		return (u_char *) &StorageTmp->mtpSpMtpT3;

	case MTPSPMTPT4:
		*write_method = write_mtpSpMtpT4;
		*var_len = sizeof(StorageTmp->mtpSpMtpT4);
		return (u_char *) &StorageTmp->mtpSpMtpT4;

	case MTPSPMTPT5:
		*write_method = write_mtpSpMtpT5;
		*var_len = sizeof(StorageTmp->mtpSpMtpT5);
		return (u_char *) &StorageTmp->mtpSpMtpT5;

	case MTPSPMTPT6:
		*write_method = write_mtpSpMtpT6;
		*var_len = sizeof(StorageTmp->mtpSpMtpT6);
		return (u_char *) &StorageTmp->mtpSpMtpT6;

	case MTPSPMTPT7:
		*write_method = write_mtpSpMtpT7;
		*var_len = sizeof(StorageTmp->mtpSpMtpT7);
		return (u_char *) &StorageTmp->mtpSpMtpT7;

	case MTPSPMTPT8:
		*write_method = write_mtpSpMtpT8;
		*var_len = sizeof(StorageTmp->mtpSpMtpT8);
		return (u_char *) &StorageTmp->mtpSpMtpT8;

	case MTPSPMTPT10:
		*write_method = write_mtpSpMtpT10;
		*var_len = sizeof(StorageTmp->mtpSpMtpT10);
		return (u_char *) &StorageTmp->mtpSpMtpT10;

	case MTPSPMTPT11:
		*write_method = write_mtpSpMtpT11;
		*var_len = sizeof(StorageTmp->mtpSpMtpT11);
		return (u_char *) &StorageTmp->mtpSpMtpT11;

	case MTPSPMTPT12:
		*write_method = write_mtpSpMtpT12;
		*var_len = sizeof(StorageTmp->mtpSpMtpT12);
		return (u_char *) &StorageTmp->mtpSpMtpT12;

	case MTPSPMTPT13:
		*write_method = write_mtpSpMtpT13;
		*var_len = sizeof(StorageTmp->mtpSpMtpT13);
		return (u_char *) &StorageTmp->mtpSpMtpT13;

	case MTPSPMTPT14:
		*write_method = write_mtpSpMtpT14;
		*var_len = sizeof(StorageTmp->mtpSpMtpT14);
		return (u_char *) &StorageTmp->mtpSpMtpT14;

	case MTPSPMTPT15:
		*write_method = write_mtpSpMtpT15;
		*var_len = sizeof(StorageTmp->mtpSpMtpT15);
		return (u_char *) &StorageTmp->mtpSpMtpT15;

	case MTPSPMTPT16:
		*write_method = write_mtpSpMtpT16;
		*var_len = sizeof(StorageTmp->mtpSpMtpT16);
		return (u_char *) &StorageTmp->mtpSpMtpT16;

	case MTPSPMTPT17:
		*write_method = write_mtpSpMtpT17;
		*var_len = sizeof(StorageTmp->mtpSpMtpT17);
		return (u_char *) &StorageTmp->mtpSpMtpT17;

	case MTPSPMTPT19A:
		*write_method = write_mtpSpMtpT19A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT19A);
		return (u_char *) &StorageTmp->mtpSpMtpT19A;

	case MTPSPMTPT31A:
		*write_method = write_mtpSpMtpT31A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT31A);
		return (u_char *) &StorageTmp->mtpSpMtpT31A;

	case MTPSPMTPT32A:
		*write_method = write_mtpSpMtpT32A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT32A);
		return (u_char *) &StorageTmp->mtpSpMtpT32A;

	case MTPSPMTPT33A:
		*write_method = write_mtpSpMtpT33A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT33A);
		return (u_char *) &StorageTmp->mtpSpMtpT33A;

	case MTPSPMTPT34A:
		*write_method = write_mtpSpMtpT34A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT34A);
		return (u_char *) &StorageTmp->mtpSpMtpT34A;

	case MTPSPMTPT18:
		*write_method = write_mtpSpMtpT18;
		*var_len = sizeof(StorageTmp->mtpSpMtpT18);
		return (u_char *) &StorageTmp->mtpSpMtpT18;

	case MTPSPMTPT19:
		*write_method = write_mtpSpMtpT19;
		*var_len = sizeof(StorageTmp->mtpSpMtpT19);
		return (u_char *) &StorageTmp->mtpSpMtpT19;

	case MTPSPMTPT20:
		*write_method = write_mtpSpMtpT20;
		*var_len = sizeof(StorageTmp->mtpSpMtpT20);
		return (u_char *) &StorageTmp->mtpSpMtpT20;

	case MTPSPMTPT21:
		*write_method = write_mtpSpMtpT21;
		*var_len = sizeof(StorageTmp->mtpSpMtpT21);
		return (u_char *) &StorageTmp->mtpSpMtpT21;

	case MTPSPMTPT22:
		*write_method = write_mtpSpMtpT22;
		*var_len = sizeof(StorageTmp->mtpSpMtpT22);
		return (u_char *) &StorageTmp->mtpSpMtpT22;

	case MTPSPMTPT23:
		*write_method = write_mtpSpMtpT23;
		*var_len = sizeof(StorageTmp->mtpSpMtpT23);
		return (u_char *) &StorageTmp->mtpSpMtpT23;

	case MTPSPMTPT20A:
		*write_method = write_mtpSpMtpT20A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT20A);
		return (u_char *) &StorageTmp->mtpSpMtpT20A;

	case MTPSPMTPT21A:
		*write_method = write_mtpSpMtpT21A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT21A);
		return (u_char *) &StorageTmp->mtpSpMtpT21A;

	case MTPSPMTPT24:
		*write_method = write_mtpSpMtpT24;
		*var_len = sizeof(StorageTmp->mtpSpMtpT24);
		return (u_char *) &StorageTmp->mtpSpMtpT24;

	case MTPSPMTPT1T:
		*write_method = write_mtpSpMtpT1T;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1T);
		return (u_char *) &StorageTmp->mtpSpMtpT1T;

	case MTPSPMTPT2T:
		*write_method = write_mtpSpMtpT2T;
		*var_len = sizeof(StorageTmp->mtpSpMtpT2T);
		return (u_char *) &StorageTmp->mtpSpMtpT2T;

	case MTPSPMTPT1S:
		*write_method = write_mtpSpMtpT1S;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1S);
		return (u_char *) &StorageTmp->mtpSpMtpT1S;

	case MTPSPPROFILEPOINTER:
		*write_method = write_mtpSpProfilePointer;
		*var_len = StorageTmp->mtpSpProfilePointerLen;
		return (u_char *) StorageTmp->mtpSpProfilePointer;

	case MTPSPNAPOINTER:
		*write_method = write_mtpSpNaPointer;
		*var_len = StorageTmp->mtpSpNaPointerLen;
		return (u_char *) StorageTmp->mtpSpNaPointer;

	case MTPSPROWSTATUS:
		*write_method = write_mtpSpRowStatus;
		*var_len = sizeof(StorageTmp->mtpSpRowStatus);
		return (u_char *) &StorageTmp->mtpSpRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpCurrentTable(): refresh mtpSpCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpCurrentTable(void)
{
	if (mtpSpCurrentTable_refresh == 0)
		return;
	mtpSpCurrentTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpCurrentTable_row(): refresh mtpSpCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpCurrentTable_row(struct mtpSpCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpSpCurrentTable_request = sa_request;
}

/*
 * var_mtpSpCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpCurrentTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpCurrentTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpCurrentTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPCURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentValidIntervals);
		return (u_char *) &StorageTmp->mtpSpCurrentValidIntervals;

	case MTPSPCURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpSpCurrentTimeDiscontinuity;

	case MTPSPCURRENTDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSpCurrentDiscardedMSUs;

	case MTPSPCURRENTRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus0);
		return (u_char *) &StorageTmp->mtpSpCurrentReceivedTFCstatus0;

	case MTPSPCURRENTRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus1);
		return (u_char *) &StorageTmp->mtpSpCurrentReceivedTFCstatus1;

	case MTPSPCURRENTRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus2);
		return (u_char *) &StorageTmp->mtpSpCurrentReceivedTFCstatus2;

	case MTPSPCURRENTOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentOctetsXferred);
		return (u_char *) &StorageTmp->mtpSpCurrentOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpInt5minTable(): refresh mtpSpInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpInt5minTable(void)
{
	if (mtpSpInt5minTable_refresh == 0)
		return;
	mtpSpInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpInt5minTable_row(): refresh mtpSpInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpInt5minTable_row(struct mtpSpInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpInt5minTable_request = sa_request;
}

/*
 * var_mtpSpInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpSpInt5minTimeStamp;

	case MTPSPINT5MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSpInt5minDiscardedMSUs;

	case MTPSPINT5MINRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus0);
		return (u_char *) &StorageTmp->mtpSpInt5minReceivedTFCstatus0;

	case MTPSPINT5MINRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus1);
		return (u_char *) &StorageTmp->mtpSpInt5minReceivedTFCstatus1;

	case MTPSPINT5MINRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus2);
		return (u_char *) &StorageTmp->mtpSpInt5minReceivedTFCstatus2;

	case MTPSPINT5MINOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minOctetsXferred);
		return (u_char *) &StorageTmp->mtpSpInt5minOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpInt15minTable(): refresh mtpSpInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpInt15minTable(void)
{
	if (mtpSpInt15minTable_refresh == 0)
		return;
	mtpSpInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpInt15minTable_row(): refresh mtpSpInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpInt15minTable_row(struct mtpSpInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpInt15minTable_request = sa_request;
}

/*
 * var_mtpSpInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpSpInt15minTimeStamp;

	case MTPSPINT15MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSpInt15minDiscardedMSUs;

	case MTPSPINT15MINRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus0);
		return (u_char *) &StorageTmp->mtpSpInt15minReceivedTFCstatus0;

	case MTPSPINT15MINRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus1);
		return (u_char *) &StorageTmp->mtpSpInt15minReceivedTFCstatus1;

	case MTPSPINT15MINRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus2);
		return (u_char *) &StorageTmp->mtpSpInt15minReceivedTFCstatus2;

	case MTPSPINT15MINOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minOctetsXferred);
		return (u_char *) &StorageTmp->mtpSpInt15minOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiTable(): refresh mtpSpSiTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiTable(void)
{
	if (mtpSpSiTable_refresh == 0)
		return;
	mtpSpSiTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpSiTable_row(): refresh mtpSpSiTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiTable_row(struct mtpSpSiTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiTable_request = sa_request;
}

/*
 * var_mtpSpSiTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpSiTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpSiTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpSiTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSIVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiValidIntervals);
		return (u_char *) &StorageTmp->mtpSpSiValidIntervals;

	case MTPSPSITIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpSpSiTimeDiscontinuity;

	case MTPSPSITRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiTransmittedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiTransmittedUPUnavailable;

	case MTPSPSIRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiReceivedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiReceivedUPUnavailable;

	case MTPSPSIHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiHandledOctetsSIO);
		return (u_char *) &StorageTmp->mtpSpSiHandledOctetsSIO;

	case MTPSPSISTATUS:
		*write_method = write_mtpSpSiStatus;
		*var_len = sizeof(StorageTmp->mtpSpSiStatus);
		return (u_char *) &StorageTmp->mtpSpSiStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiInt5minTable(): refresh mtpSpSiInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiInt5minTable(void)
{
	if (mtpSpSiInt5minTable_refresh == 0)
		return;
	mtpSpSiInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpSiInt5minTable_row(): refresh mtpSpSiInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiInt5minTable_row(struct mtpSpSiInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiInt5minTable_request = sa_request;
}

/*
 * var_mtpSpSiInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpSiInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpSiInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpSiInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpSpSiInt5minTimeStamp;

	case MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable;

	case MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minReceivedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable;

	case MTPSPSIINT5MINHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minHandledOctetsSIO);
		return (u_char *) &StorageTmp->mtpSpSiInt5minHandledOctetsSIO;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiInt15minTable(): refresh mtpSpSiInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiInt15minTable(void)
{
	if (mtpSpSiInt15minTable_refresh == 0)
		return;
	mtpSpSiInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpSiInt15minTable_row(): refresh mtpSpSiInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiInt15minTable_row(struct mtpSpSiInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiInt15minTable_request = sa_request;
}

/*
 * var_mtpSpSiInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpSiInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpSiInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpSiInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSIINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpSpSiInt15minTimeStamp;

	case MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable;

	case MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minReceivedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable;

	case MTPSPSIINT15MINHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minHandledOctetsSIO);
		return (u_char *) &StorageTmp->mtpSpSiInt15minHandledOctetsSIO;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyTable(): refresh mtpSpStudyTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyTable(void)
{
	if (mtpSpStudyTable_refresh == 0)
		return;
	mtpSpStudyTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpStudyTable_row(): refresh mtpSpStudyTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyTable_row(struct mtpSpStudyTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyTable_request = sa_request;
}

/*
 * var_mtpSpStudyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpStudyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpStudyTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpStudyTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpStudyTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSTUDYVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyValidIntervals);
		return (u_char *) &StorageTmp->mtpSpStudyValidIntervals;

	case MTPSPSTUDYTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpSpStudyTimeDiscontinuity;

	case MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio;

	case MTPSPSTUDYHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio;

	case MTPSPSTUDYSTATUS:
		*write_method = write_mtpSpStudyStatus;
		*var_len = sizeof(StorageTmp->mtpSpStudyStatus);
		return (u_char *) &StorageTmp->mtpSpStudyStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyInt5minTable(): refresh mtpSpStudyInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyInt5minTable(void)
{
	if (mtpSpStudyInt5minTable_refresh == 0)
		return;
	mtpSpStudyInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpStudyInt5minTable_row(): refresh mtpSpStudyInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyInt5minTable_row(struct mtpSpStudyInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyInt5minTable_request = sa_request;
}

/*
 * var_mtpSpStudyInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpStudyInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpStudyInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpStudyInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpStudyInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSTUDYINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpSpStudyInt5minTimeStamp;

	case MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio;

	case MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyInt15minTable(): refresh mtpSpStudyInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyInt15minTable(void)
{
	if (mtpSpStudyInt15minTable_refresh == 0)
		return;
	mtpSpStudyInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpStudyInt15minTable_row(): refresh mtpSpStudyInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyInt15minTable_row(struct mtpSpStudyInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyInt15minTable_request = sa_request;
}

/*
 * var_mtpSpStudyInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpStudyInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpStudyInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpStudyInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpStudyInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSTUDYINT15MININTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minInterval);
		return (u_char *) &StorageTmp->mtpSpStudyInt15minInterval;

	case MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio;

	case MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyMapTable(): refresh mtpSpStudyMapTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyMapTable(void)
{
	if (mtpSpStudyMapTable_refresh == 0)
		return;
	mtpSpStudyMapTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpStudyMapTable_row(): refresh mtpSpStudyMapTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyMapTable_row(struct mtpSpStudyMapTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyMapTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyMapTable_request = sa_request;
}

/*
 * var_mtpSpStudyMapTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSpStudyMapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpStudyMapTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpStudyMapTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyMapTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyMapTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpStudyMapTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSTUDYMAPSTATUS:
		*write_method = write_mtpSpStudyMapStatus;
		*var_len = sizeof(StorageTmp->mtpSpStudyMapStatus);
		return (u_char *) &StorageTmp->mtpSpStudyMapStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpL3Table(): refresh mtpL3Table
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpL3Table(void)
{
	if (mtpL3Table_refresh == 0)
		return;
	mtpL3Table_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpL3Table_row(): refresh mtpL3Table row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
{
	if (StorageTmp->mtpL3Table_request == sa_request)
		return;
	StorageTmp->mtpL3Table_request = sa_request;
}

/*
 * var_mtpL3Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpL3Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpL3Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpL3Table: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpL3Table();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpL3TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpL3Table_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPL3ADMINISTRATIVESTATE:
		*write_method = write_mtpL3AdministrativeState;
		*var_len = sizeof(StorageTmp->mtpL3AdministrativeState);
		return (u_char *) &StorageTmp->mtpL3AdministrativeState;

	case MTPL3OPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL3OperationalState);
		return (u_char *) &StorageTmp->mtpL3OperationalState;

	case MTPL3USAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL3UsageState);
		return (u_char *) &StorageTmp->mtpL3UsageState;

	case MTPL3PROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpL3ProceduralStatusLen;
		return (u_char *) StorageTmp->mtpL3ProceduralStatus;

	case MTPL3ASAPROFILEPOINTER:
		*write_method = write_mtpL3AsaProfilePointer;
		*var_len = StorageTmp->mtpL3AsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpL3AsaProfilePointer;

	case MTPL3NAME:
		*write_method = write_mtpL3Name;
		*var_len = StorageTmp->mtpL3NameLen;
		return (u_char *) StorageTmp->mtpL3Name;

	case MTPL3ROWSTATUS:
		*write_method = write_mtpL3RowStatus;
		*var_len = sizeof(StorageTmp->mtpL3RowStatus);
		return (u_char *) &StorageTmp->mtpL3RowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsTable(): refresh mtpRsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsTable(void)
{
	if (mtpRsTable_refresh == 0)
		return;
	mtpRsTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsTable_row(): refresh mtpRsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsTable_request == sa_request)
		return;
	StorageTmp->mtpRsTable_request = sa_request;
}

/*
 * var_mtpRsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSADMINISTRATIVESTATE:
		*write_method = write_mtpRsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpRsAdministrativeState);
		return (u_char *) &StorageTmp->mtpRsAdministrativeState;

	case MTPRSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsOperationalState);
		return (u_char *) &StorageTmp->mtpRsOperationalState;

	case MTPRSASAPROFILEPOINTER:
		*write_method = write_mtpRsAsaProfilePointer;
		*var_len = StorageTmp->mtpRsAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpRsAsaProfilePointer;

	case MTPRSCONGESTEDSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCongestedState);
		return (u_char *) &StorageTmp->mtpRsCongestedState;

	case MTPRSCONGESTIONLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCongestionLevel);
		return (u_char *) &StorageTmp->mtpRsCongestionLevel;

	case MTPRSLOADSHARINGINFORMATION:
		*write_method = write_mtpRsLoadsharingInformation;
		*var_len = StorageTmp->mtpRsLoadsharingInformationLen;
		return (u_char *) StorageTmp->mtpRsLoadsharingInformation;

	case MTPRSLOADSHARINGOBJECT:
		*write_method = write_mtpRsLoadsharingObject;
		*var_len = StorageTmp->mtpRsLoadsharingObjectLen;
		return (u_char *) StorageTmp->mtpRsLoadsharingObject;

	case MTPRSREMOTEEXCHANGELABEL:
		*write_method = write_mtpRsRemoteExchangeLabel;
		*var_len = StorageTmp->mtpRsRemoteExchangeLabelLen;
		return (u_char *) StorageTmp->mtpRsRemoteExchangeLabel;

	case MTPRSNAME:
		*write_method = write_mtpRsName;
		*var_len = StorageTmp->mtpRsNameLen;
		return (u_char *) StorageTmp->mtpRsName;

	case MTPRSROWSTATUS:
		*write_method = write_mtpRsRowStatus;
		*var_len = sizeof(StorageTmp->mtpRsRowStatus);
		return (u_char *) &StorageTmp->mtpRsRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsCurrentTable(): refresh mtpRsCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsCurrentTable(void)
{
	if (mtpRsCurrentTable_refresh == 0)
		return;
	mtpRsCurrentTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsCurrentTable_row(): refresh mtpRsCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsCurrentTable_row(struct mtpRsCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpRsCurrentTable_request = sa_request;
}

/*
 * var_mtpRsCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpRsCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsCurrentTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsCurrentTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsCurrentTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSCURRENTVALIDINTERVALS:
		*write_method = write_mtpRsCurrentValidIntervals;
		*var_len = sizeof(StorageTmp->mtpRsCurrentValidIntervals);
		return (u_char *) &StorageTmp->mtpRsCurrentValidIntervals;

	case MTPRSCURRENTTIMEDISCONTINUITY:
		*write_method = write_mtpRsCurrentTimeDiscontinuity;
		*var_len = sizeof(StorageTmp->mtpRsCurrentTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpRsCurrentTimeDiscontinuity;

	case MTPRSCURRENTRECEIVEDOCTETSOPC:
		*write_method = write_mtpRsCurrentReceivedOctetsOPC;
		*var_len = sizeof(StorageTmp->mtpRsCurrentReceivedOctetsOPC);
		return (u_char *) &StorageTmp->mtpRsCurrentReceivedOctetsOPC;

	case MTPRSCURRENTTRANSMITTEDOCTETSDPC:
		*write_method = write_mtpRsCurrentTransmittedOctetsDPC;
		*var_len = sizeof(StorageTmp->mtpRsCurrentTransmittedOctetsDPC);
		return (u_char *) &StorageTmp->mtpRsCurrentTransmittedOctetsDPC;

	case MTPRSCURRENTRECEIVEDMSUSOPC:
		*write_method = write_mtpRsCurrentReceivedMSUsOpc;
		*var_len = sizeof(StorageTmp->mtpRsCurrentReceivedMSUsOpc);
		return (u_char *) &StorageTmp->mtpRsCurrentReceivedMSUsOpc;

	case MTPRSCURRENTTRANSMITTEDMSUSDPC:
		*write_method = write_mtpRsCurrentTransmittedMSUsDpc;
		*var_len = sizeof(StorageTmp->mtpRsCurrentTransmittedMSUsDpc);
		return (u_char *) &StorageTmp->mtpRsCurrentTransmittedMSUsDpc;

	case MTPRSCURRENTROUTESETUNAVAILABLE:
		*write_method = write_mtpRsCurrentRouteSetUnavailable;
		*var_len = sizeof(StorageTmp->mtpRsCurrentRouteSetUnavailable);
		return (u_char *) &StorageTmp->mtpRsCurrentRouteSetUnavailable;

	case MTPRSCURRENTROUTESETUNAVAILABLEDURATION:
		*write_method = write_mtpRsCurrentRouteSetUnavailableDuration;
		*var_len = sizeof(StorageTmp->mtpRsCurrentRouteSetUnavailableDuration);
		return (u_char *) &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsInt5minTable(): refresh mtpRsInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsInt5minTable(void)
{
	if (mtpRsInt5minTable_refresh == 0)
		return;
	mtpRsInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsInt5minTable_row(): refresh mtpRsInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsInt5minTable_row(struct mtpRsInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpRsInt5minTable_request = sa_request;
}

/*
 * var_mtpRsInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpRsInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpRsInt5minTimeStamp;

	case MTPRSINT5MINRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minReceivedOctetsOPC);
		return (u_char *) &StorageTmp->mtpRsInt5minReceivedOctetsOPC;

	case MTPRSINT5MINTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTransmittedOctetsDPC);
		return (u_char *) &StorageTmp->mtpRsInt5minTransmittedOctetsDPC;

	case MTPRSINT5MINRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minReceivedMSUsOpc);
		return (u_char *) &StorageTmp->mtpRsInt5minReceivedMSUsOpc;

	case MTPRSINT5MINTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTransmittedMSUsDpc);
		return (u_char *) &StorageTmp->mtpRsInt5minTransmittedMSUsDpc;

	case MTPRSINT5MINROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minRouteSetUnavailable);
		return (u_char *) &StorageTmp->mtpRsInt5minRouteSetUnavailable;

	case MTPRSINT5MINROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minRouteSetUnavailableDuration);
		return (u_char *) &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsInt15minTable(): refresh mtpRsInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsInt15minTable(void)
{
	if (mtpRsInt15minTable_refresh == 0)
		return;
	mtpRsInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsInt15minTable_row(): refresh mtpRsInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsInt15minTable_row(struct mtpRsInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpRsInt15minTable_request = sa_request;
}

/*
 * var_mtpRsInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpRsInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpRsInt15minTimeStamp;

	case MTPRSINT15MINRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minReceivedOctetsOPC);
		return (u_char *) &StorageTmp->mtpRsInt15minReceivedOctetsOPC;

	case MTPRSINT15MINTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTransmittedOctetsDPC);
		return (u_char *) &StorageTmp->mtpRsInt15minTransmittedOctetsDPC;

	case MTPRSINT15MINRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minReceivedMSUsOpc);
		return (u_char *) &StorageTmp->mtpRsInt15minReceivedMSUsOpc;

	case MTPRSINT15MINTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTransmittedMSUsDpc);
		return (u_char *) &StorageTmp->mtpRsInt15minTransmittedMSUsDpc;

	case MTPRSINT15MINROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minRouteSetUnavailable);
		return (u_char *) &StorageTmp->mtpRsInt15minRouteSetUnavailable;

	case MTPRSINT15MINROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minRouteSetUnavailableDuration);
		return (u_char *) &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiTable(): refresh mtpRsSiTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiTable(void)
{
	if (mtpRsSiTable_refresh == 0)
		return;
	mtpRsSiTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsSiTable_row(): refresh mtpRsSiTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiTable_row(struct mtpRsSiTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiTable_request = sa_request;
}

/*
 * var_mtpRsSiTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpRsSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsSiTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsSiTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsSiTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSSIVALIDINTERVALS:
		*write_method = write_mtpRsSiValidIntervals;
		*var_len = sizeof(StorageTmp->mtpRsSiValidIntervals);
		return (u_char *) &StorageTmp->mtpRsSiValidIntervals;

	case MTPRSSITIMEDISCONTINUITY:
		*write_method = write_mtpRsSiTimeDiscontinuity;
		*var_len = sizeof(StorageTmp->mtpRsSiTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpRsSiTimeDiscontinuity;

	case MTPRSSIRECEIVEDOCTETSOPCSIO:
		*write_method = write_mtpRsSiReceivedOctetsOpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiReceivedOctetsOpcSio);
		return (u_char *) &StorageTmp->mtpRsSiReceivedOctetsOpcSio;

	case MTPRSSITRANSMITTEDOCTETSDPCSIO:
		*write_method = write_mtpRsSiTransmittedOctetsDpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiTransmittedOctetsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiTransmittedOctetsDpcSio;

	case MTPRSSIRECEIVEDMSUSOPCSIO:
		*write_method = write_mtpRsSiReceivedMSUsOpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiReceivedMSUsOpcSio);
		return (u_char *) &StorageTmp->mtpRsSiReceivedMSUsOpcSio;

	case MTPRSSITRANSMITTEDMSUSDPCSIO:
		*write_method = write_mtpRsSiTransmittedMSUsDpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiTransmittedMSUsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiTransmittedMSUsDpcSio;

	case MTPRSSISTATUS:
		*write_method = write_mtpRsSiStatus;
		*var_len = sizeof(StorageTmp->mtpRsSiStatus);
		return (u_char *) &StorageTmp->mtpRsSiStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiInt5minTable(): refresh mtpRsSiInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiInt5minTable(void)
{
	if (mtpRsSiInt5minTable_refresh == 0)
		return;
	mtpRsSiInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsSiInt5minTable_row(): refresh mtpRsSiInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiInt5minTable_row(struct mtpRsSiInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiInt5minTable_request = sa_request;
}

/*
 * var_mtpRsSiInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpRsSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsSiInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsSiInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsSiInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpRsSiInt5minTimeStamp;

	case MTPRSSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpRsSiInt5minTimeStamp;

	case MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio;

	case MTPRSSIINT5MINRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio;

	case MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiInt15minTable(): refresh mtpRsSiInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiInt15minTable(void)
{
	if (mtpRsSiInt15minTable_refresh == 0)
		return;
	mtpRsSiInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsSiInt15minTable_row(): refresh mtpRsSiInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiInt15minTable_row(struct mtpRsSiInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiInt15minTable_request = sa_request;
}

/*
 * var_mtpRsSiInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpRsSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsSiInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsSiInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsSiInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSSIINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpRsSiInt15minTimeStamp;

	case MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio;

	case MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio;

	case MTPRSSIINT15MINRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio;

	case MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRtTable(): refresh mtpRtTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRtTable(void)
{
	if (mtpRtTable_refresh == 0)
		return;
	mtpRtTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRtTable_row(): refresh mtpRtTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtTable_request == sa_request)
		return;
	StorageTmp->mtpRtTable_request = sa_request;
}

/*
 * var_mtpRtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpRtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRtTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRtTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRTLSPOINTER:
		*write_method = write_mtpRtLsPointer;
		*var_len = StorageTmp->mtpRtLsPointerLen;
		return (u_char *) StorageTmp->mtpRtLsPointer;

	case MTPRTADMINISTRATIVESTATE:
		*write_method = write_mtpRtAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpRtAdministrativeState);
		return (u_char *) &StorageTmp->mtpRtAdministrativeState;

	case MTPRTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRtOperationalState);
		return (u_char *) &StorageTmp->mtpRtOperationalState;

	case MTPRTAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpRtAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpRtAvailabilityStatus;

	case MTPRTINCLSLOADSHARINGALGORITHM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRtInClsLoadsharingAlgorithm);
		return (u_char *) &StorageTmp->mtpRtInClsLoadsharingAlgorithm;

	case MTPRTFIXEDPRIORITY:
		*write_method = write_mtpRtFixedPriority;
		*var_len = sizeof(StorageTmp->mtpRtFixedPriority);
		return (u_char *) &StorageTmp->mtpRtFixedPriority;

	case MTPRTFLEXIBLEPRIORITY:
		*write_method = write_mtpRtFlexiblePriority;
		*var_len = sizeof(StorageTmp->mtpRtFlexiblePriority);
		return (u_char *) &StorageTmp->mtpRtFlexiblePriority;

	case MTPRTPRIORITYMODE:
		*write_method = write_mtpRtPriorityMode;
		*var_len = sizeof(StorageTmp->mtpRtPriorityMode);
		return (u_char *) &StorageTmp->mtpRtPriorityMode;

	case MTPRTLOADSHARINGINFORMATION:
		*write_method = write_mtpRtLoadsharingInformation;
		*var_len = StorageTmp->mtpRtLoadsharingInformationLen;
		return (u_char *) StorageTmp->mtpRtLoadsharingInformation;

	case MTPRTLOADSHARINGOBJECT:
		*write_method = write_mtpRtLoadsharingObject;
		*var_len = StorageTmp->mtpRtLoadsharingObjectLen;
		return (u_char *) StorageTmp->mtpRtLoadsharingObject;

	case MTPRTNAME:
		*write_method = write_mtpRtName;
		*var_len = StorageTmp->mtpRtNameLen;
		return (u_char *) StorageTmp->mtpRtName;

	case MTPRTSLSLIST:
		*write_method = write_mtpRtSlsList;
		*var_len = StorageTmp->mtpRtSlsListLen;
		return (u_char *) StorageTmp->mtpRtSlsList;

	case MTPRTUSAGESTATE:
		*write_method = write_mtpRtUsageState;
		*var_len = sizeof(StorageTmp->mtpRtUsageState);
		return (u_char *) &StorageTmp->mtpRtUsageState;

	case MTPRTROWSTATUS:
		*write_method = write_mtpRtRowStatus;
		*var_len = sizeof(StorageTmp->mtpRtRowStatus);
		return (u_char *) &StorageTmp->mtpRtRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRtLsaTable(): refresh mtpRtLsaTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRtLsaTable(void)
{
	if (mtpRtLsaTable_refresh == 0)
		return;
	mtpRtLsaTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRtLsaTable_row(): refresh mtpRtLsaTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtLsaTable_request == sa_request)
		return;
	StorageTmp->mtpRtLsaTable_request = sa_request;
}

/*
 * var_mtpRtLsaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpRtLsaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRtLsaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtLsaTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRtLsaTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRtLsaTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRTLSANORMALSLCODE:
		*write_method = write_mtpRtLsaNormalSlCode;
		*var_len = sizeof(StorageTmp->mtpRtLsaNormalSlCode);
		return (u_char *) &StorageTmp->mtpRtLsaNormalSlCode;

	case MTPRTLSAALTERNATIVESLCODELIST:
		*write_method = write_mtpRtLsaAlternativeSlCodeList;
		*var_len = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
		return (u_char *) StorageTmp->mtpRtLsaAlternativeSlCodeList;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsProfileTable(): refresh mtpLsProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsProfileTable(void)
{
	if (mtpLsProfileTable_refresh == 0)
		return;
	mtpLsProfileTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpLsProfileTable_row(): refresh mtpLsProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsProfileTable_request == sa_request)
		return;
	StorageTmp->mtpLsProfileTable_request = sa_request;
}

/*
 * var_mtpLsProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpLsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpLsProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsProfileTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsProfileTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpLsProfileTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPLSPROFILEMTPT6:
		*write_method = write_mtpLsProfileMtpT6;
		*var_len = sizeof(StorageTmp->mtpLsProfileMtpT6);
		return (u_char *) &StorageTmp->mtpLsProfileMtpT6;

	case MTPLSPROFILEMTPT8:
		*write_method = write_mtpLsProfileMtpT8;
		*var_len = sizeof(StorageTmp->mtpLsProfileMtpT8);
		return (u_char *) &StorageTmp->mtpLsProfileMtpT8;

	case MTPLSPROFILEMTPT10:
		*write_method = write_mtpLsProfileMtpT10;
		*var_len = sizeof(StorageTmp->mtpLsProfileMtpT10);
		return (u_char *) &StorageTmp->mtpLsProfileMtpT10;

	case MTPLSPROFILENAME:
		*write_method = write_mtpLsProfileName;
		*var_len = StorageTmp->mtpLsProfileNameLen;
		return (u_char *) StorageTmp->mtpLsProfileName;

	case MTPLSPROFILEROWSTATUS:
		*write_method = write_mtpLsProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpLsProfileRowStatus);
		return (u_char *) &StorageTmp->mtpLsProfileRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsTable(): refresh mtpLsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsTable(void)
{
	if (mtpLsTable_refresh == 0)
		return;
	mtpLsTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpLsTable_row(): refresh mtpLsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsTable_request == sa_request)
		return;
	StorageTmp->mtpLsTable_request = sa_request;
}

/*
 * var_mtpLsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpLsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpLsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpLsTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPLSADJPC:
		*write_method = write_mtpLsAdjPc;
		*var_len = StorageTmp->mtpLsAdjPcLen;
		return (u_char *) StorageTmp->mtpLsAdjPc;

	case MTPLSMAXCAPACITY:
		*write_method = write_mtpLsMaxCapacity;
		*var_len = sizeof(StorageTmp->mtpLsMaxCapacity);
		return (u_char *) &StorageTmp->mtpLsMaxCapacity;

	case MTPLSCURRENTCAPACITY:
		*write_method = write_mtpLsCurrentCapacity;
		*var_len = sizeof(StorageTmp->mtpLsCurrentCapacity);
		return (u_char *) &StorageTmp->mtpLsCurrentCapacity;

	case MTPLSCONGESTIONCONTROLMETHOD:
		*write_method = write_mtpLsCongestionControlMethod;
		*var_len = sizeof(StorageTmp->mtpLsCongestionControlMethod);
		return (u_char *) &StorageTmp->mtpLsCongestionControlMethod;

	case MTPLSUSAGESTATE:
		*write_method = write_mtpLsUsageState;
		*var_len = sizeof(StorageTmp->mtpLsUsageState);
		return (u_char *) &StorageTmp->mtpLsUsageState;

	case MTPLSOPERATIONALSTATE:
		*write_method = write_mtpLsOperationalState;
		*var_len = sizeof(StorageTmp->mtpLsOperationalState);
		return (u_char *) &StorageTmp->mtpLsOperationalState;

	case MTPLSAVAILABILITYSTATUS:
		*write_method = write_mtpLsAvailabilityStatus;
		*var_len = StorageTmp->mtpLsAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpLsAvailabilityStatus;

	case MTPLSPERIODICLINKTESTFLAG:
		*write_method = write_mtpLsPeriodicLinkTestFlag;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFlag);
		return (u_char *) &StorageTmp->mtpLsPeriodicLinkTestFlag;

	case MTPLSADMINISTRATIVESTATE:
		*write_method = write_mtpLsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpLsAdministrativeState);
		return (u_char *) &StorageTmp->mtpLsAdministrativeState;

	case MTPLSINLSLOADSHAREALGORITHM:
		*write_method = write_mtpLsInLsLoadShareAlgorithm;
		*var_len = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
		return (u_char *) StorageTmp->mtpLsInLsLoadShareAlgorithm;

	case MTPLSPROFILEPOINTER:
		*write_method = write_mtpLsProfilePointer;
		*var_len = StorageTmp->mtpLsProfilePointerLen;
		return (u_char *) StorageTmp->mtpLsProfilePointer;

	case MTPLSNUMNORMACTSLS:
		*write_method = write_mtpLsNumNormActSls;
		*var_len = sizeof(StorageTmp->mtpLsNumNormActSls);
		return (u_char *) &StorageTmp->mtpLsNumNormActSls;

	case MTPLSNAME:
		*write_method = write_mtpLsName;
		*var_len = StorageTmp->mtpLsNameLen;
		return (u_char *) StorageTmp->mtpLsName;

	case MTPLSASAPROFILEPOINTER:
		*write_method = write_mtpLsAsaProfilePointer;
		*var_len = StorageTmp->mtpLsAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpLsAsaProfilePointer;

	case MTPLSROWSTATUS:
		*write_method = write_mtpLsRowStatus;
		*var_len = sizeof(StorageTmp->mtpLsRowStatus);
		return (u_char *) &StorageTmp->mtpLsRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsCurrentTable(): refresh mtpLsCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsCurrentTable(void)
{
	if (mtpLsCurrentTable_refresh == 0)
		return;
	mtpLsCurrentTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpLsCurrentTable_row(): refresh mtpLsCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsCurrentTable_row(struct mtpLsCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpLsCurrentTable_request = sa_request;
}

/*
 * var_mtpLsCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpLsCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpLsCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsCurrentTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsCurrentTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpLsCurrentTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPLSCURRENTVALIDINTERVALS:
		*write_method = write_mtpLsCurrentValidIntervals;
		*var_len = sizeof(StorageTmp->mtpLsCurrentValidIntervals);
		return (u_char *) &StorageTmp->mtpLsCurrentValidIntervals;

	case MTPLSCURRENTTIMEDISCONTINUITY:
		*write_method = write_mtpLsCurrentTimeDiscontinuity;
		*var_len = sizeof(StorageTmp->mtpLsCurrentTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpLsCurrentTimeDiscontinuity;

	case MTPLSCURRENTADJACENTINACCESSIBLEEVENTS:
		*write_method = write_mtpLsCurrentAdjacentInaccessibleEvents;
		*var_len = sizeof(StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents);
		return (u_char *) &StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents;

	case MTPLSCURRENTADJACENTINACCESSIBLEDURATION:
		*write_method = write_mtpLsCurrentAdjacentInaccessibleDuration;
		*var_len = sizeof(StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration);
		return (u_char *) &StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration;

	case MTPLSCURRENTSLSUNAVAILABLE:
		*write_method = write_mtpLsCurrentSlsUnavailable;
		*var_len = sizeof(StorageTmp->mtpLsCurrentSlsUnavailable);
		return (u_char *) &StorageTmp->mtpLsCurrentSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsInt5minTable(): refresh mtpLsInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsInt5minTable(void)
{
	if (mtpLsInt5minTable_refresh == 0)
		return;
	mtpLsInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpLsInt5minTable_row(): refresh mtpLsInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsInt5minTable_row(struct mtpLsInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpLsInt5minTable_request = sa_request;
}

/*
 * var_mtpLsInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpLsInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpLsInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpLsInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsInt15minTable(): refresh mtpLsInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsInt15minTable(void)
{
	if (mtpLsInt15minTable_refresh == 0)
		return;
	mtpLsInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpLsInt15minTable_row(): refresh mtpLsInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsInt15minTable_row(struct mtpLsInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpLsInt15minTable_request = sa_request;
}

/*
 * var_mtpLsInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpLsInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpLsInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpLsInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPLSINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpLsInt15minTimeStamp;

	case MTPLSINT15MINADJACENTINACCESSIBLEEVENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents);
		return (u_char *) &StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents;

	case MTPLSINT15MINADJACENTINACCESSIBLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration);
		return (u_char *) &StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration;

	case MTPLSINT15MINSLSUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minSlsUnavailable);
		return (u_char *) &StorageTmp->mtpLsInt15minSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlProfileTable(): refresh mtpSlProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlProfileTable(void)
{
	if (mtpSlProfileTable_refresh == 0)
		return;
	mtpSlProfileTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlProfileTable_row(): refresh mtpSlProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlProfileTable_row(struct mtpSlProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSlProfileTable_request = sa_request;
}

/*
 * var_mtpSlProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSlProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlProfileTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlProfileTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlProfileTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLPROFILETIMERT1:
		*write_method = write_mtpSlProfileTimerT1;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT1);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT1;

	case MTPSLPROFILETIMERT3:
		*write_method = write_mtpSlProfileTimerT3;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT3);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT3;

	case MTPSLPROFILETIMERT17:
		*write_method = write_mtpSlProfileTimerT17;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT17);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT17;

	case MTPSLPROFILETIMERT24:
		*write_method = write_mtpSlProfileTimerT24;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT24);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT24;

	case MTPSLPROFILENAME:
		*write_method = write_mtpSlProfileName;
		*var_len = StorageTmp->mtpSlProfileNameLen;
		return (u_char *) StorageTmp->mtpSlProfileName;

	case MTPSLPROFILETIMERT2:
		*write_method = write_mtpSlProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT2);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT2;

	case MTPSLPROFILETIMERT4:
		*write_method = write_mtpSlProfileTimerT4;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT4);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT4;

	case MTPSLPROFILETIMERT5:
		*write_method = write_mtpSlProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT5);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT5;

	case MTPSLPROFILETIMERT12:
		*write_method = write_mtpSlProfileTimerT12;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT12);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT12;

	case MTPSLPROFILETIMERT13:
		*write_method = write_mtpSlProfileTimerT13;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT13);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT13;

	case MTPSLPROFILETIMERT14:
		*write_method = write_mtpSlProfileTimerT14;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT14);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT14;

	case MTPSLPROFILETIMERT19A:
		*write_method = write_mtpSlProfileTimerT19A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT19A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT19A;

	case MTPSLPROFILETIMERT20A:
		*write_method = write_mtpSlProfileTimerT20A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT20A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT20A;

	case MTPSLPROFILETIMERT21A:
		*write_method = write_mtpSlProfileTimerT21A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT21A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT21A;

	case MTPSLPROFILETIMERT22:
		*write_method = write_mtpSlProfileTimerT22;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT22);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT22;

	case MTPSLPROFILETIMERT23:
		*write_method = write_mtpSlProfileTimerT23;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT23);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT23;

	case MTPSLPROFILETIMERT31A:
		*write_method = write_mtpSlProfileTimerT31A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT31A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT31A;

	case MTPSLPROFILETIMERT32A:
		*write_method = write_mtpSlProfileTimerT32A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT32A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT32A;

	case MTPSLPROFILETIMERT33A:
		*write_method = write_mtpSlProfileTimerT33A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT33A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT33A;

	case MTPSLPROFILETIMERT34A:
		*write_method = write_mtpSlProfileTimerT34A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT34A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT34A;

	case MTPSLPROFILETIMERT1T:
		*write_method = write_mtpSlProfileTimerT1T;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT1T);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT1T;

	case MTPSLPROFILETIMERT2T:
		*write_method = write_mtpSlProfileTimerT2T;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT2T);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT2T;

	case MTPSLPROFILETIMERT1S:
		*write_method = write_mtpSlProfileTimerT1S;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT1S);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT1S;

	case MTPSLPROFILEROWSTATUS:
		*write_method = write_mtpSlProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlProfileRowStatus);
		return (u_char *) &StorageTmp->mtpSlProfileRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlTable(): refresh mtpSlTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlTable(void)
{
	if (mtpSlTable_refresh == 0)
		return;
	mtpSlTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlTable_row(): refresh mtpSlTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlTable_request == sa_request)
		return;
	StorageTmp->mtpSlTable_request = sa_request;
}

/*
 * var_mtpSlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLSLSCODECURRENTLIST:
		*write_method = write_mtpSlSlsCodeCurrentList;
		*var_len = StorageTmp->mtpSlSlsCodeCurrentListLen;
		return (u_char *) StorageTmp->mtpSlSlsCodeCurrentList;

	case MTPSLMAXCAPACITY:
		*write_method = write_mtpSlMaxCapacity;
		*var_len = sizeof(StorageTmp->mtpSlMaxCapacity);
		return (u_char *) &StorageTmp->mtpSlMaxCapacity;

	case MTPSLCURRENTCAPACITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentCapacity);
		return (u_char *) &StorageTmp->mtpSlCurrentCapacity;

	case MTPSLLINKSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSlLinkStatusLen;
		return (u_char *) StorageTmp->mtpSlLinkStatus;

	case MTPSLADMINISTRATIVESTATE:
		*write_method = write_mtpSlAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpSlAdministrativeState);
		return (u_char *) &StorageTmp->mtpSlAdministrativeState;

	case MTPSLOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlOperationalState);
		return (u_char *) &StorageTmp->mtpSlOperationalState;

	case MTPSLUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlUsageState);
		return (u_char *) &StorageTmp->mtpSlUsageState;

	case MTPSLPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSlProceduralStatusLen;
		return (u_char *) StorageTmp->mtpSlProceduralStatus;

	case MTPSLL2PROFILEPOINTER:
		*write_method = write_mtpSlL2ProfilePointer;
		*var_len = StorageTmp->mtpSlL2ProfilePointerLen;
		return (u_char *) StorageTmp->mtpSlL2ProfilePointer;

	case MTPSLSDTPOINTER:
		*write_method = write_mtpSlSdtPointer;
		*var_len = StorageTmp->mtpSlSdtPointerLen;
		return (u_char *) StorageTmp->mtpSlSdtPointer;

	case MTPSLSDLPOINTER:
		*write_method = write_mtpSlSdlPointer;
		*var_len = StorageTmp->mtpSlSdlPointerLen;
		return (u_char *) StorageTmp->mtpSlSdlPointer;

	case MTPSLLOCALINHIBIT:
		*write_method = write_mtpSlLocalInhibit;
		*var_len = sizeof(StorageTmp->mtpSlLocalInhibit);
		return (u_char *) &StorageTmp->mtpSlLocalInhibit;

	case MTPSLLOCALUNINHIBIT:
		*write_method = write_mtpSlLocalUninhibit;
		*var_len = sizeof(StorageTmp->mtpSlLocalUninhibit);
		return (u_char *) &StorageTmp->mtpSlLocalUninhibit;

	case MTPSLREPLACEST:
		*write_method = write_mtpSlReplaceSt;
		*var_len = sizeof(StorageTmp->mtpSlReplaceSt);
		return (u_char *) &StorageTmp->mtpSlReplaceSt;

	case MTPSLASAPROFILEPOINTER:
		*write_method = write_mtpSlAsaProfilePointer;
		*var_len = StorageTmp->mtpSlAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpSlAsaProfilePointer;

	case MTPSLCONGESTIONLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCongestionLevel);
		return (u_char *) &StorageTmp->mtpSlCongestionLevel;

	case MTPSLRELATEDLINKGROUPNUMBER:
		*write_method = write_mtpSlRelatedLinkGroupNumber;
		*var_len = sizeof(StorageTmp->mtpSlRelatedLinkGroupNumber);
		return (u_char *) &StorageTmp->mtpSlRelatedLinkGroupNumber;

	case MTPSLSDLLIST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlSdlList);
		return (u_char *) &StorageTmp->mtpSlSdlList;

	case MTPSLTEST:
		*write_method = write_mtpSlTest;
		*var_len = sizeof(StorageTmp->mtpSlTest);
		return (u_char *) &StorageTmp->mtpSlTest;

	case MTPSLNAME:
		*write_method = write_mtpSlName;
		*var_len = StorageTmp->mtpSlNameLen;
		return (u_char *) StorageTmp->mtpSlName;

	case MTPSLSDTLIST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlSdtList);
		return (u_char *) &StorageTmp->mtpSlSdtList;

	case MTPSLSLSCODENORMALLIST:
		*write_method = write_mtpSlSlsCodeNormalList;
		*var_len = StorageTmp->mtpSlSlsCodeNormalListLen;
		return (u_char *) StorageTmp->mtpSlSlsCodeNormalList;

	case MTPSLPROFILEPOINTER:
		*write_method = write_mtpSlProfilePointer;
		*var_len = StorageTmp->mtpSlProfilePointerLen;
		return (u_char *) StorageTmp->mtpSlProfilePointer;

	case MTPSLROWSTATUS:
		*write_method = write_mtpSlRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlRowStatus);
		return (u_char *) &StorageTmp->mtpSlRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlSdlListTable(): refresh mtpSlSdlListTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlSdlListTable(void)
{
	if (mtpSlSdlListTable_refresh == 0)
		return;
	mtpSlSdlListTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlSdlListTable_row(): refresh mtpSlSdlListTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlSdlListTable_request == sa_request)
		return;
	StorageTmp->mtpSlSdlListTable_request = sa_request;
}

/*
 * var_mtpSlSdlListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSlSdlListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlSdlListTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlSdlListTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlSdlListTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlSdlListTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlSdlListTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLSDLLISTPOINTER:
		*write_method = write_mtpSlSdlListPointer;
		*var_len = StorageTmp->mtpSlSdlListPointerLen;
		return (u_char *) StorageTmp->mtpSlSdlListPointer;

	case MTPSLSDLLISTROWSTATUS:
		*write_method = write_mtpSlSdlListRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlSdlListRowStatus);
		return (u_char *) &StorageTmp->mtpSlSdlListRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlSdtListTable(): refresh mtpSlSdtListTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlSdtListTable(void)
{
	if (mtpSlSdtListTable_refresh == 0)
		return;
	mtpSlSdtListTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlSdtListTable_row(): refresh mtpSlSdtListTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlSdtListTable_request == sa_request)
		return;
	StorageTmp->mtpSlSdtListTable_request = sa_request;
}

/*
 * var_mtpSlSdtListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSlSdtListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlSdtListTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlSdtListTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlSdtListTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlSdtListTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlSdtListTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLSDTLISTPOINTER:
		*write_method = write_mtpSlSdtListPointer;
		*var_len = StorageTmp->mtpSlSdtListPointerLen;
		return (u_char *) StorageTmp->mtpSlSdtListPointer;

	case MTPSLSDTLISTROWSTATUS:
		*write_method = write_mtpSlSdtListRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlSdtListRowStatus);
		return (u_char *) &StorageTmp->mtpSlSdtListRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlCurrentTable(): refresh mtpSlCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlCurrentTable(void)
{
	if (mtpSlCurrentTable_refresh == 0)
		return;
	mtpSlCurrentTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlCurrentTable_row(): refresh mtpSlCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlCurrentTable_row(struct mtpSlCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpSlCurrentTable_request = sa_request;
}

/*
 * var_mtpSlCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSlCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlCurrentTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlCurrentTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlCurrentTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLCURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentValidIntervals);
		return (u_char *) &StorageTmp->mtpSlCurrentValidIntervals;

	case MTPSLCURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpSlCurrentTimeDiscontinuity;

	case MTPSLCURRENTSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlUnavailabilityDuration);
		return (u_char *) &StorageTmp->mtpSlCurrentSlUnavailabilityDuration;

	case MTPSLCURRENTSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlLocalInhibition);
		return (u_char *) &StorageTmp->mtpSlCurrentSlLocalInhibition;

	case MTPSLCURRENTSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlRemoteInhibition);
		return (u_char *) &StorageTmp->mtpSlCurrentSlRemoteInhibition;

	case MTPSLCURRENTSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlFailed);
		return (u_char *) &StorageTmp->mtpSlCurrentSlFailed;

	case MTPSLCURRENTSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlRemoteProcOutage);
		return (u_char *) &StorageTmp->mtpSlCurrentSlRemoteProcOutage;

	case MTPSLCURRENTLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentLocalMgmtInhibit);
		return (u_char *) &StorageTmp->mtpSlCurrentLocalMgmtInhibit;

	case MTPSLCURRENTLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentLocalMgmtUninhibit);
		return (u_char *) &StorageTmp->mtpSlCurrentLocalMgmtUninhibit;

	case MTPSLCURRENTLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentLocalBusy);
		return (u_char *) &StorageTmp->mtpSlCurrentLocalBusy;

	case MTPSLCURRENTSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlCongestedStarts);
		return (u_char *) &StorageTmp->mtpSlCurrentSlCongestedStarts;

	case MTPSLCURRENTSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlCongestedDuration);
		return (u_char *) &StorageTmp->mtpSlCurrentSlCongestedDuration;

	case MTPSLCURRENTSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlCongestionStops);
		return (u_char *) &StorageTmp->mtpSlCurrentSlCongestionStops;

	case MTPSLCURRENTDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSlCurrentDiscardedMSUs;

	case MTPSLCURRENTCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentCongestionEventsMSULoss);
		return (u_char *) &StorageTmp->mtpSlCurrentCongestionEventsMSULoss;

	case MTPSLCURRENTCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentChangeovers);
		return (u_char *) &StorageTmp->mtpSlCurrentChangeovers;

	case MTPSLCURRENTCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentChangebacks);
		return (u_char *) &StorageTmp->mtpSlCurrentChangebacks;

	case MTPSLCURRENTRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentRestorations);
		return (u_char *) &StorageTmp->mtpSlCurrentRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlInt5minTable(): refresh mtpSlInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlInt5minTable(void)
{
	if (mtpSlInt5minTable_refresh == 0)
		return;
	mtpSlInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlInt5minTable_row(): refresh mtpSlInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlInt5minTable_row(struct mtpSlInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSlInt5minTable_request = sa_request;
}

/*
 * var_mtpSlInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSlInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpSlInt5minTimeStamp;

	case MTPSLINT5MINSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlUnavailabilityDuration);
		return (u_char *) &StorageTmp->mtpSlInt5minSlUnavailabilityDuration;

	case MTPSLINT5MINSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlLocalInhibition);
		return (u_char *) &StorageTmp->mtpSlInt5minSlLocalInhibition;

	case MTPSLINT5MINSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlRemoteInhibition);
		return (u_char *) &StorageTmp->mtpSlInt5minSlRemoteInhibition;

	case MTPSLINT5MINSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlFailed);
		return (u_char *) &StorageTmp->mtpSlInt5minSlFailed;

	case MTPSLINT5MINSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlRemoteProcOutage);
		return (u_char *) &StorageTmp->mtpSlInt5minSlRemoteProcOutage;

	case MTPSLINT5MINLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minLocalMgmtInhibit);
		return (u_char *) &StorageTmp->mtpSlInt5minLocalMgmtInhibit;

	case MTPSLINT5MINLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minLocalMgmtUninhibit);
		return (u_char *) &StorageTmp->mtpSlInt5minLocalMgmtUninhibit;

	case MTPSLINT5MINLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minLocalBusy);
		return (u_char *) &StorageTmp->mtpSlInt5minLocalBusy;

	case MTPSLINT5MINSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlCongestedStarts);
		return (u_char *) &StorageTmp->mtpSlInt5minSlCongestedStarts;

	case MTPSLINT5MINSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlCongestedDuration);
		return (u_char *) &StorageTmp->mtpSlInt5minSlCongestedDuration;

	case MTPSLINT5MINSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlCongestionStops);
		return (u_char *) &StorageTmp->mtpSlInt5minSlCongestionStops;

	case MTPSLINT5MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSlInt5minDiscardedMSUs;

	case MTPSLINT5MINCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minCongestionEventsMSULoss);
		return (u_char *) &StorageTmp->mtpSlInt5minCongestionEventsMSULoss;

	case MTPSLINT5MINCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minChangeovers);
		return (u_char *) &StorageTmp->mtpSlInt5minChangeovers;

	case MTPSLINT5MINCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minChangebacks);
		return (u_char *) &StorageTmp->mtpSlInt5minChangebacks;

	case MTPSLINT5MINRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minRestorations);
		return (u_char *) &StorageTmp->mtpSlInt5minRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlInt15minTable(): refresh mtpSlInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlInt15minTable(void)
{
	if (mtpSlInt15minTable_refresh == 0)
		return;
	mtpSlInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlInt15minTable_row(): refresh mtpSlInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlInt15minTable_row(struct mtpSlInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSlInt15minTable_request = sa_request;
}

/*
 * var_mtpSlInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSlInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpSlInt15minTimeStamp;

	case MTPSLINT15MINSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlUnavailabilityDuration);
		return (u_char *) &StorageTmp->mtpSlInt15minSlUnavailabilityDuration;

	case MTPSLINT15MINSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlLocalInhibition);
		return (u_char *) &StorageTmp->mtpSlInt15minSlLocalInhibition;

	case MTPSLINT15MINSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlRemoteInhibition);
		return (u_char *) &StorageTmp->mtpSlInt15minSlRemoteInhibition;

	case MTPSLINT15MINSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlFailed);
		return (u_char *) &StorageTmp->mtpSlInt15minSlFailed;

	case MTPSLINT15MINSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlRemoteProcOutage);
		return (u_char *) &StorageTmp->mtpSlInt15minSlRemoteProcOutage;

	case MTPSLINT15MINLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minLocalMgmtInhibit);
		return (u_char *) &StorageTmp->mtpSlInt15minLocalMgmtInhibit;

	case MTPSLINT15MINLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minLocalMgmtUninhibit);
		return (u_char *) &StorageTmp->mtpSlInt15minLocalMgmtUninhibit;

	case MTPSLINT15MINLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minLocalBusy);
		return (u_char *) &StorageTmp->mtpSlInt15minLocalBusy;

	case MTPSLINT15MINSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlCongestedStarts);
		return (u_char *) &StorageTmp->mtpSlInt15minSlCongestedStarts;

	case MTPSLINT15MINSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlCongestedDuration);
		return (u_char *) &StorageTmp->mtpSlInt15minSlCongestedDuration;

	case MTPSLINT15MINSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlCongestionStops);
		return (u_char *) &StorageTmp->mtpSlInt15minSlCongestionStops;

	case MTPSLINT15MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSlInt15minDiscardedMSUs;

	case MTPSLINT15MINCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minCongestionEventsMSULoss);
		return (u_char *) &StorageTmp->mtpSlInt15minCongestionEventsMSULoss;

	case MTPSLINT15MINCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minChangeovers);
		return (u_char *) &StorageTmp->mtpSlInt15minChangeovers;

	case MTPSLINT15MINCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minChangebacks);
		return (u_char *) &StorageTmp->mtpSlInt15minChangebacks;

	case MTPSLINT15MINRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minRestorations);
		return (u_char *) &StorageTmp->mtpSlInt15minRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpL2ProfileTable(): refresh mtpL2ProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpL2ProfileTable(void)
{
	if (mtpL2ProfileTable_refresh == 0)
		return;
	mtpL2ProfileTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpL2ProfileTable_row(): refresh mtpL2ProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpL2ProfileTable_row(struct mtpL2ProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpL2ProfileTable_request == sa_request)
		return;
	StorageTmp->mtpL2ProfileTable_request = sa_request;
}

/*
 * var_mtpL2ProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpL2ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpL2ProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpL2ProfileTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpL2ProfileTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpL2ProfileTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPL2PROFILEERRORCORRECTIONMETHOD:
		*write_method = write_mtpL2ProfileErrorCorrectionMethod;
		*var_len = sizeof(StorageTmp->mtpL2ProfileErrorCorrectionMethod);
		return (u_char *) &StorageTmp->mtpL2ProfileErrorCorrectionMethod;

	case MTPL2PROFILETIMERT1:
		*write_method = write_mtpL2ProfileTimerT1;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT1);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT1;

	case MTPL2PROFILETIMERT2:
		*write_method = write_mtpL2ProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT2);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT2;

	case MTPL2PROFILETIMERT3:
		*write_method = write_mtpL2ProfileTimerT3;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT3);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT3;

	case MTPL2PROFILETIMERT4N:
		*write_method = write_mtpL2ProfileTimerT4N;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT4N);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT4N;

	case MTPL2PROFILETIMERT4E:
		*write_method = write_mtpL2ProfileTimerT4E;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT4E);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT4E;

	case MTPL2PROFILETIMERT5:
		*write_method = write_mtpL2ProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT5);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT5;

	case MTPL2PROFILETIMERT6:
		*write_method = write_mtpL2ProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT6);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT6;

	case MTPL2PROFILETIMERT7:
		*write_method = write_mtpL2ProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT7);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT7;

	case MTPL2PROFILETRANSCONGTHRESHONSETLEVEL1MSGS:
		*write_method = write_mtpL2ProfileTransCongThreshOnsetLevel1Msgs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Msgs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Msgs;

	case MTPL2PROFILETRANSCONGTHRESHONSETLEVEL1OCTS:
		*write_method = write_mtpL2ProfileTransCongThreshOnsetLevel1Octs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Octs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Octs;

	case MTPL2PROFILETRANSCONGTHRESHABATELEVEL1MSGS:
		*write_method = write_mtpL2ProfileTransCongThreshAbateLevel1Msgs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Msgs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Msgs;

	case MTPL2PROFILETRANSCONGTHRESHABATELEVEL1OCTS:
		*write_method = write_mtpL2ProfileTransCongThreshAbateLevel1Octs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Octs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Octs;

	case MTPL2PROFILENUMBEROFTHRESHOLDLEVELS:
		*write_method = write_mtpL2ProfileNumberOfThresholdLevels;
		*var_len = sizeof(StorageTmp->mtpL2ProfileNumberOfThresholdLevels);
		return (u_char *) &StorageTmp->mtpL2ProfileNumberOfThresholdLevels;

	case MTPL2PROFILECONGESTIONCOUNTING:
		*write_method = write_mtpL2ProfileCongestionCounting;
		*var_len = sizeof(StorageTmp->mtpL2ProfileCongestionCounting);
		return (u_char *) &StorageTmp->mtpL2ProfileCongestionCounting;

	case MTPL2PROFILECONGESTIONREPORTINGBASEOBJECT:
		*write_method = write_mtpL2ProfileCongestionReportingBaseObject;
		*var_len = sizeof(StorageTmp->mtpL2ProfileCongestionReportingBaseObject);
		return (u_char *) &StorageTmp->mtpL2ProfileCongestionReportingBaseObject;

	case MTPL2PROFILELOOPDELAY:
		*write_method = write_mtpL2ProfileLoopDelay;
		*var_len = sizeof(StorageTmp->mtpL2ProfileLoopDelay);
		return (u_char *) &StorageTmp->mtpL2ProfileLoopDelay;

	case MTPL2PROFILENAME:
		*write_method = write_mtpL2ProfileName;
		*var_len = StorageTmp->mtpL2ProfileNameLen;
		return (u_char *) StorageTmp->mtpL2ProfileName;

	case MTPL2PROFILETRANSCONGTHRESHONSETLEVEL2MSGS:
		*write_method = write_mtpL2ProfileTransCongThreshOnsetLevel2Msgs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Msgs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Msgs;

	case MTPL2PROFILETRANSCONGTHRESHONSETLEVEL2OCTS:
		*write_method = write_mtpL2ProfileTransCongThreshOnsetLevel2Octs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Octs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Octs;

	case MTPL2PROFILETRANSCONGTHRESHABATELEVEL2MSGS:
		*write_method = write_mtpL2ProfileTransCongThreshAbateLevel2Msgs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Msgs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Msgs;

	case MTPL2PROFILETRANSCONGTHRESHABATELEVEL2OCTS:
		*write_method = write_mtpL2ProfileTransCongThreshAbateLevel2Octs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Octs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Octs;

	case MTPL2PROFILETRANSCONGTHRESHONSETLEVEL3MSGS:
		*write_method = write_mtpL2ProfileTransCongThreshOnsetLevel3Msgs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Msgs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Msgs;

	case MTPL2PROFILETRANSCONGTHRESHONSETLEVEL3OCTS:
		*write_method = write_mtpL2ProfileTransCongThreshOnsetLevel3Octs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Octs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Octs;

	case MTPL2PROFILETRANSCONGTHRESHABATELEVEL3MSGS:
		*write_method = write_mtpL2ProfileTransCongThreshAbateLevel3Msgs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Msgs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Msgs;

	case MTPL2PROFILETRANSCONGTHRESHABATELEVEL3OCTS:
		*write_method = write_mtpL2ProfileTransCongThreshAbateLevel3Octs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Octs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Octs;

	case MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL1MSGS:
		*write_method = write_mtpL2ProfileTransCongThreshDiscardLevel1Msgs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Msgs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Msgs;

	case MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL1OCTS:
		*write_method = write_mtpL2ProfileTransCongThreshDiscardLevel1Octs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Octs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Octs;

	case MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL2MSGS:
		*write_method = write_mtpL2ProfileTransCongThreshDiscardLevel2Msgs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Msgs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Msgs;

	case MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL2OCTS:
		*write_method = write_mtpL2ProfileTransCongThreshDiscardLevel2Octs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Octs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Octs;

	case MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL3MSGS:
		*write_method = write_mtpL2ProfileTransCongThreshDiscardLevel3Msgs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Msgs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Msgs;

	case MTPL2PROFILETRANSCONGTHRESHDISCARDLEVEL3OCTS:
		*write_method = write_mtpL2ProfileTransCongThreshDiscardLevel3Octs;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Octs);
		return (u_char *) &StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Octs;

	case MTPL2PROFILETIMERTX:
		*write_method = write_mtpL2ProfileTimerTx;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerTx);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerTx;

	case MTPL2PROFILETIMERTY:
		*write_method = write_mtpL2ProfileTimerTy;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerTy);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerTy;

	case MTPL2PROFILENUMBEROFCONGESTIONSTATES:
		*write_method = write_mtpL2ProfileNumberOfCongestionStates;
		*var_len = sizeof(StorageTmp->mtpL2ProfileNumberOfCongestionStates);
		return (u_char *) &StorageTmp->mtpL2ProfileNumberOfCongestionStates;

	case MTPL2PROFILEINITIALLEVELOFCONGESTION:
		*write_method = write_mtpL2ProfileInitialLevelOfCongestion;
		*var_len = sizeof(StorageTmp->mtpL2ProfileInitialLevelOfCongestion);
		return (u_char *) &StorageTmp->mtpL2ProfileInitialLevelOfCongestion;

	case MTPL2PROFILEMAXMSUSRETRANSN1:
		*write_method = write_mtpL2ProfileMaxMSUsRetransN1;
		*var_len = sizeof(StorageTmp->mtpL2ProfileMaxMSUsRetransN1);
		return (u_char *) &StorageTmp->mtpL2ProfileMaxMSUsRetransN1;

	case MTPL2PROFILEMAXOCTRETRANSN2:
		*write_method = write_mtpL2ProfileMaxOctRetransN2;
		*var_len = sizeof(StorageTmp->mtpL2ProfileMaxOctRetransN2);
		return (u_char *) &StorageTmp->mtpL2ProfileMaxOctRetransN2;

	case MTPL2PROFILERECEIVECONGTHRESHONSET:
		*write_method = write_mtpL2ProfileReceiveCongThreshOnset;
		*var_len = sizeof(StorageTmp->mtpL2ProfileReceiveCongThreshOnset);
		return (u_char *) &StorageTmp->mtpL2ProfileReceiveCongThreshOnset;

	case MTPL2PROFILERECEIVECONGTHRESHABATE:
		*write_method = write_mtpL2ProfileReceiveCongThreshAbate;
		*var_len = sizeof(StorageTmp->mtpL2ProfileReceiveCongThreshAbate);
		return (u_char *) &StorageTmp->mtpL2ProfileReceiveCongThreshAbate;

	case MTPL2PROFILEROWSTATUS:
		*write_method = write_mtpL2ProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpL2ProfileRowStatus);
		return (u_char *) &StorageTmp->mtpL2ProfileRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpNbandTable(): refresh mtpNbandTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpNbandTable(void)
{
	if (mtpNbandTable_refresh == 0)
		return;
	mtpNbandTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpNbandTable_row(): refresh mtpNbandTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpNbandTable_row(struct mtpNbandTable_data *StorageTmp)
{
	if (StorageTmp->mtpNbandTable_request == sa_request)
		return;
	StorageTmp->mtpNbandTable_request = sa_request;
}

/*
 * var_mtpNbandTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpNbandTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpNbandTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpNbandTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpNbandTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpNbandTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpNbandTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPNBTRANSMISSIONRATE:
		*write_method = write_mtpNbTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpNbTransmissionRate);
		return (u_char *) &StorageTmp->mtpNbTransmissionRate;

	case MTPNBANDROWSTATUS:
		*write_method = write_mtpNbandRowStatus;
		*var_len = sizeof(StorageTmp->mtpNbandRowStatus);
		return (u_char *) &StorageTmp->mtpNbandRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSaalTable(): refresh mtpSaalTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSaalTable(void)
{
	if (mtpSaalTable_refresh == 0)
		return;
	mtpSaalTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSaalTable_row(): refresh mtpSaalTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
{
	if (StorageTmp->mtpSaalTable_request == sa_request)
		return;
	StorageTmp->mtpSaalTable_request = sa_request;
}

/*
 * var_mtpSaalTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSaalTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSaalTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSaalTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSaalTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSaalTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSaalTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSAALBUFFERRELEASE:
		*write_method = write_mtpSaalBufferRelease;
		*var_len = sizeof(StorageTmp->mtpSaalBufferRelease);
		return (u_char *) &StorageTmp->mtpSaalBufferRelease;

	case MTPSAALMAXCC:
		*write_method = write_mtpSaalMaxCc;
		*var_len = sizeof(StorageTmp->mtpSaalMaxCc);
		return (u_char *) &StorageTmp->mtpSaalMaxCc;

	case MTPSAALMAXNRP:
		*write_method = write_mtpSaalMaxNrp;
		*var_len = sizeof(StorageTmp->mtpSaalMaxNrp);
		return (u_char *) &StorageTmp->mtpSaalMaxNrp;

	case MTPSAALMAXINFORMATIONFIELDLENGTH:
		*write_method = write_mtpSaalMaxInformationFieldLength;
		*var_len = sizeof(StorageTmp->mtpSaalMaxInformationFieldLength);
		return (u_char *) &StorageTmp->mtpSaalMaxInformationFieldLength;

	case MTPSAALMAXLENGTHSSCOPUUFIELD:
		*write_method = write_mtpSaalMaxLengthSscopUuField;
		*var_len = sizeof(StorageTmp->mtpSaalMaxLengthSscopUuField);
		return (u_char *) &StorageTmp->mtpSaalMaxLengthSscopUuField;

	case MTPSAALMAXPD:
		*write_method = write_mtpSaalMaxPd;
		*var_len = sizeof(StorageTmp->mtpSaalMaxPd);
		return (u_char *) &StorageTmp->mtpSaalMaxPd;

	case MTPSAALMAXSSCOPCREDITTOPEER:
		*write_method = write_mtpSaalMaxSscopCreditToPeer;
		*var_len = sizeof(StorageTmp->mtpSaalMaxSscopCreditToPeer);
		return (u_char *) &StorageTmp->mtpSaalMaxSscopCreditToPeer;

	case MTPSAALMAXSTAT:
		*write_method = write_mtpSaalMaxStat;
		*var_len = sizeof(StorageTmp->mtpSaalMaxStat);
		return (u_char *) &StorageTmp->mtpSaalMaxStat;

	case MTPSAALN1:
		*write_method = write_mtpSaalN1;
		*var_len = sizeof(StorageTmp->mtpSaalN1);
		return (u_char *) &StorageTmp->mtpSaalN1;

	case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE:
		*write_method = write_mtpSaalNniLayerManagementProvingState;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementProvingState);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementProvingState;

	case MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT:
		*write_method = write_mtpSaalNniLayerManagementTimerNoCredit;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerNoCredit);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;

	case MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC:
		*write_method = write_mtpSaalNniLayerManagementTimerRepeatSrec;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;

	case MTPSAALNNITIMERT1:
		*write_method = write_mtpSaalNniTimerT1;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT1);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT1;

	case MTPSAALNNITIMERT2:
		*write_method = write_mtpSaalNniTimerT2;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT2);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT2;

	case MTPSAALNNITIMERT3:
		*write_method = write_mtpSaalNniTimerT3;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT3);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT3;

	case MTPSAALSSCOPTIMERCC:
		*write_method = write_mtpSaalSscopTimerCc;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerCc);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerCc;

	case MTPSAALSSCOPTIMERIDLE:
		*write_method = write_mtpSaalSscopTimerIdle;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerIdle);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerIdle;

	case MTPSAALSSCOPTIMERKEEPALIVE:
		*write_method = write_mtpSaalSscopTimerKeepAlive;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerKeepAlive);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerKeepAlive;

	case MTPSAALSSCOPTIMERNORESPONSE:
		*write_method = write_mtpSaalSscopTimerNoResponse;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerNoResponse);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerNoResponse;

	case MTPSAALSSCOPTIMERPOLL:
		*write_method = write_mtpSaalSscopTimerPoll;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerPoll);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerPoll;

	case MTPSAALTRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpSaalTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalLower;

	case MTPSAALTRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpSaalTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalUpper;

	case MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpSaalEgressTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;

	case MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpSaalEgressTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;

	case MTPSAALPOLLAFTERRETRANSMISSION:
		*write_method = write_mtpSaalPollAfterRetransmission;
		*var_len = sizeof(StorageTmp->mtpSaalPollAfterRetransmission);
		return (u_char *) &StorageTmp->mtpSaalPollAfterRetransmission;

	case MTPSAALROWSTATUS:
		*write_method = write_mtpSaalRowStatus;
		*var_len = sizeof(StorageTmp->mtpSaalRowStatus);
		return (u_char *) &StorageTmp->mtpSaalRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpM2paTable(): refresh mtpM2paTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpM2paTable(void)
{
	if (mtpM2paTable_refresh == 0)
		return;
	mtpM2paTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpM2paTable_row(): refresh mtpM2paTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
{
	if (StorageTmp->mtpM2paTable_request == sa_request)
		return;
	StorageTmp->mtpM2paTable_request = sa_request;
}

/*
 * var_mtpM2paTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpM2paTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpM2paTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpM2paTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpM2paTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpM2paTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpM2paTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPM2PAN1:
		*write_method = write_mtpM2paN1;
		*var_len = sizeof(StorageTmp->mtpM2paN1);
		return (u_char *) &StorageTmp->mtpM2paN1;

	case MTPM2PAPROVING:
		*write_method = write_mtpM2paProving;
		*var_len = sizeof(StorageTmp->mtpM2paProving);
		return (u_char *) &StorageTmp->mtpM2paProving;

	case MTPM2PAMANAGEMENTPROVINGSTATE:
		*write_method = write_mtpM2paManagementProvingState;
		*var_len = sizeof(StorageTmp->mtpM2paManagementProvingState);
		return (u_char *) &StorageTmp->mtpM2paManagementProvingState;

	case MTPM2PALOOPDELAYLOWER:
		*write_method = write_mtpM2paLoopDelayLower;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayLower);
		return (u_char *) &StorageTmp->mtpM2paLoopDelayLower;

	case MTPM2PALOOPDELAYUPPER:
		*write_method = write_mtpM2paLoopDelayUpper;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayUpper);
		return (u_char *) &StorageTmp->mtpM2paLoopDelayUpper;

	case MTPM2PATRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpM2paTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalLower;

	case MTPM2PATRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpM2paTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalUpper;

	case MTPM2PASCTPNODELAY:
		*write_method = write_mtpM2paSctpNoDelay;
		*var_len = sizeof(StorageTmp->mtpM2paSctpNoDelay);
		return (u_char *) &StorageTmp->mtpM2paSctpNoDelay;

	case MTPM2PASCTPMAXSEG:
		*write_method = write_mtpM2paSctpMaxseg;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxseg);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxseg;

	case MTPM2PASCTPHEARTBEATITVL:
		*write_method = write_mtpM2paSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeatItvl);
		return (u_char *) &StorageTmp->mtpM2paSctpHeartbeatItvl;

	case MTPM2PASCTPHEARTBEAT:
		*write_method = write_mtpM2paSctpHeartbeat;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeat);
		return (u_char *) &StorageTmp->mtpM2paSctpHeartbeat;

	case MTPM2PASCTPRTOINITIAL:
		*write_method = write_mtpM2paSctpRtoInitial;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoInitial);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoInitial;

	case MTPM2PASCTPRTOMIN:
		*write_method = write_mtpM2paSctpRtoMin;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMin);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoMin;

	case MTPM2PASCTPRTOMAX:
		*write_method = write_mtpM2paSctpRtoMax;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMax);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoMax;

	case MTPM2PASCTPPATHMAXRETRANS:
		*write_method = write_mtpM2paSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paSctpPathMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paSctpPathMaxRetrans;

	case MTPM2PASCTPCOOKIELIFE:
		*write_method = write_mtpM2paSctpCookieLife;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieLife);
		return (u_char *) &StorageTmp->mtpM2paSctpCookieLife;

	case MTPM2PASCTPCOOKIEINC:
		*write_method = write_mtpM2paSctpCookieInc;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieInc);
		return (u_char *) &StorageTmp->mtpM2paSctpCookieInc;

	case MTPM2PASCTPMAXINITRETRIES:
		*write_method = write_mtpM2paSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxInitRetries);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxInitRetries;

	case MTPM2PASCTPMAXBURST:
		*write_method = write_mtpM2paSctpMaxBurst;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxBurst);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxBurst;

	case MTPM2PASCTPASSOCMAXRETRANS:
		*write_method = write_mtpM2paSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paSctpAssocMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paSctpAssocMaxRetrans;

	case MTPM2PASCTPSACKDELAY:
		*write_method = write_mtpM2paSctpSackDelay;
		*var_len = sizeof(StorageTmp->mtpM2paSctpSackDelay);
		return (u_char *) &StorageTmp->mtpM2paSctpSackDelay;

	case MTPM2PASCTPLIFETIME:
		*write_method = write_mtpM2paSctpLifetime;
		*var_len = sizeof(StorageTmp->mtpM2paSctpLifetime);
		return (u_char *) &StorageTmp->mtpM2paSctpLifetime;

	case MTPM2PAPROVINGATTEMPTS:
		*write_method = write_mtpM2paProvingAttempts;
		*var_len = sizeof(StorageTmp->mtpM2paProvingAttempts);
		return (u_char *) &StorageTmp->mtpM2paProvingAttempts;

	case MTPM2PAROWSTATUS:
		*write_method = write_mtpM2paRowStatus;
		*var_len = sizeof(StorageTmp->mtpM2paRowStatus);
		return (u_char *) &StorageTmp->mtpM2paRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdtTable(): refresh mtpSdtTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSdtTable(void)
{
	if (mtpSdtTable_refresh == 0)
		return;
	mtpSdtTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSdtTable_row(): refresh mtpSdtTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdtTable_request == sa_request)
		return;
	StorageTmp->mtpSdtTable_request = sa_request;
}

/*
 * var_mtpSdtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSdtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSdtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSdtTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdtTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSdtTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSDTADMINSTATE:
		*write_method = write_mtpSdtAdminState;
		*var_len = sizeof(StorageTmp->mtpSdtAdminState);
		return (u_char *) &StorageTmp->mtpSdtAdminState;

	case MTPSDTOPERSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtOperState);
		return (u_char *) &StorageTmp->mtpSdtOperState;

	case MTPSDTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtUsageState);
		return (u_char *) &StorageTmp->mtpSdtUsageState;

	case MTPSDTPROCSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSdtProcStatusLen;
		return (u_char *) StorageTmp->mtpSdtProcStatus;

	case MTPSDTAVAILSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSdtAvailStatusLen;
		return (u_char *) StorageTmp->mtpSdtAvailStatus;

	case MTPSDTEQUIPMENTPOINTER:
		*write_method = write_mtpSdtEquipmentPointer;
		*var_len = StorageTmp->mtpSdtEquipmentPointerLen;
		return (u_char *) StorageTmp->mtpSdtEquipmentPointer;

	case MTPSDTNAME:
		*write_method = write_mtpSdtName;
		*var_len = StorageTmp->mtpSdtNameLen;
		return (u_char *) StorageTmp->mtpSdtName;

	case MTPSDTROWSTATUS:
		*write_method = write_mtpSdtRowStatus;
		*var_len = sizeof(StorageTmp->mtpSdtRowStatus);
		return (u_char *) &StorageTmp->mtpSdtRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdlTable(): refresh mtpSdlTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSdlTable(void)
{
	if (mtpSdlTable_refresh == 0)
		return;
	mtpSdlTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSdlTable_row(): refresh mtpSdlTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdlTable_request == sa_request)
		return;
	StorageTmp->mtpSdlTable_request = sa_request;
}

/*
 * var_mtpSdlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB above.
 */
u_char *
var_mtpSdlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSdlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSdlTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdlTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSdlTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSDLADJPC:
		*write_method = write_mtpSdlAdjPc;
		*var_len = StorageTmp->mtpSdlAdjPcLen;
		return (u_char *) StorageTmp->mtpSdlAdjPc;

	case MTPSDLTRANSMISSIONRATE:
		*write_method = write_mtpSdlTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpSdlTransmissionRate);
		return (u_char *) &StorageTmp->mtpSdlTransmissionRate;

	case MTPSDLLOOPDELAY:
		*write_method = write_mtpSdlLoopDelay;
		*var_len = sizeof(StorageTmp->mtpSdlLoopDelay);
		return (u_char *) &StorageTmp->mtpSdlLoopDelay;

	case MTPSDLOPERSTATE:
		*write_method = write_mtpSdlOperState;
		*var_len = sizeof(StorageTmp->mtpSdlOperState);
		return (u_char *) &StorageTmp->mtpSdlOperState;

	case MTPSDLEQUIPMENTPOINTER:
		*write_method = write_mtpSdlEquipmentPointer;
		*var_len = StorageTmp->mtpSdlEquipmentPointerLen;
		return (u_char *) StorageTmp->mtpSdlEquipmentPointer;

	case MTPSDLCIC:
		*write_method = write_mtpSdlCIC;
		*var_len = sizeof(StorageTmp->mtpSdlCIC);
		return (u_char *) &StorageTmp->mtpSdlCIC;

	case MTPSDLNAME:
		*write_method = write_mtpSdlName;
		*var_len = StorageTmp->mtpSdlNameLen;
		return (u_char *) StorageTmp->mtpSdlName;

	case MTPSDLSTMCHANNEL:
		*write_method = write_mtpSdlStmChannel;
		*var_len = sizeof(StorageTmp->mtpSdlStmChannel);
		return (u_char *) &StorageTmp->mtpSdlStmChannel;

	case MTPSDLVCTTPPOINTER:
		*write_method = write_mtpSdlVcTTpPointer;
		*var_len = StorageTmp->mtpSdlVcTTpPointerLen;
		return (u_char *) StorageTmp->mtpSdlVcTTpPointer;

	case MTPSDLROWSTATUS:
		*write_method = write_mtpSdlRowStatus;
		*var_len = sizeof(StorageTmp->mtpSdlRowStatus);
		return (u_char *) &StorageTmp->mtpSdlRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_mtpSapAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSapTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSapAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSapAsaProfilePointer;
		tmplen = StorageTmp->mtpSapAsaProfilePointerLen;
		memdup((void *) &StorageTmp->mtpSapAsaProfilePointer, var_val, var_val_len);
		StorageTmp->mtpSapAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSapAsaProfilePointer);
		StorageTmp->mtpSapAsaProfilePointer = tmpvar;
		StorageTmp->mtpSapAsaProfilePointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSapTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSapName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSapName;
		tmplen = StorageTmp->mtpSapNameLen;
		memdup((void *) &StorageTmp->mtpSapName, var_val, var_val_len);
		StorageTmp->mtpSapNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSapName);
		StorageTmp->mtpSapName = tmpvar;
		StorageTmp->mtpSapNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapLongMessageSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSapTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSapLongMessageSupported entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSapLongMessageSupported;
		StorageTmp->mtpSapLongMessageSupported = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapLongMessageSupported = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolVariant entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaProtocolVariant;
		tmplen = StorageTmp->mtpNaProtocolVariantLen;
		memdup((void *) &StorageTmp->mtpNaProtocolVariant, var_val, var_val_len);
		StorageTmp->mtpNaProtocolVariantLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaProtocolVariant);
		StorageTmp->mtpNaProtocolVariant = tmpvar;
		StorageTmp->mtpNaProtocolVariantLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolYear(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolYear entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaProtocolYear;
		StorageTmp->mtpNaProtocolYear = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolYear = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolOptions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaProtocolOptions;
		tmplen = StorageTmp->mtpNaProtocolOptionsLen;
		memdup((void *) &StorageTmp->mtpNaProtocolOptions, var_val, var_val_len);
		StorageTmp->mtpNaProtocolOptionsLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaProtocolOptions);
		StorageTmp->mtpNaProtocolOptions = tmpvar;
		StorageTmp->mtpNaProtocolOptionsLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpNaNetworkIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaNetworkIndicator;
		StorageTmp->mtpNaNetworkIndicator = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaNetworkIndicator = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpNaPointCodeFormat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaPointCodeFormat;
		tmplen = StorageTmp->mtpNaPointCodeFormatLen;
		memdup((void *) &StorageTmp->mtpNaPointCodeFormat, var_val, var_val_len);
		StorageTmp->mtpNaPointCodeFormatLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaPointCodeFormat);
		StorageTmp->mtpNaPointCodeFormat = tmpvar;
		StorageTmp->mtpNaPointCodeFormatLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaSlsLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpNaSlsLength entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaSlsLength;
		StorageTmp->mtpNaSlsLength = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaSlsLength = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaSpProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpNaSpProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaSpProfilePointer;
		tmplen = StorageTmp->mtpNaSpProfilePointerLen;
		memdup((void *) &StorageTmp->mtpNaSpProfilePointer, var_val, var_val_len);
		StorageTmp->mtpNaSpProfilePointerLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaSpProfilePointer);
		StorageTmp->mtpNaSpProfilePointer = tmpvar;
		StorageTmp->mtpNaSpProfilePointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpNaName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaName;
		tmplen = StorageTmp->mtpNaNameLen;
		memdup((void *) &StorageTmp->mtpNaName, var_val, var_val_len);
		StorageTmp->mtpNaNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaName);
		StorageTmp->mtpNaName = tmpvar;
		StorageTmp->mtpNaNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpGsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsAdministrativeState;
		StorageTmp->mtpGsAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsTreatmentOfOutsideRanges(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpGsTreatmentOfOutsideRanges entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsTreatmentOfOutsideRanges;
		StorageTmp->mtpGsTreatmentOfOutsideRanges = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsTreatmentOfOutsideRanges = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsListMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpGsListMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsListMode;
		StorageTmp->mtpGsListMode = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsListMode = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsScreeningByLinkSetOrByOpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpGsScreeningByLinkSetOrByOpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsScreeningByLinkSetOrByOpc;
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsGetScreenedOpcsOrLinkSetsByDpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpGsGetScreenedOpcsOrLinkSetsByDpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpGsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsName;
		tmplen = StorageTmp->mtpGsNameLen;
		memdup((void *) &StorageTmp->mtpGsName, var_val, var_val_len);
		StorageTmp->mtpGsNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsName);
		StorageTmp->mtpGsName = tmpvar;
		StorageTmp->mtpGsNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentDesignatedDPCLast(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentDesignatedDPCLast entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsLineContentDesignatedDPCLast;
		StorageTmp->mtpGsLineContentDesignatedDPCLast = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentDesignatedDPCLast = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentMessageTreatment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentMessageTreatment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsLineContentMessageTreatment;
		StorageTmp->mtpGsLineContentMessageTreatment = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentMessageTreatment = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT2;
		StorageTmp->mtpSpProfileMtpT2 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT4;
		StorageTmp->mtpSpProfileMtpT4 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT4 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT5;
		StorageTmp->mtpSpProfileMtpT5 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT5 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT7;
		StorageTmp->mtpSpProfileMtpT7 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT7 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT11;
		StorageTmp->mtpSpProfileMtpT11 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT11 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT12;
		StorageTmp->mtpSpProfileMtpT12 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT12 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT13;
		StorageTmp->mtpSpProfileMtpT13 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT13 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT14;
		StorageTmp->mtpSpProfileMtpT14 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT14 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT15;
		StorageTmp->mtpSpProfileMtpT15 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT15 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT16;
		StorageTmp->mtpSpProfileMtpT16 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT16 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT18(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT18 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT18 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT18;
		StorageTmp->mtpSpProfileMtpT18 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT18 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT19(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT19 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT19 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT19;
		StorageTmp->mtpSpProfileMtpT19 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT19 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT20(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT20 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT20 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT20;
		StorageTmp->mtpSpProfileMtpT20 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT20 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT21(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT21 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT21 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT21;
		StorageTmp->mtpSpProfileMtpT21 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT21 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT22(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT22 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT22 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT22;
		StorageTmp->mtpSpProfileMtpT22 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT22 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT23(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT23 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT23 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT23;
		StorageTmp->mtpSpProfileMtpT23 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT23 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT20A;
		StorageTmp->mtpSpProfileMtpT20A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT20A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT21A;
		StorageTmp->mtpSpProfileMtpT21A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT21A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT1T;
		StorageTmp->mtpSpProfileMtpT1T = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT1T = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileMtpT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileMtpT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileMtpT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileMtpT2T;
		StorageTmp->mtpSpProfileMtpT2T = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileMtpT2T = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileName;
		tmplen = StorageTmp->mtpSpProfileNameLen;
		memdup((void *) &StorageTmp->mtpSpProfileName, var_val, var_val_len);
		StorageTmp->mtpSpProfileNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpProfileName);
		StorageTmp->mtpSpProfileName = tmpvar;
		StorageTmp->mtpSpProfileNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpPointCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpPointCode;
		StorageTmp->mtpSpPointCode = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpPointCode = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpType;
		StorageTmp->mtpSpType = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpType = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpOperationalState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpOperationalState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpOperationalState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpOperationalState;
		StorageTmp->mtpSpOperationalState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpOperationalState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProceduralStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProceduralStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProceduralStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProceduralStatus;
		tmplen = StorageTmp->mtpSpProceduralStatusLen;
		memdup((void *) &StorageTmp->mtpSpProceduralStatus, var_val, var_val_len);
		StorageTmp->mtpSpProceduralStatusLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpProceduralStatus);
		StorageTmp->mtpSpProceduralStatus = tmpvar;
		StorageTmp->mtpSpProceduralStatusLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpAvailabilityStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpAvailabilityStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAvailabilityStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpAvailabilityStatus;
		tmplen = StorageTmp->mtpSpAvailabilityStatusLen;
		memdup((void *) &StorageTmp->mtpSpAvailabilityStatus, var_val, var_val_len);
		StorageTmp->mtpSpAvailabilityStatusLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpAvailabilityStatus);
		StorageTmp->mtpSpAvailabilityStatus = tmpvar;
		StorageTmp->mtpSpAvailabilityStatusLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpVersion;
		tmplen = StorageTmp->mtpSpVersionLen;
		memdup((void *) &StorageTmp->mtpSpVersion, var_val, var_val_len);
		StorageTmp->mtpSpVersionLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpVersion);
		StorageTmp->mtpSpVersion = tmpvar;
		StorageTmp->mtpSpVersionLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpNetworkIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpNetworkIndicator;
		StorageTmp->mtpSpNetworkIndicator = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpNetworkIndicator = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpName;
		tmplen = StorageTmp->mtpSpNameLen;
		memdup((void *) &StorageTmp->mtpSpName, var_val, var_val_len);
		StorageTmp->mtpSpNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpName);
		StorageTmp->mtpSpName = tmpvar;
		StorageTmp->mtpSpNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT1;
		StorageTmp->mtpSpMtpT1 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT2;
		StorageTmp->mtpSpMtpT2 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT3;
		StorageTmp->mtpSpMtpT3 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT3 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT4;
		StorageTmp->mtpSpMtpT4 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT4 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT5;
		StorageTmp->mtpSpMtpT5 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT5 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT6;
		StorageTmp->mtpSpMtpT6 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT6 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT7;
		StorageTmp->mtpSpMtpT7 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT7 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT8;
		StorageTmp->mtpSpMtpT8 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT8 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT10;
		StorageTmp->mtpSpMtpT10 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT10 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT11;
		StorageTmp->mtpSpMtpT11 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT11 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT12;
		StorageTmp->mtpSpMtpT12 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT12 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT13;
		StorageTmp->mtpSpMtpT13 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT13 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT14;
		StorageTmp->mtpSpMtpT14 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT14 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT15;
		StorageTmp->mtpSpMtpT15 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT15 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT16;
		StorageTmp->mtpSpMtpT16 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT16 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT17 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT17 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT17;
		StorageTmp->mtpSpMtpT17 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT17 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT19A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT19A;
		StorageTmp->mtpSpMtpT19A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT19A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT31A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT31A;
		StorageTmp->mtpSpMtpT31A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT31A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT32A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT32A;
		StorageTmp->mtpSpMtpT32A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT32A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT33A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT33A;
		StorageTmp->mtpSpMtpT33A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT33A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT34A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT34A;
		StorageTmp->mtpSpMtpT34A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT34A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT18(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT18 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT18 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT18;
		StorageTmp->mtpSpMtpT18 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT18 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT19(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT19 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT19;
		StorageTmp->mtpSpMtpT19 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT19 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT20(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT20 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT20;
		StorageTmp->mtpSpMtpT20 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT20 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT21(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT21 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT21;
		StorageTmp->mtpSpMtpT21 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT21 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT22(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT22 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT22 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT22;
		StorageTmp->mtpSpMtpT22 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT22 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT23(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT23 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT23 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT23;
		StorageTmp->mtpSpMtpT23 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT23 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT20A;
		StorageTmp->mtpSpMtpT20A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT20A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT21A;
		StorageTmp->mtpSpMtpT21A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT21A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT24(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT24 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT24 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT24;
		StorageTmp->mtpSpMtpT24 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT24 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT1T;
		StorageTmp->mtpSpMtpT1T = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1T = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT2T;
		StorageTmp->mtpSpMtpT2T = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT2T = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT1S entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1S not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT1S;
		StorageTmp->mtpSpMtpT1S = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1S = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfilePointer;
		tmplen = StorageTmp->mtpSpProfilePointerLen;
		memdup((void *) &StorageTmp->mtpSpProfilePointer, var_val, var_val_len);
		StorageTmp->mtpSpProfilePointerLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpProfilePointer);
		StorageTmp->mtpSpProfilePointer = tmpvar;
		StorageTmp->mtpSpProfilePointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpNaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSpNaPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpNaPointer;
		tmplen = StorageTmp->mtpSpNaPointerLen;
		memdup((void *) &StorageTmp->mtpSpNaPointer, var_val, var_val_len);
		StorageTmp->mtpSpNaPointerLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpNaPointer);
		StorageTmp->mtpSpNaPointer = tmpvar;
		StorageTmp->mtpSpNaPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL3Table_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL3AdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL3AdministrativeState;
		StorageTmp->mtpL3AdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL3AdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3AsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpL3Table_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL3AsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL3AsaProfilePointer;
		tmplen = StorageTmp->mtpL3AsaProfilePointerLen;
		memdup((void *) &StorageTmp->mtpL3AsaProfilePointer, var_val, var_val_len);
		StorageTmp->mtpL3AsaProfilePointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpL3AsaProfilePointer);
		StorageTmp->mtpL3AsaProfilePointer = tmpvar;
		StorageTmp->mtpL3AsaProfilePointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpL3Table_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL3Name entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL3Name;
		tmplen = StorageTmp->mtpL3NameLen;
		memdup((void *) &StorageTmp->mtpL3Name, var_val, var_val_len);
		StorageTmp->mtpL3NameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpL3Name);
		StorageTmp->mtpL3Name = tmpvar;
		StorageTmp->mtpL3NameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsAdministrativeState;
		StorageTmp->mtpRsAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsAsaProfilePointer;
		tmplen = StorageTmp->mtpRsAsaProfilePointerLen;
		memdup((void *) &StorageTmp->mtpRsAsaProfilePointer, var_val, var_val_len);
		StorageTmp->mtpRsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsAsaProfilePointer);
		StorageTmp->mtpRsAsaProfilePointer = tmpvar;
		StorageTmp->mtpRsAsaProfilePointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsLoadsharingInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsLoadsharingInformation;
		tmplen = StorageTmp->mtpRsLoadsharingInformationLen;
		memdup((void *) &StorageTmp->mtpRsLoadsharingInformation, var_val, var_val_len);
		StorageTmp->mtpRsLoadsharingInformationLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsLoadsharingInformation);
		StorageTmp->mtpRsLoadsharingInformation = tmpvar;
		StorageTmp->mtpRsLoadsharingInformationLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsLoadsharingObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsLoadsharingObject;
		tmplen = StorageTmp->mtpRsLoadsharingObjectLen;
		memdup((void *) &StorageTmp->mtpRsLoadsharingObject, var_val, var_val_len);
		StorageTmp->mtpRsLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsLoadsharingObject);
		StorageTmp->mtpRsLoadsharingObject = tmpvar;
		StorageTmp->mtpRsLoadsharingObjectLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsRemoteExchangeLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsRemoteExchangeLabel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsRemoteExchangeLabel;
		tmplen = StorageTmp->mtpRsRemoteExchangeLabelLen;
		memdup((void *) &StorageTmp->mtpRsRemoteExchangeLabel, var_val, var_val_len);
		StorageTmp->mtpRsRemoteExchangeLabelLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsRemoteExchangeLabel);
		StorageTmp->mtpRsRemoteExchangeLabel = tmpvar;
		StorageTmp->mtpRsRemoteExchangeLabelLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsName;
		tmplen = StorageTmp->mtpRsNameLen;
		memdup((void *) &StorageTmp->mtpRsName, var_val, var_val_len);
		StorageTmp->mtpRsNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsName);
		StorageTmp->mtpRsName = tmpvar;
		StorageTmp->mtpRsNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentValidIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsCurrentValidIntervals entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentValidIntervals;
		StorageTmp->mtpRsCurrentValidIntervals = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentValidIntervals = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentTimeDiscontinuity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsCurrentTimeDiscontinuity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentTimeDiscontinuity;
		StorageTmp->mtpRsCurrentTimeDiscontinuity = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentTimeDiscontinuity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentReceivedOctetsOPC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsCurrentReceivedOctetsOPC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentReceivedOctetsOPC not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentReceivedOctetsOPC;
		StorageTmp->mtpRsCurrentReceivedOctetsOPC = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentReceivedOctetsOPC = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentTransmittedOctetsDPC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsCurrentTransmittedOctetsDPC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentTransmittedOctetsDPC not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentTransmittedOctetsDPC;
		StorageTmp->mtpRsCurrentTransmittedOctetsDPC = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentTransmittedOctetsDPC = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentReceivedMSUsOpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsCurrentReceivedMSUsOpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentReceivedMSUsOpc not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentReceivedMSUsOpc;
		StorageTmp->mtpRsCurrentReceivedMSUsOpc = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentReceivedMSUsOpc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentTransmittedMSUsDpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsCurrentTransmittedMSUsDpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentTransmittedMSUsDpc not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentTransmittedMSUsDpc;
		StorageTmp->mtpRsCurrentTransmittedMSUsDpc = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentTransmittedMSUsDpc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentRouteSetUnavailable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsCurrentRouteSetUnavailable entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentRouteSetUnavailable not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentRouteSetUnavailable;
		StorageTmp->mtpRsCurrentRouteSetUnavailable = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentRouteSetUnavailable = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentRouteSetUnavailableDuration(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsCurrentRouteSetUnavailableDuration entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentRouteSetUnavailableDuration not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentRouteSetUnavailableDuration;
		StorageTmp->mtpRsCurrentRouteSetUnavailableDuration = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentRouteSetUnavailableDuration = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiValidIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsSiValidIntervals entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiValidIntervals;
		StorageTmp->mtpRsSiValidIntervals = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiValidIntervals = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiTimeDiscontinuity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsSiTimeDiscontinuity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiTimeDiscontinuity;
		StorageTmp->mtpRsSiTimeDiscontinuity = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiTimeDiscontinuity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiReceivedOctetsOpcSio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsSiReceivedOctetsOpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiReceivedOctetsOpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiReceivedOctetsOpcSio;
		StorageTmp->mtpRsSiReceivedOctetsOpcSio = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiReceivedOctetsOpcSio = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiTransmittedOctetsDpcSio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsSiTransmittedOctetsDpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiTransmittedOctetsDpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiTransmittedOctetsDpcSio;
		StorageTmp->mtpRsSiTransmittedOctetsDpcSio = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiTransmittedOctetsDpcSio = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiReceivedMSUsOpcSio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsSiReceivedMSUsOpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiReceivedMSUsOpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiReceivedMSUsOpcSio;
		StorageTmp->mtpRsSiReceivedMSUsOpcSio = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiReceivedMSUsOpcSio = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiTransmittedMSUsDpcSio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRsSiTransmittedMSUsDpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiTransmittedMSUsDpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiTransmittedMSUsDpcSio;
		StorageTmp->mtpRsSiTransmittedMSUsDpcSio = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiTransmittedMSUsDpcSio = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLsPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtLsPointer;
		tmplen = StorageTmp->mtpRtLsPointerLen;
		memdup((void *) &StorageTmp->mtpRtLsPointer, var_val, var_val_len);
		StorageTmp->mtpRtLsPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtLsPointer);
		StorageTmp->mtpRtLsPointer = tmpvar;
		StorageTmp->mtpRtLsPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtAdministrativeState;
		StorageTmp->mtpRtAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtFixedPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtFixedPriority entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtFixedPriority;
		StorageTmp->mtpRtFixedPriority = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFixedPriority = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtFlexiblePriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtFlexiblePriority entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtFlexiblePriority;
		StorageTmp->mtpRtFlexiblePriority = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFlexiblePriority = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtPriorityMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtPriorityMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtPriorityMode;
		StorageTmp->mtpRtPriorityMode = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtPriorityMode = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtLoadsharingInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtLoadsharingInformation;
		tmplen = StorageTmp->mtpRtLoadsharingInformationLen;
		memdup((void *) &StorageTmp->mtpRtLoadsharingInformation, var_val, var_val_len);
		StorageTmp->mtpRtLoadsharingInformationLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtLoadsharingInformation);
		StorageTmp->mtpRtLoadsharingInformation = tmpvar;
		StorageTmp->mtpRtLoadsharingInformationLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtLoadsharingObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtLoadsharingObject;
		tmplen = StorageTmp->mtpRtLoadsharingObjectLen;
		memdup((void *) &StorageTmp->mtpRtLoadsharingObject, var_val, var_val_len);
		StorageTmp->mtpRtLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtLoadsharingObject);
		StorageTmp->mtpRtLoadsharingObject = tmpvar;
		StorageTmp->mtpRtLoadsharingObjectLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtName;
		tmplen = StorageTmp->mtpRtNameLen;
		memdup((void *) &StorageTmp->mtpRtName, var_val, var_val_len);
		StorageTmp->mtpRtNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtName);
		StorageTmp->mtpRtName = tmpvar;
		StorageTmp->mtpRtNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtSlsList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtSlsList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtSlsList;
		tmplen = StorageTmp->mtpRtSlsListLen;
		memdup((void *) &StorageTmp->mtpRtSlsList, var_val, var_val_len);
		StorageTmp->mtpRtSlsListLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtSlsList);
		StorageTmp->mtpRtSlsList = tmpvar;
		StorageTmp->mtpRtSlsListLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtUsageState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtUsageState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtUsageState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtUsageState;
		StorageTmp->mtpRtUsageState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtUsageState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLsaNormalSlCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsaNormalSlCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtLsaNormalSlCode;
		StorageTmp->mtpRtLsaNormalSlCode = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLsaNormalSlCode = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLsaAlternativeSlCodeList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsaAlternativeSlCodeList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaAlternativeSlCodeList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtLsaAlternativeSlCodeList;
		tmplen = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
		memdup((void *) &StorageTmp->mtpRtLsaAlternativeSlCodeList, var_val, var_val_len);
		StorageTmp->mtpRtLsaAlternativeSlCodeListLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtLsaAlternativeSlCodeList);
		StorageTmp->mtpRtLsaAlternativeSlCodeList = tmpvar;
		StorageTmp->mtpRtLsaAlternativeSlCodeListLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileMtpT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileMtpT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileMtpT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileMtpT6;
		StorageTmp->mtpLsProfileMtpT6 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileMtpT6 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileMtpT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileMtpT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileMtpT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileMtpT8;
		StorageTmp->mtpLsProfileMtpT8 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileMtpT8 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileMtpT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileMtpT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileMtpT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileMtpT10;
		StorageTmp->mtpLsProfileMtpT10 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileMtpT10 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileName;
		tmplen = StorageTmp->mtpLsProfileNameLen;
		memdup((void *) &StorageTmp->mtpLsProfileName, var_val, var_val_len);
		StorageTmp->mtpLsProfileNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsProfileName);
		StorageTmp->mtpLsProfileName = tmpvar;
		StorageTmp->mtpLsProfileNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsAdjPc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsAdjPc;
		tmplen = StorageTmp->mtpLsAdjPcLen;
		memdup((void *) &StorageTmp->mtpLsAdjPc, var_val, var_val_len);
		StorageTmp->mtpLsAdjPcLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsAdjPc);
		StorageTmp->mtpLsAdjPc = tmpvar;
		StorageTmp->mtpLsAdjPcLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsMaxCapacity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsMaxCapacity;
		StorageTmp->mtpLsMaxCapacity = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsMaxCapacity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsCurrentCapacity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentCapacity not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentCapacity;
		StorageTmp->mtpLsCurrentCapacity = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentCapacity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCongestionControlMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsCongestionControlMethod entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsCongestionControlMethod;
		StorageTmp->mtpLsCongestionControlMethod = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCongestionControlMethod = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsUsageState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsUsageState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsUsageState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsUsageState;
		StorageTmp->mtpLsUsageState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsUsageState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsOperationalState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsOperationalState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsOperationalState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsOperationalState;
		StorageTmp->mtpLsOperationalState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsOperationalState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAvailabilityStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsAvailabilityStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAvailabilityStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsAvailabilityStatus;
		tmplen = StorageTmp->mtpLsAvailabilityStatusLen;
		memdup((void *) &StorageTmp->mtpLsAvailabilityStatus, var_val, var_val_len);
		StorageTmp->mtpLsAvailabilityStatusLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsAvailabilityStatus);
		StorageTmp->mtpLsAvailabilityStatus = tmpvar;
		StorageTmp->mtpLsAvailabilityStatusLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsPeriodicLinkTestFlag(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsPeriodicLinkTestFlag entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsPeriodicLinkTestFlag;
		StorageTmp->mtpLsPeriodicLinkTestFlag = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsPeriodicLinkTestFlag = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsAdministrativeState;
		StorageTmp->mtpLsAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsInLsLoadShareAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsInLsLoadShareAlgorithm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsInLsLoadShareAlgorithm;
		tmplen = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
		memdup((void *) &StorageTmp->mtpLsInLsLoadShareAlgorithm, var_val, var_val_len);
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsInLsLoadShareAlgorithm);
		StorageTmp->mtpLsInLsLoadShareAlgorithm = tmpvar;
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfilePointer;
		tmplen = StorageTmp->mtpLsProfilePointerLen;
		memdup((void *) &StorageTmp->mtpLsProfilePointer, var_val, var_val_len);
		StorageTmp->mtpLsProfilePointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsProfilePointer);
		StorageTmp->mtpLsProfilePointer = tmpvar;
		StorageTmp->mtpLsProfilePointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsNumNormActSls(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsNumNormActSls entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumNormActSls not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsNumNormActSls;
		StorageTmp->mtpLsNumNormActSls = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsNumNormActSls = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsName;
		tmplen = StorageTmp->mtpLsNameLen;
		memdup((void *) &StorageTmp->mtpLsName, var_val, var_val_len);
		StorageTmp->mtpLsNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsName);
		StorageTmp->mtpLsName = tmpvar;
		StorageTmp->mtpLsNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsAsaProfilePointer;
		tmplen = StorageTmp->mtpLsAsaProfilePointerLen;
		memdup((void *) &StorageTmp->mtpLsAsaProfilePointer, var_val, var_val_len);
		StorageTmp->mtpLsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsAsaProfilePointer);
		StorageTmp->mtpLsAsaProfilePointer = tmpvar;
		StorageTmp->mtpLsAsaProfilePointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentValidIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsCurrentValidIntervals entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentValidIntervals;
		StorageTmp->mtpLsCurrentValidIntervals = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentValidIntervals = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentTimeDiscontinuity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsCurrentTimeDiscontinuity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentTimeDiscontinuity;
		StorageTmp->mtpLsCurrentTimeDiscontinuity = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentTimeDiscontinuity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentAdjacentInaccessibleEvents(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsCurrentAdjacentInaccessibleEvents entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentAdjacentInaccessibleEvents not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents;
		StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentAdjacentInaccessibleDuration(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsCurrentAdjacentInaccessibleDuration entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentAdjacentInaccessibleDuration not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration;
		StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentSlsUnavailable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpLsCurrentSlsUnavailable entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentSlsUnavailable not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentSlsUnavailable;
		StorageTmp->mtpLsCurrentSlsUnavailable = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentSlsUnavailable = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT1;
		StorageTmp->mtpSlProfileTimerT1 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT3;
		StorageTmp->mtpSlProfileTimerT3 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT3 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT17 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT17 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT17;
		StorageTmp->mtpSlProfileTimerT17 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT17 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT24(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT24 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT24 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT24;
		StorageTmp->mtpSlProfileTimerT24 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT24 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileName;
		tmplen = StorageTmp->mtpSlProfileNameLen;
		memdup((void *) &StorageTmp->mtpSlProfileName, var_val, var_val_len);
		StorageTmp->mtpSlProfileNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlProfileName);
		StorageTmp->mtpSlProfileName = tmpvar;
		StorageTmp->mtpSlProfileNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT2;
		StorageTmp->mtpSlProfileTimerT2 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT4;
		StorageTmp->mtpSlProfileTimerT4 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT4 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT5;
		StorageTmp->mtpSlProfileTimerT5 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT5 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT12;
		StorageTmp->mtpSlProfileTimerT12 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT12 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT13;
		StorageTmp->mtpSlProfileTimerT13 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT13 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT14;
		StorageTmp->mtpSlProfileTimerT14 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT14 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT19A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT19A;
		StorageTmp->mtpSlProfileTimerT19A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT19A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT20A;
		StorageTmp->mtpSlProfileTimerT20A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT20A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT21A;
		StorageTmp->mtpSlProfileTimerT21A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT21A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT22(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT22 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT22 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT22;
		StorageTmp->mtpSlProfileTimerT22 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT22 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT23(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT23 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT23 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT23;
		StorageTmp->mtpSlProfileTimerT23 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT23 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT31A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT31A;
		StorageTmp->mtpSlProfileTimerT31A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT31A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT32A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT32A;
		StorageTmp->mtpSlProfileTimerT32A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT32A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT33A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT33A;
		StorageTmp->mtpSlProfileTimerT33A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT33A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT34A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT34A;
		StorageTmp->mtpSlProfileTimerT34A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT34A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT1T;
		StorageTmp->mtpSlProfileTimerT1T = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT1T = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT2T;
		StorageTmp->mtpSlProfileTimerT2T = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT2T = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfileTimerT1S entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT1S not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT1S;
		StorageTmp->mtpSlProfileTimerT1S = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT1S = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSlsCodeCurrentList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlSlsCodeCurrentList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeCurrentList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlSlsCodeCurrentList;
		tmplen = StorageTmp->mtpSlSlsCodeCurrentListLen;
		memdup((void *) &StorageTmp->mtpSlSlsCodeCurrentList, var_val, var_val_len);
		StorageTmp->mtpSlSlsCodeCurrentListLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSlsCodeCurrentList);
		StorageTmp->mtpSlSlsCodeCurrentList = tmpvar;
		StorageTmp->mtpSlSlsCodeCurrentListLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlMaxCapacity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMaxCapacity not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlMaxCapacity;
		StorageTmp->mtpSlMaxCapacity = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlMaxCapacity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlAdministrativeState;
		StorageTmp->mtpSlAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfilePointer;
		tmplen = StorageTmp->mtpSlL2ProfilePointerLen;
		memdup((void *) &StorageTmp->mtpSlL2ProfilePointer, var_val, var_val_len);
		StorageTmp->mtpSlL2ProfilePointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlL2ProfilePointer);
		StorageTmp->mtpSlL2ProfilePointer = tmpvar;
		StorageTmp->mtpSlL2ProfilePointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdtPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdtPointer;
		tmplen = StorageTmp->mtpSlSdtPointerLen;
		memdup((void *) &StorageTmp->mtpSlSdtPointer, var_val, var_val_len);
		StorageTmp->mtpSlSdtPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSdtPointer);
		StorageTmp->mtpSlSdtPointer = tmpvar;
		StorageTmp->mtpSlSdtPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdlPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdlPointer;
		tmplen = StorageTmp->mtpSlSdlPointerLen;
		memdup((void *) &StorageTmp->mtpSlSdlPointer, var_val, var_val_len);
		StorageTmp->mtpSlSdlPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSdlPointer);
		StorageTmp->mtpSlSdlPointer = tmpvar;
		StorageTmp->mtpSlSdlPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlLocalInhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlLocalInhibit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlLocalInhibit;
		StorageTmp->mtpSlLocalInhibit = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalInhibit = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlLocalUninhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlLocalUninhibit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlLocalUninhibit;
		StorageTmp->mtpSlLocalUninhibit = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalUninhibit = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlReplaceSt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlReplaceSt entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlReplaceSt;
		StorageTmp->mtpSlReplaceSt = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlReplaceSt = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlAsaProfilePointer;
		tmplen = StorageTmp->mtpSlAsaProfilePointerLen;
		memdup((void *) &StorageTmp->mtpSlAsaProfilePointer, var_val, var_val_len);
		StorageTmp->mtpSlAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlAsaProfilePointer);
		StorageTmp->mtpSlAsaProfilePointer = tmpvar;
		StorageTmp->mtpSlAsaProfilePointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlRelatedLinkGroupNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlRelatedLinkGroupNumber entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlRelatedLinkGroupNumber;
		StorageTmp->mtpSlRelatedLinkGroupNumber = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlRelatedLinkGroupNumber = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlTest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlTest entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlTest;
		StorageTmp->mtpSlTest = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlTest = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlName;
		tmplen = StorageTmp->mtpSlNameLen;
		memdup((void *) &StorageTmp->mtpSlName, var_val, var_val_len);
		StorageTmp->mtpSlNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlName);
		StorageTmp->mtpSlName = tmpvar;
		StorageTmp->mtpSlNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSlsCodeNormalList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlSlsCodeNormalList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlSlsCodeNormalList;
		tmplen = StorageTmp->mtpSlSlsCodeNormalListLen;
		memdup((void *) &StorageTmp->mtpSlSlsCodeNormalList, var_val, var_val_len);
		StorageTmp->mtpSlSlsCodeNormalListLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSlsCodeNormalList);
		StorageTmp->mtpSlSlsCodeNormalList = tmpvar;
		StorageTmp->mtpSlSlsCodeNormalListLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfilePointer;
		tmplen = StorageTmp->mtpSlProfilePointerLen;
		memdup((void *) &StorageTmp->mtpSlProfilePointer, var_val, var_val_len);
		StorageTmp->mtpSlProfilePointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlProfilePointer);
		StorageTmp->mtpSlProfilePointer = tmpvar;
		StorageTmp->mtpSlProfilePointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdlListPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdlListPointer;
		tmplen = StorageTmp->mtpSlSdlListPointerLen;
		memdup((void *) &StorageTmp->mtpSlSdlListPointer, var_val, var_val_len);
		StorageTmp->mtpSlSdlListPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSdlListPointer);
		StorageTmp->mtpSlSdlListPointer = tmpvar;
		StorageTmp->mtpSlSdlListPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdtListPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdtListPointer;
		tmplen = StorageTmp->mtpSlSdtListPointerLen;
		memdup((void *) &StorageTmp->mtpSlSdtListPointer, var_val, var_val_len);
		StorageTmp->mtpSlSdtListPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSdtListPointer);
		StorageTmp->mtpSlSdtListPointer = tmpvar;
		StorageTmp->mtpSlSdtListPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileErrorCorrectionMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileErrorCorrectionMethod entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileErrorCorrectionMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileErrorCorrectionMethod;
		StorageTmp->mtpL2ProfileErrorCorrectionMethod = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileErrorCorrectionMethod = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT1;
		StorageTmp->mtpL2ProfileTimerT1 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT2;
		StorageTmp->mtpL2ProfileTimerT2 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT3;
		StorageTmp->mtpL2ProfileTimerT3 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT3 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT4N(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTimerT4N entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT4N not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT4N;
		StorageTmp->mtpL2ProfileTimerT4N = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT4N = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT4E(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTimerT4E entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT4E not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT4E;
		StorageTmp->mtpL2ProfileTimerT4E = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT4E = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT5;
		StorageTmp->mtpL2ProfileTimerT5 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT5 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT6;
		StorageTmp->mtpL2ProfileTimerT6 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT6 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT7;
		StorageTmp->mtpL2ProfileTimerT7 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT7 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshOnsetLevel1Msgs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshOnsetLevel1Msgs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshOnsetLevel1Msgs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Msgs;
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Msgs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Msgs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshOnsetLevel1Octs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshOnsetLevel1Octs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshOnsetLevel1Octs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Octs;
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Octs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel1Octs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshAbateLevel1Msgs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshAbateLevel1Msgs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshAbateLevel1Msgs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Msgs;
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Msgs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Msgs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshAbateLevel1Octs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshAbateLevel1Octs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshAbateLevel1Octs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Octs;
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Octs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel1Octs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileNumberOfThresholdLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileNumberOfThresholdLevels entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileNumberOfThresholdLevels not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileNumberOfThresholdLevels;
		StorageTmp->mtpL2ProfileNumberOfThresholdLevels = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileNumberOfThresholdLevels = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileCongestionCounting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileCongestionCounting entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileCongestionCounting not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileCongestionCounting;
		StorageTmp->mtpL2ProfileCongestionCounting = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileCongestionCounting = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileCongestionReportingBaseObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileCongestionReportingBaseObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileCongestionReportingBaseObject not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileCongestionReportingBaseObject;
		StorageTmp->mtpL2ProfileCongestionReportingBaseObject = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileCongestionReportingBaseObject = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileLoopDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileLoopDelay;
		StorageTmp->mtpL2ProfileLoopDelay = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileLoopDelay = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileName;
		tmplen = StorageTmp->mtpL2ProfileNameLen;
		memdup((void *) &StorageTmp->mtpL2ProfileName, var_val, var_val_len);
		StorageTmp->mtpL2ProfileNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpL2ProfileName);
		StorageTmp->mtpL2ProfileName = tmpvar;
		StorageTmp->mtpL2ProfileNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshOnsetLevel2Msgs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshOnsetLevel2Msgs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshOnsetLevel2Msgs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Msgs;
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Msgs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Msgs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshOnsetLevel2Octs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshOnsetLevel2Octs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshOnsetLevel2Octs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Octs;
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Octs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel2Octs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshAbateLevel2Msgs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshAbateLevel2Msgs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshAbateLevel2Msgs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Msgs;
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Msgs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Msgs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshAbateLevel2Octs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshAbateLevel2Octs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshAbateLevel2Octs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Octs;
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Octs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel2Octs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshOnsetLevel3Msgs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshOnsetLevel3Msgs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshOnsetLevel3Msgs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Msgs;
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Msgs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Msgs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshOnsetLevel3Octs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshOnsetLevel3Octs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshOnsetLevel3Octs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Octs;
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Octs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshOnsetLevel3Octs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshAbateLevel3Msgs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshAbateLevel3Msgs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshAbateLevel3Msgs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Msgs;
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Msgs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Msgs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshAbateLevel3Octs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshAbateLevel3Octs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshAbateLevel3Octs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Octs;
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Octs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshAbateLevel3Octs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshDiscardLevel1Msgs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshDiscardLevel1Msgs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshDiscardLevel1Msgs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Msgs;
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Msgs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Msgs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshDiscardLevel1Octs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshDiscardLevel1Octs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshDiscardLevel1Octs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Octs;
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Octs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel1Octs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshDiscardLevel2Msgs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshDiscardLevel2Msgs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshDiscardLevel2Msgs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Msgs;
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Msgs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Msgs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshDiscardLevel2Octs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshDiscardLevel2Octs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshDiscardLevel2Octs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Octs;
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Octs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel2Octs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshDiscardLevel3Msgs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshDiscardLevel3Msgs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshDiscardLevel3Msgs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Msgs;
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Msgs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Msgs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransCongThreshDiscardLevel3Octs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTransCongThreshDiscardLevel3Octs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransCongThreshDiscardLevel3Octs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Octs;
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Octs = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransCongThreshDiscardLevel3Octs = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerTx(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTimerTx entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerTx not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerTx;
		StorageTmp->mtpL2ProfileTimerTx = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerTx = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerTy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileTimerTy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerTy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerTy;
		StorageTmp->mtpL2ProfileTimerTy = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerTy = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileNumberOfCongestionStates(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileNumberOfCongestionStates entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileNumberOfCongestionStates not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileNumberOfCongestionStates;
		StorageTmp->mtpL2ProfileNumberOfCongestionStates = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileNumberOfCongestionStates = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileInitialLevelOfCongestion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileInitialLevelOfCongestion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileInitialLevelOfCongestion not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileInitialLevelOfCongestion;
		StorageTmp->mtpL2ProfileInitialLevelOfCongestion = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileInitialLevelOfCongestion = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileMaxMSUsRetransN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileMaxMSUsRetransN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileMaxMSUsRetransN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileMaxMSUsRetransN1;
		StorageTmp->mtpL2ProfileMaxMSUsRetransN1 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileMaxMSUsRetransN1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileMaxOctRetransN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileMaxOctRetransN2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileMaxOctRetransN2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileMaxOctRetransN2;
		StorageTmp->mtpL2ProfileMaxOctRetransN2 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileMaxOctRetransN2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileReceiveCongThreshOnset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileReceiveCongThreshOnset entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileReceiveCongThreshOnset not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileReceiveCongThreshOnset;
		StorageTmp->mtpL2ProfileReceiveCongThreshOnset = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileReceiveCongThreshOnset = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileReceiveCongThreshAbate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpL2ProfileReceiveCongThreshAbate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileReceiveCongThreshAbate not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileReceiveCongThreshAbate;
		StorageTmp->mtpL2ProfileReceiveCongThreshAbate = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileReceiveCongThreshAbate = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNbandTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpNbTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbandTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNbTransmissionRate;
		StorageTmp->mtpNbTransmissionRate = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTransmissionRate = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalBufferRelease(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalBufferRelease entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalBufferRelease;
		StorageTmp->mtpSaalBufferRelease = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalBufferRelease = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxCc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxCc;
		StorageTmp->mtpSaalMaxCc = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxCc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxNrp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxNrp entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxNrp;
		StorageTmp->mtpSaalMaxNrp = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxNrp = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxInformationFieldLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxInformationFieldLength entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxInformationFieldLength;
		StorageTmp->mtpSaalMaxInformationFieldLength = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxInformationFieldLength = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxLengthSscopUuField(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxLengthSscopUuField entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxLengthSscopUuField;
		StorageTmp->mtpSaalMaxLengthSscopUuField = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxLengthSscopUuField = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxPd(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxPd entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxPd;
		StorageTmp->mtpSaalMaxPd = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxPd = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxSscopCreditToPeer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxSscopCreditToPeer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxSscopCreditToPeer;
		StorageTmp->mtpSaalMaxSscopCreditToPeer = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxSscopCreditToPeer = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxStat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxStat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxStat;
		StorageTmp->mtpSaalMaxStat = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxStat = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalN1;
		StorageTmp->mtpSaalN1 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalN1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementProvingState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniLayerManagementProvingState;
		StorageTmp->mtpSaalNniLayerManagementProvingState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementProvingState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementTimerNoCredit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementTimerNoCredit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementTimerRepeatSrec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementTimerRepeatSrec entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniTimerT1;
		StorageTmp->mtpSaalNniTimerT1 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniTimerT2;
		StorageTmp->mtpSaalNniTimerT2 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniTimerT3;
		StorageTmp->mtpSaalNniTimerT3 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT3 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerCc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerCc;
		StorageTmp->mtpSaalSscopTimerCc = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerCc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerIdle entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerIdle;
		StorageTmp->mtpSaalSscopTimerIdle = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerIdle = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerKeepAlive entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerKeepAlive;
		StorageTmp->mtpSaalSscopTimerKeepAlive = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerKeepAlive = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerNoResponse(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerNoResponse entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerNoResponse;
		StorageTmp->mtpSaalSscopTimerNoResponse = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerNoResponse = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerPoll(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerPoll entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerPoll;
		StorageTmp->mtpSaalSscopTimerPoll = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerPoll = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalTransmissionRateIntervalLower;
		StorageTmp->mtpSaalTransmissionRateIntervalLower = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalLower = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalEgressTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalEgressTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalEgressTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalEgressTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalPollAfterRetransmission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSaalPollAfterRetransmission entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalPollAfterRetransmission;
		StorageTmp->mtpSaalPollAfterRetransmission = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalPollAfterRetransmission = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paN1;
		StorageTmp->mtpM2paN1 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paN1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paProving(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paProving entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paProving;
		StorageTmp->mtpM2paProving = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProving = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paManagementProvingState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paManagementProvingState;
		StorageTmp->mtpM2paManagementProvingState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paManagementProvingState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paLoopDelayLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paLoopDelayLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paLoopDelayLower;
		StorageTmp->mtpM2paLoopDelayLower = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayLower = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paLoopDelayUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paLoopDelayUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paLoopDelayUpper;
		StorageTmp->mtpM2paLoopDelayUpper = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayUpper = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paTransmissionRateIntervalLower;
		StorageTmp->mtpM2paTransmissionRateIntervalLower = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalLower = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paTransmissionRateIntervalUpper;
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpNoDelay;
		StorageTmp->mtpM2paSctpNoDelay = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpNoDelay = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpMaxseg;
		StorageTmp->mtpM2paSctpMaxseg = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxseg = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpHeartbeatItvl;
		StorageTmp->mtpM2paSctpHeartbeatItvl = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeatItvl = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpHeartbeat;
		StorageTmp->mtpM2paSctpHeartbeat = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeat = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpRtoInitial;
		StorageTmp->mtpM2paSctpRtoInitial = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoInitial = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpRtoMin;
		StorageTmp->mtpM2paSctpRtoMin = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMin = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpRtoMax;
		StorageTmp->mtpM2paSctpRtoMax = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMax = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpPathMaxRetrans;
		StorageTmp->mtpM2paSctpPathMaxRetrans = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpPathMaxRetrans = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpCookieLife;
		StorageTmp->mtpM2paSctpCookieLife = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieLife = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpCookieInc;
		StorageTmp->mtpM2paSctpCookieInc = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieInc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpMaxInitRetries;
		StorageTmp->mtpM2paSctpMaxInitRetries = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxInitRetries = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpMaxBurst;
		StorageTmp->mtpM2paSctpMaxBurst = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxBurst = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpAssocMaxRetrans;
		StorageTmp->mtpM2paSctpAssocMaxRetrans = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpAssocMaxRetrans = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpSackDelay;
		StorageTmp->mtpM2paSctpSackDelay = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpSackDelay = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpLifetime;
		StorageTmp->mtpM2paSctpLifetime = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpLifetime = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paProvingAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpM2paProvingAttempts entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paProvingAttempts;
		StorageTmp->mtpM2paProvingAttempts = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProvingAttempts = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSdtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdtAdminState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdtAdminState;
		StorageTmp->mtpSdtAdminState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtAdminState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSdtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdtEquipmentPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdtEquipmentPointer;
		tmplen = StorageTmp->mtpSdtEquipmentPointerLen;
		memdup((void *) &StorageTmp->mtpSdtEquipmentPointer, var_val, var_val_len);
		StorageTmp->mtpSdtEquipmentPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdtEquipmentPointer);
		StorageTmp->mtpSdtEquipmentPointer = tmpvar;
		StorageTmp->mtpSdtEquipmentPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSdtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdtName;
		tmplen = StorageTmp->mtpSdtNameLen;
		memdup((void *) &StorageTmp->mtpSdtName, var_val, var_val_len);
		StorageTmp->mtpSdtNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdtName);
		StorageTmp->mtpSdtName = tmpvar;
		StorageTmp->mtpSdtNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdlAdjPc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlAdjPc;
		tmplen = StorageTmp->mtpSdlAdjPcLen;
		memdup((void *) &StorageTmp->mtpSdlAdjPc, var_val, var_val_len);
		StorageTmp->mtpSdlAdjPcLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlAdjPc);
		StorageTmp->mtpSdlAdjPc = tmpvar;
		StorageTmp->mtpSdlAdjPcLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdlTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlTransmissionRate;
		StorageTmp->mtpSdlTransmissionRate = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlTransmissionRate = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdlLoopDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlLoopDelay;
		StorageTmp->mtpSdlLoopDelay = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlLoopDelay = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlOperState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdlOperState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlOperState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlOperState;
		StorageTmp->mtpSdlOperState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlOperState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdlEquipmentPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlEquipmentPointer;
		tmplen = StorageTmp->mtpSdlEquipmentPointerLen;
		memdup((void *) &StorageTmp->mtpSdlEquipmentPointer, var_val, var_val_len);
		StorageTmp->mtpSdlEquipmentPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlEquipmentPointer);
		StorageTmp->mtpSdlEquipmentPointer = tmpvar;
		StorageTmp->mtpSdlEquipmentPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdlCIC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlCIC;
		StorageTmp->mtpSdlCIC = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlCIC = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdlName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlName;
		tmplen = StorageTmp->mtpSdlNameLen;
		memdup((void *) &StorageTmp->mtpSdlName, var_val, var_val_len);
		StorageTmp->mtpSdlNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlName);
		StorageTmp->mtpSdlName = tmpvar;
		StorageTmp->mtpSdlNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlStmChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdlStmChannel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlStmChannel;
		StorageTmp->mtpSdlStmChannel = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlStmChannel = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlVcTTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB", "write_mtpSdlVcTTpPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlVcTTpPointer;
		tmplen = StorageTmp->mtpSdlVcTTpPointerLen;
		memdup((void *) &StorageTmp->mtpSdlVcTTpPointer, var_val, var_val_len);
		StorageTmp->mtpSdlVcTTpPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlVcTTpPointer);
		StorageTmp->mtpSdlVcTTpPointer = tmpvar;
		StorageTmp->mtpSdlVcTTpPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpNoDelay;
		StorageTmp->mtpM2paDefaultSctpNoDelay = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpNoDelay = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpMaxseg;
		StorageTmp->mtpM2paDefaultSctpMaxseg = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxseg = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpHeartbeatItvl;
		StorageTmp->mtpM2paDefaultSctpHeartbeatItvl = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpHeartbeatItvl = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpHeartbeat;
		StorageTmp->mtpM2paDefaultSctpHeartbeat = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpHeartbeat = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 300 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpRtoInitial;
		StorageTmp->mtpM2paDefaultSctpRtoInitial = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoInitial = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpRtoMin;
		StorageTmp->mtpM2paDefaultSctpRtoMin = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoMin = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpRtoMax;
		StorageTmp->mtpM2paDefaultSctpRtoMax = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoMax = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpPathMaxRetrans;
		StorageTmp->mtpM2paDefaultSctpPathMaxRetrans = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpPathMaxRetrans = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpCookieLife;
		StorageTmp->mtpM2paDefaultSctpCookieLife = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpCookieLife = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpCookieInc;
		StorageTmp->mtpM2paDefaultSctpCookieInc = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpCookieInc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpMaxInitRetries;
		StorageTmp->mtpM2paDefaultSctpMaxInitRetries = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxInitRetries = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpMaxBurst;
		StorageTmp->mtpM2paDefaultSctpMaxBurst = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxBurst = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans;
		StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 0..50 */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpSackDelay;
		StorageTmp->mtpM2paDefaultSctpSackDelay = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpSackDelay = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpLifetime;
		StorageTmp->mtpM2paDefaultSctpLifetime = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpLifetime = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL;
	static struct mtpSapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpL3Id 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSapId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSapTable_data);
			memdup((void *) &StorageNew->mtpL3Id, vp->val.string, vp->val_len);
			StorageNew->mtpL3IdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpSapId, vp->val.string, vp->val_len);
			StorageNew->mtpSapIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			/* StorageNew->mtpSapAsaProfilePointer = zeroDotZero; */
			StorageNew->mtpSapName = strdup("\"\"");
			StorageNew->mtpSapNameLen = strlen("\"\"");

			StorageNew->mtpSapRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSapTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSapRowStatus;
			StorageTmp->mtpSapRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSapTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSapTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSapTable_add(StorageDel);
		} else {
			StorageTmp->mtpSapRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSapRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSapRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSapRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSapRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL;
	static struct mtpNaTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpNaId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpNaTable_data);
			memdup((void *) &StorageNew->mtpNaId, vp->val.string, vp->val_len);
			StorageNew->mtpNaIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			/* StorageNew->mtpNaProtocolVariant = { ss7ProtocolItut 0 }; */

			StorageNew->mtpNaRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpNaTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpNaRowStatus;
			StorageTmp->mtpNaRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpNaTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNaTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpNaTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNaTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpNaTable_add(StorageDel);
		} else {
			StorageTmp->mtpNaRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpNaRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpNaRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpNaRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpNaRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL;
	static struct mtpGsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpGsId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpGsTable_data);
			memdup((void *) &StorageNew->mtpSpId, vp->val.string, vp->val_len);
			StorageNew->mtpSpIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpGsId, vp->val.string, vp->val_len);
			StorageNew->mtpGsIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpGsRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpGsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpGsRowStatus;
			StorageTmp->mtpGsRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpGsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpGsTable_add(StorageDel);
		} else {
			StorageTmp->mtpGsRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpGsRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpGsRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpGsRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpGsRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineTable_data *StorageTmp = NULL;
	static struct mtpGsLineTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpGsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OBJECT_ID, NULL, 0);	/* mtpGsLineId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineTable_data);
			memdup((void *) &StorageNew->mtpSpId, vp->val.string, vp->val_len);
			StorageNew->mtpSpIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpGsId, vp->val.string, vp->val_len);
			StorageNew->mtpGsIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpGsLineId, (u_char *) vp->val.oid, vp->val_len);
			StorageNew->mtpGsLineIdLen = vp->val_len / sizeof(oid);
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpGsLineRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpGsLineTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpGsLineRowStatus;
			StorageTmp->mtpGsLineRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpGsLineTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsLineTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsLineTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsLineTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpGsLineTable_add(StorageDel);
		} else {
			StorageTmp->mtpGsLineRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpGsLineRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpGsLineRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpGsLineRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpGsLineRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static struct mtpGsLineContentTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpGsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OBJECT_ID, NULL, 0);	/* mtpGsLineId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsLineContentDesignatedDPCFirst 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data);
			memdup((void *) &StorageNew->mtpSpId, vp->val.string, vp->val_len);
			StorageNew->mtpSpIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpGsId, vp->val.string, vp->val_len);
			StorageNew->mtpGsIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpGsLineId, (u_char *) vp->val.oid, vp->val_len);
			StorageNew->mtpGsLineIdLen = vp->val_len / sizeof(oid);
			vp = vp->next_variable;
			StorageNew->mtpGsLineContentDesignatedDPCFirst = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpGsLineContentRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpGsLineContentTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpGsLineContentRowStatus;
			StorageTmp->mtpGsLineContentRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpGsLineContentTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsLineContentTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsLineContentTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsLineContentTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpGsLineContentTable_add(StorageDel);
		} else {
			StorageTmp->mtpGsLineContentRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpGsLineContentRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpGsLineContentRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpGsLineContentRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpGsLineContentRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static struct mtpSpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);
			memdup((void *) &StorageNew->mtpSpProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSpProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpProfileMtpT20A = 10000;
			StorageNew->mtpSpProfileMtpT21A = 10000;

			StorageNew->mtpSpProfileRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpProfileRowStatus;
			StorageTmp->mtpSpProfileRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpProfileTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpProfileRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpProfileRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpProfileRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpProfileRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpProfileRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL;
	static struct mtpSpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSpTable_data);
			memdup((void *) &StorageNew->mtpSpId, vp->val.string, vp->val_len);
			StorageNew->mtpSpIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpMtpT31A = 6000;
			StorageNew->mtpSpMtpT32A = 6000;
			StorageNew->mtpSpMtpT33A = 36000;
			StorageNew->mtpSpMtpT34A = 6000;
			StorageNew->mtpSpMtpT20A = 10000;
			StorageNew->mtpSpMtpT21A = 10000;

			StorageNew->mtpSpRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpRowStatus;
			StorageTmp->mtpSpRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpSiStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpSiTable_data *StorageTmp = NULL;
	static struct mtpSpSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpSiTableStorage, NULL, &name[sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpSiCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSpSiTable_data);
			StorageNew->mtpSpSiCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpSiStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpSiTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpSiStatus;
			StorageTmp->mtpSpSiStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpSiTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpSiTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpSiTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpSiStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpSiStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpSiStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpSiStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpSiStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpStudyStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpStudyTable_data *StorageTmp = NULL;
	static struct mtpSpStudyTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpStudyTableStorage, NULL, &name[sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpStudyStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpStudyIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSpStudyTable_data);
			StorageNew->mtpSpStudyIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpStudyStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpStudyTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpStudyStatus;
			StorageTmp->mtpSpStudyStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpStudyTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpStudyTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpStudyTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpStudyStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpStudyStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpStudyStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpStudyStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpStudyStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpStudyMapStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpStudyMapTable_data *StorageTmp = NULL;
	static struct mtpSpStudyMapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpStudyMapTableStorage, NULL, &name[sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpStudyMapStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpSiCode 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpStudyIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSpStudyMapTable_data);
			StorageNew->mtpSpSiCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpStudyIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpStudyMapStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpStudyMapTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpStudyMapStatus;
			StorageTmp->mtpSpStudyMapStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpStudyMapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyMapTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpStudyMapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyMapTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpStudyMapTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpStudyMapStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpStudyMapStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpStudyMapStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpStudyMapStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpStudyMapStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpL3Table_data *StorageTmp = NULL;
	static struct mtpL3Table_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3RowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpL3Id 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpL3Table_data);
			memdup((void *) &StorageNew->mtpL3Id, vp->val.string, vp->val_len);
			StorageNew->mtpL3IdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpL3RowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpL3Table_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpL3RowStatus;
			StorageTmp->mtpL3RowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpL3TableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpL3TableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpL3TableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpL3TableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpL3Table_add(StorageDel);
		} else {
			StorageTmp->mtpL3RowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpL3RowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpL3RowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpL3RowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpL3RowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL;
	static struct mtpRsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpRsId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpRsTable_data);
			memdup((void *) &StorageNew->mtpSpId, vp->val.string, vp->val_len);
			StorageNew->mtpSpIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpRsId, vp->val.string, vp->val_len);
			StorageNew->mtpRsIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRsRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRsRowStatus;
			StorageTmp->mtpRsRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRsTable_add(StorageDel);
		} else {
			StorageTmp->mtpRsRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRsRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRsRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRsRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRsRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static struct mtpRsSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsSiCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpRsSiTable_data);
			StorageNew->mtpRsSiCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRsSiStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRsSiTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRsSiStatus;
			StorageTmp->mtpRsSiStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRsSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsSiTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsSiTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRsSiTable_add(StorageDel);
		} else {
			StorageTmp->mtpRsSiStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRsSiStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRsSiStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRsSiStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRsSiStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL;
	static struct mtpRtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpRsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpRtId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpRtTable_data);
			memdup((void *) &StorageNew->mtpSpId, vp->val.string, vp->val_len);
			StorageNew->mtpSpIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpRsId, vp->val.string, vp->val_len);
			StorageNew->mtpRsIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpRtId, vp->val.string, vp->val_len);
			StorageNew->mtpRtIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRtRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRtTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRtRowStatus;
			StorageTmp->mtpRtRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRtTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRtTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRtTable_add(StorageDel);
		} else {
			StorageTmp->mtpRtRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRtRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRtRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRtRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRtRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static struct mtpLsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			if (header_complex_parse_oid(&(name[sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data);

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpLsProfileMtpT6 = 80;
			StorageNew->mtpLsProfileMtpT8 = 100;
			StorageNew->mtpLsProfileMtpT10 = 4500;
			StorageNew->mtpLsProfileName = strdup("\"\"");
			StorageNew->mtpLsProfileNameLen = strlen("\"\"");

			StorageNew->mtpLsProfileRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpLsProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpLsProfileRowStatus;
			StorageTmp->mtpLsProfileRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpLsProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsProfileTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpLsProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpLsProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpLsProfileRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpLsProfileRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpLsProfileRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpLsProfileRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpLsProfileRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL;
	static struct mtpLsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpLsId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpLsTable_data);
			memdup((void *) &StorageNew->mtpSpId, vp->val.string, vp->val_len);
			StorageNew->mtpSpIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpLsId, vp->val.string, vp->val_len);
			StorageNew->mtpLsIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpLsRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpLsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpLsRowStatus;
			StorageTmp->mtpLsRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpLsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpLsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpLsTable_add(StorageDel);
		} else {
			StorageTmp->mtpLsRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpLsRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpLsRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpLsRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpLsRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static struct mtpSlProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpSlProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSlProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSlProfileTable_data);
			memdup((void *) &StorageNew->mtpSlProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSlProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSlProfileTimerT20A = 10000;
			StorageNew->mtpSlProfileTimerT21A = 10000;
			StorageNew->mtpSlProfileTimerT22 = 27000;
			StorageNew->mtpSlProfileTimerT23 = 27000;
			StorageNew->mtpSlProfileTimerT31A = 6000;
			StorageNew->mtpSlProfileTimerT32A = 6000;
			StorageNew->mtpSlProfileTimerT33A = 36000;
			StorageNew->mtpSlProfileTimerT34A = 6000;

			StorageNew->mtpSlProfileRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlProfileRowStatus;
			StorageTmp->mtpSlProfileRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlProfileTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlProfileRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlProfileRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlProfileRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlProfileRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlProfileRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL;
	static struct mtpSlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpLsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSlTable_data);
			memdup((void *) &StorageNew->mtpSpId, vp->val.string, vp->val_len);
			StorageNew->mtpSpIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpLsId, vp->val.string, vp->val_len);
			StorageNew->mtpLsIdLen = vp->val_len;
			vp = vp->next_variable;
			StorageNew->mtpSlCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			/* StorageNew->mtpSlAsaProfilePointer = zeroDotZero; */

			StorageNew->mtpSlRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlRowStatus;
			StorageTmp->mtpSlRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	static struct mtpSlSdlListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpLsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlCode 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlSdlListId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);
			memdup((void *) &StorageNew->mtpSpId, vp->val.string, vp->val_len);
			StorageNew->mtpSpIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpLsId, vp->val.string, vp->val_len);
			StorageNew->mtpLsIdLen = vp->val_len;
			vp = vp->next_variable;
			StorageNew->mtpSlCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdlListId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSlSdlListRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlSdlListTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdlListRowStatus;
			StorageTmp->mtpSlSdlListRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlSdlListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdlListTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlSdlListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdlListTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlSdlListTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlSdlListRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlSdlListRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlSdlListRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlSdlListRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlSdlListRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	static struct mtpSlSdtListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpLsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlCode 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlSdtListId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);
			memdup((void *) &StorageNew->mtpSpId, vp->val.string, vp->val_len);
			StorageNew->mtpSpIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpLsId, vp->val.string, vp->val_len);
			StorageNew->mtpLsIdLen = vp->val_len;
			vp = vp->next_variable;
			StorageNew->mtpSlCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdtListId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSlSdtListRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlSdtListTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdtListRowStatus;
			StorageTmp->mtpSlSdtListRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlSdtListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdtListTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlSdtListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdtListTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlSdtListTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlSdtListRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlSdtListRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlSdtListRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlSdtListRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlSdtListRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static struct mtpL2ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpL2ProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpL2ProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpL2ProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpL2ProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpL2ProfileTable_data);
			memdup((void *) &StorageNew->mtpL2ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpL2ProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpL2ProfileRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpL2ProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpL2ProfileRowStatus;
			StorageTmp->mtpL2ProfileRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpL2ProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpL2ProfileTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpL2ProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpL2ProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpL2ProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpL2ProfileRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpL2ProfileRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpL2ProfileRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpL2ProfileRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpL2ProfileRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbandRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNbandTable_data *StorageTmp = NULL;
	static struct mtpNbandTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpNbandTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpNbandTableStorage, NULL, &name[sizeof(mtpNbandTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbandRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpL2ProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpNbandTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpNbandTable_data);
			memdup((void *) &StorageNew->mtpL2ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpL2ProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpNbandRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpNbandTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpNbandRowStatus;
			StorageTmp->mtpNbandRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpNbandTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNbandTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpNbandTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNbandTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpNbandTable_add(StorageDel);
		} else {
			StorageTmp->mtpNbandRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpNbandRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpNbandRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpNbandRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpNbandRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL;
	static struct mtpSaalTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpL2ProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSaalTable_data);
			memdup((void *) &StorageNew->mtpL2ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpL2ProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSaalMaxCc = 4;
			StorageNew->mtpSaalMaxInformationFieldLength = 4096;
			StorageNew->mtpSaalMaxLengthSscopUuField = 4;
			StorageNew->mtpSaalMaxPd = 500;
			StorageNew->mtpSaalMaxStat = 67;
			StorageNew->mtpSaalN1 = 1000;
			StorageNew->mtpSaalNniTimerT1 = 500;
			StorageNew->mtpSaalNniTimerT2 = 3000;
			StorageNew->mtpSaalSscopTimerCc = 20;
			StorageNew->mtpSaalSscopTimerIdle = 10;
			StorageNew->mtpSaalSscopTimerKeepAlive = 10;
			StorageNew->mtpSaalSscopTimerNoResponse = 150;
			StorageNew->mtpSaalSscopTimerPoll = 10;
			StorageNew->mtpSaalTransmissionRateIntervalLower = 129;
			StorageNew->mtpSaalTransmissionRateIntervalUpper = 256;

			StorageNew->mtpSaalRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSaalTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSaalRowStatus;
			StorageTmp->mtpSaalRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSaalTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSaalTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSaalTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSaalTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSaalTable_add(StorageDel);
		} else {
			StorageTmp->mtpSaalRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSaalRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSaalRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSaalRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSaalRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL;
	static struct mtpM2paTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpL2ProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpM2paTable_data);
			memdup((void *) &StorageNew->mtpL2ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpL2ProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpM2paN1 = 1000;
			StorageNew->mtpM2paProving = true;
			StorageNew->mtpM2paSctpSackDelay = 20;

			StorageNew->mtpM2paRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpM2paTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpM2paRowStatus;
			StorageTmp->mtpM2paRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpM2paTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpM2paTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpM2paTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpM2paTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpM2paTable_add(StorageDel);
		} else {
			StorageTmp->mtpM2paRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpM2paRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpM2paRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpM2paRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpM2paRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdtTable_data *StorageTmp = NULL;
	static struct mtpSdtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSdtId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSdtTable_data);
			memdup((void *) &StorageNew->mtpSdtId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSdtRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSdtTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSdtRowStatus;
			StorageTmp->mtpSdtRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSdtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdtTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSdtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdtTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSdtTable_add(StorageDel);
		} else {
			StorageTmp->mtpSdtRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSdtRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSdtRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSdtRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSdtRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL;
	static struct mtpSdlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSdlId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSdlTable_data);
			memdup((void *) &StorageNew->mtpSdlId, vp->val.string, vp->val_len);
			StorageNew->mtpSdlIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSdlRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSdlTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSdlRowStatus;
			StorageTmp->mtpSdlRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSdlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdlTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSdlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdlTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSdlTable_add(StorageDel);
		} else {
			StorageTmp->mtpSdlRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSdlRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSdlRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSdlRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSdlRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

#if !defined MODULE
static void
sa_version(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
%2$s\n\
Copyright (c) 2001-2008  OpenSS7 Corporation.  All Rights Reserved.\n\
Distributed under Affero GPL Version 3, included here by reference.\n\
See `%1$s --copying' for copying permissions.\n\
", argv[0], ident);
}

static void
sa_usage(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stderr, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-H|--help-directives}\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
", argv[0]);
}

static void
sa_help(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
Arguments:\n\
    None.\n\
Options:\n\
    -a, --log-addresses\n\
        log addresses of connecting management stations.\n\
    -A, --append\n\
        append to logfiles without truncating.\n\
    -c, --config-file CONFIGFILE\n\
        use configuration file CONFIGFILE.\n\
    -C, --config-only\n\
        only load configuration given by -c option.\n\
    -d, --dump\n\
        dump sent and received PDUs.\n\
    -D, --debug [LEVEL]\n\
        set debugging verbosity to LEVEL.\n\
    -D, --debug-tokens [TOKEN[,TOKEN]*]\n\
        debug specified TOKEN's.\n\
    -f, --dont-fork\n\
        run in the foreground.\n\
    -g, --gid, --groupid GID\n\
        become group GID after listening.\n\
    -h, --help, -?, --?\n\
        print usage information and exit.\n\
    -H, --help-directives\n\
        print config directives and exit.\n\
    -I, --initialize [-]MODULE[,MODULE]*\n\
        initialize (or not, '-') these MODULE's.\n\
    -k, --keep-open\n\
        keep system files open between requests.\n\
    -l, --log-file [LOGFILE]\n\
        log to log file name LOGFILE.  [default: /var/log/mtpmib.log]\n\
    -L, --log-stderr\n\
        log to controlling terminal standard error.\n\
    -m, --mibs [+]MIB[,MIB]*\n\
        load these (additional '+') MIBs.\n\
    -M, --master\n\
        run as SNMP master instead of AgentX sub-agent.\n\
    -M, --mibdirs [+]MIBDIR[:MIBDIR]*\n\
        search these (additional, '+') colon separated directories for MIBs.\n\
    -n, --nodaemon\n\
        run in the foreground.\n\
    -n, --name NAME\n\
        use NAME for configuration file base.  [default: mtpmib]\n\
    -p, --port PORTNUM\n\
        listen on port number PORTNUM.  [default: 161]\n\
    -p, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/mtpmib.pid]\n\
    -P, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/mtpmib.pid]\n\
    -q, --quiet\n\
        suppress normal output.\n\
    -q, --quick\n\
        abbreviate output for machine readability.\n\
    -r, --noroot\n\
        do not require root privilege.\n\
    -s, --log-syslog\n\
        log to system logs.\n\
    -S, --sysctl-file FILENAME\n\
        write sysctl config file FILENAME.  [default: /etc/streams.conf]\n\
    -t, --agent-alarms\n\
        agent blocks {SIGALARM}.\n\
    -T, --transport [TRANSPORT]\n\
        default transport TRANSPORT.  [default: udp]\n\
    -u, --uid, --userid UID\n\
        become user UID after listening.\n\
    -U, --dont-remove-pidfile\n\
        do not remove PIDFILE when shutting down.\n\
    -v, --version\n\
        print version information and exit.\n\
    -V, --verbose [LEVEL]\n\
        be verbose to LEVEL.  [default: 1]\n\
    -x, --agentx-socket [SOCKET]\n\
        master AgentX on SOCKET.  [default: /var/agentx/master]\n\
    -X, --agentx\n\
        run as AgentX sub-agent instead of master (the default).\n\
    -y, --copying\n\
        print copying information and exit.\n\
", argv[0]);
}

static void
sa_copying(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
--------------------------------------------------------------------------------\n\
%1$s\n\
--------------------------------------------------------------------------------\n\
Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com>\n\
Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>\n\
\n\
All Rights Reserved.\n\
--------------------------------------------------------------------------------\n\
This program is free software; you can  redistribute  it and/or modify  it under\n\
the terms of the GNU Affero General Public License as published by the Free\n\
Software Foundation; Version 3 of the License.\n\
\n\
This program is distributed in the hope that it will  be useful, but WITHOUT ANY\n\
WARRANTY; without even  the implied warranty of MERCHANTABILITY or FITNESS FOR A\n\
PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.\n\
\n\
You should have received a copy of the GNU  Affero  General Public License along\n\
with this program.   If not, see <http://www.gnu.org/licenses/>, or write to the\n\
Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
--------------------------------------------------------------------------------\n\
U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf\n\
of the U.S. Government (\"Government\"), the following provisions apply to you. If\n\
the Software is supplied by the  Department of Defense (\"DoD\"), it is classified\n\
as \"Commercial  Computer  Software\"  under  paragraph  252.227-7014  of the  DoD\n\
Supplement  to the  Federal Acquisition Regulations  (\"DFARS\") (or any successor\n\
regulations) and the  Government  is acquiring  only the  license rights granted\n\
herein (the license rights customarily provided to non-Government users). If the\n\
Software is supplied to any unit or agency of the Government  other than DoD, it\n\
is  classified as  \"Restricted Computer Software\" and the Government's rights in\n\
the Software  are defined  in  paragraph 52.227-19  of the  Federal  Acquisition\n\
Regulations (\"FAR\")  (or any successor regulations) or, in the cases of NASA, in\n\
paragraph  18.52.227-86 of  the  NASA  Supplement  to the FAR (or any  successor\n\
regulations).\n\
--------------------------------------------------------------------------------\n\
Commercial  licensing  and  support of this  software is  available from OpenSS7\n\
Corporation at a fee.  See http://www.openss7.com/\n\
--------------------------------------------------------------------------------\n\
", ident);
}

void
sa_help_directives(int argc, char *argv[])
{
	ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
	init_agent("mtpMIB");
	// init_mib_modules();
	init_mib();
	init_snmp("mtpMIB");
	snmp_log(MY_FACILITY(LOG_INFO), "Configuration directives understood:\n");
	/* Unfortunately, read_config_print_usage() uses snmp_log(), meaning that it can only be
	   writen to standard error and not standard output. */
	read_config_print_usage("    ");
}

static int
sa_sig_register(int signum, RETSIGTYPE(*handler) (int))
{
	sigset_t mask;
	struct sigaction act;

	act.sa_handler = handler ? handler : SIG_DFL;
	act.sa_flags = handler ? SA_RESTART : 0;
	sigemptyset(&act.sa_mask);
	if (sigaction(signum, &act, NULL))
		return (-1);
	sigemptyset(&mask);
	sigaddset(&mask, signum);
	sigprocmask(handler ? SIG_UNBLOCK : SIG_BLOCK, &mask, NULL);
	return (0);
}

static int sa_alm_signal = 0;
static int sa_pol_signal = 0;
static int sa_hup_signal = 0;
static int sa_int_signal = 0;
static int sa_trm_signal = 0;

static int sa_alm_handle = 0;

void
sa_alm_callback(unsigned int req, void *arg)
{
	if (req == sa_alm_handle)
		sa_alm_handle = 0;
	sa_alm_signal = 1;
	return;
}

static RETSIGTYPE
sa_alm_handler(int signum)
{
	sa_alm_signal = 1;
	return (RETSIGTYPE) (0);
}

static void
sa_snmp_alm_handler(unsigned int reg, void *clientarg)
{
	sa_alm_signal = 1;
	return;
}

static int
sa_alm_catch(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, &sa_alm_handler);
	return (-1);
}

static int
sa_alm_block(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, NULL);
	if (sa_alm_handle) {
		unsigned int handle = sa_alm_handle;

		sa_alm_handle = 0;
		snmp_alarm_unregister(handle);
	}
	return (0);
}

static int
sa_alm_action(void)
{
	sa_alm_signal = 0;
	return (0);
}

static RETSIGTYPE
sa_pol_handler(int signum)
{
	sa_pol_signal = 1;
	return (RETSIGTYPE) (0);
}

static int
sa_pol_catch(void)
{
	return sa_sig_register(SIGPOLL, &sa_pol_handler);
}

static int
sa_pol_block(void)
{
	return sa_sig_register(SIGPOLL, NULL);
}

/*
 * Both the sc(4) module and sad(4) driver issue an M_PCSIG message with
 * SIGPOLL to the stream head whenever the STREAMS configuration or autopush
 * configuration changes, indicating to the agent which has the sc(4) or
 * sad(4) Stream open that it is necessary to reread information from the
 * kernel.  This fact is merely recorded, as this information is not read each
 * time that a configuration change occurs, but only after a request from some
 * portion of that information occurs. This condition is also set when the
 * sc(4) and sad(4) Streams are first opened. The SIGPOLL will also deliver in
 * siginfo the file descriptor issuing the signal, so we could distiguish
 * between sc(4) and sad(4) signals, but since one can be pushed over the
 * other, there is little point in distinguishing.
 *
 * sc(4) or sad(4) also should be modified to provide the general streams
 * statistics supported here; even though they are available through the /proc
 * filesystem on Linux Fast-STREAMS.
 */
static int
sa_pol_action(void)
{
	sa_pol_signal = 0;
	snmp_log(MY_FACILITY(LOG_INFO), "%s: Caught SIGPOLL, will re-read data structures", sa_program);
	sa_changed = 1;
	return (0);
}

static RETSIGTYPE
sa_hup_handler(int signum)
{
	sa_hup_signal = 1;
	return (RETSIGTYPE) (0);
}

static int
sa_hup_catch(void)
{
	if (sa_agentx)
		return sa_sig_register(SIGHUP, &sa_hup_handler);
	return (-1);
}

static int
sa_hup_block(void)
{
	return sa_sig_register(SIGHUP, NULL);
}

static int
sa_hup_action(void)
{
	/* There are several times that we might be sent a SIGHUP.  We might be sent a SIGHUP by
	   logrotate asking us to close and reopen our log files. */
	sa_hup_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "Caught SIGHUP, reopening files.");
	if (sa_output > 1)
		snmp_log(MY_FACILITY(LOG_NOTICE), "Reopening output file %s", sa_logfile);
	if (sa_logfillog != 0) {
		fflush(stdlog);
		fclose(stdlog);
		snmp_disable_filelog();
		if ((stdlog = freopen(sa_logfile, sa_appendlog ? "a" : "w", stdlog)) == NULL) {
			/* I hope we have another log sink. */
			snmp_log(MY_FACILITY(LOG_ERR), "%s", strerror(errno));
			snmp_log(MY_FACILITY(LOG_ERR), "Could not reopen log file %s", sa_logfile);
		}
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	return (0);
}

static RETSIGTYPE
sa_int_handler(int signum)
{
	sa_int_signal = 1;
	return (RETSIGTYPE) (0);
}

static int
sa_int_catch(void)
{
	return sa_sig_register(SIGINT, &sa_int_handler);
}

static int
sa_int_block(void)
{
	return sa_sig_register(SIGINT, NULL);
}

static void sa_exit(int retval);

static int
sa_int_action(void)
{
	sa_int_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGINT, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}

static RETSIGTYPE
sa_trm_handler(int signum)
{
	sa_trm_signal = 1;
	return (RETSIGTYPE) (0);
}

static int
sa_trm_catch(void)
{
	return sa_sig_register(SIGTERM, &sa_trm_handler);
}

static int
sa_trm_block(void)
{
	return sa_sig_register(SIGTERM, NULL);
}

static void sa_exit(int retval);

static int
sa_trm_action(void)
{
	sa_trm_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGTERM, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}

static void
sa_sig_catch(void)
{
	sa_alm_catch();
	sa_pol_catch();
	sa_hup_catch();
	sa_int_catch();
	sa_trm_catch();
}

static void
sa_sig_block(void)
{
	sa_alm_block();
	sa_pol_block();
	sa_hup_block();
	sa_int_block();
	sa_trm_block();
}

int
sa_start_timer(long duration)
{
	if (sa_alarms) {
		struct itimerval setting = {
			{0, 0},
			{duration / 1000, (duration % 1000) * 1000}
		};

		if (sa_alm_catch())
			return (-1);
		if (setitimer(ITIMER_REAL, &setting, NULL))
			return (-1);
		sa_alm_signal = 0;
		return (0);
	} else {
#if defined NETSNMP_DS_APPLICATION_ID
		struct timeval setting = {
			duration / 1000, (duration % 1000) * 1000
		};

		sa_alm_handle = snmp_alarm_register_hr(setting, 0, sa_snmp_alm_handler, NULL);
#else
		sa_alm_handle = snmp_alarm_register((duration + 999) / 1000, 0, sa_snmp_alm_handler, NULL);
#endif
		return (sa_alm_handle ? 0 : -1);
	}
}

static void
sa_exit(int retval)
{
	if (retval)
		snmp_log(MY_FACILITY(LOG_ERR), "%s: Exiting %d", sa_program, retval);
	else
		snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Exiting %d", sa_program, retval);
	fflush(stdout);
	fflush(stderr);
	sa_sig_block();
	closelog();
	exit(retval);
}

static void
sa_init_logging(int argc, char *argv[])
{
	static char progname[256];

	/* The purpose of this function is to bring logging up before forking (and while still in
	   the foreground) so that we can use the snmp_log() function before and during forking if
	   necessary.  Note that the default configuration for snmp_log() is to send all logs to
	   standard error. */
	strncpy(progname, basename(argv[0]), sizeof(progname));

	snmp_disable_log();
	if (sa_logfillog) {
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	if (sa_logstderr | sa_logstdout) {
#if defined LOG_PERROR
		/* Note that when we have Linux LOG_PERROR, and logs go both to syslog and stderr,
		   it is better to use the LOG_PERROR than to use snmp_log()'s print to stderr, as
		   the former is better formated. */
		if (!sa_logsyslog)
			snmp_enable_stderrlog();
#else				/* defined LOG_PERROR */
		snmp_enable_stderrlog();
#endif				/* defined LOG_PERROR */
	}
	if (sa_logsyslog) {
#if !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT
		snmp_enable_syslog();
#else				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		snmp_enable_syslog_ident("mtpMIB", LOG_DAEMON);
#endif				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		/* Note that the way that snmp sets up the logger is not really the way we want it,
		   so close the log and reopen it the way we want. */
		closelog();
#if defined LOG_PERROR
		openlog("mtpMIB", LOG_PID | LOG_CONS | LOG_NDELAY | (sa_logstderr ? LOG_PERROR : 0), MY_FACILITY(0));
#else				/* defined LOG_PERROR */
		openlog("mtpMIB", LOG_PID | LOG_CONS | LOG_NDELAY, MY_FACILITY(0));
#endif				/* defined LOG_PERROR */
	}
	if (sa_logcallog) {
		snmp_enable_calllog();
	}
}

static void
sa_enter(int argc, char *argv[])
{
	if (sa_nomead) {
		pid_t pid;

		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent exits */
			exit(0);
		}
		setsid();	/* become a session leader */
		/* fork once more for SVR4 */
		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent responsible for writing pid file */
			if (sa_nomead || sa_pidfile[0] != '\0') {
				FILE *pidf;

				/* initialize default filename */
				if (sa_pidfile[0] == '\0')
					snprintf(sa_pidfile, sizeof(sa_pidfile), "/var/run/%s.pid", sa_program);
				if (sa_output > 1) {
					snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Writing daemon pid to file %s", sa_program, sa_pidfile);
				}
				if ((pidf = fopen(sa_pidfile, "w+"))) {
					fprintf(pidf, "%d", (int) pid);
					fflush(pidf);
					fclose(pidf);
				} else {
					snmp_log(MY_FACILITY(LOG_ERR), "%s: %m", sa_program);
					snmp_log(MY_FACILITY(LOG_ERR), "%s: Could not write pid to file %s", sa_program, sa_pidfile);
					sa_exit(2);
					/* no return */
				}
			}
			/* parent exits */
			exit(0);
		}
		/* child continues */
		/* release current directory */
		if (chdir("/") < 0) {
			perror(argv[0]);
			exit(2);
		}
		umask(0);	/* clear file creation mask */
		/* rearrange file streams */
		fclose(stdin);
	}
	/* continue as foreground or background */
	sa_init_logging(argc, argv);
	sa_sig_catch();
	snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Startup complete.", sa_program);
}

static void
sa_mloop(int argc, char *argv[])
{
	if (sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as AgentX client\n", argv[0]);
		/* run as an AgentX client */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
	} else {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master agent\n", argv[0]);
		/* run as SNMP master */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
	}

	if (sa_alarms) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using application alarms\n", argv[0]);
		/* use application alarms */
		ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
	}

	/* initialize agent */
	init_agent("mtpMIB");

	/* initialize MIB */
	init_mtpMIB();

	/* initialize SNMP */
	init_snmp("mtpMIB");

	if (!sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master\n", argv[0]);
#if !defined NETSNMP_DS_APPLICATION_ID
		init_master_agent(710, NULL, NULL);
#else
		init_master_agent();
#endif
	}

	for (;;) {
		int retval;

		/* to use select or poll you need to use the snmp_select_info() to obtain the fd of 
		   the agentx socket and add it to the fdset. */
		/* note that SIGALRM is used by snmp: use the snmp_alarm() api instead */

#if 0
		if (snmp_select() == 0) {
			if (sa_alarms == 0)
				run_alarms();
		}
#endif
		retval = agent_check_and_process(1);	/* 0 == don't block */

		if (retval == 0) {
			/* alarm occurred, alarm conditions checked */
		} else if (retval == -1) {
			/* error (or signal) ocurred */
			if (sa_alm_signal) {
				sa_alm_action();
			}
			if (sa_pol_signal) {
				sa_pol_action();
			}
			if (sa_hup_signal) {
				sa_hup_action();
			}
			if (sa_int_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("mtpMIB");
				sa_int_action();	/* no return */
			}
			if (sa_trm_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("mtpMIB");
				sa_trm_action();	/* no return */
			}
		} else if (retval > 0) {
			/* processed packets */
			if (sa_fclose) {
				/* close files after each request */
				if (sa_fd != 0) {
					int fd = sa_fd;

					sa_fd = 0;
					close(fd);
				}
			}
			sa_stats_refresh = 1;
			sa_request++;
		}
	}

	if (sa_debug)
		snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
	snmp_shutdown("mtpMIB");
}

int
main(int argc, char *argv[])
{
	for (;;) {
		int c, val, fd;
		char *cptr;
		struct passwd *pw;
		struct group *gr;
		struct stat st;

#if defined _GNU_SOURCE
		int option_index = 0;
                /* *INDENT-OFF* */
                static struct option long_options[] = {
                        {"log-addresses",	no_argument,		NULL, 'a'},
                        {"append",		no_argument,		NULL, 'A'},
                        {"config-file",		required_argument,	NULL, 'c'},
                        {"no-configs",		no_argument,		NULL, 'C'},
                        {"dump",		no_argument,		NULL, 'd'},
                        {"debug",		optional_argument,	NULL, 'D'},
                        {"debug-tokens",	optional_argument,	NULL, 'D'},
                        {"dont-fork",		no_argument,		NULL, 'f'},
                        {"gid",			required_argument,	NULL, 'g'},
                        {"groupid",		required_argument,	NULL, 'g'},
                        {"help",		no_argument,		NULL, 'h'},
                        {"?",			no_argument,		NULL, 'h'},
                        {"help-directives",	no_argument,		NULL, 'H'},
                        {"initialize",		required_argument,	NULL, 'I'},
                        {"init-modules",	required_argument,	NULL, 'I'},
                        {"keep-open",		no_argument,		NULL, 'k'},
                        {"log-file",		optional_argument,	NULL, 'l'},
                        {"logfile",		optional_argument,	NULL, 'l'},
                        {"Lf",			optional_argument,	NULL, 'l'},
                        {"LF",			required_argument,	NULL, 'l'},
                        {"log-stderr",		no_argument,		NULL, 'L'},
                        {"Le",			no_argument,		NULL, 'L'},
                        {"LE",			required_argument,	NULL, 'L'},
                        {"mibs",		required_argument,	NULL, 'm'},
                        {"master",		no_argument,		NULL, 'M'},
                        {"mibdirs",		required_argument,	NULL, 'M'},
                        {"nodaemon",		no_argument,		NULL, 'n'},
                        {"name",		required_argument,	NULL, 'n'},
                        {"dry-run",		no_argument,		NULL, 'N'},
                        {"log-stdout",		no_argument,		NULL, 'o'},
                        {"Lo",			no_argument,		NULL, 'o'},
                        {"LO",			required_argument,	NULL, 'o'},
                        {"port",		required_argument,	NULL, 'p'},
                        {"pidfile",		required_argument,	NULL, 'P'},
                        {"quiet",		no_argument,		NULL, 'q'},
                        {"quick",		no_argument,		NULL, 'q'},
                        {"noroot",		no_argument,		NULL, 'r'},
                        {"log-syslog",		no_argument,		NULL, 's'},
                        {"Ls",			no_argument,		NULL, 's'},
                        {"LS",			required_argument,	NULL, 's'},
                        {"syslog",		no_argument,		NULL, 's'},
                        {"sysctl-file",		required_argument,	NULL, 'S'},
                        {"agent-alarms",	no_argument,		NULL, 't'},
                        {"transport",		optional_argument,	NULL, 'T'},
                        {"uid",			required_argument,	NULL, 'u'},
                        {"userid",		required_argument,	NULL, 'u'},
                        {"dont-remove-pidfile",	no_argument,		NULL, 'U'},
                        {"leave-pidfile",	no_argument,		NULL, 'U'},
                        {"version",		no_argument,		NULL, 'v'},
                        {"verbose",		optional_argument,	NULL, 'V'},
                        {"agentx-socket",	required_argument,	NULL, 'x'},
                        {"agentx",		no_argument,		NULL, 'X'},
                        {"copying",		no_argument,		NULL, 'y'},
#if 0
                        {"directory",		required_argument,	NULL, 'd'},
                        {"basename",		required_argument,	NULL, 'b'},
                        {"outfile",		required_argument,	NULL, 'o'},
                        {"errfile",		required_argument,	NULL, 'e'},
#endif
                        { 0, }
                };
                /* *INDENT-ON* */

		c = getopt_long_only(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy", long_options, &option_index);
#else				/* defined _GNU_SOURCE */
		c = getopt(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy");
#endif				/* defined _GNU_SOURCE */
		if (c == -1) {
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: done options processing\n", argv[0]);
			break;
		}
		switch (c) {
		case 0:
			goto bad_usage;
		case 'a':	/* -a, --log-addresses */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging addresses\n", argv[0]);
			sa_logaddr++;
			break;
		case 'A':	/* -A, --append */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will not truncate logfile\n", argv[0]);
#if defined NETSNMP_DS_LIB_APPEND_LOGFILES
			ds_set_boolean(DS_LIBRARY_ID, NETSNMP_DS_LIB_APPEND_LOGFILES, 1);
#endif				/* defined NETSNMP_DS_LIB_APPEND_LOGFILES */
			sa_appendlog = 1;
			break;
		case 'c':	/* -c, --config-file CONFIGFILE */
			if (optarg == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using configuration file %s\n", argv[0], optarg);
			ds_set_string(DS_LIBRARY_ID, DS_LIB_OPTIONALCONFIG, optarg);
			break;
		case 'C':	/* -C, --no-configs */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: not reading default config files\n", argv[0]);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DONT_READ_CONFIGS, 1);
			break;
		case 'd':	/* -d, --dump */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting packet dump\n", argv[0]);
			sa_dump = 1;
			// snmp_set_dump_packet(sa_dump);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DUMP_PACKET, sa_dump);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, sa_dump);
			break;
		case 'D':	/* -D, --debug [LEVEL], --debug-tokens [TOKENS] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing debug verbosity\n", argv[0]);
			if (optarg == NULL) {
				/* no option: must be -D, --debug */
				sa_debug++;
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging all tokens\n", argv[0]);
				if (sa_debug)
					debug_register_tokens("ALL");
			} else {
				cptr = optarg;
				if ((val = strtol(optarg, &cptr, 0)) < 0)
					goto bad_option;
				if (*cptr == '\0') {
					/* it is just a number, must be -D, --debug [LEVEL] */
					sa_debug = val;
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				} else {
					/* not a number, must be -D, --debug-tokens TOKENS */
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging tokens %s\n", argv[0], optarg);
					debug_register_tokens(optarg);
				}
			}
			break;
		case 'f':	/* -f, --dont-fork */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing daemon mode\n", argv[0]);
			sa_nomead = 0;
			break;
		case 'u':	/* -u, --uid, --userid UID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* UID can be name or number */
			if ((pw = (*cptr == '\0') ? getpwuid((uid_t) val) : getpwnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as uid %s(%d)\n", argv[0], pw->pw_name, pw->pw_uid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_USERID, pw->pw_uid);
			break;
		case 'g':	/* -g, --gid, --groupdid GID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* GID can be name or number */
			if ((gr = (*cptr == '\0') ? getgrgid((gid_t) val) : getgrnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as gid %s(%d)\n", argv[0], gr->gr_name, gr->gr_gid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_GROUPID, gr->gr_gid);
			break;
		case 'h':	/* -h, --help, -?, --? */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing help message\n", argv[0]);
			sa_help(argc, argv);
			exit(0);
		case 'H':	/* -H, --help-directives */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing config directives\n", argv[0]);
			sa_help_directives(argc, argv);
			exit(0);
		case 'I':	/* -I, --init-modules, --initialize MODULE[{,| |:}MODULE]* */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will initialize modules: %s\n", argv[0], optarg);
			add_to_init_list(optarg);
			break;
		case 'k':	/* -k, --keep-open */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: keeping files open\n", argv[0]);
			sa_fclose = 0;
			break;
		case 'l':	/* -l, --log-file, --logfile, -Lf, -LF p1[-p2] [LOGFILE] */
			if (optarg != NULL)
				strncpy(sa_logfile, optarg, sizeof(sa_logfile));
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will log to file %s\n", argv[0], sa_logfile);
			sa_logfillog = 1;
			break;
		case 'L':	/* -L, --log-stderr, -Le, -LE p1[-p2] */
			/* Note that the recent NET-SNMP version of this option is far more
			   complicated: -Le is the same as the old version of the option; -Lf
			   LOGFILE is like the -l option; -Ls is like the -s option; -Lo logs
			   messages to standard output; -LX p1[-p2] [LOGFILE], where X = E, F, S or 
			   O, logs priority p1 and above to X, or p1 thru p2 to X. */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to standard error\n", argv[0]);
			sa_logstderr = 1;
			break;
		case 'm':	/* -m, --mibs MIBS */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBS %s\n", argv[0], optarg);
			break;
		case 'M':	/* -M, --master or -M, --mibdirs MIBDIRS */
			if (optarg) {
				/* -M, --mibdirs MIBDIRS */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBDIRS %s\n", argv[0], optarg);
			} else {
				/* -M, --master */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting SNMP master\n", argv[0]);
				sa_agentx = 0;
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
			}
			break;
		case 'n':	/* -n, --nodaemon or -n, --name NAME */
			if (optarg) {
				/* -n, --name NAME */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using name %s\n", argv[0], optarg);
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, optarg);
			} else {
				/* -n, --nodaemon */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing deamon mode\n", argv[0]);
				sa_nomead = 0;
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, basename(argv[0]));
			}
			break;
		case 'N':	/* -N, --dry-run */
#if defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for dry-runs startup\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_QUIT_IMMEDIATELY, 1);
			break;
#else				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -N option not supported\n", argv[0]);
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
		case 'o':	/* -o, --log-stdout, -Lo, -LO p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to stdout\n", argv[0]);
			sa_logstdout = 1;
			break;
		case 'p':	/* -p, --port PORTNUM or -p, --pidfile PIDFILE */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0 || val > 16383)
				goto bad_option;
			if (*cptr == '\0') {
				char buf[4096];

				/* -p, --port PORTNUM */
				if ((cptr = ds_get_string(DS_APPLICATION_ID, DS_AGENT_PORTS)))
					snprintf(buf, sizeof(buf), "%s,%s", cptr, optarg);
				else
					strncpy(buf, optarg, sizeof(buf));
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PORTS, buf);
				break;
			}
			/* fall through */
		case 'P':	/* -p, -P, --pidfile PIDFILE */
			if (optarg) {
				/* either it exists */
				if (stat(optarg, &st) == -1) {
					/* or we can create it */
					if ((fd = open(optarg, O_CREAT, 0600)) == -1) {
						perror(argv[0]);
						goto bad_option;
					}
					close(fd);
				}
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting pid file to %s\n", argv[0], optarg);
				strncpy(sa_pidfile, optarg, sizeof(sa_pidfile));
			}
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using pidfile %s\n", argv[0], sa_pidfile);
			break;
		case 'q':	/* -q, --quiet, --quick */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing normal output\n", argv[0]);
			sa_debug = 0;
			sa_output = 0;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			// snmp_set_quick_print();
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_QUICK_PRINT, 1);
			break;
		case 'r':	/* -r, --noroot */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for non-root access\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
			break;
		case 's':	/* -s, --log-syslog, -Ls, -LS p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to system logs\n", argv[0]);
			sa_logsyslog = 1;
			break;
		case 'S':	/* -S, -sysctl-file FILENAME */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using %s for backing\n", argv[0], optarg);
			strncpy(sa_sysctlf, optarg, sizeof(sa_sysctlf));
			break;
		case 't':	/* -t, --agent-alarms */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting agent alarms\n", argv[0]);
			sa_alarms = 0;
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
			break;
		case 'T':	/* -T, --transport [TRANSPORT] */
			if (optarg == NULL)
				goto udp_transport;
			if (!strcasecmp("TCP", optarg)) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to TCP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val |= SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else if (!strcasecmp("UDP", optarg)) {
			      udp_transport:
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to UDP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val &= ~SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else
				goto bad_option;
			break;
		case 'U':
#if defined NETSNMP_DS_AGENT_LEAVE_PIDFILE
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will leave pidfile after shutdown\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_LEAVE_PIDFILE, 1);
#else
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -U option not supported\n");
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_LEAVE_PIDFILE */
			break;
		case 'v':	/* -v, --version */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing version message\n", argv[0]);
			sa_version(argc, argv);
			exit(0);
		case 'V':	/* -V, --verbose [LEVEL] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing output verbosity\n", argv[0]);
			if (optarg == NULL) {
				sa_output++;
			} else {
				if ((val = strtol(optarg, NULL, 0)) < 0)
					goto bad_option;
				sa_output = val;
			}
			if (sa_output > 1)
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 1);
			else
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			break;
		case 'x':	/* -x, --agentx-socket SOCKET */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX socket to %s\n", argv[0], optarg);
			ds_set_string(DS_APPLICATION_ID, DS_AGENT_X_SOCKET, optarg);
			// ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_AGENTX_MASTER, 1);
			break;
		case 'X':	/* -X, --agentx */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX sub-agent\n", argv[0]);
			sa_agentx = 1;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
			break;
		case 'y':	/* -y, --copying */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing copying message\n", argv[0]);
			sa_copying(argc, argv);
			exit(0);
		case '?':
		case ':':
		default:
		      bad_option:
			optind--;
			goto bad_nonopt;
		      bad_nonopt:
			if (sa_output || sa_debug) {
				if (optind < argc) {
					fprintf(stderr, "%s: syntax error near '", argv[0]);
					while (optind < argc)
						fprintf(stderr, "%s ", argv[optind++]);
					fprintf(stderr, "'\n");
				} else {
					fprintf(stderr, "%s: missing option or argument", argv[0]);
					fprintf(stderr, "\n");
				}
				fflush(stderr);
			      bad_usage:
				sa_usage(argc, argv);
			}
			exit(2);
		}
	}
	if (optind < argc) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: excess non-option arguments\n", argv[0]);
		goto bad_nonopt;
	}
	sa_enter(argc, argv);	/* daemonize if necessary */
	sa_mloop(argc, argv);	/* execute main loop */
	exit(0);
}
#endif				/* !defined MODULE */

