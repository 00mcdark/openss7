/*****************************************************************************

 @(#) $RCSfile: mtpMIB.c,v $ $Name:  $($Revision: 0.9.2.4 $) $Date: 2008-12-31 16:04:43 $

 -----------------------------------------------------------------------------

 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2008-12-31 16:04:43 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: mtpMIB.c,v $
 Revision 0.9.2.4  2008-12-31 16:04:43  brian
 - updated mibs

 *****************************************************************************/

#ident "@(#) $RCSfile: mtpMIB.c,v $ $Name:  $($Revision: 0.9.2.4 $) $Date: 2008-12-31 16:04:43 $"

static char const ident[] = "$RCSfile: mtpMIB.c,v $ $Name:  $($Revision: 0.9.2.4 $) $Date: 2008-12-31 16:04:43 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "ss7MIB.h"
#include "x400pMIB.h"
#include "mtpMIB.h"
#include "mtpOmMIB.h"
#include "sccpMIB.h"
#include "sccpOmMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int mtpMIB_refresh = 1;
volatile int mtpSapTable_refresh = 1;
volatile int mtpMsTable_refresh = 1;
volatile int mtpNaTable_refresh = 1;
volatile int mtpGsTable_refresh = 1;
volatile int mtpGsLineTable_refresh = 1;
volatile int mtpGsLineContentTable_refresh = 1;
volatile int mtpSpProfileTable_refresh = 1;
volatile int mtpSpTable_refresh = 1;
volatile int mtpL3Table_refresh = 1;
volatile int mtpRsProfileTable_refresh = 1;
volatile int mtpRsTable_refresh = 1;
volatile int mtpRtProfileTable_refresh = 1;
volatile int mtpRtTable_refresh = 1;
volatile int mtpRtLsaTable_refresh = 1;
volatile int mtpLsProfileTable_refresh = 1;
volatile int mtpLsTable_refresh = 1;
volatile int mtpSlL3ProfileTable_refresh = 1;
volatile int mtpSlL2ProfileTable_refresh = 1;
volatile int mtpSlTable_refresh = 1;
volatile int mtpSlSdlListTable_refresh = 1;
volatile int mtpSlSdtListTable_refresh = 1;
volatile int mtpNbTable_refresh = 1;
volatile int mtpSaalTable_refresh = 1;
volatile int mtpM2paTable_refresh = 1;
volatile int mtpSdtTable_refresh = 1;
volatile int mtpSdlTable_refresh = 1;

/*
 * mtpMIB_variables_oid: object identifier for mtpMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid mtpMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3 };
oid mtpSapTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 1, 1, 1 };
oid mtpMsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 2, 1, 1 };
oid mtpNaTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 3, 1, 1 };
oid mtpGsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 4, 1, 1 };
oid mtpGsLineTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 4, 2, 1 };
oid mtpGsLineContentTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 4, 3, 1 };
oid mtpSpProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 5, 1, 1 };
oid mtpSpTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 5, 2, 1 };
oid mtpL3Table_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 6, 1, 1 };
oid mtpRsProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 7, 1, 1 };
oid mtpRsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 7, 2, 1 };
oid mtpRtProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 8, 1, 1 };
oid mtpRtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 8, 2, 1 };
oid mtpLsProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 9, 1, 1 };
oid mtpLsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 9, 2, 1 };
oid mtpSlL3ProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 1, 1 };
oid mtpSlL2ProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 2, 1 };
oid mtpSlTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 3, 1 };
oid mtpSlSdlListTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 4, 1 };
oid mtpSlSdtListTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 5, 1 };
oid mtpNbTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 1, 1 };
oid mtpSaalTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 2, 1 };
oid mtpM2paTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 3, 1 };
oid mtpSdtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 4, 1 };
oid mtpSdlTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 12, 1, 1 };

/*
 * variable7 mtpMIB_variables: tree for mtpMIB
 * This variable defines function callbacks and type return information for the mtpMIB mib section
 */
struct variable7 mtpMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   MTPSAP2ADDRESS        (4 % 256)
	{MTPSAP2ADDRESS, ASN_UNSIGNED, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 2}},
#define   MTPSAPUSERPART        (5 % 256)
	{MTPSAPUSERPART, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 3}},
#define   MTPSAPUSERPARTSTATUS  (6 % 256)
	{MTPSAPUSERPARTSTATUS, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 4}},
#define   MTPSAPUSERENTITYNAMES  (7 % 256)
	{MTPSAPUSERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 5}},
#define   MTPSAPPROVIDERENTITYNAMES  (8 % 256)
	{MTPSAPPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 6}},
#define   MTPSAPUSAGESTATE      (9 % 256)
	{MTPSAPUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 7}},
#define   MTPSAPASAPROFILEPOINTER  (10 % 256)
	{MTPSAPASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 8}},
#define   MTPSAPNAME            (11 % 256)
	{MTPSAPNAME, ASN_OCTET_STR, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 9}},
#define   MTPSAPLONGMESSAGESUPPORTED  (12 % 256)
	{MTPSAPLONGMESSAGESUPPORTED, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 10}},
#define   MTPSAPROWSTATUS       (13 % 256)
	{MTPSAPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 11}},
#define   MTPMSNAME             (17 % 256)
	{MTPMSNAME, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 2}},
#define   MTPMSALARMSTATUS      (18 % 256)
	{MTPMSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 3}},
#define   MTPMSOPERATIONALSTATE  (19 % 256)
	{MTPMSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 4}},
#define   MTPMSUSAGESTATE       (20 % 256)
	{MTPMSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 5}},
#define   MTPMSMANAGEDELEMENTTYPE  (21 % 256)
	{MTPMSMANAGEDELEMENTTYPE, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 6}},
#define   MTPMSMODELCODE        (22 % 256)
	{MTPMSMODELCODE, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 7}},
#define   MTPMSVENDORNAME       (23 % 256)
	{MTPMSVENDORNAME, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 8}},
#define   MTPMSUSERLABEL        (24 % 256)
	{MTPMSUSERLABEL, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 9}},
#define   MTPMSVERSION          (25 % 256)
	{MTPMSVERSION, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 10}},
#define   MTPMSASAPROFILEPOINTER  (26 % 256)
	{MTPMSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 11}},
#define   MTPMSNETWORKELEMENTALIASES  (27 % 256)
	{MTPMSNETWORKELEMENTALIASES, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 12}},
#define   MTPMSSTATUS           (28 % 256)
	{MTPMSSTATUS, ASN_INTEGER, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 13}},
#define   MTPNAPROTOCOLVARIANT  (32 % 256)
	{MTPNAPROTOCOLVARIANT, ASN_OBJECT_ID, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 2}},
#define   MTPNAPROTOCOLYEAR     (33 % 256)
	{MTPNAPROTOCOLYEAR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 3}},
#define   MTPNAPROTOCOLOPTIONS  (34 % 256)
	{MTPNAPROTOCOLOPTIONS, ASN_BIT_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 4}},
#define   MTPNANETWORKINDICATOR  (35 % 256)
	{MTPNANETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 5}},
#define   MTPNAPOINTCODEFORMAT  (36 % 256)
	{MTPNAPOINTCODEFORMAT, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 6}},
#define   MTPNASLSLENGTH        (37 % 256)
	{MTPNASLSLENGTH, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 7}},
#define   MTPNASPDEFAULT        (38 % 256)
	{MTPNASPDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 8}},
#define   MTPNANAME             (39 % 256)
	{MTPNANAME, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 9}},
#define   MTPNAROWSTATUS        (40 % 256)
	{MTPNAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 10}},
#define   MTPGSADMINISTRATIVESTATE  (45 % 256)
	{MTPGSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 2}},
#define   MTPGSTREATMENTOFOUTSIDERANGES  (46 % 256)
	{MTPGSTREATMENTOFOUTSIDERANGES, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 3}},
#define   MTPGSLISTMODE         (47 % 256)
	{MTPGSLISTMODE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 4}},
#define   MTPGSSCREENINGBYLINKSETORBYOPC  (48 % 256)
	{MTPGSSCREENINGBYLINKSETORBYOPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 5}},
#define   MTPGSGETSCREENEDOPCSORLINKSETSBYDPC  (49 % 256)
	{MTPGSGETSCREENEDOPCSORLINKSETSBYDPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 6}},
#define   MTPGSNAME             (50 % 256)
	{MTPGSNAME, ASN_OCTET_STR, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 7}},
#define   MTPGSROWSTATUS        (51 % 256)
	{MTPGSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 8}},
#define   MTPGSLINEOBJECT       (57 % 256)
	{MTPGSLINEOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpGsLineTable, 6, {1, 1, 4, 2, 1, 2}},
#define   MTPGSLINECONTENT      (58 % 256)
	{MTPGSLINECONTENT, ASN_UNSIGNED, RWRITE, var_mtpGsLineTable, 6, {1, 1, 4, 2, 1, 3}},
#define   MTPGSLINEROWSTATUS    (59 % 256)
	{MTPGSLINEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineTable, 6, {1, 1, 4, 2, 1, 4}},
#define   MTPGSLINECONTENTDESIGNATEDDPCFIRST  (66 % 256)
	{MTPGSLINECONTENTDESIGNATEDDPCFIRST, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 2}},
#define   MTPGSLINECONTENTDESIGNATEDDPCLAST  (67 % 256)
	{MTPGSLINECONTENTDESIGNATEDDPCLAST, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 3}},
#define   MTPGSLINECONTENTSIMASK  (68 % 256)
	{MTPGSLINECONTENTSIMASK, ASN_BIT_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 4}},
#define   MTPGSLINECONTENTMESSAGETREATMENT  (69 % 256)
	{MTPGSLINECONTENTMESSAGETREATMENT, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 5}},
#define   MTPGSLINECONTENTCOMMENT  (70 % 256)
	{MTPGSLINECONTENTCOMMENT, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 6}},
#define   MTPGSLINECONTENTROWSTATUS  (71 % 256)
	{MTPGSLINECONTENTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 7}},
#define   MTPSPPROFILETIMERT1R  (75 % 256)
	{MTPSPPROFILETIMERT1R, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 2}},
#define   MTPSPPROFILETIMERT2   (76 % 256)
	{MTPSPPROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 3}},
#define   MTPSPPROFILETIMERT4   (77 % 256)
	{MTPSPPROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 4}},
#define   MTPSPPROFILETIMERT5   (78 % 256)
	{MTPSPPROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 5}},
#define   MTPSPPROFILETIMERT7   (79 % 256)
	{MTPSPPROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 6}},
#define   MTPSPPROFILETIMERT11  (80 % 256)
	{MTPSPPROFILETIMERT11, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 7}},
#define   MTPSPPROFILETIMERT12  (81 % 256)
	{MTPSPPROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 8}},
#define   MTPSPPROFILETIMERT13  (82 % 256)
	{MTPSPPROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 9}},
#define   MTPSPPROFILETIMERT14  (83 % 256)
	{MTPSPPROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 10}},
#define   MTPSPPROFILETIMERT15  (84 % 256)
	{MTPSPPROFILETIMERT15, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 11}},
#define   MTPSPPROFILETIMERT16  (85 % 256)
	{MTPSPPROFILETIMERT16, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 12}},
#define   MTPSPPROFILETIMERT18I  (86 % 256)
	{MTPSPPROFILETIMERT18I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 13}},
#define   MTPSPPROFILETIMERT19I  (87 % 256)
	{MTPSPPROFILETIMERT19I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 14}},
#define   MTPSPPROFILETIMERT20I  (88 % 256)
	{MTPSPPROFILETIMERT20I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 15}},
#define   MTPSPPROFILETIMERT21I  (89 % 256)
	{MTPSPPROFILETIMERT21I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 16}},
#define   MTPSPPROFILETIMERT22I  (90 % 256)
	{MTPSPPROFILETIMERT22I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 17}},
#define   MTPSPPROFILETIMERT23I  (91 % 256)
	{MTPSPPROFILETIMERT23I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 18}},
#define   MTPSPPROFILETIMERT20A  (92 % 256)
	{MTPSPPROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 19}},
#define   MTPSPPROFILETIMERT21A  (93 % 256)
	{MTPSPPROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 20}},
#define   MTPSPPROFILETIMERT22A  (94 % 256)
	{MTPSPPROFILETIMERT22A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 21}},
#define   MTPSPPROFILETIMERT23A  (95 % 256)
	{MTPSPPROFILETIMERT23A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 22}},
#define   MTPSPPROFILETIMERT24A  (96 % 256)
	{MTPSPPROFILETIMERT24A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 23}},
#define   MTPSPPROFILETIMERT26A  (97 % 256)
	{MTPSPPROFILETIMERT26A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 24}},
#define   MTPSPPROFILETIMERT27A  (98 % 256)
	{MTPSPPROFILETIMERT27A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 25}},
#define   MTPSPPROFILETIMERT1T  (99 % 256)
	{MTPSPPROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 26}},
#define   MTPSPPROFILETIMERT2T  (100 % 256)
	{MTPSPPROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 27}},
#define   MTPSPPROFILENAME      (101 % 256)
	{MTPSPPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 28}},
#define   MTPSPPROFILEROWSTATUS  (104 % 256)
	{MTPSPPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 31}},
#define   MTPSPPOINTCODE        (109 % 256)
	{MTPSPPOINTCODE, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 2}},
#define   MTPSPTYPE             (110 % 256)
	{MTPSPTYPE, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 3}},
#define   MTPSPOPERATIONALSTATE  (111 % 256)
	{MTPSPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 4}},
#define   MTPSPPROCEDURALSTATUS  (112 % 256)
	{MTPSPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 5}},
#define   MTPSPAVAILABILITYSTATUS  (113 % 256)
	{MTPSPAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 6}},
#define   MTPSPVERSION          (114 % 256)
	{MTPSPVERSION, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 7}},
#define   MTPSPNETWORKINDICATOR  (115 % 256)
	{MTPSPNETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 8}},
#define   MTPSPNAME             (116 % 256)
	{MTPSPNAME, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 9}},
#define   MTPSPMTPT1            (117 % 256)
	{MTPSPMTPT1, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 10}},
#define   MTPSPMTPT2            (118 % 256)
	{MTPSPMTPT2, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 11}},
#define   MTPSPMTPT3            (119 % 256)
	{MTPSPMTPT3, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 12}},
#define   MTPSPMTPT4            (120 % 256)
	{MTPSPMTPT4, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 13}},
#define   MTPSPMTPT5            (121 % 256)
	{MTPSPMTPT5, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 14}},
#define   MTPSPMTPT6            (122 % 256)
	{MTPSPMTPT6, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 15}},
#define   MTPSPMTPT7            (123 % 256)
	{MTPSPMTPT7, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 16}},
#define   MTPSPMTPT8            (124 % 256)
	{MTPSPMTPT8, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 17}},
#define   MTPSPMTPT10           (125 % 256)
	{MTPSPMTPT10, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 18}},
#define   MTPSPMTPT11           (126 % 256)
	{MTPSPMTPT11, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 19}},
#define   MTPSPMTPT12           (127 % 256)
	{MTPSPMTPT12, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 20}},
#define   MTPSPMTPT13           (128 % 256)
	{MTPSPMTPT13, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 21}},
#define   MTPSPMTPT14           (129 % 256)
	{MTPSPMTPT14, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 22}},
#define   MTPSPMTPT15           (130 % 256)
	{MTPSPMTPT15, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 23}},
#define   MTPSPMTPT16           (131 % 256)
	{MTPSPMTPT16, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 24}},
#define   MTPSPMTPT17           (132 % 256)
	{MTPSPMTPT17, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 25}},
#define   MTPSPMTPT19A          (133 % 256)
	{MTPSPMTPT19A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 26}},
#define   MTPSPMTPT31A          (134 % 256)
	{MTPSPMTPT31A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 27}},
#define   MTPSPMTPT32A          (135 % 256)
	{MTPSPMTPT32A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 28}},
#define   MTPSPMTPT33A          (136 % 256)
	{MTPSPMTPT33A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 29}},
#define   MTPSPMTPT34A          (137 % 256)
	{MTPSPMTPT34A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 30}},
#define   MTPSPMTPT18I          (138 % 256)
	{MTPSPMTPT18I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 31}},
#define   MTPSPMTPT19I          (139 % 256)
	{MTPSPMTPT19I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 32}},
#define   MTPSPMTPT20I          (140 % 256)
	{MTPSPMTPT20I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 33}},
#define   MTPSPMTPT21I          (141 % 256)
	{MTPSPMTPT21I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 34}},
#define   MTPSPMTPT22I          (142 % 256)
	{MTPSPMTPT22I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 35}},
#define   MTPSPMTPT23I          (143 % 256)
	{MTPSPMTPT23I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 36}},
#define   MTPSPMTPT20A          (144 % 256)
	{MTPSPMTPT20A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 37}},
#define   MTPSPMTPT21A          (145 % 256)
	{MTPSPMTPT21A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 38}},
#define   MTPSPMTPT24I          (146 % 256)
	{MTPSPMTPT24I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 39}},
#define   MTPSPMTPT1T           (147 % 256)
	{MTPSPMTPT1T, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 40}},
#define   MTPSPMTPT2T           (148 % 256)
	{MTPSPMTPT2T, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 41}},
#define   MTPSPMTPT1S           (149 % 256)
	{MTPSPMTPT1S, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 42}},
#define   MTPSPPROFILEPOINTER   (150 % 256)
	{MTPSPPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 43}},
#define   MTPSPNAPOINTER        (151 % 256)
	{MTPSPNAPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 44}},
#define   MTPSPFLAGS            (152 % 256)
	{MTPSPFLAGS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 45}},
#define   MTPSPUSERS            (153 % 256)
	{MTPSPUSERS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 46}},
#define   MTPSPALARMSTATUS      (154 % 256)
	{MTPSPALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 47}},
#define   MTPSPROWSTATUS        (155 % 256)
	{MTPSPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 48}},
#define   MTPL3ADMINISTRATIVESTATE  (159 % 256)
	{MTPL3ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 2}},
#define   MTPL3OPERATIONALSTATE  (160 % 256)
	{MTPL3OPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 3}},
#define   MTPL3USAGESTATE       (161 % 256)
	{MTPL3USAGESTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 4}},
#define   MTPL3PROCEDURALSTATUS  (162 % 256)
	{MTPL3PROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 5}},
#define   MTPL3ASAPROFILEPOINTER  (163 % 256)
	{MTPL3ASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 6}},
#define   MTPL3NAME             (164 % 256)
	{MTPL3NAME, ASN_OCTET_STR, RWRITE, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 7}},
#define   MTPL3ROWSTATUS        (165 % 256)
	{MTPL3ROWSTATUS, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 8}},
#define   MTPRSPROFILENAME      (169 % 256)
	{MTPRSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 2}},
#define   MTPRSPROFILETIMERT8   (170 % 256)
	{MTPRSPROFILETIMERT8, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 3}},
#define   MTPRSPROFILETIMERT11  (171 % 256)
	{MTPRSPROFILETIMERT11, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 4}},
#define   MTPRSPROFILETIMERT15  (172 % 256)
	{MTPRSPROFILETIMERT15, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 5}},
#define   MTPRSPROFILETIMERT16  (173 % 256)
	{MTPRSPROFILETIMERT16, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 6}},
#define   MTPRSPROFILETIMERT18A  (174 % 256)
	{MTPRSPROFILETIMERT18A, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 7}},
#define   MTPRSPROFILERTDEFAULT  (175 % 256)
	{MTPRSPROFILERTDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 8}},
#define   MTPRSPROFILEROWSTATUS  (176 % 256)
	{MTPRSPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 9}},
#define   MTPRSDEST             (181 % 256)
	{MTPRSDEST, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 2}},
#define   MTPRSFLAGS            (182 % 256)
	{MTPRSFLAGS, ASN_BIT_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 3}},
#define   MTPRSADMINISTRATIVESTATE  (183 % 256)
	{MTPRSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 4}},
#define   MTPRSOPERATIONALSTATE  (184 % 256)
	{MTPRSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 5}},
#define   MTPRSASAPROFILEPOINTER  (185 % 256)
	{MTPRSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 6}},
#define   MTPRSCONGESTEDSTATE   (186 % 256)
	{MTPRSCONGESTEDSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 7}},
#define   MTPRSCONGESTIONLEVEL  (187 % 256)
	{MTPRSCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 8}},
#define   MTPRSLOADSHARINGINFORMATION  (188 % 256)
	{MTPRSLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 9}},
#define   MTPRSLOADSHARINGOBJECT  (189 % 256)
	{MTPRSLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 10}},
#define   MTPRSREMOTEEXCHANGELABEL  (190 % 256)
	{MTPRSREMOTEEXCHANGELABEL, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 11}},
#define   MTPRSNAME             (191 % 256)
	{MTPRSNAME, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 12}},
#define   MTPRSPROFILE          (192 % 256)
	{MTPRSPROFILE, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 13}},
#define   MTPRSALARMSTATUS      (193 % 256)
	{MTPRSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 14}},
#define   MTPRSROWSTATUS        (194 % 256)
	{MTPRSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 15}},
#define   MTPRTPROFILETIMERT6   (198 % 256)
	{MTPRTPROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 2}},
#define   MTPRTPROFILETIMERT10  (199 % 256)
	{MTPRTPROFILETIMERT10, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 3}},
#define   MTPRTPROFILEROWSTATUS  (200 % 256)
	{MTPRTPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 4}},
#define   MTPRTLSPOINTER        (206 % 256)
	{MTPRTLSPOINTER, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 2}},
#define   MTPRTADMINISTRATIVESTATE  (207 % 256)
	{MTPRTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 3}},
#define   MTPRTOPERATIONALSTATE  (208 % 256)
	{MTPRTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 4}},
#define   MTPRTAVAILABILITYSTATUS  (209 % 256)
	{MTPRTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 5}},
#define   MTPRTINCLSLOADSHARINGALGORITHM  (210 % 256)
	{MTPRTINCLSLOADSHARINGALGORITHM, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 6}},
#define   MTPRTFIXEDPRIORITY    (211 % 256)
	{MTPRTFIXEDPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 7}},
#define   MTPRTFLEXIBLEPRIORITY  (212 % 256)
	{MTPRTFLEXIBLEPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 8}},
#define   MTPRTPRIORITYMODE     (213 % 256)
	{MTPRTPRIORITYMODE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 9}},
#define   MTPRTLOADSHARINGINFORMATION  (214 % 256)
	{MTPRTLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 10}},
#define   MTPRTLOADSHARINGOBJECT  (215 % 256)
	{MTPRTLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 11}},
#define   MTPRTNAME             (216 % 256)
	{MTPRTNAME, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 12}},
#define   MTPRTSLSLIST          (217 % 256)
	{MTPRTSLSLIST, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 13}},
#define   MTPRTUSAGESTATE       (218 % 256)
	{MTPRTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 14}},
#define   MTPRTRLSLOT           (219 % 256)
	{MTPRTRLSLOT, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 15}},
#define   MTPRTPROFILE          (220 % 256)
	{MTPRTPROFILE, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 16}},
#define   MTPRTROWSTATUS        (221 % 256)
	{MTPRTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 17}},
#define   MTPRTLSANORMALSLCODE  (228 % 256)
	{MTPRTLSANORMALSLCODE, ASN_UNSIGNED, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 8, 3, 1, 2}},
#define   MTPRTLSAALTERNATIVESLCODELIST  (229 % 256)
	{MTPRTLSAALTERNATIVESLCODELIST, ASN_OCTET_STR, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 8, 3, 1, 3}},
#define   MTPLSPROFILETIMERT6   (233 % 256)
	{MTPLSPROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 2}},
#define   MTPLSPROFILETIMERT8   (234 % 256)
	{MTPLSPROFILETIMERT8, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 3}},
#define   MTPLSPROFILETIMERT10  (235 % 256)
	{MTPLSPROFILETIMERT10, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 4}},
#define   MTPLSPROFILETIMERT7   (236 % 256)
	{MTPLSPROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 5}},
#define   MTPLSPROFILETIMERT19I  (237 % 256)
	{MTPLSPROFILETIMERT19I, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 6}},
#define   MTPLSPROFILETIMERT21I  (238 % 256)
	{MTPLSPROFILETIMERT21I, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 7}},
#define   MTPLSPROFILETIMERT25A  (239 % 256)
	{MTPLSPROFILETIMERT25A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 8}},
#define   MTPLSPROFILETIMERT28A  (240 % 256)
	{MTPLSPROFILETIMERT28A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 9}},
#define   MTPLSPROFILETIMERT29A  (241 % 256)
	{MTPLSPROFILETIMERT29A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 10}},
#define   MTPLSPROFILETIMERT30A  (242 % 256)
	{MTPLSPROFILETIMERT30A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 11}},
#define   MTPLSPROFILENAME      (243 % 256)
	{MTPLSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 12}},
#define   MTPLSPROFILESLDEFAULT  (244 % 256)
	{MTPLSPROFILESLDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 13}},
#define   MTPLSPROFILEROWSTATUS  (245 % 256)
	{MTPLSPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 14}},
#define   MTPLSADJPC            (250 % 256)
	{MTPLSADJPC, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 2}},
#define   MTPLSRSID             (251 % 256)
	{MTPLSRSID, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 3}},
#define   MTPLSMAXCAPACITY      (252 % 256)
	{MTPLSMAXCAPACITY, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 4}},
#define   MTPLSCURRENTCAPACITY  (253 % 256)
	{MTPLSCURRENTCAPACITY, ASN_UNSIGNED, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 5}},
#define   MTPLSCONGESTIONCONTROLMETHOD  (254 % 256)
	{MTPLSCONGESTIONCONTROLMETHOD, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 6}},
#define   MTPLSUSAGESTATE       (255 % 256)
	{MTPLSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 7}},
#define   MTPLSOPERATIONALSTATE  (256 % 256)
	{MTPLSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 8}},
#define   MTPLSAVAILABILITYSTATUS  (257 % 256)
	{MTPLSAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 9}},
#define   MTPLSPERIODICLINKTESTFLAG  (258 % 256)
	{MTPLSPERIODICLINKTESTFLAG, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 10}},
#define   MTPLSPERIODICLINKTESTFAIL  (259 % 256)
	{MTPLSPERIODICLINKTESTFAIL, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 11}},
#define   MTPLSADMINISTRATIVESTATE  (260 % 256)
	{MTPLSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 12}},
#define   MTPLSINLSLOADSHAREALGORITHM  (261 % 256)
	{MTPLSINLSLOADSHAREALGORITHM, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 13}},
#define   MTPLSPROFILEPOINTER   (262 % 256)
	{MTPLSPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 14}},
#define   MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS  (263 % 256)
	{MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 15}},
#define   MTPLSNAME             (264 % 256)
	{MTPLSNAME, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 16}},
#define   MTPLSASAPROFILEPOINTER  (265 % 256)
	{MTPLSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 17}},
#define   MTPLSALARMSTATUS      (266 % 256)
	{MTPLSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 18}},
#define   MTPLSROWSTATUS        (267 % 256)
	{MTPLSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 19}},
#define   MTPSLL3PROFILETIMERT1  (271 % 256)
	{MTPSLL3PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 2}},
#define   MTPSLL3PROFILETIMERT3  (272 % 256)
	{MTPSLL3PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 3}},
#define   MTPSLL3PROFILETIMERT17  (273 % 256)
	{MTPSLL3PROFILETIMERT17, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 4}},
#define   MTPSLL3PROFILETIMERT24I  (274 % 256)
	{MTPSLL3PROFILETIMERT24I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 5}},
#define   MTPSLL3PROFILENAME    (275 % 256)
	{MTPSLL3PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 6}},
#define   MTPSLL3PROFILETIMERT2  (276 % 256)
	{MTPSLL3PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 7}},
#define   MTPSLL3PROFILETIMERT4  (277 % 256)
	{MTPSLL3PROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 8}},
#define   MTPSLL3PROFILETIMERT5  (278 % 256)
	{MTPSLL3PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 9}},
#define   MTPSLL3PROFILETIMERT12  (279 % 256)
	{MTPSLL3PROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 10}},
#define   MTPSLL3PROFILETIMERT13  (280 % 256)
	{MTPSLL3PROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 11}},
#define   MTPSLL3PROFILETIMERT14  (281 % 256)
	{MTPSLL3PROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 12}},
#define   MTPSLL3PROFILETIMERT19A  (282 % 256)
	{MTPSLL3PROFILETIMERT19A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 13}},
#define   MTPSLL3PROFILETIMERT20A  (283 % 256)
	{MTPSLL3PROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 14}},
#define   MTPSLL3PROFILETIMERT21A  (284 % 256)
	{MTPSLL3PROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 15}},
#define   MTPSLL3PROFILETIMERT22I  (285 % 256)
	{MTPSLL3PROFILETIMERT22I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 16}},
#define   MTPSLL3PROFILETIMERT23I  (286 % 256)
	{MTPSLL3PROFILETIMERT23I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 17}},
#define   MTPSLL3PROFILETIMERT31A  (287 % 256)
	{MTPSLL3PROFILETIMERT31A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 18}},
#define   MTPSLL3PROFILETIMERT32A  (288 % 256)
	{MTPSLL3PROFILETIMERT32A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 19}},
#define   MTPSLL3PROFILETIMERT33A  (289 % 256)
	{MTPSLL3PROFILETIMERT33A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 20}},
#define   MTPSLL3PROFILETIMERT34A  (290 % 256)
	{MTPSLL3PROFILETIMERT34A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 21}},
#define   MTPSLL3PROFILETIMERT1T  (291 % 256)
	{MTPSLL3PROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 22}},
#define   MTPSLL3PROFILETIMERT2T  (292 % 256)
	{MTPSLL3PROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 23}},
#define   MTPSLL3PROFILETIMERT1S  (293 % 256)
	{MTPSLL3PROFILETIMERT1S, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 24}},
#define   MTPSLL3PROFILEL2DEFAULT  (294 % 256)
	{MTPSLL3PROFILEL2DEFAULT, ASN_OCTET_STR, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 25}},
#define   MTPSLL3PROFILEROWSTATUS  (295 % 256)
	{MTPSLL3PROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 26}},
#define   MTPSLL2PROFILEERRORCORRECTIONMETHOD  (299 % 256)
	{MTPSLL2PROFILEERRORCORRECTIONMETHOD, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 2}},
#define   MTPSLL2PROFILETRANSMISSIONRATE  (300 % 256)
	{MTPSLL2PROFILETRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 3}},
#define   MTPSLL2PROFILETIMERT1  (301 % 256)
	{MTPSLL2PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 4}},
#define   MTPSLL2PROFILETIMERT2  (302 % 256)
	{MTPSLL2PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 5}},
#define   MTPSLL2PROFILETIMERT2L  (303 % 256)
	{MTPSLL2PROFILETIMERT2L, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 6}},
#define   MTPSLL2PROFILETIMERT2H  (304 % 256)
	{MTPSLL2PROFILETIMERT2H, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 7}},
#define   MTPSLL2PROFILETIMERT3  (305 % 256)
	{MTPSLL2PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 8}},
#define   MTPSLL2PROFILETIMERT4N  (306 % 256)
	{MTPSLL2PROFILETIMERT4N, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 9}},
#define   MTPSLL2PROFILETIMERT4E  (307 % 256)
	{MTPSLL2PROFILETIMERT4E, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 10}},
#define   MTPSLL2PROFILETIMERT5  (308 % 256)
	{MTPSLL2PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 11}},
#define   MTPSLL2PROFILETIMERT6  (309 % 256)
	{MTPSLL2PROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 12}},
#define   MTPSLL2PROFILETIMERT7  (310 % 256)
	{MTPSLL2PROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 13}},
#define   MTPSLL2PROFILETBONSET1  (311 % 256)
	{MTPSLL2PROFILETBONSET1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 14}},
#define   MTPSLL2PROFILETBABATE1  (312 % 256)
	{MTPSLL2PROFILETBABATE1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 15}},
#define   MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS  (313 % 256)
	{MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 16}},
#define   MTPSLL2PROFILECONGESTIONCOUNTING  (314 % 256)
	{MTPSLL2PROFILECONGESTIONCOUNTING, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 17}},
#define   MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT  (315 % 256)
	{MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 18}},
#define   MTPSLL2PROFILELOOPDELAY  (316 % 256)
	{MTPSLL2PROFILELOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 19}},
#define   MTPSLL2PROFILENAME    (317 % 256)
	{MTPSLL2PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 20}},
#define   MTPSLL2PROFILETBONSET2  (318 % 256)
	{MTPSLL2PROFILETBONSET2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 21}},
#define   MTPSLL2PROFILETBABATE2  (319 % 256)
	{MTPSLL2PROFILETBABATE2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 22}},
#define   MTPSLL2PROFILETBONSET3  (320 % 256)
	{MTPSLL2PROFILETBONSET3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 23}},
#define   MTPSLL2PROFILETBABATE3  (321 % 256)
	{MTPSLL2PROFILETBABATE3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 24}},
#define   MTPSLL2PROFILETBDISCARD1  (322 % 256)
	{MTPSLL2PROFILETBDISCARD1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 25}},
#define   MTPSLL2PROFILETBDISCARD2  (323 % 256)
	{MTPSLL2PROFILETBDISCARD2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 26}},
#define   MTPSLL2PROFILETBDISCARD3  (324 % 256)
	{MTPSLL2PROFILETBDISCARD3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 27}},
#define   MTPSLL2PROFILETIMERTX  (325 % 256)
	{MTPSLL2PROFILETIMERTX, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 28}},
#define   MTPSLL2PROFILETIMERTY  (326 % 256)
	{MTPSLL2PROFILETIMERTY, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 29}},
#define   MTPSLL2PROFILENUMBEROFCONGESTIONSTATES  (327 % 256)
	{MTPSLL2PROFILENUMBEROFCONGESTIONSTATES, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 30}},
#define   MTPSLL2PROFILEINITIALLEVELOFCONGESTION  (328 % 256)
	{MTPSLL2PROFILEINITIALLEVELOFCONGESTION, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 31}},
#define   MTPSLL2PROFILEMAXMSUSRETRANSN1  (329 % 256)
	{MTPSLL2PROFILEMAXMSUSRETRANSN1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 32}},
#define   MTPSLL2PROFILEMAXOCTRETRANSN2  (330 % 256)
	{MTPSLL2PROFILEMAXOCTRETRANSN2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 33}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET  (331 % 256)
	{MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 34}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE  (332 % 256)
	{MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 35}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD  (333 % 256)
	{MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 36}},
#define   MTPSLL2PROFILEM       (334 % 256)
	{MTPSLL2PROFILEM, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 37}},
#define   MTPSLL2PROFILEROWSTATUS  (335 % 256)
	{MTPSLL2PROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 38}},
#define   MTPSLSLSCODECURRENTLIST  (341 % 256)
	{MTPSLSLSCODECURRENTLIST, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 2}},
#define   MTPSLMAXCAPACITYSL    (342 % 256)
	{MTPSLMAXCAPACITYSL, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 3}},
#define   MTPSLCURRENTCAPACITYSL  (343 % 256)
	{MTPSLCURRENTCAPACITYSL, ASN_UNSIGNED, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 4}},
#define   MTPSLLINKTPSTATUS     (344 % 256)
	{MTPSLLINKTPSTATUS, ASN_BIT_STR, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 5}},
#define   MTPSLADMINISTRATIVESTATE  (345 % 256)
	{MTPSLADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 6}},
#define   MTPSLOPERATIONALSTATE  (346 % 256)
	{MTPSLOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 7}},
#define   MTPSLUSAGESTATE       (347 % 256)
	{MTPSLUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 8}},
#define   MTPSLPROCEDURALSTATUS  (348 % 256)
	{MTPSLPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 9}},
#define   MTPSLMTPL2PROTOCOLPROFILEPOINTER  (349 % 256)
	{MTPSLMTPL2PROTOCOLPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 10}},
#define   MTPSLSIGNTERMPOINTER  (350 % 256)
	{MTPSLSIGNTERMPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 11}},
#define   MTPSLSIGNDATALINKTPPOINTER  (351 % 256)
	{MTPSLSIGNDATALINKTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 12}},
#define   MTPSLLOCALINHIBIT     (352 % 256)
	{MTPSLLOCALINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 13}},
#define   MTPSLLOCALUNINHIBIT   (353 % 256)
	{MTPSLLOCALUNINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 14}},
#define   MTPSLREPLACEST        (354 % 256)
	{MTPSLREPLACEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 15}},
#define   MTPSLASAPROFILEPOINTER  (355 % 256)
	{MTPSLASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 16}},
#define   MTPSLCONGESTIONLEVEL  (356 % 256)
	{MTPSLCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 17}},
#define   MTPSLRELATEDLINKGROUPNUMBER  (357 % 256)
	{MTPSLRELATEDLINKGROUPNUMBER, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 18}},
#define   MTPSLSDLLIST          (358 % 256)
	{MTPSLSDLLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 19}},
#define   MTPSLTEST             (359 % 256)
	{MTPSLTEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 20}},
#define   MTPSLNAME             (360 % 256)
	{MTPSLNAME, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 21}},
#define   MTPSLSDTLIST          (361 % 256)
	{MTPSLSDTLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 22}},
#define   MTPSLSLSCODENORMALLIST  (362 % 256)
	{MTPSLSLSCODENORMALLIST, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 23}},
#define   MTPSLL3PROFILEPOINTER  (363 % 256)
	{MTPSLL3PROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 24}},
#define   MTPSLALARMSTATUS      (364 % 256)
	{MTPSLALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 25}},
#define   MTPSLROWSTATUS        (365 % 256)
	{MTPSLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 26}},
#define   MTPSLSDLLISTPOINTER   (372 % 256)
	{MTPSLSDLLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 10, 4, 1, 2}},
#define   MTPSLSDLLISTROWSTATUS  (373 % 256)
	{MTPSLSDLLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 10, 4, 1, 3}},
#define   MTPSLSDTLISTPOINTER   (380 % 256)
	{MTPSLSDTLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 10, 5, 1, 2}},
#define   MTPSLSDTLISTROWSTATUS  (381 % 256)
	{MTPSLSDTLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 10, 5, 1, 3}},
#define   MTPNBTRANSMISSIONRATE  (385 % 256)
	{MTPNBTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 2}},
#define   MTPNBTIMERT8          (386 % 256)
	{MTPNBTIMERT8, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 3}},
#define   MTPNBTIN              (387 % 256)
	{MTPNBTIN, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 4}},
#define   MTPNBTIE              (388 % 256)
	{MTPNBTIE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 5}},
#define   MTPNBT                (389 % 256)
	{MTPNBT, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 6}},
#define   MTPNBD                (390 % 256)
	{MTPNBD, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 7}},
#define   MTPNBTE               (391 % 256)
	{MTPNBTE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 8}},
#define   MTPNBDE               (392 % 256)
	{MTPNBDE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 9}},
#define   MTPNBUE               (393 % 256)
	{MTPNBUE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 10}},
#define   MTPNBN                (394 % 256)
	{MTPNBN, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 11}},
#define   MTPNBM                (395 % 256)
	{MTPNBM, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 12}},
#define   MTPNBB                (396 % 256)
	{MTPNBB, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 13}},
#define   MTPNBF                (397 % 256)
	{MTPNBF, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 14}},
#define   MTPNBROWSTATUS        (398 % 256)
	{MTPNBROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 15}},
#define   MTPSAALBUFFERRELEASE  (402 % 256)
	{MTPSAALBUFFERRELEASE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 1}},
#define   MTPSAALMAXCC          (403 % 256)
	{MTPSAALMAXCC, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 2}},
#define   MTPSAALMAXNRP         (404 % 256)
	{MTPSAALMAXNRP, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 3}},
#define   MTPSAALMAXINFORMATIONFIELDLENGTH  (405 % 256)
	{MTPSAALMAXINFORMATIONFIELDLENGTH, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 4}},
#define   MTPSAALMAXLENGTHSSCOPUUFIELD  (406 % 256)
	{MTPSAALMAXLENGTHSSCOPUUFIELD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 5}},
#define   MTPSAALMAXPD          (407 % 256)
	{MTPSAALMAXPD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 6}},
#define   MTPSAALMAXSSCOPCREDITTOPEER  (408 % 256)
	{MTPSAALMAXSSCOPCREDITTOPEER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 7}},
#define   MTPSAALMAXSTAT        (409 % 256)
	{MTPSAALMAXSTAT, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 8}},
#define   MTPSAALN1             (410 % 256)
	{MTPSAALN1, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 9}},
#define   MTPSAALNNILAYERMANAGEMENTPROVINGSTATE  (411 % 256)
	{MTPSAALNNILAYERMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 10}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT  (412 % 256)
	{MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 11}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC  (413 % 256)
	{MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 12}},
#define   MTPSAALNNITIMERT1     (414 % 256)
	{MTPSAALNNITIMERT1, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 13}},
#define   MTPSAALNNITIMERT2     (415 % 256)
	{MTPSAALNNITIMERT2, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 14}},
#define   MTPSAALNNITIMERT3     (416 % 256)
	{MTPSAALNNITIMERT3, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 15}},
#define   MTPSAALSSCOPTIMERCC   (417 % 256)
	{MTPSAALSSCOPTIMERCC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 16}},
#define   MTPSAALSSCOPTIMERIDLE  (418 % 256)
	{MTPSAALSSCOPTIMERIDLE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 17}},
#define   MTPSAALSSCOPTIMERKEEPALIVE  (419 % 256)
	{MTPSAALSSCOPTIMERKEEPALIVE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 18}},
#define   MTPSAALSSCOPTIMERNORESPONSE  (420 % 256)
	{MTPSAALSSCOPTIMERNORESPONSE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 19}},
#define   MTPSAALSSCOPTIMERPOLL  (421 % 256)
	{MTPSAALSSCOPTIMERPOLL, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 20}},
#define   MTPSAALTRANSMISSIONRATEINTERVALLOWER  (422 % 256)
	{MTPSAALTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 21}},
#define   MTPSAALTRANSMISSIONRATEINTERVALUPPER  (423 % 256)
	{MTPSAALTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 22}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER  (424 % 256)
	{MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 23}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER  (425 % 256)
	{MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 24}},
#define   MTPSAALPOLLAFTERRETRANSMISSION  (426 % 256)
	{MTPSAALPOLLAFTERRETRANSMISSION, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 25}},
#define   MTPSAALROWSTATUS      (427 % 256)
	{MTPSAALROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 26}},
#define   MTPM2PAN1             (431 % 256)
	{MTPM2PAN1, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 1}},
#define   MTPM2PAPROVING        (432 % 256)
	{MTPM2PAPROVING, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 2}},
#define   MTPM2PAMANAGEMENTPROVINGSTATE  (433 % 256)
	{MTPM2PAMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 3}},
#define   MTPM2PALOOPDELAYLOWER  (434 % 256)
	{MTPM2PALOOPDELAYLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 4}},
#define   MTPM2PALOOPDELAYUPPER  (435 % 256)
	{MTPM2PALOOPDELAYUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 5}},
#define   MTPM2PATRANSMISSIONRATEINTERVALLOWER  (436 % 256)
	{MTPM2PATRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 6}},
#define   MTPM2PATRANSMISSIONRATEINTERVALUPPER  (437 % 256)
	{MTPM2PATRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 7}},
#define   MTPM2PASCTPNODELAY    (438 % 256)
	{MTPM2PASCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 8}},
#define   MTPM2PASCTPMAXSEG     (439 % 256)
	{MTPM2PASCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 9}},
#define   MTPM2PASCTPHEARTBEATITVL  (440 % 256)
	{MTPM2PASCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 10}},
#define   MTPM2PASCTPHEARTBEAT  (441 % 256)
	{MTPM2PASCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 11}},
#define   MTPM2PASCTPRTOINITIAL  (442 % 256)
	{MTPM2PASCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 12}},
#define   MTPM2PASCTPRTOMIN     (443 % 256)
	{MTPM2PASCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 13}},
#define   MTPM2PASCTPRTOMAX     (444 % 256)
	{MTPM2PASCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 14}},
#define   MTPM2PASCTPPATHMAXRETRANS  (445 % 256)
	{MTPM2PASCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 15}},
#define   MTPM2PASCTPCOOKIELIFE  (446 % 256)
	{MTPM2PASCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 16}},
#define   MTPM2PASCTPCOOKIEINC  (447 % 256)
	{MTPM2PASCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 17}},
#define   MTPM2PASCTPMAXINITRETRIES  (448 % 256)
	{MTPM2PASCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 18}},
#define   MTPM2PASCTPMAXBURST   (449 % 256)
	{MTPM2PASCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 19}},
#define   MTPM2PASCTPASSOCMAXRETRANS  (450 % 256)
	{MTPM2PASCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 20}},
#define   MTPM2PASCTPSACKDELAY  (451 % 256)
	{MTPM2PASCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 21}},
#define   MTPM2PASCTPLIFETIME   (452 % 256)
	{MTPM2PASCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 22}},
#define   MTPM2PAPROVINGATTEMPTS  (453 % 256)
	{MTPM2PAPROVINGATTEMPTS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 23}},
#define   MTPM2PAROWSTATUS      (454 % 256)
	{MTPM2PAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 24}},
#define   MTPSDTADMINISTRATIVESTATE  (458 % 256)
	{MTPSDTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 2}},
#define   MTPSDTOPERATIONALSTATE  (459 % 256)
	{MTPSDTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 3}},
#define   MTPSDTUSAGESTATE      (460 % 256)
	{MTPSDTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 4}},
#define   MTPSDTPROCEDURALSTATUS  (461 % 256)
	{MTPSDTPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 5}},
#define   MTPSDTAVAILABILITYSTATUS  (462 % 256)
	{MTPSDTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 6}},
#define   MTPSDTEQUIPMENTPOINTER  (463 % 256)
	{MTPSDTEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 7}},
#define   MTPSDTNAME            (464 % 256)
	{MTPSDTNAME, ASN_OCTET_STR, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 8}},
#define   MTPSDTPROFILEPOINTER  (465 % 256)
	{MTPSDTPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 9}},
#define   MTPSDTROWSTATUS       (466 % 256)
	{MTPSDTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 10}},
#define   MTPSDLADJPC           (470 % 256)
	{MTPSDLADJPC, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 2}},
#define   MTPSDLTRANSMISSIONRATE  (471 % 256)
	{MTPSDLTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 3}},
#define   MTPSDLLOOPDELAY       (472 % 256)
	{MTPSDLLOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 4}},
#define   MTPSDLOPERATIONALSTATE  (473 % 256)
	{MTPSDLOPERATIONALSTATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 5}},
#define   MTPSDLEQUIPMENTPOINTER  (474 % 256)
	{MTPSDLEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 6}},
#define   MTPSDLCIC             (475 % 256)
	{MTPSDLCIC, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 7}},
#define   MTPSDLNAME            (476 % 256)
	{MTPSDLNAME, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 8}},
#define   MTPSDLSTMCHANNEL      (477 % 256)
	{MTPSDLSTMCHANNEL, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 9}},
#define   MTPSDLVCTTPPOINTER    (478 % 256)
	{MTPSDLVCTTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 10}},
#define   MTPSDLROWSTATUS       (479 % 256)
	{MTPSDLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 11}},
#define   MTPM2PADEFAULTSCTPNODELAY  (480 % 256)
	{MTPM2PADEFAULTSCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpMIB, 4, {1, 2, 1, 1}},
#define   MTPM2PADEFAULTSCTPMAXSEG  (481 % 256)
	{MTPM2PADEFAULTSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 2}},
#define   MTPM2PADEFAULTSCTPHEARTBEATITVL  (482 % 256)
	{MTPM2PADEFAULTSCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 3}},
#define   MTPM2PADEFAULTSCTPHEARTBEAT  (483 % 256)
	{MTPM2PADEFAULTSCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpMIB, 4, {1, 2, 1, 4}},
#define   MTPM2PADEFAULTSCTPRTOINITIAL  (484 % 256)
	{MTPM2PADEFAULTSCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 5}},
#define   MTPM2PADEFAULTSCTPRTOMIN  (485 % 256)
	{MTPM2PADEFAULTSCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 6}},
#define   MTPM2PADEFAULTSCTPRTOMAX  (486 % 256)
	{MTPM2PADEFAULTSCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 7}},
#define   MTPM2PADEFAULTSCTPPATHMAXRETRANS  (487 % 256)
	{MTPM2PADEFAULTSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 8}},
#define   MTPM2PADEFAULTSCTPCOOKIELIFE  (488 % 256)
	{MTPM2PADEFAULTSCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 9}},
#define   MTPM2PADEFAULTSCTPCOOKIEINC  (489 % 256)
	{MTPM2PADEFAULTSCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 10}},
#define   MTPM2PADEFAULTSCTPMAXINITRETRIES  (490 % 256)
	{MTPM2PADEFAULTSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 11}},
#define   MTPM2PADEFAULTSCTPMAXBURST  (491 % 256)
	{MTPM2PADEFAULTSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 12}},
#define   MTPM2PADEFAULTSCTPASSOCMAXRETRANS  (492 % 256)
	{MTPM2PADEFAULTSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 13}},
#define   MTPM2PADEFAULTSCTPSACKDELAY  (493 % 256)
	{MTPM2PADEFAULTSCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 14}},
#define   MTPM2PADEFAULTSCTPLIFETIME  (494 % 256)
	{MTPM2PADEFAULTSCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 15}},
};

/* (L = length of the oidsuffix) */
struct mtpMIB_data *mtpMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *mtpSapTableStorage = NULL;
struct header_complex_index *mtpMsTableStorage = NULL;
struct header_complex_index *mtpNaTableStorage = NULL;
struct header_complex_index *mtpGsTableStorage = NULL;
struct header_complex_index *mtpGsLineTableStorage = NULL;
struct header_complex_index *mtpGsLineContentTableStorage = NULL;
struct header_complex_index *mtpSpProfileTableStorage = NULL;
struct header_complex_index *mtpSpTableStorage = NULL;
struct header_complex_index *mtpL3TableStorage = NULL;
struct header_complex_index *mtpRsProfileTableStorage = NULL;
struct header_complex_index *mtpRsTableStorage = NULL;
struct header_complex_index *mtpRtProfileTableStorage = NULL;
struct header_complex_index *mtpRtTableStorage = NULL;
struct header_complex_index *mtpRtLsaTableStorage = NULL;
struct header_complex_index *mtpLsProfileTableStorage = NULL;
struct header_complex_index *mtpLsTableStorage = NULL;
struct header_complex_index *mtpSlL3ProfileTableStorage = NULL;
struct header_complex_index *mtpSlL2ProfileTableStorage = NULL;
struct header_complex_index *mtpSlTableStorage = NULL;
struct header_complex_index *mtpSlSdlListTableStorage = NULL;
struct header_complex_index *mtpSlSdtListTableStorage = NULL;
struct header_complex_index *mtpNbTableStorage = NULL;
struct header_complex_index *mtpSaalTableStorage = NULL;
struct header_complex_index *mtpM2paTableStorage = NULL;
struct header_complex_index *mtpSdtTableStorage = NULL;
struct header_complex_index *mtpSdlTableStorage = NULL;

/*
 * init_mtpMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_mtpMIB(void)
{
	DEBUGMSGTL(("mtpMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("mtpMIB", mtpMIB_variables, variable7, mtpMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_mtpMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("mtpMIB", parse_mtpMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSapTable", parse_mtpSapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpMsTable", parse_mtpMsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNaTable", parse_mtpNaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsTable", parse_mtpGsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineTable", parse_mtpGsLineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineContentTable", parse_mtpGsLineContentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpProfileTable", parse_mtpSpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpTable", parse_mtpSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL3Table", parse_mtpL3Table, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsProfileTable", parse_mtpRsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsTable", parse_mtpRsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtProfileTable", parse_mtpRtProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtTable", parse_mtpRtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtLsaTable", parse_mtpRtLsaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsProfileTable", parse_mtpLsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsTable", parse_mtpLsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL3ProfileTable", parse_mtpSlL3ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL2ProfileTable", parse_mtpSlL2ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlTable", parse_mtpSlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdlListTable", parse_mtpSlSdlListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdtListTable", parse_mtpSlSdtListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNbTable", parse_mtpNbTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSaalTable", parse_mtpSaalTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM2paTable", parse_mtpM2paTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdtTable", parse_mtpSdtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdlTable", parse_mtpSdlTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineContentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL3Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtLsaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL3ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL2ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdlListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdtListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNbTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSaalTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM2paTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdlTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * deinit_mtpMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_mtpMIB(void)
{
	DEBUGMSGTL(("mtpMIB", "deinitializating...  "));
	unregister_mib(mtpMIB_variables_oid, sizeof(mtpMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("mtpMIB");
	snmpd_unregister_config_handler("mtpSapTable");
	snmpd_unregister_config_handler("mtpMsTable");
	snmpd_unregister_config_handler("mtpNaTable");
	snmpd_unregister_config_handler("mtpGsTable");
	snmpd_unregister_config_handler("mtpGsLineTable");
	snmpd_unregister_config_handler("mtpGsLineContentTable");
	snmpd_unregister_config_handler("mtpSpProfileTable");
	snmpd_unregister_config_handler("mtpSpTable");
	snmpd_unregister_config_handler("mtpL3Table");
	snmpd_unregister_config_handler("mtpRsProfileTable");
	snmpd_unregister_config_handler("mtpRsTable");
	snmpd_unregister_config_handler("mtpRtProfileTable");
	snmpd_unregister_config_handler("mtpRtTable");
	snmpd_unregister_config_handler("mtpRtLsaTable");
	snmpd_unregister_config_handler("mtpLsProfileTable");
	snmpd_unregister_config_handler("mtpLsTable");
	snmpd_unregister_config_handler("mtpSlL3ProfileTable");
	snmpd_unregister_config_handler("mtpSlL2ProfileTable");
	snmpd_unregister_config_handler("mtpSlTable");
	snmpd_unregister_config_handler("mtpSlSdlListTable");
	snmpd_unregister_config_handler("mtpSlSdtListTable");
	snmpd_unregister_config_handler("mtpNbTable");
	snmpd_unregister_config_handler("mtpSaalTable");
	snmpd_unregister_config_handler("mtpM2paTable");
	snmpd_unregister_config_handler("mtpSdtTable");
	snmpd_unregister_config_handler("mtpSdlTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

int
term_mtpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_mtpMIB();
	return 0;
}

/*
 * mtpMIB_add(): adds a structure node for scalars
 */
int
mtpMIB_add(struct mtpMIB_data *thedata)
{
	DEBUGMSGTL(("mtpMIB", "adding data...  "));
	mtpMIBStorage = thedata;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpMIB(): parses .conf file entries needed to configure the mib.
 */
void
parse_mtpMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpMIB_data);

	DEBUGMSGTL(("mtpMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paDefaultSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paDefaultSctpHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpLifetime, &tmpsize);
	mtpMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_mtpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpMIB_data *StorageTmp;

	DEBUGMSGTL(("mtpMIB", "storing data...  "));
	refresh_mtpMIB();
	if ((StorageTmp = mtpMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->mtpMIBStorageType == ST_NONVOLATILE) */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "mtpMIB ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paDefaultSctpNoDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxseg, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paDefaultSctpHeartbeat, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoInitial, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoMin, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoMax, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpCookieLife, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpCookieInc, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxInitRetries, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxBurst, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpSackDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpLifetime, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpMIB: refresh mtpMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS susbystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_mtpMIB(void)
{
	if (mtpMIBStorage == NULL) {
		struct mtpMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(mtpMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */
		StorageNew->mtpM2paDefaultSctpNoDelay = 1;
		StorageNew->mtpM2paDefaultSctpMaxseg = 65536;
		StorageNew->mtpM2paDefaultSctpHeartbeatItvl = 60000;
		StorageNew->mtpM2paDefaultSctpRtoInitial = 3000;
		StorageNew->mtpM2paDefaultSctpRtoMin = 1000;
		StorageNew->mtpM2paDefaultSctpRtoMax = 60000;
		StorageNew->mtpM2paDefaultSctpPathMaxRetrans = 5;
		StorageNew->mtpM2paDefaultSctpCookieLife = 60000;
		StorageNew->mtpM2paDefaultSctpCookieInc = 1000;
		StorageNew->mtpM2paDefaultSctpMaxInitRetries = 8;
		StorageNew->mtpM2paDefaultSctpMaxBurst = 4;
		StorageNew->mtpM2paDefaultSctpAssocMaxRetrans = 10;
		StorageNew->mtpM2paDefaultSctpSackDelay = 200;
		mtpMIBStorage = StorageNew;
		mtpMIB_refresh = 1;
	}
	if (mtpMIB_refresh == 0)
		return;
	mtpMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_mtpMIB(): locate variables in mtpMIB
 *
 * This function is called every time the agent gets a request for a scalar variable that might be
 * found within your mib section registered above.  It is up to you to do the right thing and return
 * the correct value.  You should also correct the value of "var_len" if necessary.
 *
 * Please see the documentation for more information about writing module extensions, and check out
 * the examples in the examples and mibII directories.
 */
u_char *
var_mtpMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_mtpMIB();
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPM2PADEFAULTSCTPNODELAY:
		*write_method = write_mtpM2paDefaultSctpNoDelay;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpNoDelay);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpNoDelay;
	case MTPM2PADEFAULTSCTPMAXSEG:
		*write_method = write_mtpM2paDefaultSctpMaxseg;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxseg);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxseg;
	case MTPM2PADEFAULTSCTPHEARTBEATITVL:
		*write_method = write_mtpM2paDefaultSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpHeartbeatItvl);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl;
	case MTPM2PADEFAULTSCTPHEARTBEAT:
		*write_method = write_mtpM2paDefaultSctpHeartbeat;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpHeartbeat);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpHeartbeat;
	case MTPM2PADEFAULTSCTPRTOINITIAL:
		*write_method = write_mtpM2paDefaultSctpRtoInitial;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoInitial);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoInitial;
	case MTPM2PADEFAULTSCTPRTOMIN:
		*write_method = write_mtpM2paDefaultSctpRtoMin;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoMin);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoMin;
	case MTPM2PADEFAULTSCTPRTOMAX:
		*write_method = write_mtpM2paDefaultSctpRtoMax;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoMax);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoMax;
	case MTPM2PADEFAULTSCTPPATHMAXRETRANS:
		*write_method = write_mtpM2paDefaultSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpPathMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans;
	case MTPM2PADEFAULTSCTPCOOKIELIFE:
		*write_method = write_mtpM2paDefaultSctpCookieLife;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpCookieLife);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpCookieLife;
	case MTPM2PADEFAULTSCTPCOOKIEINC:
		*write_method = write_mtpM2paDefaultSctpCookieInc;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpCookieInc);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpCookieInc;
	case MTPM2PADEFAULTSCTPMAXINITRETRIES:
		*write_method = write_mtpM2paDefaultSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxInitRetries);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxInitRetries;
	case MTPM2PADEFAULTSCTPMAXBURST:
		*write_method = write_mtpM2paDefaultSctpMaxBurst;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxBurst);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxBurst;
	case MTPM2PADEFAULTSCTPASSOCMAXRETRANS:
		*write_method = write_mtpM2paDefaultSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans;
	case MTPM2PADEFAULTSCTPSACKDELAY:
		*write_method = write_mtpM2paDefaultSctpSackDelay;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpSackDelay);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpSackDelay;
	case MTPM2PADEFAULTSCTPLIFETIME:
		*write_method = write_mtpM2paDefaultSctpLifetime;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpLifetime);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpLifetime;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * mtpSapTable_add(): adds a structure node to our data set
 */
int
mtpSapTable_add(struct mtpSapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSapId, sizeof(thedata->mtpSapId));
	header_complex_add_data(&mtpSapTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSapTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSapTable_del(): delete a structure
 */
int
mtpSapTable_del(struct mtpSapTable_data **thedata)
{
	struct mtpSapTable_data *StorageDel;

	DEBUGMSGTL(("mtpSapTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSapUserEntityNames);
		StorageDel->mtpSapUserEntityNamesLen = 0;
		SNMP_FREE(StorageDel->mtpSapProviderEntityNames);
		StorageDel->mtpSapProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel->mtpSapAsaProfilePointer);
		StorageDel->mtpSapAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSapName);
		StorageDel->mtpSapNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSapTable(): parse configuration file for mtpSapTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSapTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSapTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSapTable_data);

	DEBUGMSGTL(("mtpSapTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSapId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSap2Address, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUserPart, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUserPartStatus, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapUserEntityNames, &tmpsize);
	StorageTmp->mtpSapUserEntityNamesLen = tmpsize;
	if (StorageTmp->mtpSapUserEntityNames == NULL) {
		config_perror("invalid specification for mtpSapUserEntityNames");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapProviderEntityNames, &tmpsize);
	StorageTmp->mtpSapProviderEntityNamesLen = tmpsize;
	if (StorageTmp->mtpSapProviderEntityNames == NULL) {
		config_perror("invalid specification for mtpSapProviderEntityNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUsageState, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapAsaProfilePointer, &tmpsize);
	StorageTmp->mtpSapAsaProfilePointerLen = tmpsize;
	if (StorageTmp->mtpSapAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSapAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSapName, &tmpsize);
	StorageTmp->mtpSapNameLen = tmpsize;
	if (StorageTmp->mtpSapName == NULL) {
		config_perror("invalid specification for mtpSapName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapLongMessageSupported, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapRowStatus, &tmpsize);
	mtpSapTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
}

/*
 * store_mtpSapTable(): store configuraiton file for mtpSapTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSapTable", "storing data...  "));
	refresh_mtpSapTable();
	(void) tmpsize;
	for (hcindex = mtpSapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSapTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpSapTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSapTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSapId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSap2Address, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUserPart, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUserPartStatus, &tmpsize);
			tmpsize = StorageTmp->mtpSapUserEntityNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapUserEntityNames, &tmpsize);
			tmpsize = StorageTmp->mtpSapProviderEntityNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapProviderEntityNames, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUsageState, &tmpsize);
			tmpsize = StorageTmp->mtpSapAsaProfilePointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapAsaProfilePointer, &tmpsize);
			tmpsize = StorageTmp->mtpSapNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSapName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapLongMessageSupported, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpMsTable_add(): adds a structure node to our data set
 */
int
mtpMsTable_add(struct mtpMsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	header_complex_add_data(&mtpMsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpMsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpMsTable_del(): delete a structure
 */
int
mtpMsTable_del(struct mtpMsTable_data **thedata)
{
	struct mtpMsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMsTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpMsName);
		StorageDel->mtpMsNameLen = 0;
		SNMP_FREE(StorageDel->mtpMsAlarmStatus);
		StorageDel->mtpMsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->mtpMsManagedElementType);
		StorageDel->mtpMsManagedElementTypeLen = 0;
		SNMP_FREE(StorageDel->mtpMsModelCode);
		StorageDel->mtpMsModelCodeLen = 0;
		SNMP_FREE(StorageDel->mtpMsVendorName);
		StorageDel->mtpMsVendorNameLen = 0;
		SNMP_FREE(StorageDel->mtpMsUserLabel);
		StorageDel->mtpMsUserLabelLen = 0;
		SNMP_FREE(StorageDel->mtpMsVersion);
		StorageDel->mtpMsVersionLen = 0;
		SNMP_FREE(StorageDel->mtpMsAsaProfilePointer);
		StorageDel->mtpMsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpMsNetworkElementAliases);
		StorageDel->mtpMsNetworkElementAliasesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpMsTable(): parse configuration file for mtpMsTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpMsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpMsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpMsTable_data);

	DEBUGMSGTL(("mtpMsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsName, &tmpsize);
	StorageTmp->mtpMsNameLen = tmpsize;
	if (StorageTmp->mtpMsName == NULL) {
		config_perror("invalid specification for mtpMsName");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpMsAlarmStatus, &tmpsize);
	StorageTmp->mtpMsAlarmStatusLen = tmpsize;
	if (StorageTmp->mtpMsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpMsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsUsageState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsManagedElementType, &tmpsize);
	StorageTmp->mtpMsManagedElementTypeLen = tmpsize;
	if (StorageTmp->mtpMsManagedElementType == NULL) {
		config_perror("invalid specification for mtpMsManagedElementType");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsModelCode, &tmpsize);
	StorageTmp->mtpMsModelCodeLen = tmpsize;
	if (StorageTmp->mtpMsModelCode == NULL) {
		config_perror("invalid specification for mtpMsModelCode");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVendorName, &tmpsize);
	StorageTmp->mtpMsVendorNameLen = tmpsize;
	if (StorageTmp->mtpMsVendorName == NULL) {
		config_perror("invalid specification for mtpMsVendorName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsUserLabel, &tmpsize);
	StorageTmp->mtpMsUserLabelLen = tmpsize;
	if (StorageTmp->mtpMsUserLabel == NULL) {
		config_perror("invalid specification for mtpMsUserLabel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVersion, &tmpsize);
	StorageTmp->mtpMsVersionLen = tmpsize;
	if (StorageTmp->mtpMsVersion == NULL) {
		config_perror("invalid specification for mtpMsVersion");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpMsAsaProfilePointer, &tmpsize);
	StorageTmp->mtpMsAsaProfilePointerLen = tmpsize;
	if (StorageTmp->mtpMsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpMsAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsNetworkElementAliases, &tmpsize);
	StorageTmp->mtpMsNetworkElementAliasesLen = tmpsize;
	if (StorageTmp->mtpMsNetworkElementAliases == NULL) {
		config_perror("invalid specification for mtpMsNetworkElementAliases");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsStatus, &tmpsize);
	mtpMsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
}

/*
 * store_mtpMsTable(): store configuraiton file for mtpMsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpMsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpMsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMsTable", "storing data...  "));
	refresh_mtpMsTable();
	(void) tmpsize;
	for (hcindex = mtpMsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpMsTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpMsTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpMsTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			tmpsize = StorageTmp->mtpMsNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsName, &tmpsize);
			tmpsize = StorageTmp->mtpMsAlarmStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpMsAlarmStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsUsageState, &tmpsize);
			tmpsize = StorageTmp->mtpMsManagedElementTypeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsManagedElementType, &tmpsize);
			tmpsize = StorageTmp->mtpMsModelCodeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsModelCode, &tmpsize);
			tmpsize = StorageTmp->mtpMsVendorNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVendorName, &tmpsize);
			tmpsize = StorageTmp->mtpMsUserLabelLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsUserLabel, &tmpsize);
			tmpsize = StorageTmp->mtpMsVersionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVersion, &tmpsize);
			tmpsize = StorageTmp->mtpMsAsaProfilePointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpMsAsaProfilePointer, &tmpsize);
			tmpsize = StorageTmp->mtpMsNetworkElementAliasesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsNetworkElementAliases, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpNaTable_add(): adds a structure node to our data set
 */
int
mtpNaTable_add(struct mtpNaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpNaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpNaId, sizeof(thedata->mtpNaId));
	header_complex_add_data(&mtpNaTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNaTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpNaTable_del(): delete a structure
 */
int
mtpNaTable_del(struct mtpNaTable_data **thedata)
{
	struct mtpNaTable_data *StorageDel;

	DEBUGMSGTL(("mtpNaTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpNaProtocolVariant);
		StorageDel->mtpNaProtocolVariantLen = 0;
		SNMP_FREE(StorageDel->mtpNaProtocolOptions);
		StorageDel->mtpNaProtocolOptionsLen = 0;
		SNMP_FREE(StorageDel->mtpNaPointCodeFormat);
		StorageDel->mtpNaPointCodeFormatLen = 0;
		SNMP_FREE(StorageDel->mtpNaSpDefault);
		StorageDel->mtpNaSpDefaultLen = 0;
		SNMP_FREE(StorageDel->mtpNaName);
		StorageDel->mtpNaNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpNaTable(): parse configuration file for mtpNaTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpNaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpNaTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpNaTable_data);

	DEBUGMSGTL(("mtpNaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaId, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpNaProtocolVariant, &tmpsize);
	StorageTmp->mtpNaProtocolVariantLen = tmpsize;
	if (StorageTmp->mtpNaProtocolVariant == NULL) {
		config_perror("invalid specification for mtpNaProtocolVariant");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaProtocolYear, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpNaProtocolOptions, &tmpsize);
	StorageTmp->mtpNaProtocolOptionsLen = tmpsize;
	if (StorageTmp->mtpNaProtocolOptions == NULL) {
		config_perror("invalid specification for mtpNaProtocolOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaNetworkIndicator, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaPointCodeFormat, &tmpsize);
	StorageTmp->mtpNaPointCodeFormatLen = tmpsize;
	if (StorageTmp->mtpNaPointCodeFormat == NULL) {
		config_perror("invalid specification for mtpNaPointCodeFormat");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaSlsLength, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaSpDefault, &tmpsize);
	StorageTmp->mtpNaSpDefaultLen = tmpsize;
	if (StorageTmp->mtpNaSpDefault == NULL) {
		config_perror("invalid specification for mtpNaSpDefault");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaName, &tmpsize);
	StorageTmp->mtpNaNameLen = tmpsize;
	if (StorageTmp->mtpNaName == NULL) {
		config_perror("invalid specification for mtpNaName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaRowStatus, &tmpsize);
	mtpNaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
}

/*
 * store_mtpNaTable(): store configuraiton file for mtpNaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpNaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpNaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNaTable", "storing data...  "));
	refresh_mtpNaTable();
	(void) tmpsize;
	for (hcindex = mtpNaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNaTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpNaTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpNaTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaId, &tmpsize);
			tmpsize = StorageTmp->mtpNaProtocolVariantLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpNaProtocolVariant, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaProtocolYear, &tmpsize);
			tmpsize = StorageTmp->mtpNaProtocolOptionsLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpNaProtocolOptions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaNetworkIndicator, &tmpsize);
			tmpsize = StorageTmp->mtpNaPointCodeFormatLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaPointCodeFormat, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaSlsLength, &tmpsize);
			tmpsize = StorageTmp->mtpNaSpDefaultLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaSpDefault, &tmpsize);
			tmpsize = StorageTmp->mtpNaNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpGsTable_add(): adds a structure node to our data set
 */
int
mtpGsTable_add(struct mtpGsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
	header_complex_add_data(&mtpGsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpGsTable_del(): delete a structure
 */
int
mtpGsTable_del(struct mtpGsTable_data **thedata)
{
	struct mtpGsTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsName);
		StorageDel->mtpGsNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsTable(): parse configuration file for mtpGsTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsTable_data);

	DEBUGMSGTL(("mtpGsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsListMode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsName, &tmpsize);
	StorageTmp->mtpGsNameLen = tmpsize;
	if (StorageTmp->mtpGsName == NULL) {
		config_perror("invalid specification for mtpGsName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsRowStatus, &tmpsize);
	mtpGsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
}

/*
 * store_mtpGsTable(): store configuraiton file for mtpGsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsTable", "storing data...  "));
	refresh_mtpGsTable();
	(void) tmpsize;
	for (hcindex = mtpGsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpGsTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsListMode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpsize);
			tmpsize = StorageTmp->mtpGsNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpGsLineTable_add(): adds a structure node to our data set
 */
int
mtpGsLineTable_add(struct mtpGsLineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsLineTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
	/* mtpGsLineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineId, sizeof(thedata->mtpGsLineId));
	header_complex_add_data(&mtpGsLineTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsLineTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpGsLineTable_del(): delete a structure
 */
int
mtpGsLineTable_del(struct mtpGsLineTable_data **thedata)
{
	struct mtpGsLineTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsLineTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsLineObject);
		StorageDel->mtpGsLineObjectLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsLineTable(): parse configuration file for mtpGsLineTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsLineTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsLineTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsLineTable_data);

	DEBUGMSGTL(("mtpGsLineTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineId, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpGsLineObject, &tmpsize);
	StorageTmp->mtpGsLineObjectLen = tmpsize;
	if (StorageTmp->mtpGsLineObject == NULL) {
		config_perror("invalid specification for mtpGsLineObject");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineRowStatus, &tmpsize);
	mtpGsLineTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
}

/*
 * store_mtpGsLineTable(): store configuraiton file for mtpGsLineTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsLineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsLineTable", "storing data...  "));
	refresh_mtpGsLineTable();
	(void) tmpsize;
	for (hcindex = mtpGsLineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpGsLineTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsLineTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineId, &tmpsize);
			tmpsize = StorageTmp->mtpGsLineObjectLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpGsLineObject, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContent, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpGsLineContentTable_add(): adds a structure node to our data set
 */
int
mtpGsLineContentTable_add(struct mtpGsLineContentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsLineContentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
	/* mtpGsLineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineId, sizeof(thedata->mtpGsLineId));
	/* mtpGsLineContentId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineContentId, sizeof(thedata->mtpGsLineContentId));
	header_complex_add_data(&mtpGsLineContentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsLineContentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpGsLineContentTable_del(): delete a structure
 */
int
mtpGsLineContentTable_del(struct mtpGsLineContentTable_data **thedata)
{
	struct mtpGsLineContentTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsLineContentTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsLineContentDesignatedDPCFirst);
		StorageDel->mtpGsLineContentDesignatedDPCFirstLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentDesignatedDPCLast);
		StorageDel->mtpGsLineContentDesignatedDPCLastLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentSiMask);
		StorageDel->mtpGsLineContentSiMaskLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentComment);
		StorageDel->mtpGsLineContentCommentLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsLineContentTable(): parse configuration file for mtpGsLineContentTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsLineContentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsLineContentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data);

	DEBUGMSGTL(("mtpGsLineContentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContentId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &tmpsize);
	StorageTmp->mtpGsLineContentDesignatedDPCFirstLen = tmpsize;
	if (StorageTmp->mtpGsLineContentDesignatedDPCFirst == NULL) {
		config_perror("invalid specification for mtpGsLineContentDesignatedDPCFirst");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &tmpsize);
	StorageTmp->mtpGsLineContentDesignatedDPCLastLen = tmpsize;
	if (StorageTmp->mtpGsLineContentDesignatedDPCLast == NULL) {
		config_perror("invalid specification for mtpGsLineContentDesignatedDPCLast");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpGsLineContentSiMask, &tmpsize);
	StorageTmp->mtpGsLineContentSiMaskLen = tmpsize;
	if (StorageTmp->mtpGsLineContentSiMask == NULL) {
		config_perror("invalid specification for mtpGsLineContentSiMask");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentComment, &tmpsize);
	StorageTmp->mtpGsLineContentCommentLen = tmpsize;
	if (StorageTmp->mtpGsLineContentComment == NULL) {
		config_perror("invalid specification for mtpGsLineContentComment");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentRowStatus, &tmpsize);
	mtpGsLineContentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
}

/*
 * store_mtpGsLineContentTable(): store configuraiton file for mtpGsLineContentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineContentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsLineContentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsLineContentTable", "storing data...  "));
	refresh_mtpGsLineContentTable();
	(void) tmpsize;
	for (hcindex = mtpGsLineContentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineContentTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpGsLineContentTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsLineContentTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContentId, &tmpsize);
			tmpsize = StorageTmp->mtpGsLineContentDesignatedDPCFirstLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &tmpsize);
			tmpsize = StorageTmp->mtpGsLineContentDesignatedDPCLastLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &tmpsize);
			tmpsize = StorageTmp->mtpGsLineContentSiMaskLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpGsLineContentSiMask, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpsize);
			tmpsize = StorageTmp->mtpGsLineContentCommentLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentComment, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpProfileTable_add(): adds a structure node to our data set
 */
int
mtpSpProfileTable_add(struct mtpSpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpProfileId, thedata->mtpSpProfileIdLen);
	header_complex_add_data(&mtpSpProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpProfileTable_del(): delete a structure
 */
int
mtpSpProfileTable_del(struct mtpSpProfileTable_data **thedata)
{
	struct mtpSpProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSpProfileTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSpProfileId);
		StorageDel->mtpSpProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSpProfileName);
		StorageDel->mtpSpProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpSpRsDefault);
		StorageDel->mtpSpRsDefaultLen = 0;
		SNMP_FREE(StorageDel->mtpSpLsDefault);
		StorageDel->mtpSpLsDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpProfileTable(): parse configuration file for mtpSpProfileTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);

	DEBUGMSGTL(("mtpSpProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileId, &tmpsize);
	StorageTmp->mtpSpProfileIdLen = tmpsize;
	if (StorageTmp->mtpSpProfileId == NULL) {
		config_perror("invalid specification for mtpSpProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT1R, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT12, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT13, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT14, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT18I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT19I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT20I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT21I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT22I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT23I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT20A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT21A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT22A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT23A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT24A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT26A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT27A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT2T, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileName, &tmpsize);
	StorageTmp->mtpSpProfileNameLen = tmpsize;
	if (StorageTmp->mtpSpProfileName == NULL) {
		config_perror("invalid specification for mtpSpProfileName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpRsDefault, &tmpsize);
	StorageTmp->mtpSpRsDefaultLen = tmpsize;
	if (StorageTmp->mtpSpRsDefault == NULL) {
		config_perror("invalid specification for mtpSpRsDefault");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpLsDefault, &tmpsize);
	StorageTmp->mtpSpLsDefaultLen = tmpsize;
	if (StorageTmp->mtpSpLsDefault == NULL) {
		config_perror("invalid specification for mtpSpLsDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileRowStatus, &tmpsize);
	mtpSpProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
}

/*
 * store_mtpSpProfileTable(): store configuraiton file for mtpSpProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpProfileTable", "storing data...  "));
	refresh_mtpSpProfileTable();
	(void) tmpsize;
	for (hcindex = mtpSpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpProfileTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpSpProfileTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSpProfileTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mtpSpProfileIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT1R, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT11, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT12, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT13, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT14, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT15, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT16, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT18I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT19I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT20I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT21I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT22I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT23I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT20A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT21A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT22A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT23A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT24A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT26A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT27A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT1T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT2T, &tmpsize);
			tmpsize = StorageTmp->mtpSpProfileNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileName, &tmpsize);
			tmpsize = StorageTmp->mtpSpRsDefaultLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpRsDefault, &tmpsize);
			tmpsize = StorageTmp->mtpSpLsDefaultLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpLsDefault, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpTable_add(): adds a structure node to our data set
 */
int
mtpSpTable_add(struct mtpSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	header_complex_add_data(&mtpSpTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpTable_del(): delete a structure
 */
int
mtpSpTable_del(struct mtpSpTable_data **thedata)
{
	struct mtpSpTable_data *StorageDel;

	DEBUGMSGTL(("mtpSpTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSpPointCode);
		StorageDel->mtpSpPointCodeLen = 0;
		SNMP_FREE(StorageDel->mtpSpProceduralStatus);
		StorageDel->mtpSpProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSpAvailabilityStatus);
		StorageDel->mtpSpAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSpVersion);
		StorageDel->mtpSpVersionLen = 0;
		SNMP_FREE(StorageDel->mtpSpName);
		StorageDel->mtpSpNameLen = 0;
		SNMP_FREE(StorageDel->mtpSpProfilePointer);
		StorageDel->mtpSpProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSpNaPointer);
		StorageDel->mtpSpNaPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSpFlags);
		StorageDel->mtpSpFlagsLen = 0;
		SNMP_FREE(StorageDel->mtpSpUsers);
		StorageDel->mtpSpUsersLen = 0;
		SNMP_FREE(StorageDel->mtpSpAlarmStatus);
		StorageDel->mtpSpAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpTable(): parse configuration file for mtpSpTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpTable_data);

	DEBUGMSGTL(("mtpSpTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpPointCode, &tmpsize);
	StorageTmp->mtpSpPointCodeLen = tmpsize;
	if (StorageTmp->mtpSpPointCode == NULL) {
		config_perror("invalid specification for mtpSpPointCode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpProceduralStatus, &tmpsize);
	StorageTmp->mtpSpProceduralStatusLen = tmpsize;
	if (StorageTmp->mtpSpProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSpProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpAvailabilityStatus, &tmpsize);
	StorageTmp->mtpSpAvailabilityStatusLen = tmpsize;
	if (StorageTmp->mtpSpAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSpAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpVersion, &tmpsize);
	StorageTmp->mtpSpVersionLen = tmpsize;
	if (StorageTmp->mtpSpVersion == NULL) {
		config_perror("invalid specification for mtpSpVersion");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpNetworkIndicator, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpName, &tmpsize);
	StorageTmp->mtpSpNameLen = tmpsize;
	if (StorageTmp->mtpSpName == NULL) {
		config_perror("invalid specification for mtpSpName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT10, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT12, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT13, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT14, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT17, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT19A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT31A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT32A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT33A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT34A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT18I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT19I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT20I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT21I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT22I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT23I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT20A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT21A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT24I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT2T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1S, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfilePointer, &tmpsize);
	StorageTmp->mtpSpProfilePointerLen = tmpsize;
	if (StorageTmp->mtpSpProfilePointer == NULL) {
		config_perror("invalid specification for mtpSpProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpNaPointer, &tmpsize);
	StorageTmp->mtpSpNaPointerLen = tmpsize;
	if (StorageTmp->mtpSpNaPointer == NULL) {
		config_perror("invalid specification for mtpSpNaPointer");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpFlags, &tmpsize);
	StorageTmp->mtpSpFlagsLen = tmpsize;
	if (StorageTmp->mtpSpFlags == NULL) {
		config_perror("invalid specification for mtpSpFlags");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpUsers, &tmpsize);
	StorageTmp->mtpSpUsersLen = tmpsize;
	if (StorageTmp->mtpSpUsers == NULL) {
		config_perror("invalid specification for mtpSpUsers");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpAlarmStatus, &tmpsize);
	StorageTmp->mtpSpAlarmStatusLen = tmpsize;
	if (StorageTmp->mtpSpAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSpAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpRowStatus, &tmpsize);
	mtpSpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
}

/*
 * store_mtpSpTable(): store configuraiton file for mtpSpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpTable", "storing data...  "));
	refresh_mtpSpTable();
	(void) tmpsize;
	for (hcindex = mtpSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpSpTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSpTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			tmpsize = StorageTmp->mtpSpPointCodeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpPointCode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpOperationalState, &tmpsize);
			tmpsize = StorageTmp->mtpSpProceduralStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpProceduralStatus, &tmpsize);
			tmpsize = StorageTmp->mtpSpAvailabilityStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpAvailabilityStatus, &tmpsize);
			tmpsize = StorageTmp->mtpSpVersionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpVersion, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpNetworkIndicator, &tmpsize);
			tmpsize = StorageTmp->mtpSpNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT7, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT8, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT10, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT11, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT12, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT13, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT14, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT15, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT16, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT17, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT19A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT31A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT32A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT33A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT34A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT18I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT19I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT20I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT21I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT22I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT23I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT20A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT21A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT24I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT2T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1S, &tmpsize);
			tmpsize = StorageTmp->mtpSpProfilePointerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfilePointer, &tmpsize);
			tmpsize = StorageTmp->mtpSpNaPointerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpNaPointer, &tmpsize);
			tmpsize = StorageTmp->mtpSpFlagsLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpFlags, &tmpsize);
			tmpsize = StorageTmp->mtpSpUsersLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpUsers, &tmpsize);
			tmpsize = StorageTmp->mtpSpAlarmStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpAlarmStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpL3Table_add(): adds a structure node to our data set
 */
int
mtpL3Table_add(struct mtpL3Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpL3Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpL3Id */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpL3Id, thedata->mtpL3IdLen);
	header_complex_add_data(&mtpL3TableStorage, vars, thedata);
	DEBUGMSGTL(("mtpL3Table", "registered an entry\n"));
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpL3Table_del(): delete a structure
 */
int
mtpL3Table_del(struct mtpL3Table_data **thedata)
{
	struct mtpL3Table_data *StorageDel;

	DEBUGMSGTL(("mtpL3Table", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpL3Id);
		StorageDel->mtpL3IdLen = 0;
		SNMP_FREE(StorageDel->mtpL3ProceduralStatus);
		StorageDel->mtpL3ProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpL3AsaProfilePointer);
		StorageDel->mtpL3AsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpL3Name);
		StorageDel->mtpL3NameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpL3Table(): parse configuration file for mtpL3Table
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpL3Table(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpL3Table_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpL3Table_data);

	DEBUGMSGTL(("mtpL3Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Id, &tmpsize);
	StorageTmp->mtpL3IdLen = tmpsize;
	if (StorageTmp->mtpL3Id == NULL) {
		config_perror("invalid specification for mtpL3Id");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3AdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3OperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3UsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpL3ProceduralStatus, &tmpsize);
	StorageTmp->mtpL3ProceduralStatusLen = tmpsize;
	if (StorageTmp->mtpL3ProceduralStatus == NULL) {
		config_perror("invalid specification for mtpL3ProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpL3AsaProfilePointer, &tmpsize);
	StorageTmp->mtpL3AsaProfilePointerLen = tmpsize;
	if (StorageTmp->mtpL3AsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpL3AsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Name, &tmpsize);
	StorageTmp->mtpL3NameLen = tmpsize;
	if (StorageTmp->mtpL3Name == NULL) {
		config_perror("invalid specification for mtpL3Name");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3RowStatus, &tmpsize);
	mtpL3Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
}

/*
 * store_mtpL3Table(): store configuraiton file for mtpL3Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpL3Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpL3Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpL3Table", "storing data...  "));
	refresh_mtpL3Table();
	(void) tmpsize;
	for (hcindex = mtpL3TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL3Table_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpL3TableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpL3Table ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mtpL3IdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Id, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3AdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3OperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3UsageState, &tmpsize);
			tmpsize = StorageTmp->mtpL3ProceduralStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpL3ProceduralStatus, &tmpsize);
			tmpsize = StorageTmp->mtpL3AsaProfilePointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpL3AsaProfilePointer, &tmpsize);
			tmpsize = StorageTmp->mtpL3NameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Name, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3RowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsProfileTable_add(): adds a structure node to our data set
 */
int
mtpRsProfileTable_add(struct mtpRsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRsProfileId, thedata->mtpRsProfileIdLen);
	header_complex_add_data(&mtpRsProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsProfileTable_del(): delete a structure
 */
int
mtpRsProfileTable_del(struct mtpRsProfileTable_data **thedata)
{
	struct mtpRsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpRsProfileTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRsProfileId);
		StorageDel->mtpRsProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfileName);
		StorageDel->mtpRsProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfileRtDefault);
		StorageDel->mtpRsProfileRtDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsProfileTable(): parse configuration file for mtpRsProfileTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data);

	DEBUGMSGTL(("mtpRsProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileId, &tmpsize);
	StorageTmp->mtpRsProfileIdLen = tmpsize;
	if (StorageTmp->mtpRsProfileId == NULL) {
		config_perror("invalid specification for mtpRsProfileId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileName, &tmpsize);
	StorageTmp->mtpRsProfileNameLen = tmpsize;
	if (StorageTmp->mtpRsProfileName == NULL) {
		config_perror("invalid specification for mtpRsProfileName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT18A, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileRtDefault, &tmpsize);
	StorageTmp->mtpRsProfileRtDefaultLen = tmpsize;
	if (StorageTmp->mtpRsProfileRtDefault == NULL) {
		config_perror("invalid specification for mtpRsProfileRtDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileRowStatus, &tmpsize);
	mtpRsProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
}

/*
 * store_mtpRsProfileTable(): store configuraiton file for mtpRsProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsProfileTable", "storing data...  "));
	refresh_mtpRsProfileTable();
	(void) tmpsize;
	for (hcindex = mtpRsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsProfileTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpRsProfileTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRsProfileTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mtpRsProfileIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileId, &tmpsize);
			tmpsize = StorageTmp->mtpRsProfileNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT11, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT15, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT16, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT18A, &tmpsize);
			tmpsize = StorageTmp->mtpRsProfileRtDefaultLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileRtDefault, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsTable_add(): adds a structure node to our data set
 */
int
mtpRsTable_add(struct mtpRsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	header_complex_add_data(&mtpRsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsTable_del(): delete a structure
 */
int
mtpRsTable_del(struct mtpRsTable_data **thedata)
{
	struct mtpRsTable_data *StorageDel;

	DEBUGMSGTL(("mtpRsTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRsDest);
		StorageDel->mtpRsDestLen = 0;
		SNMP_FREE(StorageDel->mtpRsFlags);
		StorageDel->mtpRsFlagsLen = 0;
		SNMP_FREE(StorageDel->mtpRsAsaProfilePointer);
		StorageDel->mtpRsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpRsLoadsharingInformation);
		StorageDel->mtpRsLoadsharingInformationLen = 0;
		SNMP_FREE(StorageDel->mtpRsLoadsharingObject);
		StorageDel->mtpRsLoadsharingObjectLen = 0;
		SNMP_FREE(StorageDel->mtpRsRemoteExchangeLabel);
		StorageDel->mtpRsRemoteExchangeLabelLen = 0;
		SNMP_FREE(StorageDel->mtpRsName);
		StorageDel->mtpRsNameLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfile);
		StorageDel->mtpRsProfileLen = 0;
		SNMP_FREE(StorageDel->mtpRsAlarmStatus);
		StorageDel->mtpRsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsTable(): parse configuration file for mtpRsTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsTable_data);

	DEBUGMSGTL(("mtpRsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsDest, &tmpsize);
	StorageTmp->mtpRsDestLen = tmpsize;
	if (StorageTmp->mtpRsDest == NULL) {
		config_perror("invalid specification for mtpRsDest");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRsFlags, &tmpsize);
	StorageTmp->mtpRsFlagsLen = tmpsize;
	if (StorageTmp->mtpRsFlags == NULL) {
		config_perror("invalid specification for mtpRsFlags");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsAsaProfilePointer, &tmpsize);
	StorageTmp->mtpRsAsaProfilePointerLen = tmpsize;
	if (StorageTmp->mtpRsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpRsAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestedState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestionLevel, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsLoadsharingInformation, &tmpsize);
	StorageTmp->mtpRsLoadsharingInformationLen = tmpsize;
	if (StorageTmp->mtpRsLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingInformation");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsLoadsharingObject, &tmpsize);
	StorageTmp->mtpRsLoadsharingObjectLen = tmpsize;
	if (StorageTmp->mtpRsLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingObject");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsRemoteExchangeLabel, &tmpsize);
	StorageTmp->mtpRsRemoteExchangeLabelLen = tmpsize;
	if (StorageTmp->mtpRsRemoteExchangeLabel == NULL) {
		config_perror("invalid specification for mtpRsRemoteExchangeLabel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsName, &tmpsize);
	StorageTmp->mtpRsNameLen = tmpsize;
	if (StorageTmp->mtpRsName == NULL) {
		config_perror("invalid specification for mtpRsName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfile, &tmpsize);
	StorageTmp->mtpRsProfileLen = tmpsize;
	if (StorageTmp->mtpRsProfile == NULL) {
		config_perror("invalid specification for mtpRsProfile");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRsAlarmStatus, &tmpsize);
	StorageTmp->mtpRsAlarmStatusLen = tmpsize;
	if (StorageTmp->mtpRsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpRsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsRowStatus, &tmpsize);
	mtpRsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
}

/*
 * store_mtpRsTable(): store configuraiton file for mtpRsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsTable", "storing data...  "));
	refresh_mtpRsTable();
	(void) tmpsize;
	for (hcindex = mtpRsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpRsTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRsTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			tmpsize = StorageTmp->mtpRsDestLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsDest, &tmpsize);
			tmpsize = StorageTmp->mtpRsFlagsLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRsFlags, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsOperationalState, &tmpsize);
			tmpsize = StorageTmp->mtpRsAsaProfilePointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsAsaProfilePointer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestedState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestionLevel, &tmpsize);
			tmpsize = StorageTmp->mtpRsLoadsharingInformationLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsLoadsharingInformation, &tmpsize);
			tmpsize = StorageTmp->mtpRsLoadsharingObjectLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsLoadsharingObject, &tmpsize);
			tmpsize = StorageTmp->mtpRsRemoteExchangeLabelLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsRemoteExchangeLabel, &tmpsize);
			tmpsize = StorageTmp->mtpRsNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsName, &tmpsize);
			tmpsize = StorageTmp->mtpRsProfileLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfile, &tmpsize);
			tmpsize = StorageTmp->mtpRsAlarmStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRsAlarmStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRtProfileTable_add(): adds a structure node to our data set
 */
int
mtpRtProfileTable_add(struct mtpRtProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRtProfileId, thedata->mtpRtProfileIdLen);
	header_complex_add_data(&mtpRtProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRtProfileTable_del(): delete a structure
 */
int
mtpRtProfileTable_del(struct mtpRtProfileTable_data **thedata)
{
	struct mtpRtProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtProfileTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtProfileId);
		StorageDel->mtpRtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRtProfileTable(): parse configuration file for mtpRtProfileTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRtProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data);

	DEBUGMSGTL(("mtpRtProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtProfileId, &tmpsize);
	StorageTmp->mtpRtProfileIdLen = tmpsize;
	if (StorageTmp->mtpRtProfileId == NULL) {
		config_perror("invalid specification for mtpRtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT10, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileRowStatus, &tmpsize);
	mtpRtProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
}

/*
 * store_mtpRtProfileTable(): store configuraiton file for mtpRtProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtProfileTable", "storing data...  "));
	refresh_mtpRtProfileTable();
	(void) tmpsize;
	for (hcindex = mtpRtProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtProfileTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpRtProfileTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtProfileTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mtpRtProfileIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtProfileId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT10, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRtTable_add(): adds a structure node to our data set
 */
int
mtpRtTable_add(struct mtpRtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtId, sizeof(thedata->mtpRtId));
	header_complex_add_data(&mtpRtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRtTable_del(): delete a structure
 */
int
mtpRtTable_del(struct mtpRtTable_data **thedata)
{
	struct mtpRtTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtLsPointer);
		StorageDel->mtpRtLsPointerLen = 0;
		SNMP_FREE(StorageDel->mtpRtAvailabilityStatus);
		StorageDel->mtpRtAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpRtLoadsharingInformation);
		StorageDel->mtpRtLoadsharingInformationLen = 0;
		SNMP_FREE(StorageDel->mtpRtLoadsharingObject);
		StorageDel->mtpRtLoadsharingObjectLen = 0;
		SNMP_FREE(StorageDel->mtpRtName);
		StorageDel->mtpRtNameLen = 0;
		SNMP_FREE(StorageDel->mtpRtSlsList);
		StorageDel->mtpRtSlsListLen = 0;
		SNMP_FREE(StorageDel->mtpRtProfile);
		StorageDel->mtpRtProfileLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRtTable(): parse configuration file for mtpRtTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRtTable_data);

	DEBUGMSGTL(("mtpRtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLsPointer, &tmpsize);
	StorageTmp->mtpRtLsPointerLen = tmpsize;
	if (StorageTmp->mtpRtLsPointer == NULL) {
		config_perror("invalid specification for mtpRtLsPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRtAvailabilityStatus, &tmpsize);
	StorageTmp->mtpRtAvailabilityStatusLen = tmpsize;
	if (StorageTmp->mtpRtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpRtAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFixedPriority, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFlexiblePriority, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtPriorityMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLoadsharingInformation, &tmpsize);
	StorageTmp->mtpRtLoadsharingInformationLen = tmpsize;
	if (StorageTmp->mtpRtLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingInformation");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRtLoadsharingObject, &tmpsize);
	StorageTmp->mtpRtLoadsharingObjectLen = tmpsize;
	if (StorageTmp->mtpRtLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingObject");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtName, &tmpsize);
	StorageTmp->mtpRtNameLen = tmpsize;
	if (StorageTmp->mtpRtName == NULL) {
		config_perror("invalid specification for mtpRtName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtSlsList, &tmpsize);
	StorageTmp->mtpRtSlsListLen = tmpsize;
	if (StorageTmp->mtpRtSlsList == NULL) {
		config_perror("invalid specification for mtpRtSlsList");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtUsageState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtRlSlot, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtProfile, &tmpsize);
	StorageTmp->mtpRtProfileLen = tmpsize;
	if (StorageTmp->mtpRtProfile == NULL) {
		config_perror("invalid specification for mtpRtProfile");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtRowStatus, &tmpsize);
	mtpRtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
}

/*
 * store_mtpRtTable(): store configuraiton file for mtpRtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtTable", "storing data...  "));
	refresh_mtpRtTable();
	(void) tmpsize;
	for (hcindex = mtpRtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpRtTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtId, &tmpsize);
			tmpsize = StorageTmp->mtpRtLsPointerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLsPointer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtOperationalState, &tmpsize);
			tmpsize = StorageTmp->mtpRtAvailabilityStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRtAvailabilityStatus, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFixedPriority, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFlexiblePriority, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtPriorityMode, &tmpsize);
			tmpsize = StorageTmp->mtpRtLoadsharingInformationLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLoadsharingInformation, &tmpsize);
			tmpsize = StorageTmp->mtpRtLoadsharingObjectLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRtLoadsharingObject, &tmpsize);
			tmpsize = StorageTmp->mtpRtNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtName, &tmpsize);
			tmpsize = StorageTmp->mtpRtSlsListLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtSlsList, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtRlSlot, &tmpsize);
			tmpsize = StorageTmp->mtpRtProfileLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtProfile, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRtLsaTable_add(): adds a structure node to our data set
 */
int
mtpRtLsaTable_add(struct mtpRtLsaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtLsaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtId, sizeof(thedata->mtpRtId));
	/* mtpRtLsaSlsCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtLsaSlsCode, sizeof(thedata->mtpRtLsaSlsCode));
	header_complex_add_data(&mtpRtLsaTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtLsaTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRtLsaTable_del(): delete a structure
 */
int
mtpRtLsaTable_del(struct mtpRtLsaTable_data **thedata)
{
	struct mtpRtLsaTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtLsaTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtLsaAlternativeSlCodeList);
		StorageDel->mtpRtLsaAlternativeSlCodeListLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRtLsaTable(): parse configuration file for mtpRtLsaTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRtLsaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtLsaTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRtLsaTable_data);

	DEBUGMSGTL(("mtpRtLsaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtLsaSlsCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtLsaNormalSlCode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &tmpsize);
	StorageTmp->mtpRtLsaAlternativeSlCodeListLen = tmpsize;
	if (StorageTmp->mtpRtLsaAlternativeSlCodeList == NULL) {
		config_perror("invalid specification for mtpRtLsaAlternativeSlCodeList");
		return;
	}

	mtpRtLsaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
}

/*
 * store_mtpRtLsaTable(): store configuraiton file for mtpRtLsaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtLsaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtLsaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtLsaTable", "storing data...  "));
	refresh_mtpRtLsaTable();
	(void) tmpsize;
	for (hcindex = mtpRtLsaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtLsaTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpRtLsaTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtLsaTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtLsaSlsCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtLsaNormalSlCode, &tmpsize);
			tmpsize = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsProfileTable_add(): adds a structure node to our data set
 */
int
mtpLsProfileTable_add(struct mtpLsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpLsProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpLsProfileId, thedata->mtpLsProfileIdLen);
	header_complex_add_data(&mtpLsProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsProfileTable_del(): delete a structure
 */
int
mtpLsProfileTable_del(struct mtpLsProfileTable_data **thedata)
{
	struct mtpLsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpLsProfileTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpLsProfileId);
		StorageDel->mtpLsProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfileName);
		StorageDel->mtpLsProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfileSlDefault);
		StorageDel->mtpLsProfileSlDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsProfileTable(): parse configuration file for mtpLsProfileTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpLsProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data);

	DEBUGMSGTL(("mtpLsProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileId, &tmpsize);
	StorageTmp->mtpLsProfileIdLen = tmpsize;
	if (StorageTmp->mtpLsProfileId == NULL) {
		config_perror("invalid specification for mtpLsProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT10, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT19I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT21I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT25A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT28A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT29A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT30A, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileName, &tmpsize);
	StorageTmp->mtpLsProfileNameLen = tmpsize;
	if (StorageTmp->mtpLsProfileName == NULL) {
		config_perror("invalid specification for mtpLsProfileName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileSlDefault, &tmpsize);
	StorageTmp->mtpLsProfileSlDefaultLen = tmpsize;
	if (StorageTmp->mtpLsProfileSlDefault == NULL) {
		config_perror("invalid specification for mtpLsProfileSlDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileRowStatus, &tmpsize);
	mtpLsProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
}

/*
 * store_mtpLsProfileTable(): store configuraiton file for mtpLsProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpLsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsProfileTable", "storing data...  "));
	refresh_mtpLsProfileTable();
	(void) tmpsize;
	for (hcindex = mtpLsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsProfileTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpLsProfileTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpLsProfileTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mtpLsProfileIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT10, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT19I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT21I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT25A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT28A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT29A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT30A, &tmpsize);
			tmpsize = StorageTmp->mtpLsProfileNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileName, &tmpsize);
			tmpsize = StorageTmp->mtpLsProfileSlDefaultLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileSlDefault, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsTable_add(): adds a structure node to our data set
 */
int
mtpLsTable_add(struct mtpLsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	header_complex_add_data(&mtpLsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsTable_del(): delete a structure
 */
int
mtpLsTable_del(struct mtpLsTable_data **thedata)
{
	struct mtpLsTable_data *StorageDel;

	DEBUGMSGTL(("mtpLsTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpLsAdjPc);
		StorageDel->mtpLsAdjPcLen = 0;
		SNMP_FREE(StorageDel->mtpLsRsId);
		StorageDel->mtpLsRsIdLen = 0;
		SNMP_FREE(StorageDel->mtpLsAvailabilityStatus);
		StorageDel->mtpLsAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpLsInLsLoadShareAlgorithm);
		StorageDel->mtpLsInLsLoadShareAlgorithmLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfilePointer);
		StorageDel->mtpLsProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpLsName);
		StorageDel->mtpLsNameLen = 0;
		SNMP_FREE(StorageDel->mtpLsAsaProfilePointer);
		StorageDel->mtpLsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpLsAlarmStatus);
		StorageDel->mtpLsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsTable(): parse configuration file for mtpLsTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpLsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsTable_data);

	DEBUGMSGTL(("mtpLsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsAdjPc, &tmpsize);
	StorageTmp->mtpLsAdjPcLen = tmpsize;
	if (StorageTmp->mtpLsAdjPc == NULL) {
		config_perror("invalid specification for mtpLsAdjPc");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsRsId, &tmpsize);
	StorageTmp->mtpLsRsIdLen = tmpsize;
	if (StorageTmp->mtpLsRsId == NULL) {
		config_perror("invalid specification for mtpLsRsId");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsMaxCapacity, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsCurrentCapacity, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsCongestionControlMethod, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLsAvailabilityStatus, &tmpsize);
	StorageTmp->mtpLsAvailabilityStatusLen = tmpsize;
	if (StorageTmp->mtpLsAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpLsAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFail, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &tmpsize);
	StorageTmp->mtpLsInLsLoadShareAlgorithmLen = tmpsize;
	if (StorageTmp->mtpLsInLsLoadShareAlgorithm == NULL) {
		config_perror("invalid specification for mtpLsInLsLoadShareAlgorithm");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfilePointer, &tmpsize);
	StorageTmp->mtpLsProfilePointerLen = tmpsize;
	if (StorageTmp->mtpLsProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsName, &tmpsize);
	StorageTmp->mtpLsNameLen = tmpsize;
	if (StorageTmp->mtpLsName == NULL) {
		config_perror("invalid specification for mtpLsName");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsAsaProfilePointer, &tmpsize);
	StorageTmp->mtpLsAsaProfilePointerLen = tmpsize;
	if (StorageTmp->mtpLsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLsAlarmStatus, &tmpsize);
	StorageTmp->mtpLsAlarmStatusLen = tmpsize;
	if (StorageTmp->mtpLsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpLsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsRowStatus, &tmpsize);
	mtpLsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
}

/*
 * store_mtpLsTable(): store configuraiton file for mtpLsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpLsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsTable", "storing data...  "));
	refresh_mtpLsTable();
	(void) tmpsize;
	for (hcindex = mtpLsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpLsTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpLsTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			tmpsize = StorageTmp->mtpLsAdjPcLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsAdjPc, &tmpsize);
			tmpsize = StorageTmp->mtpLsRsIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsMaxCapacity, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsCurrentCapacity, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsCongestionControlMethod, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsOperationalState, &tmpsize);
			tmpsize = StorageTmp->mtpLsAvailabilityStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLsAvailabilityStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFail, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsAdministrativeState, &tmpsize);
			tmpsize = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &tmpsize);
			tmpsize = StorageTmp->mtpLsProfilePointerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfilePointer, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks, &tmpsize);
			tmpsize = StorageTmp->mtpLsNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsName, &tmpsize);
			tmpsize = StorageTmp->mtpLsAsaProfilePointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsAsaProfilePointer, &tmpsize);
			tmpsize = StorageTmp->mtpLsAlarmStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLsAlarmStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL3ProfileTable_add(): adds a structure node to our data set
 */
int
mtpSlL3ProfileTable_add(struct mtpSlL3ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSlL3ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSlL3ProfileId, thedata->mtpSlL3ProfileIdLen);
	header_complex_add_data(&mtpSlL3ProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL3ProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL3ProfileTable_del(): delete a structure
 */
int
mtpSlL3ProfileTable_del(struct mtpSlL3ProfileTable_data **thedata)
{
	struct mtpSlL3ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlL3ProfileId);
		StorageDel->mtpSlL3ProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfileName);
		StorageDel->mtpSlL3ProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfileL2Default);
		StorageDel->mtpSlL3ProfileL2DefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL3ProfileTable(): parse configuration file for mtpSlL3ProfileTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL3ProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL3ProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL3ProfileTable_data);

	DEBUGMSGTL(("mtpSlL3ProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileId, &tmpsize);
	StorageTmp->mtpSlL3ProfileIdLen = tmpsize;
	if (StorageTmp->mtpSlL3ProfileId == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT17, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT24I, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileName, &tmpsize);
	StorageTmp->mtpSlL3ProfileNameLen = tmpsize;
	if (StorageTmp->mtpSlL3ProfileName == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT12, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT13, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT14, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT19A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT20A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT21A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT22I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT23I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT31A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT32A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT33A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT34A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT2T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1S, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileL2Default, &tmpsize);
	StorageTmp->mtpSlL3ProfileL2DefaultLen = tmpsize;
	if (StorageTmp->mtpSlL3ProfileL2Default == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileL2Default");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileRowStatus, &tmpsize);
	mtpSlL3ProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
}

/*
 * store_mtpSlL3ProfileTable(): store configuraiton file for mtpSlL3ProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL3ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL3ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "storing data...  "));
	refresh_mtpSlL3ProfileTable();
	(void) tmpsize;
	for (hcindex = mtpSlL3ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL3ProfileTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpSlL3ProfileTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlL3ProfileTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mtpSlL3ProfileIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT17, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT24I, &tmpsize);
			tmpsize = StorageTmp->mtpSlL3ProfileNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT12, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT13, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT14, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT19A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT20A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT21A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT22I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT23I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT31A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT32A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT33A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT34A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT2T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1S, &tmpsize);
			tmpsize = StorageTmp->mtpSlL3ProfileL2DefaultLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileL2Default, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL2ProfileTable_add(): adds a structure node to our data set
 */
int
mtpSlL2ProfileTable_add(struct mtpSlL2ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSlL2ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSlL2ProfileId, thedata->mtpSlL2ProfileIdLen);
	/* mtpSlL2ProfileTransmissionRate */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpSlL2ProfileTransmissionRate, sizeof(thedata->mtpSlL2ProfileTransmissionRate));
	header_complex_add_data(&mtpSlL2ProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL2ProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL2ProfileTable_del(): delete a structure
 */
int
mtpSlL2ProfileTable_del(struct mtpSlL2ProfileTable_data **thedata)
{
	struct mtpSlL2ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlL2ProfileId);
		StorageDel->mtpSlL2ProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSlL2ProfileName);
		StorageDel->mtpSlL2ProfileNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL2ProfileTable(): parse configuration file for mtpSlL2ProfileTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL2ProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL2ProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL2ProfileTable_data);

	DEBUGMSGTL(("mtpSlL2ProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL2ProfileId, &tmpsize);
	StorageTmp->mtpSlL2ProfileIdLen = tmpsize;
	if (StorageTmp->mtpSlL2ProfileId == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTransmissionRate, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2L, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2H, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT4N, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT4E, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileCongestionCounting, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileLoopDelay, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL2ProfileName, &tmpsize);
	StorageTmp->mtpSlL2ProfileNameLen = tmpsize;
	if (StorageTmp->mtpSlL2ProfileName == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset3, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate3, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerTx, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerTy, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileMaxOctRetransN2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileM, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileRowStatus, &tmpsize);
	mtpSlL2ProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
}

/*
 * store_mtpSlL2ProfileTable(): store configuraiton file for mtpSlL2ProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL2ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL2ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "storing data...  "));
	refresh_mtpSlL2ProfileTable();
	(void) tmpsize;
	for (hcindex = mtpSlL2ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL2ProfileTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpSlL2ProfileTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlL2ProfileTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mtpSlL2ProfileIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL2ProfileId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2L, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2H, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT4N, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT4E, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileCongestionCounting, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileLoopDelay, &tmpsize);
			tmpsize = StorageTmp->mtpSlL2ProfileNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL2ProfileName, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset3, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate3, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerTx, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerTy, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileMaxOctRetransN2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileM, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlTable_add(): adds a structure node to our data set
 */
int
mtpSlTable_add(struct mtpSlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	header_complex_add_data(&mtpSlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlTable_del(): delete a structure
 */
int
mtpSlTable_del(struct mtpSlTable_data **thedata)
{
	struct mtpSlTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSlsCodeCurrentList);
		StorageDel->mtpSlSlsCodeCurrentListLen = 0;
		SNMP_FREE(StorageDel->mtpSlLinkTpStatus);
		StorageDel->mtpSlLinkTpStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSlProceduralStatus);
		StorageDel->mtpSlProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSlMtpL2ProtocolProfilePointer);
		StorageDel->mtpSlMtpL2ProtocolProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlSignTermPointer);
		StorageDel->mtpSlSignTermPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlSignDataLinkTpPointer);
		StorageDel->mtpSlSignDataLinkTpPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlAsaProfilePointer);
		StorageDel->mtpSlAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlName);
		StorageDel->mtpSlNameLen = 0;
		SNMP_FREE(StorageDel->mtpSlSlsCodeNormalList);
		StorageDel->mtpSlSlsCodeNormalListLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfilePointer);
		StorageDel->mtpSlL3ProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlAlarmStatus);
		StorageDel->mtpSlAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlTable(): parse configuration file for mtpSlTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlTable_data);

	DEBUGMSGTL(("mtpSlTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeCurrentList, &tmpsize);
	StorageTmp->mtpSlSlsCodeCurrentListLen = tmpsize;
	if (StorageTmp->mtpSlSlsCodeCurrentList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeCurrentList");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlMaxCapacitySL, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCurrentCapacitySL, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlLinkTpStatus, &tmpsize);
	StorageTmp->mtpSlLinkTpStatusLen = tmpsize;
	if (StorageTmp->mtpSlLinkTpStatus == NULL) {
		config_perror("invalid specification for mtpSlLinkTpStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlUsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlProceduralStatus, &tmpsize);
	StorageTmp->mtpSlProceduralStatusLen = tmpsize;
	if (StorageTmp->mtpSlProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSlProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlMtpL2ProtocolProfilePointer, &tmpsize);
	StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen = tmpsize;
	if (StorageTmp->mtpSlMtpL2ProtocolProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlMtpL2ProtocolProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSignTermPointer, &tmpsize);
	StorageTmp->mtpSlSignTermPointerLen = tmpsize;
	if (StorageTmp->mtpSlSignTermPointer == NULL) {
		config_perror("invalid specification for mtpSlSignTermPointer");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSignDataLinkTpPointer, &tmpsize);
	StorageTmp->mtpSlSignDataLinkTpPointerLen = tmpsize;
	if (StorageTmp->mtpSlSignDataLinkTpPointer == NULL) {
		config_perror("invalid specification for mtpSlSignDataLinkTpPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalInhibit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalUninhibit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlReplaceSt, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlAsaProfilePointer, &tmpsize);
	StorageTmp->mtpSlAsaProfilePointerLen = tmpsize;
	if (StorageTmp->mtpSlAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlCongestionLevel, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlList, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlTest, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlName, &tmpsize);
	StorageTmp->mtpSlNameLen = tmpsize;
	if (StorageTmp->mtpSlName == NULL) {
		config_perror("invalid specification for mtpSlName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtList, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeNormalList, &tmpsize);
	StorageTmp->mtpSlSlsCodeNormalListLen = tmpsize;
	if (StorageTmp->mtpSlSlsCodeNormalList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeNormalList");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfilePointer, &tmpsize);
	StorageTmp->mtpSlL3ProfilePointerLen = tmpsize;
	if (StorageTmp->mtpSlL3ProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlL3ProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlAlarmStatus, &tmpsize);
	StorageTmp->mtpSlAlarmStatusLen = tmpsize;
	if (StorageTmp->mtpSlAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSlAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlRowStatus, &tmpsize);
	mtpSlTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
}

/*
 * store_mtpSlTable(): store configuraiton file for mtpSlTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlTable", "storing data...  "));
	refresh_mtpSlTable();
	(void) tmpsize;
	for (hcindex = mtpSlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpSlTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			tmpsize = StorageTmp->mtpSlSlsCodeCurrentListLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeCurrentList, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlMaxCapacitySL, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCurrentCapacitySL, &tmpsize);
			tmpsize = StorageTmp->mtpSlLinkTpStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlLinkTpStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlUsageState, &tmpsize);
			tmpsize = StorageTmp->mtpSlProceduralStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlProceduralStatus, &tmpsize);
			tmpsize = StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlMtpL2ProtocolProfilePointer, &tmpsize);
			tmpsize = StorageTmp->mtpSlSignTermPointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSignTermPointer, &tmpsize);
			tmpsize = StorageTmp->mtpSlSignDataLinkTpPointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSignDataLinkTpPointer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalInhibit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalUninhibit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlReplaceSt, &tmpsize);
			tmpsize = StorageTmp->mtpSlAsaProfilePointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlAsaProfilePointer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlCongestionLevel, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlList, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlTest, &tmpsize);
			tmpsize = StorageTmp->mtpSlNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlName, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtList, &tmpsize);
			tmpsize = StorageTmp->mtpSlSlsCodeNormalListLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeNormalList, &tmpsize);
			tmpsize = StorageTmp->mtpSlL3ProfilePointerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfilePointer, &tmpsize);
			tmpsize = StorageTmp->mtpSlAlarmStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlAlarmStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlSdlListTable_add(): adds a structure node to our data set
 */
int
mtpSlSdlListTable_add(struct mtpSlSdlListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdlListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlSdlListId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdlListId, sizeof(thedata->mtpSlSdlListId));
	header_complex_add_data(&mtpSlSdlListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdlListTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlSdlListTable_del(): delete a structure
 */
int
mtpSlSdlListTable_del(struct mtpSlSdlListTable_data **thedata)
{
	struct mtpSlSdlListTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlSdlListTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSdlListPointer);
		StorageDel->mtpSlSdlListPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlSdlListTable(): parse configuration file for mtpSlSdlListTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlSdlListTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlSdlListTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);

	DEBUGMSGTL(("mtpSlSdlListTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlListId, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdlListPointer, &tmpsize);
	StorageTmp->mtpSlSdlListPointerLen = tmpsize;
	if (StorageTmp->mtpSlSdlListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdlListPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdlListRowStatus, &tmpsize);
	mtpSlSdlListTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
}

/*
 * store_mtpSlSdlListTable(): store configuraiton file for mtpSlSdlListTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdlListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlSdlListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdlListTable", "storing data...  "));
	refresh_mtpSlSdlListTable();
	(void) tmpsize;
	for (hcindex = mtpSlSdlListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdlListTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpSlSdlListTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlSdlListTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlListId, &tmpsize);
			tmpsize = StorageTmp->mtpSlSdlListPointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdlListPointer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdlListRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlSdtListTable_add(): adds a structure node to our data set
 */
int
mtpSlSdtListTable_add(struct mtpSlSdtListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdtListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlSdtListId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdtListId, sizeof(thedata->mtpSlSdtListId));
	header_complex_add_data(&mtpSlSdtListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdtListTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlSdtListTable_del(): delete a structure
 */
int
mtpSlSdtListTable_del(struct mtpSlSdtListTable_data **thedata)
{
	struct mtpSlSdtListTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlSdtListTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSdtListPointer);
		StorageDel->mtpSlSdtListPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlSdtListTable(): parse configuration file for mtpSlSdtListTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlSdtListTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlSdtListTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);

	DEBUGMSGTL(("mtpSlSdtListTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtListId, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdtListPointer, &tmpsize);
	StorageTmp->mtpSlSdtListPointerLen = tmpsize;
	if (StorageTmp->mtpSlSdtListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdtListPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdtListRowStatus, &tmpsize);
	mtpSlSdtListTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
}

/*
 * store_mtpSlSdtListTable(): store configuraiton file for mtpSlSdtListTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdtListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlSdtListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdtListTable", "storing data...  "));
	refresh_mtpSlSdtListTable();
	(void) tmpsize;
	for (hcindex = mtpSlSdtListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdtListTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpSlSdtListTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlSdtListTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtListId, &tmpsize);
			tmpsize = StorageTmp->mtpSlSdtListPointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdtListPointer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdtListRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpNbTable_add(): adds a structure node to our data set
 */
int
mtpNbTable_add(struct mtpNbTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNbTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
	header_complex_add_data(&mtpNbTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNbTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpNbTable_del(): delete a structure
 */
int
mtpNbTable_del(struct mtpNbTable_data **thedata)
{
	struct mtpNbTable_data *StorageDel;

	DEBUGMSGTL(("mtpNbTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpNbTable(): parse configuration file for mtpNbTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpNbTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpNbTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpNbTable_data);

	DEBUGMSGTL(("mtpNbTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &tmpsize);
	StorageTmp->mtpSdtProfileIdLen = tmpsize;
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbTransmissionRate, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTimerT8, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTie, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbT, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbD, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbDe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbUe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbN, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbm, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbb, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbf, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbRowStatus, &tmpsize);
	mtpNbTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
}

/*
 * store_mtpNbTable(): store configuraiton file for mtpNbTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpNbTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpNbTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNbTable", "storing data...  "));
	refresh_mtpNbTable();
	(void) tmpsize;
	for (hcindex = mtpNbTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNbTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpNbTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpNbTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mtpSdtProfileIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTin, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTie, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbT, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbD, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbDe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbUe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbN, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbm, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbb, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbf, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSaalTable_add(): adds a structure node to our data set
 */
int
mtpSaalTable_add(struct mtpSaalTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSaalTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
	header_complex_add_data(&mtpSaalTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSaalTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSaalTable_del(): delete a structure
 */
int
mtpSaalTable_del(struct mtpSaalTable_data **thedata)
{
	struct mtpSaalTable_data *StorageDel;

	DEBUGMSGTL(("mtpSaalTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSaalTable(): parse configuration file for mtpSaalTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSaalTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSaalTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSaalTable_data);

	DEBUGMSGTL(("mtpSaalTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &tmpsize);
	StorageTmp->mtpSdtProfileIdLen = tmpsize;
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalBufferRelease, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxCc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxNrp, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxPd, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxStat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerCc, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerIdle, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerPoll, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalRowStatus, &tmpsize);
	mtpSaalTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
}

/*
 * store_mtpSaalTable(): store configuraiton file for mtpSaalTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSaalTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSaalTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSaalTable", "storing data...  "));
	refresh_mtpSaalTable();
	(void) tmpsize;
	for (hcindex = mtpSaalTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSaalTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpSaalTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSaalTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mtpSdtProfileIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalBufferRelease, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxCc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxNrp, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxPd, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxStat, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalN1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerCc, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerIdle, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerPoll, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpM2paTable_add(): adds a structure node to our data set
 */
int
mtpM2paTable_add(struct mtpM2paTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpM2paTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
	header_complex_add_data(&mtpM2paTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpM2paTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpM2paTable_del(): delete a structure
 */
int
mtpM2paTable_del(struct mtpM2paTable_data **thedata)
{
	struct mtpM2paTable_data *StorageDel;

	DEBUGMSGTL(("mtpM2paTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpM2paTable(): parse configuration file for mtpM2paTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpM2paTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM2paTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpM2paTable_data);

	DEBUGMSGTL(("mtpM2paTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &tmpsize);
	StorageTmp->mtpSdtProfileIdLen = tmpsize;
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paProving, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paManagementProvingState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayUpper, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpLifetime, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paProvingAttempts, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paRowStatus, &tmpsize);
	mtpM2paTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
}

/*
 * store_mtpM2paTable(): store configuraiton file for mtpM2paTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM2paTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM2paTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpM2paTable", "storing data...  "));
	refresh_mtpM2paTable();
	(void) tmpsize;
	for (hcindex = mtpM2paTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM2paTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpM2paTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM2paTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mtpSdtProfileIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paN1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paProving, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paManagementProvingState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayUpper, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpNoDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxseg, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpHeartbeat, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoInitial, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMin, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMax, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieLife, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieInc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxBurst, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpSackDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paProvingAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSdtTable_add(): adds a structure node to our data set
 */
int
mtpSdtTable_add(struct mtpSdtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSdtId, sizeof(thedata->mtpSdtId));
	header_complex_add_data(&mtpSdtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdtTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSdtTable_del(): delete a structure
 */
int
mtpSdtTable_del(struct mtpSdtTable_data **thedata)
{
	struct mtpSdtTable_data *StorageDel;

	DEBUGMSGTL(("mtpSdtTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProceduralStatus);
		StorageDel->mtpSdtProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSdtAvailabilityStatus);
		StorageDel->mtpSdtAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSdtEquipmentPointer);
		StorageDel->mtpSdtEquipmentPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdtName);
		StorageDel->mtpSdtNameLen = 0;
		SNMP_FREE(StorageDel->mtpSdtProfilePointer);
		StorageDel->mtpSdtProfilePointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdtTable(): parse configuration file for mtpSdtTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSdtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdtTable_data);

	DEBUGMSGTL(("mtpSdtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtUsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtProceduralStatus, &tmpsize);
	StorageTmp->mtpSdtProceduralStatusLen = tmpsize;
	if (StorageTmp->mtpSdtProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSdtProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtAvailabilityStatus, &tmpsize);
	StorageTmp->mtpSdtAvailabilityStatusLen = tmpsize;
	if (StorageTmp->mtpSdtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSdtAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtEquipmentPointer, &tmpsize);
	StorageTmp->mtpSdtEquipmentPointerLen = tmpsize;
	if (StorageTmp->mtpSdtEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdtEquipmentPointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtName, &tmpsize);
	StorageTmp->mtpSdtNameLen = tmpsize;
	if (StorageTmp->mtpSdtName == NULL) {
		config_perror("invalid specification for mtpSdtName");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtProfilePointer, &tmpsize);
	StorageTmp->mtpSdtProfilePointerLen = tmpsize;
	if (StorageTmp->mtpSdtProfilePointer == NULL) {
		config_perror("invalid specification for mtpSdtProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtRowStatus, &tmpsize);
	mtpSdtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
}

/*
 * store_mtpSdtTable(): store configuraiton file for mtpSdtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSdtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdtTable", "storing data...  "));
	refresh_mtpSdtTable();
	(void) tmpsize;
	for (hcindex = mtpSdtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdtTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpSdtTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSdtTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtUsageState, &tmpsize);
			tmpsize = StorageTmp->mtpSdtProceduralStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtProceduralStatus, &tmpsize);
			tmpsize = StorageTmp->mtpSdtAvailabilityStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtAvailabilityStatus, &tmpsize);
			tmpsize = StorageTmp->mtpSdtEquipmentPointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtEquipmentPointer, &tmpsize);
			tmpsize = StorageTmp->mtpSdtNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtName, &tmpsize);
			tmpsize = StorageTmp->mtpSdtProfilePointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtProfilePointer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSdlTable_add(): adds a structure node to our data set
 */
int
mtpSdlTable_add(struct mtpSdlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdlId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSdlId, sizeof(thedata->mtpSdlId));
	header_complex_add_data(&mtpSdlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdlTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSdlTable_del(): delete a structure
 */
int
mtpSdlTable_del(struct mtpSdlTable_data **thedata)
{
	struct mtpSdlTable_data *StorageDel;

	DEBUGMSGTL(("mtpSdlTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdlAdjPc);
		StorageDel->mtpSdlAdjPcLen = 0;
		SNMP_FREE(StorageDel->mtpSdlEquipmentPointer);
		StorageDel->mtpSdlEquipmentPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdlName);
		StorageDel->mtpSdlNameLen = 0;
		SNMP_FREE(StorageDel->mtpSdlStmChannel);
		StorageDel->mtpSdlStmChannelLen = 0;
		SNMP_FREE(StorageDel->mtpSdlVcTTpPointer);
		StorageDel->mtpSdlVcTTpPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdlTable(): parse configuration file for mtpSdlTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdlTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSdlTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdlTable_data);

	DEBUGMSGTL(("mtpSdlTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlAdjPc, &tmpsize);
	StorageTmp->mtpSdlAdjPcLen = tmpsize;
	if (StorageTmp->mtpSdlAdjPc == NULL) {
		config_perror("invalid specification for mtpSdlAdjPc");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlTransmissionRate, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlLoopDelay, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlOperationalState, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlEquipmentPointer, &tmpsize);
	StorageTmp->mtpSdlEquipmentPointerLen = tmpsize;
	if (StorageTmp->mtpSdlEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdlEquipmentPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlCIC, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlName, &tmpsize);
	StorageTmp->mtpSdlNameLen = tmpsize;
	if (StorageTmp->mtpSdlName == NULL) {
		config_perror("invalid specification for mtpSdlName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlStmChannel, &tmpsize);
	StorageTmp->mtpSdlStmChannelLen = tmpsize;
	if (StorageTmp->mtpSdlStmChannel == NULL) {
		config_perror("invalid specification for mtpSdlStmChannel");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlVcTTpPointer, &tmpsize);
	StorageTmp->mtpSdlVcTTpPointerLen = tmpsize;
	if (StorageTmp->mtpSdlVcTTpPointer == NULL) {
		config_perror("invalid specification for mtpSdlVcTTpPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlRowStatus, &tmpsize);
	mtpSdlTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
}

/*
 * store_mtpSdlTable(): store configuraiton file for mtpSdlTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSdlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdlTable", "storing data...  "));
	refresh_mtpSdlTable();
	(void) tmpsize;
	for (hcindex = mtpSdlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdlTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpSdlTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSdlTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlId, &tmpsize);
			tmpsize = StorageTmp->mtpSdlAdjPcLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlAdjPc, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlLoopDelay, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlOperationalState, &tmpsize);
			tmpsize = StorageTmp->mtpSdlEquipmentPointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlEquipmentPointer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlCIC, &tmpsize);
			tmpsize = StorageTmp->mtpSdlNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlName, &tmpsize);
			tmpsize = StorageTmp->mtpSdlStmChannelLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlStmChannel, &tmpsize);
			tmpsize = StorageTmp->mtpSdlVcTTpPointerLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlVcTTpPointer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpSapTable(): refresh mtpSapTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSapTable(void)
{
	if (mtpSapTable_refresh == 0)
		return;
	mtpSapTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSapTable_row(): refresh mtpSapTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
{
	if (StorageTmp->mtpSapTable_request == sa_request)
		return;
	StorageTmp->mtpSapTable_request = sa_request;
}

/*
 * var_mtpSapTable(): locate variables in mtpSapTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSapTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSapTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSapTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSapTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSAP2ADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSap2Address);
		return (u_char *) &StorageTmp->mtpSap2Address;
	case MTPSAPUSERPART:
		*write_method = write_mtpSapUserPart;
		*var_len = sizeof(StorageTmp->mtpSapUserPart);
		return (u_char *) &StorageTmp->mtpSapUserPart;
	case MTPSAPUSERPARTSTATUS:
		*write_method = write_mtpSapUserPartStatus;
		*var_len = sizeof(StorageTmp->mtpSapUserPartStatus);
		return (u_char *) &StorageTmp->mtpSapUserPartStatus;
	case MTPSAPUSERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSapUserEntityNamesLen;
		return (u_char *) StorageTmp->mtpSapUserEntityNames;
	case MTPSAPPROVIDERENTITYNAMES:
		*write_method = write_mtpSapProviderEntityNames;
		*var_len = StorageTmp->mtpSapProviderEntityNamesLen;
		return (u_char *) StorageTmp->mtpSapProviderEntityNames;
	case MTPSAPUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSapUsageState);
		return (u_char *) &StorageTmp->mtpSapUsageState;
	case MTPSAPASAPROFILEPOINTER:
		*write_method = write_mtpSapAsaProfilePointer;
		*var_len = StorageTmp->mtpSapAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpSapAsaProfilePointer;
	case MTPSAPNAME:
		*write_method = write_mtpSapName;
		*var_len = StorageTmp->mtpSapNameLen;
		return (u_char *) StorageTmp->mtpSapName;
	case MTPSAPLONGMESSAGESUPPORTED:
		*write_method = write_mtpSapLongMessageSupported;
		*var_len = sizeof(StorageTmp->mtpSapLongMessageSupported);
		return (u_char *) &StorageTmp->mtpSapLongMessageSupported;
	case MTPSAPROWSTATUS:
		*write_method = write_mtpSapRowStatus;
		*var_len = sizeof(StorageTmp->mtpSapRowStatus);
		return (u_char *) &StorageTmp->mtpSapRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpMsTable(): refresh mtpMsTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpMsTable(void)
{
	if (mtpMsTable_refresh == 0)
		return;
	mtpMsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpMsTable_row(): refresh mtpMsTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
{
	if (StorageTmp->mtpMsTable_request == sa_request)
		return;
	StorageTmp->mtpMsTable_request = sa_request;
}

/*
 * var_mtpMsTable(): locate variables in mtpMsTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpMsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpMsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpMsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpMsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpMsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPMSNAME:
		*write_method = write_mtpMsName;
		*var_len = StorageTmp->mtpMsNameLen;
		return (u_char *) StorageTmp->mtpMsName;
	case MTPMSALARMSTATUS:
		*write_method = write_mtpMsAlarmStatus;
		*var_len = StorageTmp->mtpMsAlarmStatusLen;
		return (u_char *) StorageTmp->mtpMsAlarmStatus;
	case MTPMSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpMsOperationalState);
		return (u_char *) &StorageTmp->mtpMsOperationalState;
	case MTPMSUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpMsUsageState);
		return (u_char *) &StorageTmp->mtpMsUsageState;
	case MTPMSMANAGEDELEMENTTYPE:
		*write_method = write_mtpMsManagedElementType;
		*var_len = StorageTmp->mtpMsManagedElementTypeLen;
		return (u_char *) StorageTmp->mtpMsManagedElementType;
	case MTPMSMODELCODE:
		*write_method = write_mtpMsModelCode;
		*var_len = StorageTmp->mtpMsModelCodeLen;
		return (u_char *) StorageTmp->mtpMsModelCode;
	case MTPMSVENDORNAME:
		*write_method = write_mtpMsVendorName;
		*var_len = StorageTmp->mtpMsVendorNameLen;
		return (u_char *) StorageTmp->mtpMsVendorName;
	case MTPMSUSERLABEL:
		*write_method = write_mtpMsUserLabel;
		*var_len = StorageTmp->mtpMsUserLabelLen;
		return (u_char *) StorageTmp->mtpMsUserLabel;
	case MTPMSVERSION:
		*write_method = write_mtpMsVersion;
		*var_len = StorageTmp->mtpMsVersionLen;
		return (u_char *) StorageTmp->mtpMsVersion;
	case MTPMSASAPROFILEPOINTER:
		*write_method = write_mtpMsAsaProfilePointer;
		*var_len = StorageTmp->mtpMsAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpMsAsaProfilePointer;
	case MTPMSNETWORKELEMENTALIASES:
		*write_method = write_mtpMsNetworkElementAliases;
		*var_len = StorageTmp->mtpMsNetworkElementAliasesLen;
		return (u_char *) StorageTmp->mtpMsNetworkElementAliases;
	case MTPMSSTATUS:
		*write_method = write_mtpMsStatus;
		*var_len = sizeof(StorageTmp->mtpMsStatus);
		return (u_char *) &StorageTmp->mtpMsStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpNaTable(): refresh mtpNaTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpNaTable(void)
{
	if (mtpNaTable_refresh == 0)
		return;
	mtpNaTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpNaTable_row(): refresh mtpNaTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
{
	if (StorageTmp->mtpNaTable_request == sa_request)
		return;
	StorageTmp->mtpNaTable_request = sa_request;
}

/*
 * var_mtpNaTable(): locate variables in mtpNaTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpNaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpNaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpNaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpNaTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpNaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpNaTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPNAPROTOCOLVARIANT:
		*write_method = write_mtpNaProtocolVariant;
		*var_len = StorageTmp->mtpNaProtocolVariantLen;
		return (u_char *) StorageTmp->mtpNaProtocolVariant;
	case MTPNAPROTOCOLYEAR:
		*write_method = write_mtpNaProtocolYear;
		*var_len = sizeof(StorageTmp->mtpNaProtocolYear);
		return (u_char *) &StorageTmp->mtpNaProtocolYear;
	case MTPNAPROTOCOLOPTIONS:
		*write_method = write_mtpNaProtocolOptions;
		*var_len = StorageTmp->mtpNaProtocolOptionsLen;
		return (u_char *) StorageTmp->mtpNaProtocolOptions;
	case MTPNANETWORKINDICATOR:
		*write_method = write_mtpNaNetworkIndicator;
		*var_len = sizeof(StorageTmp->mtpNaNetworkIndicator);
		return (u_char *) &StorageTmp->mtpNaNetworkIndicator;
	case MTPNAPOINTCODEFORMAT:
		*write_method = write_mtpNaPointCodeFormat;
		*var_len = StorageTmp->mtpNaPointCodeFormatLen;
		return (u_char *) StorageTmp->mtpNaPointCodeFormat;
	case MTPNASLSLENGTH:
		*write_method = write_mtpNaSlsLength;
		*var_len = sizeof(StorageTmp->mtpNaSlsLength);
		return (u_char *) &StorageTmp->mtpNaSlsLength;
	case MTPNASPDEFAULT:
		*write_method = write_mtpNaSpDefault;
		*var_len = StorageTmp->mtpNaSpDefaultLen;
		return (u_char *) StorageTmp->mtpNaSpDefault;
	case MTPNANAME:
		*write_method = write_mtpNaName;
		*var_len = StorageTmp->mtpNaNameLen;
		return (u_char *) StorageTmp->mtpNaName;
	case MTPNAROWSTATUS:
		*write_method = write_mtpNaRowStatus;
		*var_len = sizeof(StorageTmp->mtpNaRowStatus);
		return (u_char *) &StorageTmp->mtpNaRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsTable(): refresh mtpGsTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsTable(void)
{
	if (mtpGsTable_refresh == 0)
		return;
	mtpGsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpGsTable_row(): refresh mtpGsTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsTable_request == sa_request)
		return;
	StorageTmp->mtpGsTable_request = sa_request;
}

/*
 * var_mtpGsTable(): locate variables in mtpGsTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpGsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPGSADMINISTRATIVESTATE:
		*write_method = write_mtpGsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpGsAdministrativeState);
		return (u_char *) &StorageTmp->mtpGsAdministrativeState;
	case MTPGSTREATMENTOFOUTSIDERANGES:
		*write_method = write_mtpGsTreatmentOfOutsideRanges;
		*var_len = sizeof(StorageTmp->mtpGsTreatmentOfOutsideRanges);
		return (u_char *) &StorageTmp->mtpGsTreatmentOfOutsideRanges;
	case MTPGSLISTMODE:
		*write_method = write_mtpGsListMode;
		*var_len = sizeof(StorageTmp->mtpGsListMode);
		return (u_char *) &StorageTmp->mtpGsListMode;
	case MTPGSSCREENINGBYLINKSETORBYOPC:
		*write_method = write_mtpGsScreeningByLinkSetOrByOpc;
		*var_len = sizeof(StorageTmp->mtpGsScreeningByLinkSetOrByOpc);
		return (u_char *) &StorageTmp->mtpGsScreeningByLinkSetOrByOpc;
	case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC:
		*write_method = write_mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		*var_len = sizeof(StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc);
		return (u_char *) &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
	case MTPGSNAME:
		*write_method = write_mtpGsName;
		*var_len = StorageTmp->mtpGsNameLen;
		return (u_char *) StorageTmp->mtpGsName;
	case MTPGSROWSTATUS:
		*write_method = write_mtpGsRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsRowStatus);
		return (u_char *) &StorageTmp->mtpGsRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsLineTable(): refresh mtpGsLineTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsLineTable(void)
{
	if (mtpGsLineTable_refresh == 0)
		return;
	mtpGsLineTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpGsLineTable_row(): refresh mtpGsLineTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsLineTable_request == sa_request)
		return;
	StorageTmp->mtpGsLineTable_request = sa_request;
}

/*
 * var_mtpGsLineTable(): locate variables in mtpGsLineTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsLineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsLineTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsLineTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsLineTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsLineTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpGsLineTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPGSLINEOBJECT:
		*write_method = write_mtpGsLineObject;
		*var_len = StorageTmp->mtpGsLineObjectLen;
		return (u_char *) StorageTmp->mtpGsLineObject;
	case MTPGSLINECONTENT:
		*write_method = write_mtpGsLineContent;
		*var_len = sizeof(StorageTmp->mtpGsLineContent);
		return (u_char *) &StorageTmp->mtpGsLineContent;
	case MTPGSLINEROWSTATUS:
		*write_method = write_mtpGsLineRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsLineRowStatus);
		return (u_char *) &StorageTmp->mtpGsLineRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsLineContentTable(): refresh mtpGsLineContentTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsLineContentTable(void)
{
	if (mtpGsLineContentTable_refresh == 0)
		return;
	mtpGsLineContentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpGsLineContentTable_row(): refresh mtpGsLineContentTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsLineContentTable_request == sa_request)
		return;
	StorageTmp->mtpGsLineContentTable_request = sa_request;
}

/*
 * var_mtpGsLineContentTable(): locate variables in mtpGsLineContentTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsLineContentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsLineContentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsLineContentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpGsLineContentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPGSLINECONTENTDESIGNATEDDPCFIRST:
		*write_method = write_mtpGsLineContentDesignatedDPCFirst;
		*var_len = StorageTmp->mtpGsLineContentDesignatedDPCFirstLen;
		return (u_char *) StorageTmp->mtpGsLineContentDesignatedDPCFirst;
	case MTPGSLINECONTENTDESIGNATEDDPCLAST:
		*write_method = write_mtpGsLineContentDesignatedDPCLast;
		*var_len = StorageTmp->mtpGsLineContentDesignatedDPCLastLen;
		return (u_char *) StorageTmp->mtpGsLineContentDesignatedDPCLast;
	case MTPGSLINECONTENTSIMASK:
		*write_method = write_mtpGsLineContentSiMask;
		*var_len = StorageTmp->mtpGsLineContentSiMaskLen;
		return (u_char *) StorageTmp->mtpGsLineContentSiMask;
	case MTPGSLINECONTENTMESSAGETREATMENT:
		*write_method = write_mtpGsLineContentMessageTreatment;
		*var_len = sizeof(StorageTmp->mtpGsLineContentMessageTreatment);
		return (u_char *) &StorageTmp->mtpGsLineContentMessageTreatment;
	case MTPGSLINECONTENTCOMMENT:
		*write_method = write_mtpGsLineContentComment;
		*var_len = StorageTmp->mtpGsLineContentCommentLen;
		return (u_char *) StorageTmp->mtpGsLineContentComment;
	case MTPGSLINECONTENTROWSTATUS:
		*write_method = write_mtpGsLineContentRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsLineContentRowStatus);
		return (u_char *) &StorageTmp->mtpGsLineContentRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpProfileTable(): refresh mtpSpProfileTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSpProfileTable(void)
{
	if (mtpSpProfileTable_refresh == 0)
		return;
	mtpSpProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpProfileTable_row(): refresh mtpSpProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSpProfileTable_request = sa_request;
}

/*
 * var_mtpSpProfileTable(): locate variables in mtpSpProfileTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSPPROFILETIMERT1R:
		*write_method = write_mtpSpProfileTimerT1R;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT1R);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT1R;
	case MTPSPPROFILETIMERT2:
		*write_method = write_mtpSpProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT2);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT2;
	case MTPSPPROFILETIMERT4:
		*write_method = write_mtpSpProfileTimerT4;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT4);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT4;
	case MTPSPPROFILETIMERT5:
		*write_method = write_mtpSpProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT5);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT5;
	case MTPSPPROFILETIMERT7:
		*write_method = write_mtpSpProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT7);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT7;
	case MTPSPPROFILETIMERT11:
		*write_method = write_mtpSpProfileTimerT11;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT11);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT11;
	case MTPSPPROFILETIMERT12:
		*write_method = write_mtpSpProfileTimerT12;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT12);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT12;
	case MTPSPPROFILETIMERT13:
		*write_method = write_mtpSpProfileTimerT13;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT13);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT13;
	case MTPSPPROFILETIMERT14:
		*write_method = write_mtpSpProfileTimerT14;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT14);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT14;
	case MTPSPPROFILETIMERT15:
		*write_method = write_mtpSpProfileTimerT15;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT15);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT15;
	case MTPSPPROFILETIMERT16:
		*write_method = write_mtpSpProfileTimerT16;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT16);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT16;
	case MTPSPPROFILETIMERT18I:
		*write_method = write_mtpSpProfileTimerT18I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT18I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT18I;
	case MTPSPPROFILETIMERT19I:
		*write_method = write_mtpSpProfileTimerT19I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT19I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT19I;
	case MTPSPPROFILETIMERT20I:
		*write_method = write_mtpSpProfileTimerT20I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT20I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT20I;
	case MTPSPPROFILETIMERT21I:
		*write_method = write_mtpSpProfileTimerT21I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT21I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT21I;
	case MTPSPPROFILETIMERT22I:
		*write_method = write_mtpSpProfileTimerT22I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT22I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT22I;
	case MTPSPPROFILETIMERT23I:
		*write_method = write_mtpSpProfileTimerT23I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT23I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT23I;
	case MTPSPPROFILETIMERT20A:
		*write_method = write_mtpSpProfileTimerT20A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT20A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT20A;
	case MTPSPPROFILETIMERT21A:
		*write_method = write_mtpSpProfileTimerT21A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT21A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT21A;
	case MTPSPPROFILETIMERT22A:
		*write_method = write_mtpSpProfileTimerT22A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT22A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT22A;
	case MTPSPPROFILETIMERT23A:
		*write_method = write_mtpSpProfileTimerT23A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT23A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT23A;
	case MTPSPPROFILETIMERT24A:
		*write_method = write_mtpSpProfileTimerT24A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT24A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT24A;
	case MTPSPPROFILETIMERT26A:
		*write_method = write_mtpSpProfileTimerT26A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT26A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT26A;
	case MTPSPPROFILETIMERT27A:
		*write_method = write_mtpSpProfileTimerT27A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT27A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT27A;
	case MTPSPPROFILETIMERT1T:
		*write_method = write_mtpSpProfileTimerT1T;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT1T);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT1T;
	case MTPSPPROFILETIMERT2T:
		*write_method = write_mtpSpProfileTimerT2T;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT2T);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT2T;
	case MTPSPPROFILENAME:
		*write_method = write_mtpSpProfileName;
		*var_len = StorageTmp->mtpSpProfileNameLen;
		return (u_char *) StorageTmp->mtpSpProfileName;
	case MTPSPPROFILEROWSTATUS:
		*write_method = write_mtpSpProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpSpProfileRowStatus);
		return (u_char *) &StorageTmp->mtpSpProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpTable(): refresh mtpSpTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSpTable(void)
{
	if (mtpSpTable_refresh == 0)
		return;
	mtpSpTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpTable_row(): refresh mtpSpTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpTable_request == sa_request)
		return;
	StorageTmp->mtpSpTable_request = sa_request;
}

/*
 * var_mtpSpTable(): locate variables in mtpSpTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSPPOINTCODE:
		*write_method = write_mtpSpPointCode;
		*var_len = StorageTmp->mtpSpPointCodeLen;
		return (u_char *) StorageTmp->mtpSpPointCode;
	case MTPSPTYPE:
		*write_method = write_mtpSpType;
		*var_len = sizeof(StorageTmp->mtpSpType);
		return (u_char *) &StorageTmp->mtpSpType;
	case MTPSPOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpOperationalState);
		return (u_char *) &StorageTmp->mtpSpOperationalState;
	case MTPSPPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSpProceduralStatusLen;
		return (u_char *) StorageTmp->mtpSpProceduralStatus;
	case MTPSPAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSpAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpSpAvailabilityStatus;
	case MTPSPVERSION:
		*write_method = write_mtpSpVersion;
		*var_len = StorageTmp->mtpSpVersionLen;
		return (u_char *) StorageTmp->mtpSpVersion;
	case MTPSPNETWORKINDICATOR:
		*write_method = write_mtpSpNetworkIndicator;
		*var_len = sizeof(StorageTmp->mtpSpNetworkIndicator);
		return (u_char *) &StorageTmp->mtpSpNetworkIndicator;
	case MTPSPNAME:
		*write_method = write_mtpSpName;
		*var_len = StorageTmp->mtpSpNameLen;
		return (u_char *) StorageTmp->mtpSpName;
	case MTPSPMTPT1:
		*write_method = write_mtpSpMtpT1;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1);
		return (u_char *) &StorageTmp->mtpSpMtpT1;
	case MTPSPMTPT2:
		*write_method = write_mtpSpMtpT2;
		*var_len = sizeof(StorageTmp->mtpSpMtpT2);
		return (u_char *) &StorageTmp->mtpSpMtpT2;
	case MTPSPMTPT3:
		*write_method = write_mtpSpMtpT3;
		*var_len = sizeof(StorageTmp->mtpSpMtpT3);
		return (u_char *) &StorageTmp->mtpSpMtpT3;
	case MTPSPMTPT4:
		*write_method = write_mtpSpMtpT4;
		*var_len = sizeof(StorageTmp->mtpSpMtpT4);
		return (u_char *) &StorageTmp->mtpSpMtpT4;
	case MTPSPMTPT5:
		*write_method = write_mtpSpMtpT5;
		*var_len = sizeof(StorageTmp->mtpSpMtpT5);
		return (u_char *) &StorageTmp->mtpSpMtpT5;
	case MTPSPMTPT6:
		*write_method = write_mtpSpMtpT6;
		*var_len = sizeof(StorageTmp->mtpSpMtpT6);
		return (u_char *) &StorageTmp->mtpSpMtpT6;
	case MTPSPMTPT7:
		*write_method = write_mtpSpMtpT7;
		*var_len = sizeof(StorageTmp->mtpSpMtpT7);
		return (u_char *) &StorageTmp->mtpSpMtpT7;
	case MTPSPMTPT8:
		*write_method = write_mtpSpMtpT8;
		*var_len = sizeof(StorageTmp->mtpSpMtpT8);
		return (u_char *) &StorageTmp->mtpSpMtpT8;
	case MTPSPMTPT10:
		*write_method = write_mtpSpMtpT10;
		*var_len = sizeof(StorageTmp->mtpSpMtpT10);
		return (u_char *) &StorageTmp->mtpSpMtpT10;
	case MTPSPMTPT11:
		*write_method = write_mtpSpMtpT11;
		*var_len = sizeof(StorageTmp->mtpSpMtpT11);
		return (u_char *) &StorageTmp->mtpSpMtpT11;
	case MTPSPMTPT12:
		*write_method = write_mtpSpMtpT12;
		*var_len = sizeof(StorageTmp->mtpSpMtpT12);
		return (u_char *) &StorageTmp->mtpSpMtpT12;
	case MTPSPMTPT13:
		*write_method = write_mtpSpMtpT13;
		*var_len = sizeof(StorageTmp->mtpSpMtpT13);
		return (u_char *) &StorageTmp->mtpSpMtpT13;
	case MTPSPMTPT14:
		*write_method = write_mtpSpMtpT14;
		*var_len = sizeof(StorageTmp->mtpSpMtpT14);
		return (u_char *) &StorageTmp->mtpSpMtpT14;
	case MTPSPMTPT15:
		*write_method = write_mtpSpMtpT15;
		*var_len = sizeof(StorageTmp->mtpSpMtpT15);
		return (u_char *) &StorageTmp->mtpSpMtpT15;
	case MTPSPMTPT16:
		*write_method = write_mtpSpMtpT16;
		*var_len = sizeof(StorageTmp->mtpSpMtpT16);
		return (u_char *) &StorageTmp->mtpSpMtpT16;
	case MTPSPMTPT17:
		*write_method = write_mtpSpMtpT17;
		*var_len = sizeof(StorageTmp->mtpSpMtpT17);
		return (u_char *) &StorageTmp->mtpSpMtpT17;
	case MTPSPMTPT19A:
		*write_method = write_mtpSpMtpT19A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT19A);
		return (u_char *) &StorageTmp->mtpSpMtpT19A;
	case MTPSPMTPT31A:
		*write_method = write_mtpSpMtpT31A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT31A);
		return (u_char *) &StorageTmp->mtpSpMtpT31A;
	case MTPSPMTPT32A:
		*write_method = write_mtpSpMtpT32A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT32A);
		return (u_char *) &StorageTmp->mtpSpMtpT32A;
	case MTPSPMTPT33A:
		*write_method = write_mtpSpMtpT33A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT33A);
		return (u_char *) &StorageTmp->mtpSpMtpT33A;
	case MTPSPMTPT34A:
		*write_method = write_mtpSpMtpT34A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT34A);
		return (u_char *) &StorageTmp->mtpSpMtpT34A;
	case MTPSPMTPT18I:
		*write_method = write_mtpSpMtpT18I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT18I);
		return (u_char *) &StorageTmp->mtpSpMtpT18I;
	case MTPSPMTPT19I:
		*write_method = write_mtpSpMtpT19I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT19I);
		return (u_char *) &StorageTmp->mtpSpMtpT19I;
	case MTPSPMTPT20I:
		*write_method = write_mtpSpMtpT20I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT20I);
		return (u_char *) &StorageTmp->mtpSpMtpT20I;
	case MTPSPMTPT21I:
		*write_method = write_mtpSpMtpT21I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT21I);
		return (u_char *) &StorageTmp->mtpSpMtpT21I;
	case MTPSPMTPT22I:
		*write_method = write_mtpSpMtpT22I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT22I);
		return (u_char *) &StorageTmp->mtpSpMtpT22I;
	case MTPSPMTPT23I:
		*write_method = write_mtpSpMtpT23I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT23I);
		return (u_char *) &StorageTmp->mtpSpMtpT23I;
	case MTPSPMTPT20A:
		*write_method = write_mtpSpMtpT20A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT20A);
		return (u_char *) &StorageTmp->mtpSpMtpT20A;
	case MTPSPMTPT21A:
		*write_method = write_mtpSpMtpT21A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT21A);
		return (u_char *) &StorageTmp->mtpSpMtpT21A;
	case MTPSPMTPT24I:
		*write_method = write_mtpSpMtpT24I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT24I);
		return (u_char *) &StorageTmp->mtpSpMtpT24I;
	case MTPSPMTPT1T:
		*write_method = write_mtpSpMtpT1T;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1T);
		return (u_char *) &StorageTmp->mtpSpMtpT1T;
	case MTPSPMTPT2T:
		*write_method = write_mtpSpMtpT2T;
		*var_len = sizeof(StorageTmp->mtpSpMtpT2T);
		return (u_char *) &StorageTmp->mtpSpMtpT2T;
	case MTPSPMTPT1S:
		*write_method = write_mtpSpMtpT1S;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1S);
		return (u_char *) &StorageTmp->mtpSpMtpT1S;
	case MTPSPPROFILEPOINTER:
		*write_method = write_mtpSpProfilePointer;
		*var_len = StorageTmp->mtpSpProfilePointerLen;
		return (u_char *) StorageTmp->mtpSpProfilePointer;
	case MTPSPNAPOINTER:
		*write_method = write_mtpSpNaPointer;
		*var_len = StorageTmp->mtpSpNaPointerLen;
		return (u_char *) StorageTmp->mtpSpNaPointer;
	case MTPSPFLAGS:
		*write_method = write_mtpSpFlags;
		*var_len = StorageTmp->mtpSpFlagsLen;
		return (u_char *) StorageTmp->mtpSpFlags;
	case MTPSPUSERS:
		*write_method = write_mtpSpUsers;
		*var_len = StorageTmp->mtpSpUsersLen;
		return (u_char *) StorageTmp->mtpSpUsers;
	case MTPSPALARMSTATUS:
		*write_method = write_mtpSpAlarmStatus;
		*var_len = StorageTmp->mtpSpAlarmStatusLen;
		return (u_char *) StorageTmp->mtpSpAlarmStatus;
	case MTPSPROWSTATUS:
		*write_method = write_mtpSpRowStatus;
		*var_len = sizeof(StorageTmp->mtpSpRowStatus);
		return (u_char *) &StorageTmp->mtpSpRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpL3Table(): refresh mtpL3Table
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpL3Table(void)
{
	if (mtpL3Table_refresh == 0)
		return;
	mtpL3Table_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpL3Table_row(): refresh mtpL3Table row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
{
	if (StorageTmp->mtpL3Table_request == sa_request)
		return;
	StorageTmp->mtpL3Table_request = sa_request;
}

/*
 * var_mtpL3Table(): locate variables in mtpL3Table
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpL3Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpL3Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpL3Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpL3Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpL3TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpL3Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPL3ADMINISTRATIVESTATE:
		*write_method = write_mtpL3AdministrativeState;
		*var_len = sizeof(StorageTmp->mtpL3AdministrativeState);
		return (u_char *) &StorageTmp->mtpL3AdministrativeState;
	case MTPL3OPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL3OperationalState);
		return (u_char *) &StorageTmp->mtpL3OperationalState;
	case MTPL3USAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL3UsageState);
		return (u_char *) &StorageTmp->mtpL3UsageState;
	case MTPL3PROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpL3ProceduralStatusLen;
		return (u_char *) StorageTmp->mtpL3ProceduralStatus;
	case MTPL3ASAPROFILEPOINTER:
		*write_method = write_mtpL3AsaProfilePointer;
		*var_len = StorageTmp->mtpL3AsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpL3AsaProfilePointer;
	case MTPL3NAME:
		*write_method = write_mtpL3Name;
		*var_len = StorageTmp->mtpL3NameLen;
		return (u_char *) StorageTmp->mtpL3Name;
	case MTPL3ROWSTATUS:
		*write_method = write_mtpL3RowStatus;
		*var_len = sizeof(StorageTmp->mtpL3RowStatus);
		return (u_char *) &StorageTmp->mtpL3RowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsProfileTable(): refresh mtpRsProfileTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRsProfileTable(void)
{
	if (mtpRsProfileTable_refresh == 0)
		return;
	mtpRsProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsProfileTable_row(): refresh mtpRsProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsProfileTable_request == sa_request)
		return;
	StorageTmp->mtpRsProfileTable_request = sa_request;
}

/*
 * var_mtpRsProfileTable(): locate variables in mtpRsProfileTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPRSPROFILENAME:
		*write_method = write_mtpRsProfileName;
		*var_len = StorageTmp->mtpRsProfileNameLen;
		return (u_char *) StorageTmp->mtpRsProfileName;
	case MTPRSPROFILETIMERT8:
		*write_method = write_mtpRsProfileTimerT8;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT8);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT8;
	case MTPRSPROFILETIMERT11:
		*write_method = write_mtpRsProfileTimerT11;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT11);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT11;
	case MTPRSPROFILETIMERT15:
		*write_method = write_mtpRsProfileTimerT15;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT15);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT15;
	case MTPRSPROFILETIMERT16:
		*write_method = write_mtpRsProfileTimerT16;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT16);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT16;
	case MTPRSPROFILETIMERT18A:
		*write_method = write_mtpRsProfileTimerT18A;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT18A);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT18A;
	case MTPRSPROFILERTDEFAULT:
		*write_method = write_mtpRsProfileRtDefault;
		*var_len = StorageTmp->mtpRsProfileRtDefaultLen;
		return (u_char *) StorageTmp->mtpRsProfileRtDefault;
	case MTPRSPROFILEROWSTATUS:
		*write_method = write_mtpRsProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpRsProfileRowStatus);
		return (u_char *) &StorageTmp->mtpRsProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsTable(): refresh mtpRsTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRsTable(void)
{
	if (mtpRsTable_refresh == 0)
		return;
	mtpRsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsTable_row(): refresh mtpRsTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsTable_request == sa_request)
		return;
	StorageTmp->mtpRsTable_request = sa_request;
}

/*
 * var_mtpRsTable(): locate variables in mtpRsTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPRSDEST:
		*write_method = write_mtpRsDest;
		*var_len = StorageTmp->mtpRsDestLen;
		return (u_char *) StorageTmp->mtpRsDest;
	case MTPRSFLAGS:
		*write_method = write_mtpRsFlags;
		*var_len = StorageTmp->mtpRsFlagsLen;
		return (u_char *) StorageTmp->mtpRsFlags;
	case MTPRSADMINISTRATIVESTATE:
		*write_method = write_mtpRsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpRsAdministrativeState);
		return (u_char *) &StorageTmp->mtpRsAdministrativeState;
	case MTPRSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsOperationalState);
		return (u_char *) &StorageTmp->mtpRsOperationalState;
	case MTPRSASAPROFILEPOINTER:
		*write_method = write_mtpRsAsaProfilePointer;
		*var_len = StorageTmp->mtpRsAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpRsAsaProfilePointer;
	case MTPRSCONGESTEDSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCongestedState);
		return (u_char *) &StorageTmp->mtpRsCongestedState;
	case MTPRSCONGESTIONLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCongestionLevel);
		return (u_char *) &StorageTmp->mtpRsCongestionLevel;
	case MTPRSLOADSHARINGINFORMATION:
		*write_method = write_mtpRsLoadsharingInformation;
		*var_len = StorageTmp->mtpRsLoadsharingInformationLen;
		return (u_char *) StorageTmp->mtpRsLoadsharingInformation;
	case MTPRSLOADSHARINGOBJECT:
		*write_method = write_mtpRsLoadsharingObject;
		*var_len = StorageTmp->mtpRsLoadsharingObjectLen;
		return (u_char *) StorageTmp->mtpRsLoadsharingObject;
	case MTPRSREMOTEEXCHANGELABEL:
		*write_method = write_mtpRsRemoteExchangeLabel;
		*var_len = StorageTmp->mtpRsRemoteExchangeLabelLen;
		return (u_char *) StorageTmp->mtpRsRemoteExchangeLabel;
	case MTPRSNAME:
		*write_method = write_mtpRsName;
		*var_len = StorageTmp->mtpRsNameLen;
		return (u_char *) StorageTmp->mtpRsName;
	case MTPRSPROFILE:
		*write_method = write_mtpRsProfile;
		*var_len = StorageTmp->mtpRsProfileLen;
		return (u_char *) StorageTmp->mtpRsProfile;
	case MTPRSALARMSTATUS:
		*write_method = write_mtpRsAlarmStatus;
		*var_len = StorageTmp->mtpRsAlarmStatusLen;
		return (u_char *) StorageTmp->mtpRsAlarmStatus;
	case MTPRSROWSTATUS:
		*write_method = write_mtpRsRowStatus;
		*var_len = sizeof(StorageTmp->mtpRsRowStatus);
		return (u_char *) &StorageTmp->mtpRsRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRtProfileTable(): refresh mtpRtProfileTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtProfileTable(void)
{
	if (mtpRtProfileTable_refresh == 0)
		return;
	mtpRtProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRtProfileTable_row(): refresh mtpRtProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtProfileTable_request == sa_request)
		return;
	StorageTmp->mtpRtProfileTable_request = sa_request;
}

/*
 * var_mtpRtProfileTable(): locate variables in mtpRtProfileTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRtProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRtProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPRTPROFILETIMERT6:
		*write_method = write_mtpRtProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT6);
		return (u_char *) &StorageTmp->mtpRtProfileTimerT6;
	case MTPRTPROFILETIMERT10:
		*write_method = write_mtpRtProfileTimerT10;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT10);
		return (u_char *) &StorageTmp->mtpRtProfileTimerT10;
	case MTPRTPROFILEROWSTATUS:
		*write_method = write_mtpRtProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpRtProfileRowStatus);
		return (u_char *) &StorageTmp->mtpRtProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRtTable(): refresh mtpRtTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtTable(void)
{
	if (mtpRtTable_refresh == 0)
		return;
	mtpRtTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRtTable_row(): refresh mtpRtTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtTable_request == sa_request)
		return;
	StorageTmp->mtpRtTable_request = sa_request;
}

/*
 * var_mtpRtTable(): locate variables in mtpRtTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRtTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPRTLSPOINTER:
		*write_method = write_mtpRtLsPointer;
		*var_len = StorageTmp->mtpRtLsPointerLen;
		return (u_char *) StorageTmp->mtpRtLsPointer;
	case MTPRTADMINISTRATIVESTATE:
		*write_method = write_mtpRtAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpRtAdministrativeState);
		return (u_char *) &StorageTmp->mtpRtAdministrativeState;
	case MTPRTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRtOperationalState);
		return (u_char *) &StorageTmp->mtpRtOperationalState;
	case MTPRTAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpRtAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpRtAvailabilityStatus;
	case MTPRTINCLSLOADSHARINGALGORITHM:
		*write_method = write_mtpRtInClsLoadsharingAlgorithm;
		*var_len = sizeof(StorageTmp->mtpRtInClsLoadsharingAlgorithm);
		return (u_char *) &StorageTmp->mtpRtInClsLoadsharingAlgorithm;
	case MTPRTFIXEDPRIORITY:
		*write_method = write_mtpRtFixedPriority;
		*var_len = sizeof(StorageTmp->mtpRtFixedPriority);
		return (u_char *) &StorageTmp->mtpRtFixedPriority;
	case MTPRTFLEXIBLEPRIORITY:
		*write_method = write_mtpRtFlexiblePriority;
		*var_len = sizeof(StorageTmp->mtpRtFlexiblePriority);
		return (u_char *) &StorageTmp->mtpRtFlexiblePriority;
	case MTPRTPRIORITYMODE:
		*write_method = write_mtpRtPriorityMode;
		*var_len = sizeof(StorageTmp->mtpRtPriorityMode);
		return (u_char *) &StorageTmp->mtpRtPriorityMode;
	case MTPRTLOADSHARINGINFORMATION:
		*write_method = write_mtpRtLoadsharingInformation;
		*var_len = StorageTmp->mtpRtLoadsharingInformationLen;
		return (u_char *) StorageTmp->mtpRtLoadsharingInformation;
	case MTPRTLOADSHARINGOBJECT:
		*write_method = write_mtpRtLoadsharingObject;
		*var_len = StorageTmp->mtpRtLoadsharingObjectLen;
		return (u_char *) StorageTmp->mtpRtLoadsharingObject;
	case MTPRTNAME:
		*write_method = write_mtpRtName;
		*var_len = StorageTmp->mtpRtNameLen;
		return (u_char *) StorageTmp->mtpRtName;
	case MTPRTSLSLIST:
		*write_method = write_mtpRtSlsList;
		*var_len = StorageTmp->mtpRtSlsListLen;
		return (u_char *) StorageTmp->mtpRtSlsList;
	case MTPRTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRtUsageState);
		return (u_char *) &StorageTmp->mtpRtUsageState;
	case MTPRTRLSLOT:
		*write_method = write_mtpRtRlSlot;
		*var_len = sizeof(StorageTmp->mtpRtRlSlot);
		return (u_char *) &StorageTmp->mtpRtRlSlot;
	case MTPRTPROFILE:
		*write_method = write_mtpRtProfile;
		*var_len = StorageTmp->mtpRtProfileLen;
		return (u_char *) StorageTmp->mtpRtProfile;
	case MTPRTROWSTATUS:
		*write_method = write_mtpRtRowStatus;
		*var_len = sizeof(StorageTmp->mtpRtRowStatus);
		return (u_char *) &StorageTmp->mtpRtRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRtLsaTable(): refresh mtpRtLsaTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtLsaTable(void)
{
	if (mtpRtLsaTable_refresh == 0)
		return;
	mtpRtLsaTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRtLsaTable_row(): refresh mtpRtLsaTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtLsaTable_request == sa_request)
		return;
	StorageTmp->mtpRtLsaTable_request = sa_request;
}

/*
 * var_mtpRtLsaTable(): locate variables in mtpRtLsaTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtLsaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtLsaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtLsaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRtLsaTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRtLsaTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPRTLSANORMALSLCODE:
		*write_method = write_mtpRtLsaNormalSlCode;
		*var_len = sizeof(StorageTmp->mtpRtLsaNormalSlCode);
		return (u_char *) &StorageTmp->mtpRtLsaNormalSlCode;
	case MTPRTLSAALTERNATIVESLCODELIST:
		*write_method = write_mtpRtLsaAlternativeSlCodeList;
		*var_len = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
		return (u_char *) StorageTmp->mtpRtLsaAlternativeSlCodeList;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsProfileTable(): refresh mtpLsProfileTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpLsProfileTable(void)
{
	if (mtpLsProfileTable_refresh == 0)
		return;
	mtpLsProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpLsProfileTable_row(): refresh mtpLsProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsProfileTable_request == sa_request)
		return;
	StorageTmp->mtpLsProfileTable_request = sa_request;
}

/*
 * var_mtpLsProfileTable(): locate variables in mtpLsProfileTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpLsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPLSPROFILETIMERT6:
		*write_method = write_mtpLsProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT6);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT6;
	case MTPLSPROFILETIMERT8:
		*write_method = write_mtpLsProfileTimerT8;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT8);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT8;
	case MTPLSPROFILETIMERT10:
		*write_method = write_mtpLsProfileTimerT10;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT10);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT10;
	case MTPLSPROFILETIMERT7:
		*write_method = write_mtpLsProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT7);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT7;
	case MTPLSPROFILETIMERT19I:
		*write_method = write_mtpLsProfileTimerT19I;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT19I);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT19I;
	case MTPLSPROFILETIMERT21I:
		*write_method = write_mtpLsProfileTimerT21I;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT21I);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT21I;
	case MTPLSPROFILETIMERT25A:
		*write_method = write_mtpLsProfileTimerT25A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT25A);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT25A;
	case MTPLSPROFILETIMERT28A:
		*write_method = write_mtpLsProfileTimerT28A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT28A);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT28A;
	case MTPLSPROFILETIMERT29A:
		*write_method = write_mtpLsProfileTimerT29A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT29A);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT29A;
	case MTPLSPROFILETIMERT30A:
		*write_method = write_mtpLsProfileTimerT30A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT30A);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT30A;
	case MTPLSPROFILENAME:
		*write_method = write_mtpLsProfileName;
		*var_len = StorageTmp->mtpLsProfileNameLen;
		return (u_char *) StorageTmp->mtpLsProfileName;
	case MTPLSPROFILESLDEFAULT:
		*write_method = write_mtpLsProfileSlDefault;
		*var_len = StorageTmp->mtpLsProfileSlDefaultLen;
		return (u_char *) StorageTmp->mtpLsProfileSlDefault;
	case MTPLSPROFILEROWSTATUS:
		*write_method = write_mtpLsProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpLsProfileRowStatus);
		return (u_char *) &StorageTmp->mtpLsProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsTable(): refresh mtpLsTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpLsTable(void)
{
	if (mtpLsTable_refresh == 0)
		return;
	mtpLsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpLsTable_row(): refresh mtpLsTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsTable_request == sa_request)
		return;
	StorageTmp->mtpLsTable_request = sa_request;
}

/*
 * var_mtpLsTable(): locate variables in mtpLsTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpLsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPLSADJPC:
		*write_method = write_mtpLsAdjPc;
		*var_len = StorageTmp->mtpLsAdjPcLen;
		return (u_char *) StorageTmp->mtpLsAdjPc;
	case MTPLSRSID:
		*write_method = write_mtpLsRsId;
		*var_len = StorageTmp->mtpLsRsIdLen;
		return (u_char *) StorageTmp->mtpLsRsId;
	case MTPLSMAXCAPACITY:
		*write_method = write_mtpLsMaxCapacity;
		*var_len = sizeof(StorageTmp->mtpLsMaxCapacity);
		return (u_char *) &StorageTmp->mtpLsMaxCapacity;
	case MTPLSCURRENTCAPACITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsCurrentCapacity);
		return (u_char *) &StorageTmp->mtpLsCurrentCapacity;
	case MTPLSCONGESTIONCONTROLMETHOD:
		*write_method = write_mtpLsCongestionControlMethod;
		*var_len = sizeof(StorageTmp->mtpLsCongestionControlMethod);
		return (u_char *) &StorageTmp->mtpLsCongestionControlMethod;
	case MTPLSUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsUsageState);
		return (u_char *) &StorageTmp->mtpLsUsageState;
	case MTPLSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsOperationalState);
		return (u_char *) &StorageTmp->mtpLsOperationalState;
	case MTPLSAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpLsAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpLsAvailabilityStatus;
	case MTPLSPERIODICLINKTESTFLAG:
		*write_method = write_mtpLsPeriodicLinkTestFlag;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFlag);
		return (u_char *) &StorageTmp->mtpLsPeriodicLinkTestFlag;
	case MTPLSPERIODICLINKTESTFAIL:
		*write_method = write_mtpLsPeriodicLinkTestFail;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFail);
		return (u_char *) &StorageTmp->mtpLsPeriodicLinkTestFail;
	case MTPLSADMINISTRATIVESTATE:
		*write_method = write_mtpLsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpLsAdministrativeState);
		return (u_char *) &StorageTmp->mtpLsAdministrativeState;
	case MTPLSINLSLOADSHAREALGORITHM:
		*write_method = write_mtpLsInLsLoadShareAlgorithm;
		*var_len = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
		return (u_char *) StorageTmp->mtpLsInLsLoadShareAlgorithm;
	case MTPLSPROFILEPOINTER:
		*write_method = write_mtpLsProfilePointer;
		*var_len = StorageTmp->mtpLsProfilePointerLen;
		return (u_char *) StorageTmp->mtpLsProfilePointer;
	case MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS:
		*write_method = write_mtpLsNumberOfNormallyActiveSignLinks;
		*var_len = sizeof(StorageTmp->mtpLsNumberOfNormallyActiveSignLinks);
		return (u_char *) &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks;
	case MTPLSNAME:
		*write_method = write_mtpLsName;
		*var_len = StorageTmp->mtpLsNameLen;
		return (u_char *) StorageTmp->mtpLsName;
	case MTPLSASAPROFILEPOINTER:
		*write_method = write_mtpLsAsaProfilePointer;
		*var_len = StorageTmp->mtpLsAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpLsAsaProfilePointer;
	case MTPLSALARMSTATUS:
		*write_method = write_mtpLsAlarmStatus;
		*var_len = StorageTmp->mtpLsAlarmStatusLen;
		return (u_char *) StorageTmp->mtpLsAlarmStatus;
	case MTPLSROWSTATUS:
		*write_method = write_mtpLsRowStatus;
		*var_len = sizeof(StorageTmp->mtpLsRowStatus);
		return (u_char *) &StorageTmp->mtpLsRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL3ProfileTable(): refresh mtpSlL3ProfileTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlL3ProfileTable(void)
{
	if (mtpSlL3ProfileTable_refresh == 0)
		return;
	mtpSlL3ProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL3ProfileTable_row(): refresh mtpSlL3ProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL3ProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSlL3ProfileTable_request = sa_request;
}

/*
 * var_mtpSlL3ProfileTable(): locate variables in mtpSlL3ProfileTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlL3ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlL3ProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL3ProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL3ProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSLL3PROFILETIMERT1:
		*write_method = write_mtpSlL3ProfileTimerT1;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1;
	case MTPSLL3PROFILETIMERT3:
		*write_method = write_mtpSlL3ProfileTimerT3;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT3);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT3;
	case MTPSLL3PROFILETIMERT17:
		*write_method = write_mtpSlL3ProfileTimerT17;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT17);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT17;
	case MTPSLL3PROFILETIMERT24I:
		*write_method = write_mtpSlL3ProfileTimerT24I;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT24I);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT24I;
	case MTPSLL3PROFILENAME:
		*write_method = write_mtpSlL3ProfileName;
		*var_len = StorageTmp->mtpSlL3ProfileNameLen;
		return (u_char *) StorageTmp->mtpSlL3ProfileName;
	case MTPSLL3PROFILETIMERT2:
		*write_method = write_mtpSlL3ProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT2);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT2;
	case MTPSLL3PROFILETIMERT4:
		*write_method = write_mtpSlL3ProfileTimerT4;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT4);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT4;
	case MTPSLL3PROFILETIMERT5:
		*write_method = write_mtpSlL3ProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT5);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT5;
	case MTPSLL3PROFILETIMERT12:
		*write_method = write_mtpSlL3ProfileTimerT12;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT12);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT12;
	case MTPSLL3PROFILETIMERT13:
		*write_method = write_mtpSlL3ProfileTimerT13;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT13);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT13;
	case MTPSLL3PROFILETIMERT14:
		*write_method = write_mtpSlL3ProfileTimerT14;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT14);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT14;
	case MTPSLL3PROFILETIMERT19A:
		*write_method = write_mtpSlL3ProfileTimerT19A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT19A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT19A;
	case MTPSLL3PROFILETIMERT20A:
		*write_method = write_mtpSlL3ProfileTimerT20A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT20A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT20A;
	case MTPSLL3PROFILETIMERT21A:
		*write_method = write_mtpSlL3ProfileTimerT21A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT21A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT21A;
	case MTPSLL3PROFILETIMERT22I:
		*write_method = write_mtpSlL3ProfileTimerT22I;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT22I);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT22I;
	case MTPSLL3PROFILETIMERT23I:
		*write_method = write_mtpSlL3ProfileTimerT23I;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT23I);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT23I;
	case MTPSLL3PROFILETIMERT31A:
		*write_method = write_mtpSlL3ProfileTimerT31A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT31A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT31A;
	case MTPSLL3PROFILETIMERT32A:
		*write_method = write_mtpSlL3ProfileTimerT32A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT32A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT32A;
	case MTPSLL3PROFILETIMERT33A:
		*write_method = write_mtpSlL3ProfileTimerT33A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT33A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT33A;
	case MTPSLL3PROFILETIMERT34A:
		*write_method = write_mtpSlL3ProfileTimerT34A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT34A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT34A;
	case MTPSLL3PROFILETIMERT1T:
		*write_method = write_mtpSlL3ProfileTimerT1T;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1T);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1T;
	case MTPSLL3PROFILETIMERT2T:
		*write_method = write_mtpSlL3ProfileTimerT2T;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT2T);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT2T;
	case MTPSLL3PROFILETIMERT1S:
		*write_method = write_mtpSlL3ProfileTimerT1S;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1S);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1S;
	case MTPSLL3PROFILEL2DEFAULT:
		*write_method = write_mtpSlL3ProfileL2Default;
		*var_len = StorageTmp->mtpSlL3ProfileL2DefaultLen;
		return (u_char *) StorageTmp->mtpSlL3ProfileL2Default;
	case MTPSLL3PROFILEROWSTATUS:
		*write_method = write_mtpSlL3ProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileRowStatus);
		return (u_char *) &StorageTmp->mtpSlL3ProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL2ProfileTable(): refresh mtpSlL2ProfileTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlL2ProfileTable(void)
{
	if (mtpSlL2ProfileTable_refresh == 0)
		return;
	mtpSlL2ProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL2ProfileTable_row(): refresh mtpSlL2ProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL2ProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSlL2ProfileTable_request = sa_request;
}

/*
 * var_mtpSlL2ProfileTable(): locate variables in mtpSlL2ProfileTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlL2ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlL2ProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL2ProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL2ProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSLL2PROFILEERRORCORRECTIONMETHOD:
		*write_method = write_mtpSlL2ProfileErrorCorrectionMethod;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileErrorCorrectionMethod);
		return (u_char *) &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod;
	case MTPSLL2PROFILETRANSMISSIONRATE:
		*write_method = write_mtpSlL2ProfileTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTransmissionRate);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTransmissionRate;
	case MTPSLL2PROFILETIMERT1:
		*write_method = write_mtpSlL2ProfileTimerT1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT1);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT1;
	case MTPSLL2PROFILETIMERT2:
		*write_method = write_mtpSlL2ProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2;
	case MTPSLL2PROFILETIMERT2L:
		*write_method = write_mtpSlL2ProfileTimerT2L;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2L);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2L;
	case MTPSLL2PROFILETIMERT2H:
		*write_method = write_mtpSlL2ProfileTimerT2H;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2H);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2H;
	case MTPSLL2PROFILETIMERT3:
		*write_method = write_mtpSlL2ProfileTimerT3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT3);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT3;
	case MTPSLL2PROFILETIMERT4N:
		*write_method = write_mtpSlL2ProfileTimerT4N;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT4N);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT4N;
	case MTPSLL2PROFILETIMERT4E:
		*write_method = write_mtpSlL2ProfileTimerT4E;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT4E);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT4E;
	case MTPSLL2PROFILETIMERT5:
		*write_method = write_mtpSlL2ProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT5);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT5;
	case MTPSLL2PROFILETIMERT6:
		*write_method = write_mtpSlL2ProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT6);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT6;
	case MTPSLL2PROFILETIMERT7:
		*write_method = write_mtpSlL2ProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT7);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT7;
	case MTPSLL2PROFILETBONSET1:
		*write_method = write_mtpSlL2ProfileTbOnset1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset1);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset1;
	case MTPSLL2PROFILETBABATE1:
		*write_method = write_mtpSlL2ProfileTbAbate1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate1);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate1;
	case MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS:
		*write_method = write_mtpSlL2ProfileNumberOfThresholdLevels;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels);
		return (u_char *) &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels;
	case MTPSLL2PROFILECONGESTIONCOUNTING:
		*write_method = write_mtpSlL2ProfileCongestionCounting;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileCongestionCounting);
		return (u_char *) &StorageTmp->mtpSlL2ProfileCongestionCounting;
	case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT:
		*write_method = write_mtpSlL2ProfileCongestionReportingBaseObject;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject);
		return (u_char *) &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject;
	case MTPSLL2PROFILELOOPDELAY:
		*write_method = write_mtpSlL2ProfileLoopDelay;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileLoopDelay);
		return (u_char *) &StorageTmp->mtpSlL2ProfileLoopDelay;
	case MTPSLL2PROFILENAME:
		*write_method = write_mtpSlL2ProfileName;
		*var_len = StorageTmp->mtpSlL2ProfileNameLen;
		return (u_char *) StorageTmp->mtpSlL2ProfileName;
	case MTPSLL2PROFILETBONSET2:
		*write_method = write_mtpSlL2ProfileTbOnset2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset2);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset2;
	case MTPSLL2PROFILETBABATE2:
		*write_method = write_mtpSlL2ProfileTbAbate2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate2);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate2;
	case MTPSLL2PROFILETBONSET3:
		*write_method = write_mtpSlL2ProfileTbOnset3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset3);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset3;
	case MTPSLL2PROFILETBABATE3:
		*write_method = write_mtpSlL2ProfileTbAbate3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate3);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate3;
	case MTPSLL2PROFILETBDISCARD1:
		*write_method = write_mtpSlL2ProfileTbDiscard1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard1);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard1;
	case MTPSLL2PROFILETBDISCARD2:
		*write_method = write_mtpSlL2ProfileTbDiscard2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard2);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard2;
	case MTPSLL2PROFILETBDISCARD3:
		*write_method = write_mtpSlL2ProfileTbDiscard3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard3);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard3;
	case MTPSLL2PROFILETIMERTX:
		*write_method = write_mtpSlL2ProfileTimerTx;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerTx);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerTx;
	case MTPSLL2PROFILETIMERTY:
		*write_method = write_mtpSlL2ProfileTimerTy;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerTy);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerTy;
	case MTPSLL2PROFILENUMBEROFCONGESTIONSTATES:
		*write_method = write_mtpSlL2ProfileNumberOfCongestionStates;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileNumberOfCongestionStates);
		return (u_char *) &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates;
	case MTPSLL2PROFILEINITIALLEVELOFCONGESTION:
		*write_method = write_mtpSlL2ProfileInitialLevelOfCongestion;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion);
		return (u_char *) &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion;
	case MTPSLL2PROFILEMAXMSUSRETRANSN1:
		*write_method = write_mtpSlL2ProfileMaxMSUsRetransN1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1);
		return (u_char *) &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1;
	case MTPSLL2PROFILEMAXOCTRETRANSN2:
		*write_method = write_mtpSlL2ProfileMaxOctRetransN2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileMaxOctRetransN2);
		return (u_char *) &StorageTmp->mtpSlL2ProfileMaxOctRetransN2;
	case MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET:
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdOnset;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset);
		return (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset;
	case MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE:
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdAbate;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate);
		return (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate;
	case MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD:
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard);
		return (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard;
	case MTPSLL2PROFILEM:
		*write_method = write_mtpSlL2ProfileM;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileM);
		return (u_char *) &StorageTmp->mtpSlL2ProfileM;
	case MTPSLL2PROFILEROWSTATUS:
		*write_method = write_mtpSlL2ProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileRowStatus);
		return (u_char *) &StorageTmp->mtpSlL2ProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlTable(): refresh mtpSlTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlTable(void)
{
	if (mtpSlTable_refresh == 0)
		return;
	mtpSlTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlTable_row(): refresh mtpSlTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlTable_request == sa_request)
		return;
	StorageTmp->mtpSlTable_request = sa_request;
}

/*
 * var_mtpSlTable(): locate variables in mtpSlTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSLSLSCODECURRENTLIST:
		*write_method = write_mtpSlSlsCodeCurrentList;
		*var_len = StorageTmp->mtpSlSlsCodeCurrentListLen;
		return (u_char *) StorageTmp->mtpSlSlsCodeCurrentList;
	case MTPSLMAXCAPACITYSL:
		*write_method = write_mtpSlMaxCapacitySL;
		*var_len = sizeof(StorageTmp->mtpSlMaxCapacitySL);
		return (u_char *) &StorageTmp->mtpSlMaxCapacitySL;
	case MTPSLCURRENTCAPACITYSL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentCapacitySL);
		return (u_char *) &StorageTmp->mtpSlCurrentCapacitySL;
	case MTPSLLINKTPSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSlLinkTpStatusLen;
		return (u_char *) StorageTmp->mtpSlLinkTpStatus;
	case MTPSLADMINISTRATIVESTATE:
		*write_method = write_mtpSlAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpSlAdministrativeState);
		return (u_char *) &StorageTmp->mtpSlAdministrativeState;
	case MTPSLOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlOperationalState);
		return (u_char *) &StorageTmp->mtpSlOperationalState;
	case MTPSLUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlUsageState);
		return (u_char *) &StorageTmp->mtpSlUsageState;
	case MTPSLPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSlProceduralStatusLen;
		return (u_char *) StorageTmp->mtpSlProceduralStatus;
	case MTPSLMTPL2PROTOCOLPROFILEPOINTER:
		*write_method = write_mtpSlMtpL2ProtocolProfilePointer;
		*var_len = StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen;
		return (u_char *) StorageTmp->mtpSlMtpL2ProtocolProfilePointer;
	case MTPSLSIGNTERMPOINTER:
		*write_method = write_mtpSlSignTermPointer;
		*var_len = StorageTmp->mtpSlSignTermPointerLen;
		return (u_char *) StorageTmp->mtpSlSignTermPointer;
	case MTPSLSIGNDATALINKTPPOINTER:
		*write_method = write_mtpSlSignDataLinkTpPointer;
		*var_len = StorageTmp->mtpSlSignDataLinkTpPointerLen;
		return (u_char *) StorageTmp->mtpSlSignDataLinkTpPointer;
	case MTPSLLOCALINHIBIT:
		*write_method = write_mtpSlLocalInhibit;
		*var_len = sizeof(StorageTmp->mtpSlLocalInhibit);
		return (u_char *) &StorageTmp->mtpSlLocalInhibit;
	case MTPSLLOCALUNINHIBIT:
		*write_method = write_mtpSlLocalUninhibit;
		*var_len = sizeof(StorageTmp->mtpSlLocalUninhibit);
		return (u_char *) &StorageTmp->mtpSlLocalUninhibit;
	case MTPSLREPLACEST:
		*write_method = write_mtpSlReplaceSt;
		*var_len = sizeof(StorageTmp->mtpSlReplaceSt);
		return (u_char *) &StorageTmp->mtpSlReplaceSt;
	case MTPSLASAPROFILEPOINTER:
		*write_method = write_mtpSlAsaProfilePointer;
		*var_len = StorageTmp->mtpSlAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpSlAsaProfilePointer;
	case MTPSLCONGESTIONLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCongestionLevel);
		return (u_char *) &StorageTmp->mtpSlCongestionLevel;
	case MTPSLRELATEDLINKGROUPNUMBER:
		*write_method = write_mtpSlRelatedLinkGroupNumber;
		*var_len = sizeof(StorageTmp->mtpSlRelatedLinkGroupNumber);
		return (u_char *) &StorageTmp->mtpSlRelatedLinkGroupNumber;
	case MTPSLSDLLIST:
		*write_method = write_mtpSlSdlList;
		*var_len = sizeof(StorageTmp->mtpSlSdlList);
		return (u_char *) &StorageTmp->mtpSlSdlList;
	case MTPSLTEST:
		*write_method = write_mtpSlTest;
		*var_len = sizeof(StorageTmp->mtpSlTest);
		return (u_char *) &StorageTmp->mtpSlTest;
	case MTPSLNAME:
		*write_method = write_mtpSlName;
		*var_len = StorageTmp->mtpSlNameLen;
		return (u_char *) StorageTmp->mtpSlName;
	case MTPSLSDTLIST:
		*write_method = write_mtpSlSdtList;
		*var_len = sizeof(StorageTmp->mtpSlSdtList);
		return (u_char *) &StorageTmp->mtpSlSdtList;
	case MTPSLSLSCODENORMALLIST:
		*write_method = write_mtpSlSlsCodeNormalList;
		*var_len = StorageTmp->mtpSlSlsCodeNormalListLen;
		return (u_char *) StorageTmp->mtpSlSlsCodeNormalList;
	case MTPSLL3PROFILEPOINTER:
		*write_method = write_mtpSlL3ProfilePointer;
		*var_len = StorageTmp->mtpSlL3ProfilePointerLen;
		return (u_char *) StorageTmp->mtpSlL3ProfilePointer;
	case MTPSLALARMSTATUS:
		*write_method = write_mtpSlAlarmStatus;
		*var_len = StorageTmp->mtpSlAlarmStatusLen;
		return (u_char *) StorageTmp->mtpSlAlarmStatus;
	case MTPSLROWSTATUS:
		*write_method = write_mtpSlRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlRowStatus);
		return (u_char *) &StorageTmp->mtpSlRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlSdlListTable(): refresh mtpSlSdlListTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlSdlListTable(void)
{
	if (mtpSlSdlListTable_refresh == 0)
		return;
	mtpSlSdlListTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlSdlListTable_row(): refresh mtpSlSdlListTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlSdlListTable_request == sa_request)
		return;
	StorageTmp->mtpSlSdlListTable_request = sa_request;
}

/*
 * var_mtpSlSdlListTable(): locate variables in mtpSlSdlListTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlSdlListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlSdlListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlSdlListTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlSdlListTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlSdlListTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSLSDLLISTPOINTER:
		*write_method = write_mtpSlSdlListPointer;
		*var_len = StorageTmp->mtpSlSdlListPointerLen;
		return (u_char *) StorageTmp->mtpSlSdlListPointer;
	case MTPSLSDLLISTROWSTATUS:
		*write_method = write_mtpSlSdlListRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlSdlListRowStatus);
		return (u_char *) &StorageTmp->mtpSlSdlListRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlSdtListTable(): refresh mtpSlSdtListTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlSdtListTable(void)
{
	if (mtpSlSdtListTable_refresh == 0)
		return;
	mtpSlSdtListTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlSdtListTable_row(): refresh mtpSlSdtListTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlSdtListTable_request == sa_request)
		return;
	StorageTmp->mtpSlSdtListTable_request = sa_request;
}

/*
 * var_mtpSlSdtListTable(): locate variables in mtpSlSdtListTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlSdtListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlSdtListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlSdtListTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlSdtListTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlSdtListTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSLSDTLISTPOINTER:
		*write_method = write_mtpSlSdtListPointer;
		*var_len = StorageTmp->mtpSlSdtListPointerLen;
		return (u_char *) StorageTmp->mtpSlSdtListPointer;
	case MTPSLSDTLISTROWSTATUS:
		*write_method = write_mtpSlSdtListRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlSdtListRowStatus);
		return (u_char *) &StorageTmp->mtpSlSdtListRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpNbTable(): refresh mtpNbTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpNbTable(void)
{
	if (mtpNbTable_refresh == 0)
		return;
	mtpNbTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpNbTable_row(): refresh mtpNbTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
{
	if (StorageTmp->mtpNbTable_request == sa_request)
		return;
	StorageTmp->mtpNbTable_request = sa_request;
}

/*
 * var_mtpNbTable(): locate variables in mtpNbTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpNbTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpNbTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpNbTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpNbTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpNbTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpNbTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPNBTRANSMISSIONRATE:
		*write_method = write_mtpNbTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpNbTransmissionRate);
		return (u_char *) &StorageTmp->mtpNbTransmissionRate;
	case MTPNBTIMERT8:
		*write_method = write_mtpNbTimerT8;
		*var_len = sizeof(StorageTmp->mtpNbTimerT8);
		return (u_char *) &StorageTmp->mtpNbTimerT8;
	case MTPNBTIN:
		*write_method = write_mtpNbTin;
		*var_len = sizeof(StorageTmp->mtpNbTin);
		return (u_char *) &StorageTmp->mtpNbTin;
	case MTPNBTIE:
		*write_method = write_mtpNbTie;
		*var_len = sizeof(StorageTmp->mtpNbTie);
		return (u_char *) &StorageTmp->mtpNbTie;
	case MTPNBT:
		*write_method = write_mtpNbT;
		*var_len = sizeof(StorageTmp->mtpNbT);
		return (u_char *) &StorageTmp->mtpNbT;
	case MTPNBD:
		*write_method = write_mtpNbD;
		*var_len = sizeof(StorageTmp->mtpNbD);
		return (u_char *) &StorageTmp->mtpNbD;
	case MTPNBTE:
		*write_method = write_mtpNbTe;
		*var_len = sizeof(StorageTmp->mtpNbTe);
		return (u_char *) &StorageTmp->mtpNbTe;
	case MTPNBDE:
		*write_method = write_mtpNbDe;
		*var_len = sizeof(StorageTmp->mtpNbDe);
		return (u_char *) &StorageTmp->mtpNbDe;
	case MTPNBUE:
		*write_method = write_mtpNbUe;
		*var_len = sizeof(StorageTmp->mtpNbUe);
		return (u_char *) &StorageTmp->mtpNbUe;
	case MTPNBN:
		*write_method = write_mtpNbN;
		*var_len = sizeof(StorageTmp->mtpNbN);
		return (u_char *) &StorageTmp->mtpNbN;
	case MTPNBM:
		*write_method = write_mtpNbm;
		*var_len = sizeof(StorageTmp->mtpNbm);
		return (u_char *) &StorageTmp->mtpNbm;
	case MTPNBB:
		*write_method = write_mtpNbb;
		*var_len = sizeof(StorageTmp->mtpNbb);
		return (u_char *) &StorageTmp->mtpNbb;
	case MTPNBF:
		*write_method = write_mtpNbf;
		*var_len = sizeof(StorageTmp->mtpNbf);
		return (u_char *) &StorageTmp->mtpNbf;
	case MTPNBROWSTATUS:
		*write_method = write_mtpNbRowStatus;
		*var_len = sizeof(StorageTmp->mtpNbRowStatus);
		return (u_char *) &StorageTmp->mtpNbRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSaalTable(): refresh mtpSaalTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSaalTable(void)
{
	if (mtpSaalTable_refresh == 0)
		return;
	mtpSaalTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSaalTable_row(): refresh mtpSaalTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
{
	if (StorageTmp->mtpSaalTable_request == sa_request)
		return;
	StorageTmp->mtpSaalTable_request = sa_request;
}

/*
 * var_mtpSaalTable(): locate variables in mtpSaalTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSaalTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSaalTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSaalTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSaalTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSaalTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSaalTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSAALBUFFERRELEASE:
		*write_method = write_mtpSaalBufferRelease;
		*var_len = sizeof(StorageTmp->mtpSaalBufferRelease);
		return (u_char *) &StorageTmp->mtpSaalBufferRelease;
	case MTPSAALMAXCC:
		*write_method = write_mtpSaalMaxCc;
		*var_len = sizeof(StorageTmp->mtpSaalMaxCc);
		return (u_char *) &StorageTmp->mtpSaalMaxCc;
	case MTPSAALMAXNRP:
		*write_method = write_mtpSaalMaxNrp;
		*var_len = sizeof(StorageTmp->mtpSaalMaxNrp);
		return (u_char *) &StorageTmp->mtpSaalMaxNrp;
	case MTPSAALMAXINFORMATIONFIELDLENGTH:
		*write_method = write_mtpSaalMaxInformationFieldLength;
		*var_len = sizeof(StorageTmp->mtpSaalMaxInformationFieldLength);
		return (u_char *) &StorageTmp->mtpSaalMaxInformationFieldLength;
	case MTPSAALMAXLENGTHSSCOPUUFIELD:
		*write_method = write_mtpSaalMaxLengthSscopUuField;
		*var_len = sizeof(StorageTmp->mtpSaalMaxLengthSscopUuField);
		return (u_char *) &StorageTmp->mtpSaalMaxLengthSscopUuField;
	case MTPSAALMAXPD:
		*write_method = write_mtpSaalMaxPd;
		*var_len = sizeof(StorageTmp->mtpSaalMaxPd);
		return (u_char *) &StorageTmp->mtpSaalMaxPd;
	case MTPSAALMAXSSCOPCREDITTOPEER:
		*write_method = write_mtpSaalMaxSscopCreditToPeer;
		*var_len = sizeof(StorageTmp->mtpSaalMaxSscopCreditToPeer);
		return (u_char *) &StorageTmp->mtpSaalMaxSscopCreditToPeer;
	case MTPSAALMAXSTAT:
		*write_method = write_mtpSaalMaxStat;
		*var_len = sizeof(StorageTmp->mtpSaalMaxStat);
		return (u_char *) &StorageTmp->mtpSaalMaxStat;
	case MTPSAALN1:
		*write_method = write_mtpSaalN1;
		*var_len = sizeof(StorageTmp->mtpSaalN1);
		return (u_char *) &StorageTmp->mtpSaalN1;
	case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE:
		*write_method = write_mtpSaalNniLayerManagementProvingState;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementProvingState);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementProvingState;
	case MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT:
		*write_method = write_mtpSaalNniLayerManagementTimerNoCredit;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerNoCredit);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;
	case MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC:
		*write_method = write_mtpSaalNniLayerManagementTimerRepeatSrec;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;
	case MTPSAALNNITIMERT1:
		*write_method = write_mtpSaalNniTimerT1;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT1);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT1;
	case MTPSAALNNITIMERT2:
		*write_method = write_mtpSaalNniTimerT2;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT2);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT2;
	case MTPSAALNNITIMERT3:
		*write_method = write_mtpSaalNniTimerT3;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT3);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT3;
	case MTPSAALSSCOPTIMERCC:
		*write_method = write_mtpSaalSscopTimerCc;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerCc);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerCc;
	case MTPSAALSSCOPTIMERIDLE:
		*write_method = write_mtpSaalSscopTimerIdle;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerIdle);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerIdle;
	case MTPSAALSSCOPTIMERKEEPALIVE:
		*write_method = write_mtpSaalSscopTimerKeepAlive;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerKeepAlive);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerKeepAlive;
	case MTPSAALSSCOPTIMERNORESPONSE:
		*write_method = write_mtpSaalSscopTimerNoResponse;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerNoResponse);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerNoResponse;
	case MTPSAALSSCOPTIMERPOLL:
		*write_method = write_mtpSaalSscopTimerPoll;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerPoll);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerPoll;
	case MTPSAALTRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpSaalTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalLower;
	case MTPSAALTRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpSaalTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalUpper;
	case MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpSaalEgressTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;
	case MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpSaalEgressTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;
	case MTPSAALPOLLAFTERRETRANSMISSION:
		*write_method = write_mtpSaalPollAfterRetransmission;
		*var_len = sizeof(StorageTmp->mtpSaalPollAfterRetransmission);
		return (u_char *) &StorageTmp->mtpSaalPollAfterRetransmission;
	case MTPSAALROWSTATUS:
		*write_method = write_mtpSaalRowStatus;
		*var_len = sizeof(StorageTmp->mtpSaalRowStatus);
		return (u_char *) &StorageTmp->mtpSaalRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpM2paTable(): refresh mtpM2paTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM2paTable(void)
{
	if (mtpM2paTable_refresh == 0)
		return;
	mtpM2paTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpM2paTable_row(): refresh mtpM2paTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
{
	if (StorageTmp->mtpM2paTable_request == sa_request)
		return;
	StorageTmp->mtpM2paTable_request = sa_request;
}

/*
 * var_mtpM2paTable(): locate variables in mtpM2paTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM2paTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM2paTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpM2paTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpM2paTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpM2paTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpM2paTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPM2PAN1:
		*write_method = write_mtpM2paN1;
		*var_len = sizeof(StorageTmp->mtpM2paN1);
		return (u_char *) &StorageTmp->mtpM2paN1;
	case MTPM2PAPROVING:
		*write_method = write_mtpM2paProving;
		*var_len = sizeof(StorageTmp->mtpM2paProving);
		return (u_char *) &StorageTmp->mtpM2paProving;
	case MTPM2PAMANAGEMENTPROVINGSTATE:
		*write_method = write_mtpM2paManagementProvingState;
		*var_len = sizeof(StorageTmp->mtpM2paManagementProvingState);
		return (u_char *) &StorageTmp->mtpM2paManagementProvingState;
	case MTPM2PALOOPDELAYLOWER:
		*write_method = write_mtpM2paLoopDelayLower;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayLower);
		return (u_char *) &StorageTmp->mtpM2paLoopDelayLower;
	case MTPM2PALOOPDELAYUPPER:
		*write_method = write_mtpM2paLoopDelayUpper;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayUpper);
		return (u_char *) &StorageTmp->mtpM2paLoopDelayUpper;
	case MTPM2PATRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpM2paTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalLower;
	case MTPM2PATRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpM2paTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalUpper;
	case MTPM2PASCTPNODELAY:
		*write_method = write_mtpM2paSctpNoDelay;
		*var_len = sizeof(StorageTmp->mtpM2paSctpNoDelay);
		return (u_char *) &StorageTmp->mtpM2paSctpNoDelay;
	case MTPM2PASCTPMAXSEG:
		*write_method = write_mtpM2paSctpMaxseg;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxseg);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxseg;
	case MTPM2PASCTPHEARTBEATITVL:
		*write_method = write_mtpM2paSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeatItvl);
		return (u_char *) &StorageTmp->mtpM2paSctpHeartbeatItvl;
	case MTPM2PASCTPHEARTBEAT:
		*write_method = write_mtpM2paSctpHeartbeat;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeat);
		return (u_char *) &StorageTmp->mtpM2paSctpHeartbeat;
	case MTPM2PASCTPRTOINITIAL:
		*write_method = write_mtpM2paSctpRtoInitial;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoInitial);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoInitial;
	case MTPM2PASCTPRTOMIN:
		*write_method = write_mtpM2paSctpRtoMin;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMin);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoMin;
	case MTPM2PASCTPRTOMAX:
		*write_method = write_mtpM2paSctpRtoMax;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMax);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoMax;
	case MTPM2PASCTPPATHMAXRETRANS:
		*write_method = write_mtpM2paSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paSctpPathMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paSctpPathMaxRetrans;
	case MTPM2PASCTPCOOKIELIFE:
		*write_method = write_mtpM2paSctpCookieLife;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieLife);
		return (u_char *) &StorageTmp->mtpM2paSctpCookieLife;
	case MTPM2PASCTPCOOKIEINC:
		*write_method = write_mtpM2paSctpCookieInc;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieInc);
		return (u_char *) &StorageTmp->mtpM2paSctpCookieInc;
	case MTPM2PASCTPMAXINITRETRIES:
		*write_method = write_mtpM2paSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxInitRetries);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxInitRetries;
	case MTPM2PASCTPMAXBURST:
		*write_method = write_mtpM2paSctpMaxBurst;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxBurst);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxBurst;
	case MTPM2PASCTPASSOCMAXRETRANS:
		*write_method = write_mtpM2paSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paSctpAssocMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paSctpAssocMaxRetrans;
	case MTPM2PASCTPSACKDELAY:
		*write_method = write_mtpM2paSctpSackDelay;
		*var_len = sizeof(StorageTmp->mtpM2paSctpSackDelay);
		return (u_char *) &StorageTmp->mtpM2paSctpSackDelay;
	case MTPM2PASCTPLIFETIME:
		*write_method = write_mtpM2paSctpLifetime;
		*var_len = sizeof(StorageTmp->mtpM2paSctpLifetime);
		return (u_char *) &StorageTmp->mtpM2paSctpLifetime;
	case MTPM2PAPROVINGATTEMPTS:
		*write_method = write_mtpM2paProvingAttempts;
		*var_len = sizeof(StorageTmp->mtpM2paProvingAttempts);
		return (u_char *) &StorageTmp->mtpM2paProvingAttempts;
	case MTPM2PAROWSTATUS:
		*write_method = write_mtpM2paRowStatus;
		*var_len = sizeof(StorageTmp->mtpM2paRowStatus);
		return (u_char *) &StorageTmp->mtpM2paRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdtTable(): refresh mtpSdtTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSdtTable(void)
{
	if (mtpSdtTable_refresh == 0)
		return;
	mtpSdtTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSdtTable_row(): refresh mtpSdtTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdtTable_request == sa_request)
		return;
	StorageTmp->mtpSdtTable_request = sa_request;
}

/*
 * var_mtpSdtTable(): locate variables in mtpSdtTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSdtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSdtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdtTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSdtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSDTADMINISTRATIVESTATE:
		*write_method = write_mtpSdtAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpSdtAdministrativeState);
		return (u_char *) &StorageTmp->mtpSdtAdministrativeState;
	case MTPSDTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtOperationalState);
		return (u_char *) &StorageTmp->mtpSdtOperationalState;
	case MTPSDTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtUsageState);
		return (u_char *) &StorageTmp->mtpSdtUsageState;
	case MTPSDTPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSdtProceduralStatusLen;
		return (u_char *) StorageTmp->mtpSdtProceduralStatus;
	case MTPSDTAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSdtAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpSdtAvailabilityStatus;
	case MTPSDTEQUIPMENTPOINTER:
		*write_method = write_mtpSdtEquipmentPointer;
		*var_len = StorageTmp->mtpSdtEquipmentPointerLen;
		return (u_char *) StorageTmp->mtpSdtEquipmentPointer;
	case MTPSDTNAME:
		*write_method = write_mtpSdtName;
		*var_len = StorageTmp->mtpSdtNameLen;
		return (u_char *) StorageTmp->mtpSdtName;
	case MTPSDTPROFILEPOINTER:
		*write_method = write_mtpSdtProfilePointer;
		*var_len = StorageTmp->mtpSdtProfilePointerLen;
		return (u_char *) StorageTmp->mtpSdtProfilePointer;
	case MTPSDTROWSTATUS:
		*write_method = write_mtpSdtRowStatus;
		*var_len = sizeof(StorageTmp->mtpSdtRowStatus);
		return (u_char *) &StorageTmp->mtpSdtRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdlTable(): refresh mtpSdlTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSdlTable(void)
{
	if (mtpSdlTable_refresh == 0)
		return;
	mtpSdlTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSdlTable_row(): refresh mtpSdlTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdlTable_request == sa_request)
		return;
	StorageTmp->mtpSdlTable_request = sa_request;
}

/*
 * var_mtpSdlTable(): locate variables in mtpSdlTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSdlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSdlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdlTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSdlTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSDLADJPC:
		*write_method = write_mtpSdlAdjPc;
		*var_len = StorageTmp->mtpSdlAdjPcLen;
		return (u_char *) StorageTmp->mtpSdlAdjPc;
	case MTPSDLTRANSMISSIONRATE:
		*write_method = write_mtpSdlTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpSdlTransmissionRate);
		return (u_char *) &StorageTmp->mtpSdlTransmissionRate;
	case MTPSDLLOOPDELAY:
		*write_method = write_mtpSdlLoopDelay;
		*var_len = sizeof(StorageTmp->mtpSdlLoopDelay);
		return (u_char *) &StorageTmp->mtpSdlLoopDelay;
	case MTPSDLOPERATIONALSTATE:
		*write_method = write_mtpSdlOperationalState;
		*var_len = sizeof(StorageTmp->mtpSdlOperationalState);
		return (u_char *) &StorageTmp->mtpSdlOperationalState;
	case MTPSDLEQUIPMENTPOINTER:
		*write_method = write_mtpSdlEquipmentPointer;
		*var_len = StorageTmp->mtpSdlEquipmentPointerLen;
		return (u_char *) StorageTmp->mtpSdlEquipmentPointer;
	case MTPSDLCIC:
		*write_method = write_mtpSdlCIC;
		*var_len = sizeof(StorageTmp->mtpSdlCIC);
		return (u_char *) &StorageTmp->mtpSdlCIC;
	case MTPSDLNAME:
		*write_method = write_mtpSdlName;
		*var_len = StorageTmp->mtpSdlNameLen;
		return (u_char *) StorageTmp->mtpSdlName;
	case MTPSDLSTMCHANNEL:
		*write_method = write_mtpSdlStmChannel;
		*var_len = StorageTmp->mtpSdlStmChannelLen;
		return (u_char *) StorageTmp->mtpSdlStmChannel;
	case MTPSDLVCTTPPOINTER:
		*write_method = write_mtpSdlVcTTpPointer;
		*var_len = StorageTmp->mtpSdlVcTTpPointerLen;
		return (u_char *) StorageTmp->mtpSdlVcTTpPointer;
	case MTPSDLROWSTATUS:
		*write_method = write_mtpSdlRowStatus;
		*var_len = sizeof(StorageTmp->mtpSdlRowStatus);
		return (u_char *) &StorageTmp->mtpSdlRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_mtpSapUserPart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSapUserPart entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAPUSERPART_SNMM:
		case MTPSAPUSERPART_SNTM:
		case MTPSAPUSERPART_SNSM:
		case MTPSAPUSERPART_SCCP:
		case MTPSAPUSERPART_TUP:
		case MTPSAPUSERPART_ISUP:
		case MTPSAPUSERPART_DUP1:
		case MTPSAPUSERPART_DUP2:
		case MTPSAPUSERPART_MTUP:
		case MTPSAPUSERPART_BISUP:
		case MTPSAPUSERPART_SIUP:
		case MTPSAPUSERPART_USER11:
		case MTPSAPUSERPART_USER12:
		case MTPSAPUSERPART_USER13:
		case MTPSAPUSERPART_USER14:
		case MTPSAPUSERPART_USER15:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSapUserPart;
		StorageTmp->mtpSapUserPart = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapUserPart = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapUserPartStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSapUserPartStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAPUSERPARTSTATUS_UNKNOWN:
		case MTPSAPUSERPARTSTATUS_INACCESSIBLE:
		case MTPSAPUSERPARTSTATUS_UNEQUIPPED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSapUserPartStatus;
		StorageTmp->mtpSapUserPartStatus = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapUserPartStatus = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapProviderEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSapProviderEntityNames;
		old_length = StorageTmp->mtpSapProviderEntityNamesLen;
		StorageTmp->mtpSapProviderEntityNames = objid;
		StorageTmp->mtpSapProviderEntityNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapProviderEntityNames = old_value;
		StorageTmp->mtpSapProviderEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSapAsaProfilePointer;
		old_length = StorageTmp->mtpSapAsaProfilePointerLen;
		StorageTmp->mtpSapAsaProfilePointer = objid;
		StorageTmp->mtpSapAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapAsaProfilePointer = old_value;
		StorageTmp->mtpSapAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSapName;
		old_length = StorageTmp->mtpSapNameLen;
		StorageTmp->mtpSapName = string;
		StorageTmp->mtpSapNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapName = old_value;
		StorageTmp->mtpSapNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapLongMessageSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSapLongMessageSupported entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAPLONGMESSAGESUPPORTED_TRUE:
		case MTPSAPLONGMESSAGESUPPORTED_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSapLongMessageSupported;
		StorageTmp->mtpSapLongMessageSupported = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapLongMessageSupported = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsName;
		old_length = StorageTmp->mtpMsNameLen;
		StorageTmp->mtpMsName = string;
		StorageTmp->mtpMsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsName = old_value;
		StorageTmp->mtpMsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsAlarmStatus;
		old_length = StorageTmp->mtpMsAlarmStatusLen;
		StorageTmp->mtpMsAlarmStatus = string;
		StorageTmp->mtpMsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsAlarmStatus = old_value;
		StorageTmp->mtpMsAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsManagedElementType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsManagedElementType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsManagedElementType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsManagedElementType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsManagedElementType;
		old_length = StorageTmp->mtpMsManagedElementTypeLen;
		StorageTmp->mtpMsManagedElementType = string;
		StorageTmp->mtpMsManagedElementTypeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsManagedElementType = old_value;
		StorageTmp->mtpMsManagedElementTypeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsModelCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsModelCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsModelCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsModelCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsModelCode;
		old_length = StorageTmp->mtpMsModelCodeLen;
		StorageTmp->mtpMsModelCode = string;
		StorageTmp->mtpMsModelCodeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsModelCode = old_value;
		StorageTmp->mtpMsModelCodeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsVendorName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsVendorName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVendorName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVendorName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsVendorName;
		old_length = StorageTmp->mtpMsVendorNameLen;
		StorageTmp->mtpMsVendorName = string;
		StorageTmp->mtpMsVendorNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsVendorName = old_value;
		StorageTmp->mtpMsVendorNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsUserLabel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsUserLabel;
		old_length = StorageTmp->mtpMsUserLabelLen;
		StorageTmp->mtpMsUserLabel = string;
		StorageTmp->mtpMsUserLabelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsUserLabel = old_value;
		StorageTmp->mtpMsUserLabelLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVersion not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsVersion;
		old_length = StorageTmp->mtpMsVersionLen;
		StorageTmp->mtpMsVersion = string;
		StorageTmp->mtpMsVersionLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsVersion = old_value;
		StorageTmp->mtpMsVersionLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsAsaProfilePointer;
		old_length = StorageTmp->mtpMsAsaProfilePointerLen;
		StorageTmp->mtpMsAsaProfilePointer = objid;
		StorageTmp->mtpMsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsAsaProfilePointer = old_value;
		StorageTmp->mtpMsAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsNetworkElementAliases entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsNetworkElementAliases;
		old_length = StorageTmp->mtpMsNetworkElementAliasesLen;
		StorageTmp->mtpMsNetworkElementAliases = string;
		StorageTmp->mtpMsNetworkElementAliasesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsNetworkElementAliases = old_value;
		StorageTmp->mtpMsNetworkElementAliasesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolVariant entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 14..15 */
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid) || ((14 * sizeof(oid) > var_val_len || var_val_len > 15 * sizeof(oid)))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { ss7ProtocolItut 0 } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaProtocolVariant;
		old_length = StorageTmp->mtpNaProtocolVariantLen;
		StorageTmp->mtpNaProtocolVariant = objid;
		StorageTmp->mtpNaProtocolVariantLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolVariant = old_value;
		StorageTmp->mtpNaProtocolVariantLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolYear(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolYear entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case MTPNAPROTOCOLYEAR_Y1980:
		case MTPNAPROTOCOLYEAR_Y1984:
		case MTPNAPROTOCOLYEAR_Y1988:
		case MTPNAPROTOCOLYEAR_Y1992:
		case MTPNAPROTOCOLYEAR_Y1996:
		case MTPNAPROTOCOLYEAR_Y2000:
		case MTPNAPROTOCOLYEAR_Y2004:
		case MTPNAPROTOCOLYEAR_Y2008:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaProtocolYear;
		StorageTmp->mtpNaProtocolYear = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolYear = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolOptions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaProtocolOptions;
		old_length = StorageTmp->mtpNaProtocolOptionsLen;
		StorageTmp->mtpNaProtocolOptions = string;
		StorageTmp->mtpNaProtocolOptionsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolOptions = old_value;
		StorageTmp->mtpNaProtocolOptionsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNaNetworkIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPNANETWORKINDICATOR_INTERNATIONALNETWORK1:
		case MTPNANETWORKINDICATOR_INTERNATIONALNETWORK2:
		case MTPNANETWORKINDICATOR_NATIONALNETWORK1:
		case MTPNANETWORKINDICATOR_NATIONALNETWORK2:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaNetworkIndicator;
		StorageTmp->mtpNaNetworkIndicator = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaNetworkIndicator = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaPointCodeFormat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 3..3 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 3)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaPointCodeFormat;
		old_length = StorageTmp->mtpNaPointCodeFormatLen;
		StorageTmp->mtpNaPointCodeFormat = string;
		StorageTmp->mtpNaPointCodeFormatLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaPointCodeFormat = old_value;
		StorageTmp->mtpNaPointCodeFormatLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaSlsLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNaSlsLength entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPNASLSLENGTH_SLS4BITS:
		case MTPNASLSLENGTH_SLS5BITS:
		case MTPNASLSLENGTH_SLS8BITS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaSlsLength;
		StorageTmp->mtpNaSlsLength = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaSlsLength = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaSpDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaSpDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaSpDefault;
		old_length = StorageTmp->mtpNaSpDefaultLen;
		StorageTmp->mtpNaSpDefault = string;
		StorageTmp->mtpNaSpDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaSpDefault = old_value;
		StorageTmp->mtpNaSpDefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaName;
		old_length = StorageTmp->mtpNaNameLen;
		StorageTmp->mtpNaName = string;
		StorageTmp->mtpNaNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaName = old_value;
		StorageTmp->mtpNaNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case MTPGSADMINISTRATIVESTATE_LOCKED:
		case MTPGSADMINISTRATIVESTATE_UNLOCKED:
		case MTPGSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsAdministrativeState;
		StorageTmp->mtpGsAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsTreatmentOfOutsideRanges(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsTreatmentOfOutsideRanges entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPGSTREATMENTOFOUTSIDERANGES_NORMAL:
		case MTPGSTREATMENTOFOUTSIDERANGES_DISCARD:
		case MTPGSTREATMENTOFOUTSIDERANGES_PROHIBIT:
		case MTPGSTREATMENTOFOUTSIDERANGES_UNEQUIPPED:
		case MTPGSTREATMENTOFOUTSIDERANGES_INACCESSIBLE:
		case MTPGSTREATMENTOFOUTSIDERANGES_CONGEST:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsTreatmentOfOutsideRanges;
		StorageTmp->mtpGsTreatmentOfOutsideRanges = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsTreatmentOfOutsideRanges = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsListMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsListMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPGSLISTMODE_TRUE:
		case MTPGSLISTMODE_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsListMode;
		StorageTmp->mtpGsListMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsListMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsScreeningByLinkSetOrByOpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsScreeningByLinkSetOrByOpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYOPC:
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYINCOMINGLINKSET:
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYOUTGOINGLINKSET:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsScreeningByLinkSetOrByOpc;
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsGetScreenedOpcsOrLinkSetsByDpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsGetScreenedOpcsOrLinkSetsByDpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SUCCESS:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_UNSUCCESSFUL:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_NOTPERFORMED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_LINKALREADYINHIBITED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_LINKNOTINHIBITED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_WRONGCLASSREFERENCED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SIGNTERMNONEXISTING:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SIGNTERMALREADYREFERENCED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsName;
		old_length = StorageTmp->mtpGsNameLen;
		StorageTmp->mtpGsName = string;
		StorageTmp->mtpGsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsName = old_value;
		StorageTmp->mtpGsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpGsLineTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineObject;
		old_length = StorageTmp->mtpGsLineObjectLen;
		StorageTmp->mtpGsLineObject = objid;
		StorageTmp->mtpGsLineObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineObject = old_value;
		StorageTmp->mtpGsLineObjectLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpGsLineTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContent entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContent;
		StorageTmp->mtpGsLineContent = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContent = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentDesignatedDPCFirst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentDesignatedDPCFirst entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContentDesignatedDPCFirst;
		old_length = StorageTmp->mtpGsLineContentDesignatedDPCFirstLen;
		StorageTmp->mtpGsLineContentDesignatedDPCFirst = string;
		StorageTmp->mtpGsLineContentDesignatedDPCFirstLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentDesignatedDPCFirst = old_value;
		StorageTmp->mtpGsLineContentDesignatedDPCFirstLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentDesignatedDPCLast(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentDesignatedDPCLast entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContentDesignatedDPCLast;
		old_length = StorageTmp->mtpGsLineContentDesignatedDPCLastLen;
		StorageTmp->mtpGsLineContentDesignatedDPCLast = string;
		StorageTmp->mtpGsLineContentDesignatedDPCLastLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentDesignatedDPCLast = old_value;
		StorageTmp->mtpGsLineContentDesignatedDPCLastLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentSiMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentSiMask entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContentSiMask;
		old_length = StorageTmp->mtpGsLineContentSiMaskLen;
		StorageTmp->mtpGsLineContentSiMask = string;
		StorageTmp->mtpGsLineContentSiMaskLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentSiMask = old_value;
		StorageTmp->mtpGsLineContentSiMaskLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentMessageTreatment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentMessageTreatment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPGSLINECONTENTMESSAGETREATMENT_NORMAL:
		case MTPGSLINECONTENTMESSAGETREATMENT_DISCARD:
		case MTPGSLINECONTENTMESSAGETREATMENT_PROHIBIT:
		case MTPGSLINECONTENTMESSAGETREATMENT_UNEQUIPPED:
		case MTPGSLINECONTENTMESSAGETREATMENT_INACCESSIBLE:
		case MTPGSLINECONTENTMESSAGETREATMENT_CONGEST:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContentMessageTreatment;
		StorageTmp->mtpGsLineContentMessageTreatment = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentMessageTreatment = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentComment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentComment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContentComment;
		old_length = StorageTmp->mtpGsLineContentCommentLen;
		StorageTmp->mtpGsLineContentComment = string;
		StorageTmp->mtpGsLineContentCommentLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentComment = old_value;
		StorageTmp->mtpGsLineContentCommentLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT1R(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT1R entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT1R;
		StorageTmp->mtpSpProfileTimerT1R = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT1R = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT2;
		StorageTmp->mtpSpProfileTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT4;
		StorageTmp->mtpSpProfileTimerT4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT5;
		StorageTmp->mtpSpProfileTimerT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT7;
		StorageTmp->mtpSpProfileTimerT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT11;
		StorageTmp->mtpSpProfileTimerT11 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT11 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT12;
		StorageTmp->mtpSpProfileTimerT12 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT12 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT13;
		StorageTmp->mtpSpProfileTimerT13 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT13 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT14;
		StorageTmp->mtpSpProfileTimerT14 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT14 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT15;
		StorageTmp->mtpSpProfileTimerT15 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT15 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT16;
		StorageTmp->mtpSpProfileTimerT16 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT16 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT18I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT18I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT18I;
		StorageTmp->mtpSpProfileTimerT18I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT18I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT19I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT19I;
		StorageTmp->mtpSpProfileTimerT19I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT19I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT20I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT20I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 5900..6100 */
		if ((5900 > set_value || set_value > 6100)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT20I;
		StorageTmp->mtpSpProfileTimerT20I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT20I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT21I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT21I;
		StorageTmp->mtpSpProfileTimerT21I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT21I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT22I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT22I;
		StorageTmp->mtpSpProfileTimerT22I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT22I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT23I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT23I;
		StorageTmp->mtpSpProfileTimerT23I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT23I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT20A;
		StorageTmp->mtpSpProfileTimerT20A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT20A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT21A;
		StorageTmp->mtpSpProfileTimerT21A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT21A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT22A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT22A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT22A;
		StorageTmp->mtpSpProfileTimerT22A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT22A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT23A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT23A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT23A;
		StorageTmp->mtpSpProfileTimerT23A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT23A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT24A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT24A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT24A;
		StorageTmp->mtpSpProfileTimerT24A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT24A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT26A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT26A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1350 */
		/* Note: ranges 1200..1500 */
		if ((1200 > set_value || set_value > 1500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT26A;
		StorageTmp->mtpSpProfileTimerT26A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT26A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT27A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT27A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 300 */
		/* Note: ranges 200..500 */
		if ((200 > set_value || set_value > 500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT27A;
		StorageTmp->mtpSpProfileTimerT27A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT27A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT1T;
		StorageTmp->mtpSpProfileTimerT1T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT1T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT2T;
		StorageTmp->mtpSpProfileTimerT2T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT2T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileName;
		old_length = StorageTmp->mtpSpProfileNameLen;
		StorageTmp->mtpSpProfileName = string;
		StorageTmp->mtpSpProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileName = old_value;
		StorageTmp->mtpSpProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpPointCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpPointCode;
		old_length = StorageTmp->mtpSpPointCodeLen;
		StorageTmp->mtpSpPointCode = string;
		StorageTmp->mtpSpPointCodeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpPointCode = old_value;
		StorageTmp->mtpSpPointCodeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSPTYPE_SEP:
		case MTPSPTYPE_STEP:
		case MTPSPTYPE_STP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpType;
		StorageTmp->mtpSpType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpVersion;
		old_length = StorageTmp->mtpSpVersionLen;
		StorageTmp->mtpSpVersion = string;
		StorageTmp->mtpSpVersionLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpVersion = old_value;
		StorageTmp->mtpSpVersionLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpNetworkIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSPNETWORKINDICATOR_INTERNATIONALNETWORK1:
		case MTPSPNETWORKINDICATOR_INTERNATIONALNETWORK2:
		case MTPSPNETWORKINDICATOR_NATIONALNETWORK1:
		case MTPSPNETWORKINDICATOR_NATIONALNETWORK2:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpNetworkIndicator;
		StorageTmp->mtpSpNetworkIndicator = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpNetworkIndicator = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpName;
		old_length = StorageTmp->mtpSpNameLen;
		StorageTmp->mtpSpName = string;
		StorageTmp->mtpSpNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpName = old_value;
		StorageTmp->mtpSpNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT1;
		StorageTmp->mtpSpMtpT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT2;
		StorageTmp->mtpSpMtpT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT3;
		StorageTmp->mtpSpMtpT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT4: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT4;
		StorageTmp->mtpSpMtpT4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT5;
		StorageTmp->mtpSpMtpT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT6;
		StorageTmp->mtpSpMtpT6 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT6 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT7;
		StorageTmp->mtpSpMtpT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT8: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT8;
		StorageTmp->mtpSpMtpT8 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT8 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT10: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT10: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT10;
		StorageTmp->mtpSpMtpT10 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT10 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT11: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT11: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT11;
		StorageTmp->mtpSpMtpT11 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT11 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT12: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT12: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT12;
		StorageTmp->mtpSpMtpT12 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT12 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT13: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT13: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT13;
		StorageTmp->mtpSpMtpT13 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT13 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT14: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT14: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT14;
		StorageTmp->mtpSpMtpT14 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT14 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT15: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT15: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT15;
		StorageTmp->mtpSpMtpT15 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT15 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT16: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT16: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT16;
		StorageTmp->mtpSpMtpT16 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT16 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT17 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT17 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT17: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT17: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT17;
		StorageTmp->mtpSpMtpT17 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT17 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT19A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT19A;
		StorageTmp->mtpSpMtpT19A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT19A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT31A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT31A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 1000..12000 */
		if ((1000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT31A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT31A;
		StorageTmp->mtpSpMtpT31A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT31A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT32A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT32A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT32A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT32A;
		StorageTmp->mtpSpMtpT32A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT32A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT33A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT33A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 36000 */
		/* Note: ranges 6000..60000 */
		if ((6000 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT33A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT33A;
		StorageTmp->mtpSpMtpT33A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT33A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT34A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT34A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT34A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT34A;
		StorageTmp->mtpSpMtpT34A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT34A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT18I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT18I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT18I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT18I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT18I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT18I;
		StorageTmp->mtpSpMtpT18I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT18I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT19I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT19I;
		StorageTmp->mtpSpMtpT19I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT19I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT20I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT20I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT20I;
		StorageTmp->mtpSpMtpT20I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT20I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT21I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT21I;
		StorageTmp->mtpSpMtpT21I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT21I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT22I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT22I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT22I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT22I;
		StorageTmp->mtpSpMtpT22I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT22I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT23I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT23I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT23I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT23I;
		StorageTmp->mtpSpMtpT23I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT23I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT20A;
		StorageTmp->mtpSpMtpT20A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT20A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT21A;
		StorageTmp->mtpSpMtpT21A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT21A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT24I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT24I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT24I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT24I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT24I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT24I;
		StorageTmp->mtpSpMtpT24I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT24I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT1T;
		StorageTmp->mtpSpMtpT1T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT2T;
		StorageTmp->mtpSpMtpT2T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT2T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT1S entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1S not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1S: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1S: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpMtpT1S;
		StorageTmp->mtpSpMtpT1S = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1S = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfilePointer;
		old_length = StorageTmp->mtpSpProfilePointerLen;
		StorageTmp->mtpSpProfilePointer = string;
		StorageTmp->mtpSpProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfilePointer = old_value;
		StorageTmp->mtpSpProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpNaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpNaPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpNaPointer;
		old_length = StorageTmp->mtpSpNaPointerLen;
		StorageTmp->mtpSpNaPointer = string;
		StorageTmp->mtpSpNaPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpNaPointer = old_value;
		StorageTmp->mtpSpNaPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpFlags(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpFlags entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpFlags not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpFlags: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpFlags;
		old_length = StorageTmp->mtpSpFlagsLen;
		StorageTmp->mtpSpFlags = string;
		StorageTmp->mtpSpFlagsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpFlags = old_value;
		StorageTmp->mtpSpFlagsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpUsers(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpUsers entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpUsers;
		old_length = StorageTmp->mtpSpUsersLen;
		StorageTmp->mtpSpUsers = string;
		StorageTmp->mtpSpUsersLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpUsers = old_value;
		StorageTmp->mtpSpUsersLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpAlarmStatus;
		old_length = StorageTmp->mtpSpAlarmStatusLen;
		StorageTmp->mtpSpAlarmStatus = string;
		StorageTmp->mtpSpAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpAlarmStatus = old_value;
		StorageTmp->mtpSpAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpL3Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpL3AdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case MTPL3ADMINISTRATIVESTATE_LOCKED:
		case MTPL3ADMINISTRATIVESTATE_UNLOCKED:
		case MTPL3ADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpL3AdministrativeState;
		StorageTmp->mtpL3AdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL3AdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3AsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpL3Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpL3AsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpL3AsaProfilePointer;
		old_length = StorageTmp->mtpL3AsaProfilePointerLen;
		StorageTmp->mtpL3AsaProfilePointer = objid;
		StorageTmp->mtpL3AsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL3AsaProfilePointer = old_value;
		StorageTmp->mtpL3AsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpL3Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpL3Name entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpL3Name;
		old_length = StorageTmp->mtpL3NameLen;
		StorageTmp->mtpL3Name = string;
		StorageTmp->mtpL3NameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL3Name = old_value;
		StorageTmp->mtpL3NameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileName;
		old_length = StorageTmp->mtpRsProfileNameLen;
		StorageTmp->mtpRsProfileName = string;
		StorageTmp->mtpRsProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileName = old_value;
		StorageTmp->mtpRsProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 80..120 */
		if ((80 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT8;
		StorageTmp->mtpRsProfileTimerT8 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT8 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 3000..9000 */
		if ((3000 > set_value || set_value > 9000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT11;
		StorageTmp->mtpRsProfileTimerT11 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT11 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 250 */
		/* Note: ranges 200..300 */
		if ((200 > set_value || set_value > 300)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT15;
		StorageTmp->mtpRsProfileTimerT15 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT15 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 175 */
		/* Note: ranges 140..200 */
		if ((140 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT16;
		StorageTmp->mtpRsProfileTimerT16 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT16 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT18A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT18A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1200 */
		/* Note: ranges 200..2000 */
		if ((200 > set_value || set_value > 2000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT18A;
		StorageTmp->mtpRsProfileTimerT18A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT18A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileRtDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileRtDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileRtDefault;
		old_length = StorageTmp->mtpRsProfileRtDefaultLen;
		StorageTmp->mtpRsProfileRtDefault = string;
		StorageTmp->mtpRsProfileRtDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileRtDefault = old_value;
		StorageTmp->mtpRsProfileRtDefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsDest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsDest entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsDest;
		old_length = StorageTmp->mtpRsDestLen;
		StorageTmp->mtpRsDest = string;
		StorageTmp->mtpRsDestLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsDest = old_value;
		StorageTmp->mtpRsDestLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsFlags(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsFlags entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsFlags not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsFlags: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsFlags;
		old_length = StorageTmp->mtpRsFlagsLen;
		StorageTmp->mtpRsFlags = string;
		StorageTmp->mtpRsFlagsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsFlags = old_value;
		StorageTmp->mtpRsFlagsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case MTPRSADMINISTRATIVESTATE_LOCKED:
		case MTPRSADMINISTRATIVESTATE_UNLOCKED:
		case MTPRSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsAdministrativeState;
		StorageTmp->mtpRsAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsAsaProfilePointer;
		old_length = StorageTmp->mtpRsAsaProfilePointerLen;
		StorageTmp->mtpRsAsaProfilePointer = objid;
		StorageTmp->mtpRsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAsaProfilePointer = old_value;
		StorageTmp->mtpRsAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsLoadsharingInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsLoadsharingInformation;
		old_length = StorageTmp->mtpRsLoadsharingInformationLen;
		StorageTmp->mtpRsLoadsharingInformation = string;
		StorageTmp->mtpRsLoadsharingInformationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsLoadsharingInformation = old_value;
		StorageTmp->mtpRsLoadsharingInformationLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsLoadsharingObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsLoadsharingObject;
		old_length = StorageTmp->mtpRsLoadsharingObjectLen;
		StorageTmp->mtpRsLoadsharingObject = objid;
		StorageTmp->mtpRsLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsLoadsharingObject = old_value;
		StorageTmp->mtpRsLoadsharingObjectLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsRemoteExchangeLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsRemoteExchangeLabel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsRemoteExchangeLabel;
		old_length = StorageTmp->mtpRsRemoteExchangeLabelLen;
		StorageTmp->mtpRsRemoteExchangeLabel = string;
		StorageTmp->mtpRsRemoteExchangeLabelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsRemoteExchangeLabel = old_value;
		StorageTmp->mtpRsRemoteExchangeLabelLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsName;
		old_length = StorageTmp->mtpRsNameLen;
		StorageTmp->mtpRsName = string;
		StorageTmp->mtpRsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsName = old_value;
		StorageTmp->mtpRsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfile;
		old_length = StorageTmp->mtpRsProfileLen;
		StorageTmp->mtpRsProfile = string;
		StorageTmp->mtpRsProfileLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfile = old_value;
		StorageTmp->mtpRsProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsAlarmStatus;
		old_length = StorageTmp->mtpRsAlarmStatusLen;
		StorageTmp->mtpRsAlarmStatus = string;
		StorageTmp->mtpRsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAlarmStatus = old_value;
		StorageTmp->mtpRsAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtProfileTimerT6;
		StorageTmp->mtpRtProfileTimerT6 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfileTimerT6 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfileTimerT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4500 */
		/* Note: ranges 3000..6000 */
		if ((3000 > set_value || set_value > 6000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtProfileTimerT10;
		StorageTmp->mtpRtProfileTimerT10 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfileTimerT10 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLsPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtLsPointer;
		old_length = StorageTmp->mtpRtLsPointerLen;
		StorageTmp->mtpRtLsPointer = string;
		StorageTmp->mtpRtLsPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLsPointer = old_value;
		StorageTmp->mtpRtLsPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case MTPRTADMINISTRATIVESTATE_LOCKED:
		case MTPRTADMINISTRATIVESTATE_UNLOCKED:
		case MTPRTADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtAdministrativeState;
		StorageTmp->mtpRtAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtInClsLoadsharingAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtInClsLoadsharingAlgorithm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..0 16..16 32..32 256..256 */
		if (set_value != 0 && set_value != 16 && set_value != 32 && set_value != 256) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtInClsLoadsharingAlgorithm;
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtFixedPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtFixedPriority entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtFixedPriority;
		StorageTmp->mtpRtFixedPriority = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFixedPriority = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtFlexiblePriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtFlexiblePriority entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtFlexiblePriority;
		StorageTmp->mtpRtFlexiblePriority = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFlexiblePriority = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtPriorityMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtPriorityMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPRTPRIORITYMODE_INSERT:
		case MTPRTPRIORITYMODE_EQUAL:
		case MTPRTPRIORITYMODE_EXCHANGESINGLE:
		case MTPRTPRIORITYMODE_EXCHANGEGROUP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtPriorityMode;
		StorageTmp->mtpRtPriorityMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtPriorityMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLoadsharingInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtLoadsharingInformation;
		old_length = StorageTmp->mtpRtLoadsharingInformationLen;
		StorageTmp->mtpRtLoadsharingInformation = string;
		StorageTmp->mtpRtLoadsharingInformationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLoadsharingInformation = old_value;
		StorageTmp->mtpRtLoadsharingInformationLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLoadsharingObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtLoadsharingObject;
		old_length = StorageTmp->mtpRtLoadsharingObjectLen;
		StorageTmp->mtpRtLoadsharingObject = objid;
		StorageTmp->mtpRtLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLoadsharingObject = old_value;
		StorageTmp->mtpRtLoadsharingObjectLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtName;
		old_length = StorageTmp->mtpRtNameLen;
		StorageTmp->mtpRtName = string;
		StorageTmp->mtpRtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtName = old_value;
		StorageTmp->mtpRtNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtSlsList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtSlsList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..256 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 256))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtSlsList;
		old_length = StorageTmp->mtpRtSlsListLen;
		StorageTmp->mtpRtSlsList = string;
		StorageTmp->mtpRtSlsListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtSlsList = old_value;
		StorageTmp->mtpRtSlsListLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtRlSlot(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtRlSlot entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..3 */
		if ((0 > set_value || set_value > 3)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtRlSlot;
		StorageTmp->mtpRtRlSlot = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtRlSlot = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtProfile;
		old_length = StorageTmp->mtpRtProfileLen;
		StorageTmp->mtpRtProfile = string;
		StorageTmp->mtpRtProfileLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfile = old_value;
		StorageTmp->mtpRtProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLsaNormalSlCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsaNormalSlCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..15 */
		if ((0 > set_value || set_value > 15)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtLsaNormalSlCode;
		StorageTmp->mtpRtLsaNormalSlCode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLsaNormalSlCode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLsaAlternativeSlCodeList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsaAlternativeSlCodeList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaAlternativeSlCodeList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..31 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 31))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaAlternativeSlCodeList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtLsaAlternativeSlCodeList;
		old_length = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
		StorageTmp->mtpRtLsaAlternativeSlCodeList = string;
		StorageTmp->mtpRtLsaAlternativeSlCodeListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLsaAlternativeSlCodeList = old_value;
		StorageTmp->mtpRtLsaAlternativeSlCodeListLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT6;
		StorageTmp->mtpLsProfileTimerT6 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT6 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT8;
		StorageTmp->mtpLsProfileTimerT8 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT8 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4500 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT10;
		StorageTmp->mtpLsProfileTimerT10 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT10 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 150 */
		/* Note: ranges 100..200 */
		if ((100 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT7;
		StorageTmp->mtpLsProfileTimerT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT19I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT19I;
		StorageTmp->mtpLsProfileTimerT19I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT19I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT21I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT21I;
		StorageTmp->mtpLsProfileTimerT21I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT21I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT25A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT25A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT25A;
		StorageTmp->mtpLsProfileTimerT25A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT25A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT28A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT28A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT28A;
		StorageTmp->mtpLsProfileTimerT28A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT28A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT29A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT29A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT29A;
		StorageTmp->mtpLsProfileTimerT29A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT29A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT30A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT30A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT30A;
		StorageTmp->mtpLsProfileTimerT30A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT30A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileName;
		old_length = StorageTmp->mtpLsProfileNameLen;
		StorageTmp->mtpLsProfileName = string;
		StorageTmp->mtpLsProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileName = old_value;
		StorageTmp->mtpLsProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileSlDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileSlDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileSlDefault;
		old_length = StorageTmp->mtpLsProfileSlDefaultLen;
		StorageTmp->mtpLsProfileSlDefault = string;
		StorageTmp->mtpLsProfileSlDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileSlDefault = old_value;
		StorageTmp->mtpLsProfileSlDefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAdjPc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsAdjPc;
		old_length = StorageTmp->mtpLsAdjPcLen;
		StorageTmp->mtpLsAdjPc = string;
		StorageTmp->mtpLsAdjPcLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAdjPc = old_value;
		StorageTmp->mtpLsAdjPcLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsRsId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsRsId entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsRsId;
		old_length = StorageTmp->mtpLsRsIdLen;
		StorageTmp->mtpLsRsId = string;
		StorageTmp->mtpLsRsIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsRsId = old_value;
		StorageTmp->mtpLsRsIdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsMaxCapacity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..128000 */
		if ((0 > set_value || set_value > 128000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsMaxCapacity;
		StorageTmp->mtpLsMaxCapacity = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsMaxCapacity = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCongestionControlMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsCongestionControlMethod entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPLSCONGESTIONCONTROLMETHOD_UNKNOWN:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704INTERNATIONAL:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALWITHPRIO:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALNOPRIOBUFFERMECHANISM:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALNOPRIOTIMERMECHANISM:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsCongestionControlMethod;
		StorageTmp->mtpLsCongestionControlMethod = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCongestionControlMethod = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsPeriodicLinkTestFlag(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsPeriodicLinkTestFlag entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case MTPLSPERIODICLINKTESTFLAG_ON:
		case MTPLSPERIODICLINKTESTFLAG_OFF:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsPeriodicLinkTestFlag;
		StorageTmp->mtpLsPeriodicLinkTestFlag = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsPeriodicLinkTestFlag = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsPeriodicLinkTestFail(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsPeriodicLinkTestFail entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		switch (set_value) {
		case MTPLSPERIODICLINKTESTFAIL_TRUE:
		case MTPLSPERIODICLINKTESTFAIL_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsPeriodicLinkTestFail;
		StorageTmp->mtpLsPeriodicLinkTestFail = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsPeriodicLinkTestFail = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case MTPLSADMINISTRATIVESTATE_LOCKED:
		case MTPLSADMINISTRATIVESTATE_UNLOCKED:
		case MTPLSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsAdministrativeState;
		StorageTmp->mtpLsAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsInLsLoadShareAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsInLsLoadShareAlgorithm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsInLsLoadShareAlgorithm;
		old_length = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
		StorageTmp->mtpLsInLsLoadShareAlgorithm = objid;
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsInLsLoadShareAlgorithm = old_value;
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfilePointer;
		old_length = StorageTmp->mtpLsProfilePointerLen;
		StorageTmp->mtpLsProfilePointer = string;
		StorageTmp->mtpLsProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfilePointer = old_value;
		StorageTmp->mtpLsProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsNumberOfNormallyActiveSignLinks(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsNumberOfNormallyActiveSignLinks entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..32 */
		if ((0 > set_value || set_value > 32)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsNumberOfNormallyActiveSignLinks;
		StorageTmp->mtpLsNumberOfNormallyActiveSignLinks = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsNumberOfNormallyActiveSignLinks = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsName;
		old_length = StorageTmp->mtpLsNameLen;
		StorageTmp->mtpLsName = string;
		StorageTmp->mtpLsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsName = old_value;
		StorageTmp->mtpLsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsAsaProfilePointer;
		old_length = StorageTmp->mtpLsAsaProfilePointerLen;
		StorageTmp->mtpLsAsaProfilePointer = objid;
		StorageTmp->mtpLsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAsaProfilePointer = old_value;
		StorageTmp->mtpLsAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsAlarmStatus;
		old_length = StorageTmp->mtpLsAlarmStatusLen;
		StorageTmp->mtpLsAlarmStatus = string;
		StorageTmp->mtpLsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAlarmStatus = old_value;
		StorageTmp->mtpLsAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT1;
		StorageTmp->mtpSlL3ProfileTimerT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT3;
		StorageTmp->mtpSlL3ProfileTimerT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT17 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT17;
		StorageTmp->mtpSlL3ProfileTimerT17 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT17 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT24I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT24I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 50 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT24I;
		StorageTmp->mtpSlL3ProfileTimerT24I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT24I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileName;
		old_length = StorageTmp->mtpSlL3ProfileNameLen;
		StorageTmp->mtpSlL3ProfileName = string;
		StorageTmp->mtpSlL3ProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileName = old_value;
		StorageTmp->mtpSlL3ProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT2;
		StorageTmp->mtpSlL3ProfileTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT4;
		StorageTmp->mtpSlL3ProfileTimerT4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT5;
		StorageTmp->mtpSlL3ProfileTimerT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT12;
		StorageTmp->mtpSlL3ProfileTimerT12 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT12 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT13;
		StorageTmp->mtpSlL3ProfileTimerT13 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT13 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT14;
		StorageTmp->mtpSlL3ProfileTimerT14 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT14 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT19A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT19A;
		StorageTmp->mtpSlL3ProfileTimerT19A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT19A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT20A;
		StorageTmp->mtpSlL3ProfileTimerT20A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT20A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT21A;
		StorageTmp->mtpSlL3ProfileTimerT21A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT21A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT22I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT22I;
		StorageTmp->mtpSlL3ProfileTimerT22I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT22I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT23I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT23I;
		StorageTmp->mtpSlL3ProfileTimerT23I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT23I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT31A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 1000..12000 */
		if ((1000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT31A;
		StorageTmp->mtpSlL3ProfileTimerT31A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT31A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT32A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT32A;
		StorageTmp->mtpSlL3ProfileTimerT32A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT32A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT33A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 36000 */
		/* Note: ranges 6000..60000 */
		if ((6000 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT33A;
		StorageTmp->mtpSlL3ProfileTimerT33A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT33A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT34A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT34A;
		StorageTmp->mtpSlL3ProfileTimerT34A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT34A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT1T;
		StorageTmp->mtpSlL3ProfileTimerT1T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT2T;
		StorageTmp->mtpSlL3ProfileTimerT2T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT2T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1S entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT1S;
		StorageTmp->mtpSlL3ProfileTimerT1S = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1S = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileL2Default(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileL2Default entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileL2Default;
		old_length = StorageTmp->mtpSlL3ProfileL2DefaultLen;
		StorageTmp->mtpSlL3ProfileL2Default = string;
		StorageTmp->mtpSlL3ProfileL2DefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileL2Default = old_value;
		StorageTmp->mtpSlL3ProfileL2DefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileErrorCorrectionMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileErrorCorrectionMethod entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLL2PROFILEERRORCORRECTIONMETHOD_BASICRETR:
		case MTPSLL2PROFILEERRORCORRECTIONMETHOD_PREVCYCLRETR:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileErrorCorrectionMethod;
		StorageTmp->mtpSlL2ProfileErrorCorrectionMethod = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileErrorCorrectionMethod = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLL2PROFILETRANSMISSIONRATE_KBITS4POINT8:
		case MTPSLL2PROFILETRANSMISSIONRATE_KBITS56:
		case MTPSLL2PROFILETRANSMISSIONRATE_KBITS64:
		case MTPSLL2PROFILETRANSMISSIONRATE_KBITS1544:
		case MTPSLL2PROFILETRANSMISSIONRATE_KBITS2048:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTransmissionRate;
		StorageTmp->mtpSlL2ProfileTransmissionRate = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTransmissionRate = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1290..60000 */
		if ((1290 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT1;
		StorageTmp->mtpSlL2ProfileTimerT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 500..15000 */
		if ((500 > set_value || set_value > 15000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT2;
		StorageTmp->mtpSlL2ProfileTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT2L(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2L entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT2L;
		StorageTmp->mtpSlL2ProfileTimerT2L = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2L = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT2H(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2H entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT2H;
		StorageTmp->mtpSlL2ProfileTimerT2H = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2H = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 100..1400 */
		if ((100 > set_value || set_value > 1400)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT3;
		StorageTmp->mtpSlL2ProfileTimerT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT4N(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT4N entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 230..12000 */
		if ((230 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT4N;
		StorageTmp->mtpSlL2ProfileTimerT4N = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT4N = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT4E(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT4E entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 40..800 */
		if ((40 > set_value || set_value > 800)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT4E;
		StorageTmp->mtpSlL2ProfileTimerT4E = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT4E = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..12 */
		if ((8 > set_value || set_value > 12)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT5;
		StorageTmp->mtpSlL2ProfileTimerT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 300..1200 */
		if ((300 > set_value || set_value > 1200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT6;
		StorageTmp->mtpSlL2ProfileTimerT6 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT6 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 50..600 */
		if ((50 > set_value || set_value > 600)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT7;
		StorageTmp->mtpSlL2ProfileTimerT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbOnset1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbOnset1;
		StorageTmp->mtpSlL2ProfileTbOnset1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbAbate1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbAbate1;
		StorageTmp->mtpSlL2ProfileTbAbate1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileNumberOfThresholdLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileNumberOfThresholdLevels entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels;
		StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileCongestionCounting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileCongestionCounting entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLL2PROFILECONGESTIONCOUNTING_OCTET:
		case MTPSLL2PROFILECONGESTIONCOUNTING_MESSAGE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileCongestionCounting;
		StorageTmp->mtpSlL2ProfileCongestionCounting = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileCongestionCounting = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileCongestionReportingBaseObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileCongestionReportingBaseObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_ROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_LINKSETOFCONGESTEDROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_LINKOFCONGESTEDROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_CONGESTEDLINKOFCONGESTEDROUTE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject;
		StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileLoopDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileLoopDelay;
		StorageTmp->mtpSlL2ProfileLoopDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileLoopDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileName;
		old_length = StorageTmp->mtpSlL2ProfileNameLen;
		StorageTmp->mtpSlL2ProfileName = string;
		StorageTmp->mtpSlL2ProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileName = old_value;
		StorageTmp->mtpSlL2ProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbOnset2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbOnset2;
		StorageTmp->mtpSlL2ProfileTbOnset2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbAbate2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbAbate2;
		StorageTmp->mtpSlL2ProfileTbAbate2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbOnset3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbOnset3;
		StorageTmp->mtpSlL2ProfileTbOnset3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbAbate3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbAbate3;
		StorageTmp->mtpSlL2ProfileTbAbate3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbDiscard1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbDiscard1;
		StorageTmp->mtpSlL2ProfileTbDiscard1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbDiscard2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbDiscard2;
		StorageTmp->mtpSlL2ProfileTbDiscard2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbDiscard3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbDiscard3;
		StorageTmp->mtpSlL2ProfileTbDiscard3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerTx(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerTx entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerTx;
		StorageTmp->mtpSlL2ProfileTimerTx = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerTx = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerTy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerTy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerTy;
		StorageTmp->mtpSlL2ProfileTimerTy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerTy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileNumberOfCongestionStates(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileNumberOfCongestionStates entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileNumberOfCongestionStates;
		StorageTmp->mtpSlL2ProfileNumberOfCongestionStates = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileNumberOfCongestionStates = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileInitialLevelOfCongestion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileInitialLevelOfCongestion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion;
		StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileMaxMSUsRetransN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileMaxMSUsRetransN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..16777215 */
		if ((0 > set_value || set_value > 16777215)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1;
		StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileMaxOctRetransN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileMaxOctRetransN2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileMaxOctRetransN2;
		StorageTmp->mtpSlL2ProfileMaxOctRetransN2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileMaxOctRetransN2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileReceiveCongestionThresholdOnset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdOnset entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileReceiveCongestionThresholdAbate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdAbate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileReceiveCongestionThresholdDiscard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdDiscard entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileM entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileM;
		StorageTmp->mtpSlL2ProfileM = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileM = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSlsCodeCurrentList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSlsCodeCurrentList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeCurrentList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..256 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 256))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeCurrentList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSlsCodeCurrentList;
		old_length = StorageTmp->mtpSlSlsCodeCurrentListLen;
		StorageTmp->mtpSlSlsCodeCurrentList = string;
		StorageTmp->mtpSlSlsCodeCurrentListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSlsCodeCurrentList = old_value;
		StorageTmp->mtpSlSlsCodeCurrentListLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlMaxCapacitySL(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlMaxCapacitySL entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMaxCapacitySL not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMaxCapacitySL: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..512000 */
		if ((0 > set_value || set_value > 512000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMaxCapacitySL: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlMaxCapacitySL;
		StorageTmp->mtpSlMaxCapacitySL = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlMaxCapacitySL = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case MTPSLADMINISTRATIVESTATE_LOCKED:
		case MTPSLADMINISTRATIVESTATE_UNLOCKED:
		case MTPSLADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlAdministrativeState;
		StorageTmp->mtpSlAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlMtpL2ProtocolProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlMtpL2ProtocolProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlMtpL2ProtocolProfilePointer;
		old_length = StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen;
		StorageTmp->mtpSlMtpL2ProtocolProfilePointer = string;
		StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlMtpL2ProtocolProfilePointer = old_value;
		StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSignTermPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSignTermPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSignTermPointer;
		old_length = StorageTmp->mtpSlSignTermPointerLen;
		StorageTmp->mtpSlSignTermPointer = objid;
		StorageTmp->mtpSlSignTermPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSignTermPointer = old_value;
		StorageTmp->mtpSlSignTermPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSignDataLinkTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSignDataLinkTpPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSignDataLinkTpPointer;
		old_length = StorageTmp->mtpSlSignDataLinkTpPointerLen;
		StorageTmp->mtpSlSignDataLinkTpPointer = objid;
		StorageTmp->mtpSlSignDataLinkTpPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSignDataLinkTpPointer = old_value;
		StorageTmp->mtpSlSignDataLinkTpPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlLocalInhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlLocalInhibit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLLOCALINHIBIT_SUCCESS:
		case MTPSLLOCALINHIBIT_UNSUCCESSFUL:
		case MTPSLLOCALINHIBIT_NOTPERFORMED:
		case MTPSLLOCALINHIBIT_LINKALREADYINHIBITED:
		case MTPSLLOCALINHIBIT_LINKNOTINHIBITED:
		case MTPSLLOCALINHIBIT_WRONGCLASSREFERENCED:
		case MTPSLLOCALINHIBIT_SIGNTERMNONEXISTING:
		case MTPSLLOCALINHIBIT_SIGNTERMALREADYREFERENCED:
		case MTPSLLOCALINHIBIT_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlLocalInhibit;
		StorageTmp->mtpSlLocalInhibit = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalInhibit = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlLocalUninhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlLocalUninhibit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLLOCALUNINHIBIT_SUCCESS:
		case MTPSLLOCALUNINHIBIT_UNSUCCESSFUL:
		case MTPSLLOCALUNINHIBIT_NOTPERFORMED:
		case MTPSLLOCALUNINHIBIT_LINKALREADYINHIBITED:
		case MTPSLLOCALUNINHIBIT_LINKNOTINHIBITED:
		case MTPSLLOCALUNINHIBIT_WRONGCLASSREFERENCED:
		case MTPSLLOCALUNINHIBIT_SIGNTERMNONEXISTING:
		case MTPSLLOCALUNINHIBIT_SIGNTERMALREADYREFERENCED:
		case MTPSLLOCALUNINHIBIT_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlLocalUninhibit;
		StorageTmp->mtpSlLocalUninhibit = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalUninhibit = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlReplaceSt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlReplaceSt entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLREPLACEST_SUCCESS:
		case MTPSLREPLACEST_UNSUCCESSFUL:
		case MTPSLREPLACEST_NOTPERFORMED:
		case MTPSLREPLACEST_LINKALREADYINHIBITED:
		case MTPSLREPLACEST_LINKNOTINHIBITED:
		case MTPSLREPLACEST_WRONGCLASSREFERENCED:
		case MTPSLREPLACEST_SIGNTERMNONEXISTING:
		case MTPSLREPLACEST_SIGNTERMALREADYREFERENCED:
		case MTPSLREPLACEST_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlReplaceSt;
		StorageTmp->mtpSlReplaceSt = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlReplaceSt = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlAsaProfilePointer;
		old_length = StorageTmp->mtpSlAsaProfilePointerLen;
		StorageTmp->mtpSlAsaProfilePointer = objid;
		StorageTmp->mtpSlAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAsaProfilePointer = old_value;
		StorageTmp->mtpSlAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlRelatedLinkGroupNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlRelatedLinkGroupNumber entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..15 */
		if ((0 > set_value || set_value > 15)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlRelatedLinkGroupNumber;
		StorageTmp->mtpSlRelatedLinkGroupNumber = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlRelatedLinkGroupNumber = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdlList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSdlList;
		StorageTmp->mtpSlSdlList = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdlList = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlTest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlTest entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLTEST_SUCCESS:
		case MTPSLTEST_UNSUCCESSFUL:
		case MTPSLTEST_NOTPERFORMED:
		case MTPSLTEST_LINKALREADYINHIBITED:
		case MTPSLTEST_LINKNOTINHIBITED:
		case MTPSLTEST_WRONGCLASSREFERENCED:
		case MTPSLTEST_SIGNTERMNONEXISTING:
		case MTPSLTEST_SIGNTERMALREADYREFERENCED:
		case MTPSLTEST_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlTest;
		StorageTmp->mtpSlTest = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlTest = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlName;
		old_length = StorageTmp->mtpSlNameLen;
		StorageTmp->mtpSlName = string;
		StorageTmp->mtpSlNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlName = old_value;
		StorageTmp->mtpSlNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdtList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSdtList;
		StorageTmp->mtpSlSdtList = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdtList = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSlsCodeNormalList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSlsCodeNormalList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..256 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 256))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSlsCodeNormalList;
		old_length = StorageTmp->mtpSlSlsCodeNormalListLen;
		StorageTmp->mtpSlSlsCodeNormalList = string;
		StorageTmp->mtpSlSlsCodeNormalListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSlsCodeNormalList = old_value;
		StorageTmp->mtpSlSlsCodeNormalListLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfilePointer;
		old_length = StorageTmp->mtpSlL3ProfilePointerLen;
		StorageTmp->mtpSlL3ProfilePointer = string;
		StorageTmp->mtpSlL3ProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfilePointer = old_value;
		StorageTmp->mtpSlL3ProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlAlarmStatus;
		old_length = StorageTmp->mtpSlAlarmStatusLen;
		StorageTmp->mtpSlAlarmStatus = string;
		StorageTmp->mtpSlAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAlarmStatus = old_value;
		StorageTmp->mtpSlAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdlListPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSdlListPointer;
		old_length = StorageTmp->mtpSlSdlListPointerLen;
		StorageTmp->mtpSlSdlListPointer = objid;
		StorageTmp->mtpSlSdlListPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdlListPointer = old_value;
		StorageTmp->mtpSlSdlListPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdtListPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSdtListPointer;
		old_length = StorageTmp->mtpSlSdtListPointerLen;
		StorageTmp->mtpSlSdtListPointer = objid;
		StorageTmp->mtpSlSdtListPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdtListPointer = old_value;
		StorageTmp->mtpSlSdtListPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPNBTRANSMISSIONRATE_KBITS4POINT8:
		case MTPNBTRANSMISSIONRATE_KBITS56:
		case MTPNBTRANSMISSIONRATE_KBITS64:
		case MTPNBTRANSMISSIONRATE_KBITS1544:
		case MTPNBTRANSMISSIONRATE_KBITS2048:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbTransmissionRate;
		StorageTmp->mtpNbTransmissionRate = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTransmissionRate = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTimerT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTimerT8 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTimerT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbTimerT8;
		StorageTmp->mtpNbTimerT8 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTimerT8 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbTin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* Note: ranges 4..4 */
		if (set_value != 4) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTin: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbTin;
		StorageTmp->mtpNbTin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbTie(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTie entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTie not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTie: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		/* Note: ranges 1..1 */
		if (set_value != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTie: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbTie;
		StorageTmp->mtpNbTie = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTie = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbT not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		/* Note: ranges 256..256 */
		if (set_value != 256) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbT: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbT;
		StorageTmp->mtpNbT = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbT = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbD(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbD entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbD not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbD: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 64 */
		/* Note: ranges 64..64 */
		if (set_value != 64) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbD: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbD;
		StorageTmp->mtpNbD = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbD = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbTe(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTe entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTe not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTe: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbTe;
		StorageTmp->mtpNbTe = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTe = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbDe(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbDe entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbDe not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbDe: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbDe;
		StorageTmp->mtpNbDe = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbDe = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbUe(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbUe entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbUe not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbUe: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbUe;
		StorageTmp->mtpNbUe = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbUe = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbN(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbN entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbN not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbN: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 16 */
		/* Note: ranges 16..16 */
		if (set_value != 16) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbN: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbN;
		StorageTmp->mtpNbN = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbN = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbm not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 272 */
		/* Note: ranges 272..272 4096..4096 */
		if (set_value != 272 && set_value != 4096) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbm: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbm;
		StorageTmp->mtpNbm = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbm = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbb(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbb entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbb not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbb: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..8 192..192 256..256 */
		if (set_value != 8 && set_value != 192 && set_value != 256) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbb: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbb;
		StorageTmp->mtpNbb = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbb = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbf(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbf entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case MTPNBF_ONE:
		case MTPNBF_SHARED:
		case MTPNBF_TWO:
		case MTPNBF_THREE:
		case MTPNBF_FOUR:
		case MTPNBF_FIVE:
		case MTPNBF_SIX:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbf;
		StorageTmp->mtpNbf = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbf = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalBufferRelease(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalBufferRelease entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAALBUFFERRELEASE_TRUE:
		case MTPSAALBUFFERRELEASE_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalBufferRelease;
		StorageTmp->mtpSaalBufferRelease = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalBufferRelease = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxCc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxCc;
		StorageTmp->mtpSaalMaxCc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxCc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxNrp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxNrp entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxNrp;
		StorageTmp->mtpSaalMaxNrp = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxNrp = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxInformationFieldLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxInformationFieldLength entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4096 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxInformationFieldLength;
		StorageTmp->mtpSaalMaxInformationFieldLength = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxInformationFieldLength = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxLengthSscopUuField(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxLengthSscopUuField entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxLengthSscopUuField;
		StorageTmp->mtpSaalMaxLengthSscopUuField = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxLengthSscopUuField = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxPd(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxPd entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxPd;
		StorageTmp->mtpSaalMaxPd = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxPd = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxSscopCreditToPeer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxSscopCreditToPeer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxSscopCreditToPeer;
		StorageTmp->mtpSaalMaxSscopCreditToPeer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxSscopCreditToPeer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxStat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxStat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 67 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxStat;
		StorageTmp->mtpSaalMaxStat = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxStat = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalN1;
		StorageTmp->mtpSaalN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementProvingState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_NORMAL:
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_EMERGENCY:
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_NEUTRAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniLayerManagementProvingState;
		StorageTmp->mtpSaalNniLayerManagementProvingState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementProvingState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementTimerNoCredit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementTimerNoCredit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementTimerRepeatSrec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementTimerRepeatSrec entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniTimerT1;
		StorageTmp->mtpSaalNniTimerT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniTimerT2;
		StorageTmp->mtpSaalNniTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniTimerT3;
		StorageTmp->mtpSaalNniTimerT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerCc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerCc;
		StorageTmp->mtpSaalSscopTimerCc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerCc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerIdle entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerIdle;
		StorageTmp->mtpSaalSscopTimerIdle = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerIdle = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerKeepAlive entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerKeepAlive;
		StorageTmp->mtpSaalSscopTimerKeepAlive = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerKeepAlive = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerNoResponse(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerNoResponse entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 150 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerNoResponse;
		StorageTmp->mtpSaalSscopTimerNoResponse = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerNoResponse = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerPoll(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerPoll entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerPoll;
		StorageTmp->mtpSaalSscopTimerPoll = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerPoll = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 129 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalTransmissionRateIntervalLower;
		StorageTmp->mtpSaalTransmissionRateIntervalLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalEgressTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalEgressTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalEgressTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalEgressTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalPollAfterRetransmission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalPollAfterRetransmission entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAALPOLLAFTERRETRANSMISSION_TRUE:
		case MTPSAALPOLLAFTERRETRANSMISSION_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalPollAfterRetransmission;
		StorageTmp->mtpSaalPollAfterRetransmission = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalPollAfterRetransmission = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paN1;
		StorageTmp->mtpM2paN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paProving(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paProving entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		switch (set_value) {
		case MTPM2PAPROVING_TRUE:
		case MTPM2PAPROVING_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paProving;
		StorageTmp->mtpM2paProving = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProving = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paManagementProvingState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPM2PAMANAGEMENTPROVINGSTATE_NORMAL:
		case MTPM2PAMANAGEMENTPROVINGSTATE_EMERGENCY:
		case MTPM2PAMANAGEMENTPROVINGSTATE_NEUTRAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paManagementProvingState;
		StorageTmp->mtpM2paManagementProvingState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paManagementProvingState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paLoopDelayLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paLoopDelayLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paLoopDelayLower;
		StorageTmp->mtpM2paLoopDelayLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paLoopDelayUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paLoopDelayUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paLoopDelayUpper;
		StorageTmp->mtpM2paLoopDelayUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paTransmissionRateIntervalLower;
		StorageTmp->mtpM2paTransmissionRateIntervalLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paTransmissionRateIntervalUpper;
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPM2PASCTPNODELAY_TRUE:
		case MTPM2PASCTPNODELAY_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpNoDelay;
		StorageTmp->mtpM2paSctpNoDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpNoDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..65536 */
		if ((1 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpMaxseg;
		StorageTmp->mtpM2paSctpMaxseg = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxseg = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpHeartbeatItvl;
		StorageTmp->mtpM2paSctpHeartbeatItvl = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeatItvl = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPM2PASCTPHEARTBEAT_TRUE:
		case MTPM2PASCTPHEARTBEAT_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpHeartbeat;
		StorageTmp->mtpM2paSctpHeartbeat = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeat = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpRtoInitial;
		StorageTmp->mtpM2paSctpRtoInitial = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoInitial = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpRtoMin;
		StorageTmp->mtpM2paSctpRtoMin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpRtoMax;
		StorageTmp->mtpM2paSctpRtoMax = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMax = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpPathMaxRetrans;
		StorageTmp->mtpM2paSctpPathMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpPathMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpCookieLife;
		StorageTmp->mtpM2paSctpCookieLife = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieLife = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpCookieInc;
		StorageTmp->mtpM2paSctpCookieInc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieInc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpMaxInitRetries;
		StorageTmp->mtpM2paSctpMaxInitRetries = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxInitRetries = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpMaxBurst;
		StorageTmp->mtpM2paSctpMaxBurst = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxBurst = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpAssocMaxRetrans;
		StorageTmp->mtpM2paSctpAssocMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpAssocMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 0..50 */
		if ((0 > set_value || set_value > 50)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpSackDelay;
		StorageTmp->mtpM2paSctpSackDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpSackDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpLifetime;
		StorageTmp->mtpM2paSctpLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paProvingAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paProvingAttempts entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paProvingAttempts;
		StorageTmp->mtpM2paProvingAttempts = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProvingAttempts = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case MTPSDTADMINISTRATIVESTATE_LOCKED:
		case MTPSDTADMINISTRATIVESTATE_UNLOCKED:
		case MTPSDTADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdtAdministrativeState;
		StorageTmp->mtpSdtAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtEquipmentPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdtEquipmentPointer;
		old_length = StorageTmp->mtpSdtEquipmentPointerLen;
		StorageTmp->mtpSdtEquipmentPointer = objid;
		StorageTmp->mtpSdtEquipmentPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtEquipmentPointer = old_value;
		StorageTmp->mtpSdtEquipmentPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdtName;
		old_length = StorageTmp->mtpSdtNameLen;
		StorageTmp->mtpSdtName = string;
		StorageTmp->mtpSdtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtName = old_value;
		StorageTmp->mtpSdtNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdtProfilePointer;
		old_length = StorageTmp->mtpSdtProfilePointerLen;
		StorageTmp->mtpSdtProfilePointer = objid;
		StorageTmp->mtpSdtProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtProfilePointer = old_value;
		StorageTmp->mtpSdtProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlAdjPc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlAdjPc;
		old_length = StorageTmp->mtpSdlAdjPcLen;
		StorageTmp->mtpSdlAdjPc = string;
		StorageTmp->mtpSdlAdjPcLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlAdjPc = old_value;
		StorageTmp->mtpSdlAdjPcLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSDLTRANSMISSIONRATE_KBITS4POINT8:
		case MTPSDLTRANSMISSIONRATE_KBITS56:
		case MTPSDLTRANSMISSIONRATE_KBITS64:
		case MTPSDLTRANSMISSIONRATE_KBITS1544:
		case MTPSDLTRANSMISSIONRATE_KBITS2048:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlTransmissionRate;
		StorageTmp->mtpSdlTransmissionRate = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlTransmissionRate = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlLoopDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlLoopDelay;
		StorageTmp->mtpSdlLoopDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlLoopDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlOperationalState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlOperationalState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlOperationalState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlOperationalState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case MTPSDLOPERATIONALSTATE_DISABLED:
		case MTPSDLOPERATIONALSTATE_ENABLED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlOperationalState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlOperationalState;
		StorageTmp->mtpSdlOperationalState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlOperationalState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlEquipmentPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlEquipmentPointer;
		old_length = StorageTmp->mtpSdlEquipmentPointerLen;
		StorageTmp->mtpSdlEquipmentPointer = objid;
		StorageTmp->mtpSdlEquipmentPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlEquipmentPointer = old_value;
		StorageTmp->mtpSdlEquipmentPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlCIC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..16383 */
		if ((0 > set_value || set_value > 16383)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlCIC;
		StorageTmp->mtpSdlCIC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlCIC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlName;
		old_length = StorageTmp->mtpSdlNameLen;
		StorageTmp->mtpSdlName = string;
		StorageTmp->mtpSdlNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlName = old_value;
		StorageTmp->mtpSdlNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlStmChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlStmChannel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlStmChannel;
		old_length = StorageTmp->mtpSdlStmChannelLen;
		StorageTmp->mtpSdlStmChannel = string;
		StorageTmp->mtpSdlStmChannelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlStmChannel = old_value;
		StorageTmp->mtpSdlStmChannelLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlVcTTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlVcTTpPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlVcTTpPointer;
		old_length = StorageTmp->mtpSdlVcTTpPointerLen;
		StorageTmp->mtpSdlVcTTpPointer = objid;
		StorageTmp->mtpSdlVcTTpPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlVcTTpPointer = old_value;
		StorageTmp->mtpSdlVcTTpPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		switch (set_value) {
		case MTPM2PADEFAULTSCTPNODELAY_TRUE:
		case MTPM2PADEFAULTSCTPNODELAY_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpNoDelay;
		StorageTmp->mtpM2paDefaultSctpNoDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpNoDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		if ((1 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpMaxseg;
		StorageTmp->mtpM2paDefaultSctpMaxseg = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxseg = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpHeartbeatItvl;
		StorageTmp->mtpM2paDefaultSctpHeartbeatItvl = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpHeartbeatItvl = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPM2PADEFAULTSCTPHEARTBEAT_TRUE:
		case MTPM2PADEFAULTSCTPHEARTBEAT_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpHeartbeat;
		StorageTmp->mtpM2paDefaultSctpHeartbeat = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpHeartbeat = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpRtoInitial;
		StorageTmp->mtpM2paDefaultSctpRtoInitial = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoInitial = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpRtoMin;
		StorageTmp->mtpM2paDefaultSctpRtoMin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoMin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpRtoMax;
		StorageTmp->mtpM2paDefaultSctpRtoMax = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoMax = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpPathMaxRetrans;
		StorageTmp->mtpM2paDefaultSctpPathMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpPathMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpCookieLife;
		StorageTmp->mtpM2paDefaultSctpCookieLife = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpCookieLife = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpCookieInc;
		StorageTmp->mtpM2paDefaultSctpCookieInc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpCookieInc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpMaxInitRetries;
		StorageTmp->mtpM2paDefaultSctpMaxInitRetries = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxInitRetries = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpMaxBurst;
		StorageTmp->mtpM2paDefaultSctpMaxBurst = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxBurst = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans;
		StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..50 */
		if ((0 > set_value || set_value > 50)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpSackDelay;
		StorageTmp->mtpM2paDefaultSctpSackDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpSackDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpLifetime;
		StorageTmp->mtpM2paDefaultSctpLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL;
	static struct mtpSapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSapRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSapTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSapTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpSapTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSapId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSapAsaProfilePointer = { zeroDotZero }; */
			StorageNew->mtpSapRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSapTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSapTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSapRowStatus;
			StorageTmp->mtpSapRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpSapTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpSapTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSapTableStorage, StorageNew);
			header_complex_extract_entry(&mtpSapTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSapRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSapTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSapRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSapRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSapTable_del(&StorageDel);
			/* mtpSapTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMsTable_data *StorageTmp = NULL;
	static struct mtpMsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpMsStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpMsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpMsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpMsTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpMsAsaProfilePointer = { zeroDotZero }; */
			StorageNew->mtpMsStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpMsTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpMsTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpMsStatus;
			StorageTmp->mtpMsStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpMsTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpMsTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpMsTableStorage, StorageNew);
			header_complex_extract_entry(&mtpMsTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpMsStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpMsTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpMsStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpMsStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpMsTable_del(&StorageDel);
			/* mtpMsTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL;
	static struct mtpNaTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpNaRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpNaTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpNaTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpNaId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpNaTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpNaId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpNaProtocolVariant = { ss7ProtocolItut 0 }; */
			StorageNew->mtpNaRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpNaTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpNaTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpNaRowStatus;
			StorageTmp->mtpNaRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpNaTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpNaTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpNaTableStorage, StorageNew);
			header_complex_extract_entry(&mtpNaTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpNaRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpNaTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpNaRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpNaRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpNaTable_del(&StorageDel);
			/* mtpNaTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL;
	static struct mtpGsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpGsTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpGsRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpGsTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpGsTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpGsRowStatus;
			StorageTmp->mtpGsRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpGsTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpGsTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsTableStorage, StorageNew);
			header_complex_extract_entry(&mtpGsTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpGsRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpGsTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpGsTable_del(&StorageDel);
			/* mtpGsTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineTable_data *StorageTmp = NULL;
	static struct mtpGsLineTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsLineRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsLineTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsLineTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsLineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpGsLineObject = { zeroDotZero }; */
			StorageNew->mtpGsLineRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpGsLineTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpGsLineTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpGsLineRowStatus;
			StorageTmp->mtpGsLineRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpGsLineTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpGsLineTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsLineTableStorage, StorageNew);
			header_complex_extract_entry(&mtpGsLineTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpGsLineRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpGsLineTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsLineRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsLineRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpGsLineTable_del(&StorageDel);
			/* mtpGsLineTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static struct mtpGsLineContentTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsLineContentRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsLineContentTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsLineContentTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsLineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsLineContentId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineContentId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpGsLineContentRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpGsLineContentTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpGsLineContentTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpGsLineContentRowStatus;
			StorageTmp->mtpGsLineContentRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpGsLineContentTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpGsLineContentTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsLineContentTableStorage, StorageNew);
			header_complex_extract_entry(&mtpGsLineContentTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpGsLineContentRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpGsLineContentTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsLineContentRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsLineContentRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpGsLineContentTable_del(&StorageDel);
			/* mtpGsLineContentTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static struct mtpSpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSpProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSpProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSpProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSpProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSpProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpSpProfileTimerT1R = 80;
			StorageNew->mtpSpProfileTimerT18I = 60000;
			StorageNew->mtpSpProfileTimerT20I = 6000;
			StorageNew->mtpSpProfileTimerT20A = 10000;
			StorageNew->mtpSpProfileTimerT21A = 10000;
			StorageNew->mtpSpProfileTimerT22A = 60000;
			StorageNew->mtpSpProfileTimerT23A = 60000;
			StorageNew->mtpSpProfileTimerT24A = 60000;
			StorageNew->mtpSpProfileTimerT26A = 1350;
			StorageNew->mtpSpProfileTimerT27A = 300;
			StorageNew->mtpSpProfileRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSpProfileTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSpProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSpProfileRowStatus;
			StorageTmp->mtpSpProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpSpProfileTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpSpProfileTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpProfileTableStorage, StorageNew);
			header_complex_extract_entry(&mtpSpProfileTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSpProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSpProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSpProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSpProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSpProfileTable_del(&StorageDel);
			/* mtpSpProfileTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL;
	static struct mtpSpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSpTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSpTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpSpTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpSpMtpT31A = 6000;
			StorageNew->mtpSpMtpT32A = 6000;
			StorageNew->mtpSpMtpT33A = 36000;
			StorageNew->mtpSpMtpT34A = 6000;
			StorageNew->mtpSpMtpT20A = 10000;
			StorageNew->mtpSpMtpT21A = 10000;
			StorageNew->mtpSpRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSpTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSpTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSpRowStatus;
			StorageTmp->mtpSpRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpSpTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpSpTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpTableStorage, StorageNew);
			header_complex_extract_entry(&mtpSpTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSpRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSpTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSpRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSpRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSpTable_del(&StorageDel);
			/* mtpSpTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpL3Table_data *StorageTmp = NULL;
	static struct mtpL3Table_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3RowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpL3RowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpL3Table_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpL3Table_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpL3Id */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpL3Table_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpL3Id, vp->val.string, vp->val_len);
			StorageNew->mtpL3IdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpL3AsaProfilePointer = { zeroDotZero }; */
			StorageNew->mtpL3RowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpL3Table_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpL3Table_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpL3RowStatus;
			StorageTmp->mtpL3RowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpL3TableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpL3TableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpL3TableStorage, StorageNew);
			header_complex_extract_entry(&mtpL3TableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpL3RowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpL3Table_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpL3RowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpL3RowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpL3Table_del(&StorageDel);
			/* mtpL3Table_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static struct mtpRsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRsProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRsProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRsProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpRsProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpRsProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpRsProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpRsProfileTimerT8 = 100;
			StorageNew->mtpRsProfileTimerT11 = 6000;
			StorageNew->mtpRsProfileTimerT15 = 250;
			StorageNew->mtpRsProfileTimerT16 = 175;
			StorageNew->mtpRsProfileTimerT18A = 1200;
			StorageNew->mtpRsProfileRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRsProfileTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpRsProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRsProfileRowStatus;
			StorageTmp->mtpRsProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpRsProfileTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpRsProfileTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsProfileTableStorage, StorageNew);
			header_complex_extract_entry(&mtpRsProfileTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRsProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRsProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRsProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRsProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRsProfileTable_del(&StorageDel);
			/* mtpRsProfileTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL;
	static struct mtpRsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpRsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpRsTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpRsAsaProfilePointer = { zeroDotZero }; */
			/* StorageNew->mtpRsLoadsharingObject = { zeroDotZero }; */
			StorageNew->mtpRsRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRsTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpRsTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRsRowStatus;
			StorageTmp->mtpRsRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpRsTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpRsTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsTableStorage, StorageNew);
			header_complex_extract_entry(&mtpRsTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRsRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRsTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRsTable_del(&StorageDel);
			/* mtpRsTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	static struct mtpRtProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRtProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRtProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRtProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpRtProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpRtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpRtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpRtProfileTimerT6 = 80;
			StorageNew->mtpRtProfileTimerT10 = 4500;
			StorageNew->mtpRtProfileRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRtProfileTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpRtProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRtProfileRowStatus;
			StorageTmp->mtpRtProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpRtProfileTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpRtProfileTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRtProfileTableStorage, StorageNew);
			header_complex_extract_entry(&mtpRtProfileTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRtProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRtProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRtProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRtProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRtProfileTable_del(&StorageDel);
			/* mtpRtProfileTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL;
	static struct mtpRtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRtRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpRsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpRtId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpRtTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRtId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpRtLoadsharingObject = { zeroDotZero }; */
			StorageNew->mtpRtRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRtTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpRtTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRtRowStatus;
			StorageTmp->mtpRtRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpRtTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpRtTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRtTableStorage, StorageNew);
			header_complex_extract_entry(&mtpRtTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRtRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRtTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRtRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRtRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRtTable_del(&StorageDel);
			/* mtpRtTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static struct mtpLsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpLsProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpLsProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpLsProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpLsProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpLsProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpLsProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpLsProfileTimerT8 = 100;
			StorageNew->mtpLsProfileTimerT10 = 4500;
			StorageNew->mtpLsProfileTimerT7 = 150;
			StorageNew->mtpLsProfileRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpLsProfileTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpLsProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpLsProfileRowStatus;
			StorageTmp->mtpLsProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpLsProfileTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpLsProfileTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpLsProfileTableStorage, StorageNew);
			header_complex_extract_entry(&mtpLsProfileTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpLsProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpLsProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpLsProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpLsProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpLsProfileTable_del(&StorageDel);
			/* mtpLsProfileTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL;
	static struct mtpLsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpLsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpLsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpLsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpLsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpLsTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpLsPeriodicLinkTestFail = 1;
			/* StorageNew->mtpLsAsaProfilePointer = { zeroDotZero }; */
			StorageNew->mtpLsRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpLsTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpLsTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpLsRowStatus;
			StorageTmp->mtpLsRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpLsTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpLsTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpLsTableStorage, StorageNew);
			header_complex_extract_entry(&mtpLsTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpLsRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpLsTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpLsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpLsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpLsTable_del(&StorageDel);
			/* mtpLsTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static struct mtpSlL3ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlL3ProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpSlL3ProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlL3ProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlL3ProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlL3ProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSlL3ProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSlL3ProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpSlL3ProfileTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSlL3ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSlL3ProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpSlL3ProfileTimerT24I = 50;
			StorageNew->mtpSlL3ProfileTimerT20A = 10000;
			StorageNew->mtpSlL3ProfileTimerT21A = 10000;
			StorageNew->mtpSlL3ProfileTimerT22I = 27000;
			StorageNew->mtpSlL3ProfileTimerT23I = 27000;
			StorageNew->mtpSlL3ProfileTimerT31A = 6000;
			StorageNew->mtpSlL3ProfileTimerT32A = 6000;
			StorageNew->mtpSlL3ProfileTimerT33A = 36000;
			StorageNew->mtpSlL3ProfileTimerT34A = 6000;
			StorageNew->mtpSlL3ProfileRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlL3ProfileTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSlL3ProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlL3ProfileRowStatus;
			StorageTmp->mtpSlL3ProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpSlL3ProfileTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpSlL3ProfileTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlL3ProfileTableStorage, StorageNew);
			header_complex_extract_entry(&mtpSlL3ProfileTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlL3ProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlL3ProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlL3ProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlL3ProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlL3ProfileTable_del(&StorageDel);
			/* mtpSlL3ProfileTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static struct mtpSlL2ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlL2ProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpSlL2ProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlL2ProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlL2ProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlL2ProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSlL2ProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* mtpSlL2ProfileTransmissionRate */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSlL2ProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpSlL2ProfileTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSlL2ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSlL2ProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			StorageNew->mtpSlL2ProfileTransmissionRate = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpSlL2ProfileM = 5;
			StorageNew->mtpSlL2ProfileRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlL2ProfileTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSlL2ProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlL2ProfileRowStatus;
			StorageTmp->mtpSlL2ProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpSlL2ProfileTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpSlL2ProfileTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlL2ProfileTableStorage, StorageNew);
			header_complex_extract_entry(&mtpSlL2ProfileTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlL2ProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlL2ProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlL2ProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlL2ProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlL2ProfileTable_del(&StorageDel);
			/* mtpSlL2ProfileTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL;
	static struct mtpSlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpLsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSlSlCode */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpSlTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSlCode = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSlSignTermPointer = { zeroDotZero }; */
			/* StorageNew->mtpSlSignDataLinkTpPointer = { zeroDotZero }; */
			/* StorageNew->mtpSlAsaProfilePointer = { zeroDotZero }; */
			StorageNew->mtpSlRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSlTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlRowStatus;
			StorageTmp->mtpSlRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpSlTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpSlTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlTableStorage, StorageNew);
			header_complex_extract_entry(&mtpSlTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlTable_del(&StorageDel);
			/* mtpSlTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	static struct mtpSlSdlListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlSdlListRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlSdlListTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlSdlListTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpLsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSlSlCode */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSlSdlListId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSlCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdlListId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSlSdlListPointer = { zeroDotZero }; */
			StorageNew->mtpSlSdlListRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlSdlListTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSlSdlListTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdlListRowStatus;
			StorageTmp->mtpSlSdlListRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpSlSdlListTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpSlSdlListTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlSdlListTableStorage, StorageNew);
			header_complex_extract_entry(&mtpSlSdlListTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlSdlListRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlSdlListTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlSdlListRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlSdlListRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlSdlListTable_del(&StorageDel);
			/* mtpSlSdlListTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	static struct mtpSlSdtListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlSdtListRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlSdtListTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlSdtListTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpLsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSlSlCode */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSlSdtListId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSlCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdtListId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSlSdtListPointer = { zeroDotZero }; */
			StorageNew->mtpSlSdtListRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlSdtListTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSlSdtListTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdtListRowStatus;
			StorageTmp->mtpSlSdtListRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpSlSdtListTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpSlSdtListTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlSdtListTableStorage, StorageNew);
			header_complex_extract_entry(&mtpSlSdtListTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlSdtListRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlSdtListTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlSdtListRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlSdtListRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlSdtListTable_del(&StorageDel);
			/* mtpSlSdtListTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNbTable_data *StorageTmp = NULL;
	static struct mtpNbTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpNbTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpNbTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpNbRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpNbTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpNbTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpNbTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpNbTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpNbTin = 4;
			StorageNew->mtpNbTie = 1;
			StorageNew->mtpNbT = 256;
			StorageNew->mtpNbD = 64;
			StorageNew->mtpNbN = 16;
			StorageNew->mtpNbm = 272;
			StorageNew->mtpNbRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpNbTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpNbTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpNbRowStatus;
			StorageTmp->mtpNbRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpNbTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpNbTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpNbTableStorage, StorageNew);
			header_complex_extract_entry(&mtpNbTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpNbRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpNbTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpNbRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpNbRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpNbTable_del(&StorageDel);
			/* mtpNbTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL;
	static struct mtpSaalTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSaalRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSaalTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSaalTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpSaalTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpSaalMaxCc = 4;
			StorageNew->mtpSaalMaxInformationFieldLength = 4096;
			StorageNew->mtpSaalMaxLengthSscopUuField = 4;
			StorageNew->mtpSaalMaxPd = 500;
			StorageNew->mtpSaalMaxStat = 67;
			StorageNew->mtpSaalN1 = 1000;
			StorageNew->mtpSaalNniTimerT1 = 500;
			StorageNew->mtpSaalNniTimerT2 = 3000;
			StorageNew->mtpSaalSscopTimerCc = 20;
			StorageNew->mtpSaalSscopTimerIdle = 10;
			StorageNew->mtpSaalSscopTimerKeepAlive = 10;
			StorageNew->mtpSaalSscopTimerNoResponse = 150;
			StorageNew->mtpSaalSscopTimerPoll = 10;
			StorageNew->mtpSaalTransmissionRateIntervalLower = 129;
			StorageNew->mtpSaalTransmissionRateIntervalUpper = 256;
			StorageNew->mtpSaalRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSaalTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSaalTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSaalRowStatus;
			StorageTmp->mtpSaalRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpSaalTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpSaalTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSaalTableStorage, StorageNew);
			header_complex_extract_entry(&mtpSaalTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSaalRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSaalTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSaalRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSaalRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSaalTable_del(&StorageDel);
			/* mtpSaalTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL;
	static struct mtpM2paTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM2paRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM2paTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM2paTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpM2paTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpM2paN1 = 1000;
			StorageNew->mtpM2paProving = 1;
			StorageNew->mtpM2paSctpAssocMaxRetrans = 20;
			StorageNew->mtpM2paSctpSackDelay = 20;
			StorageNew->mtpM2paRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpM2paTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpM2paTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpM2paRowStatus;
			StorageTmp->mtpM2paRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpM2paTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpM2paTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpM2paTableStorage, StorageNew);
			header_complex_extract_entry(&mtpM2paTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpM2paRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpM2paTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpM2paRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpM2paRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpM2paTable_del(&StorageDel);
			/* mtpM2paTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdtTable_data *StorageTmp = NULL;
	static struct mtpSdtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSdtRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSdtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSdtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdtId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpSdtTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSdtId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSdtEquipmentPointer = { zeroDotZero }; */
			StorageNew->mtpSdtRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSdtTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSdtTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSdtRowStatus;
			StorageTmp->mtpSdtRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpSdtTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpSdtTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSdtTableStorage, StorageNew);
			header_complex_extract_entry(&mtpSdtTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSdtRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSdtTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSdtRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSdtRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSdtTable_del(&StorageDel);
			/* mtpSdtTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL;
	static struct mtpSdlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSdlRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSdlTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSdlTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdlId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpSdlTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSdlId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSdlEquipmentPointer = { zeroDotZero }; */
			StorageNew->mtpSdlRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSdlTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSdlTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSdlRowStatus;
			StorageTmp->mtpSdlRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpSdlTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpSdlTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSdlTableStorage, StorageNew);
			header_complex_extract_entry(&mtpSdlTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSdlRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSdlTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSdlRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSdlRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSdlTable_del(&StorageDel);
			/* mtpSdlTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
