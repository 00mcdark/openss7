/*****************************************************************************

 @(#) $RCSfile: mtpMIB.c,v $ $Name:  $($Revision: 0.9.2.7 $) $Date: 2009-01-03 10:51:01 $

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2009  Monavacom Limited <http://www.monavacom.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2009-01-03 10:51:01 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: mtpMIB.c,v $
 Revision 0.9.2.7  2009-01-03 10:51:01  brian
 - updated agent

 Revision 0.9.2.6  2009-01-02 15:46:39  brian
 - corrections

 Revision 0.9.2.5  2009-01-02 15:04:11  brian
 - updated agents

 Revision 0.9.2.4  2008-12-31 16:04:43  brian
 - updated mibs

 *****************************************************************************/

#ident "@(#) $RCSfile: mtpMIB.c,v $ $Name:  $($Revision: 0.9.2.7 $) $Date: 2009-01-03 10:51:01 $"

static char const ident[] = "$RCSfile: mtpMIB.c,v $ $Name:  $($Revision: 0.9.2.7 $) $Date: 2009-01-03 10:51:01 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "ss7MIB.h"
#include "x400pMIB.h"
#include "mtpMIB.h"
#include "mtpOmMIB.h"
#include "sccpMIB.h"
#include "sccpOmMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int mtpMIB_refresh = 1;
volatile int mtpSapTable_refresh = 1;
volatile int mtpMsTable_refresh = 1;
volatile int mtpNaTable_refresh = 1;
volatile int mtpGsTable_refresh = 1;
volatile int mtpGsLineTable_refresh = 1;
volatile int mtpGsLineContentTable_refresh = 1;
volatile int mtpSpProfileTable_refresh = 1;
volatile int mtpSpTable_refresh = 1;
volatile int mtpL3Table_refresh = 1;
volatile int mtpRsProfileTable_refresh = 1;
volatile int mtpRsTable_refresh = 1;
volatile int mtpRtProfileTable_refresh = 1;
volatile int mtpRtTable_refresh = 1;
volatile int mtpRtLsaTable_refresh = 1;
volatile int mtpLsProfileTable_refresh = 1;
volatile int mtpLsTable_refresh = 1;
volatile int mtpSlL3ProfileTable_refresh = 1;
volatile int mtpSlL2ProfileTable_refresh = 1;
volatile int mtpSlTable_refresh = 1;
volatile int mtpSlSdlListTable_refresh = 1;
volatile int mtpSlSdtListTable_refresh = 1;
volatile int mtpNbTable_refresh = 1;
volatile int mtpSaalTable_refresh = 1;
volatile int mtpM2paTable_refresh = 1;
volatile int mtpSdtTable_refresh = 1;
volatile int mtpSdlTable_refresh = 1;

/*
 * mtpMIB_variables_oid: object identifier for mtpMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid mtpMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3 };
oid mtpSapTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 1, 1, 1 };
oid mtpMsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 2, 1, 1 };
oid mtpNaTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 3, 1, 1 };
oid mtpGsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 4, 1, 1 };
oid mtpGsLineTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 4, 2, 1 };
oid mtpGsLineContentTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 4, 3, 1 };
oid mtpSpProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 5, 1, 1 };
oid mtpSpTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 5, 2, 1 };
oid mtpL3Table_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 6, 1, 1 };
oid mtpRsProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 7, 1, 1 };
oid mtpRsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 7, 2, 1 };
oid mtpRtProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 8, 1, 1 };
oid mtpRtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 8, 2, 1 };
oid mtpLsProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 9, 1, 1 };
oid mtpLsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 9, 2, 1 };
oid mtpSlL3ProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 1, 1 };
oid mtpSlL2ProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 2, 1 };
oid mtpSlTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 3, 1 };
oid mtpSlSdlListTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 4, 1 };
oid mtpSlSdtListTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 5, 1 };
oid mtpNbTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 1, 1 };
oid mtpSaalTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 2, 1 };
oid mtpM2paTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 3, 1 };
oid mtpSdtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 4, 1 };
oid mtpSdlTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 12, 1, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid mtpRestarting_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid ss7OnOccEvent_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid sdlEventLostSync_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid sdlEventSuError_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid sdlEventTxFail_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid sdlEventRxFail_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid sdtEventLostSync_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid sdtEventSuError_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid sdtEventTxFail_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid sdtEventRxFail_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid sdtEventCarrier_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventFailureAllReasons_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventFailureAbnormalBsnrFibr_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventFailureExcessiveDelayOfAck_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventFailureExcessiveErrorRate_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventFailureExcessiveDurationCongestion_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventLocalAutomaticChangeover_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventLocalAutomaticChangeback_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventRestoration_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventRpoStartEvent_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventRpoStopEvent_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventLocalInhibitionStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventLocalInhibitionStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventRemoteInhibitionStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventRemoteInhibitionStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventCongestionStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventCongestionStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid slEventCongestionLoss_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid lkEventFailureStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid lkEventFailureStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid lkEventSendTFP_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid lkEventSendTFA_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid rsEventUnavailableStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid rsEventUnavailableStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid rsEventAdjSpLinkSetChange_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid rsEventAdjSPInaccessibleStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid rsEventAdjSpInaccessibleStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid rsEventRecvTFC_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid spEventMsuDiscard_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid spEventUpuSent_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };
oid spEventUpuRecv_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0 };

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid changeInLsToAdjSp_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3 };
oid oldLs_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3 };
oid newLs_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3 };
oid inaccessibleSp_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3 };
oid remoteUnavailableUserPart_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3 };
oid congestionStatus_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3 };
oid networkPointCode_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3 };
oid userPart_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3 };
oid userPartStatus_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3 };
oid linkFailureReason_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3 };

/*
 * Other oids defined in this MIB.
 */
oid mtpProtocolItut_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1 };
oid mtpProtocolEtsi_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1 };
oid mtpProtocolAnsi_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1 };
oid mtpProtocolJttc_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1 };
oid mtpProtocolChin_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1 };
oid mtpProtocolPnoc_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1 };
oid mtpProtocolSing_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1 };
oid mtpProtocolSpan_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1 };
oid localUserPartUnavailable_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 2 };
oid remoteUserPartUnavailable_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 2 };
oid abnormalFIBRorBSNR_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3 };
oid excessiveAckDelay_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3 };
oid excessiveErrorRate_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3 };
oid excessiveCongDuration_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3 };
oid remoteUPUnknown_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3 };
oid remoteUPUnequipped_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3 };
oid remoteUPInaccessible_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3 };
oid defaultInLsLoadShareAlgorithm_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 4 };
static const oid zeroDotZero_oid[2] = { 0, 0 };

/*
 * variable7 mtpMIB_variables: tree for mtpMIB
 * This variable defines function callbacks and type return information for the mtpMIB mib section
 */
struct variable7 mtpMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   MTPSAP2ADDRESS        (4 % 256)
	{MTPSAP2ADDRESS, ASN_UNSIGNED, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 2}},
#define   MTPSAPUSERPART        (5 % 256)
	{MTPSAPUSERPART, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 3}},
#define   MTPSAPUSERPARTSTATUS  (6 % 256)
	{MTPSAPUSERPARTSTATUS, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 4}},
#define   MTPSAPUSERENTITYNAMES  (7 % 256)
	{MTPSAPUSERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 5}},
#define   MTPSAPPROVIDERENTITYNAMES  (8 % 256)
	{MTPSAPPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 6}},
#define   MTPSAPUSAGESTATE      (9 % 256)
	{MTPSAPUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 7}},
#define   MTPSAPASAPROFILEPOINTER  (10 % 256)
	{MTPSAPASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 8}},
#define   MTPSAPNAME            (11 % 256)
	{MTPSAPNAME, ASN_OCTET_STR, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 9}},
#define   MTPSAPLONGMESSAGESUPPORTED  (12 % 256)
	{MTPSAPLONGMESSAGESUPPORTED, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 10}},
#define   MTPSAPROWSTATUS       (13 % 256)
	{MTPSAPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 11}},
#define   MTPMSNAME             (17 % 256)
	{MTPMSNAME, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 2}},
#define   MTPMSALARMSTATUS      (18 % 256)
	{MTPMSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 3}},
#define   MTPMSOPERATIONALSTATE  (19 % 256)
	{MTPMSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 4}},
#define   MTPMSUSAGESTATE       (20 % 256)
	{MTPMSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 5}},
#define   MTPMSMANAGEDELEMENTTYPE  (21 % 256)
	{MTPMSMANAGEDELEMENTTYPE, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 6}},
#define   MTPMSMODELCODE        (22 % 256)
	{MTPMSMODELCODE, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 7}},
#define   MTPMSVENDORNAME       (23 % 256)
	{MTPMSVENDORNAME, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 8}},
#define   MTPMSUSERLABEL        (24 % 256)
	{MTPMSUSERLABEL, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 9}},
#define   MTPMSVERSION          (25 % 256)
	{MTPMSVERSION, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 10}},
#define   MTPMSASAPROFILEPOINTER  (26 % 256)
	{MTPMSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 11}},
#define   MTPMSNETWORKELEMENTALIASES  (27 % 256)
	{MTPMSNETWORKELEMENTALIASES, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 12}},
#define   MTPMSSTATUS           (28 % 256)
	{MTPMSSTATUS, ASN_INTEGER, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 13}},
#define   MTPNAPROTOCOLVARIANT  (32 % 256)
	{MTPNAPROTOCOLVARIANT, ASN_OBJECT_ID, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 2}},
#define   MTPNAPROTOCOLYEAR     (33 % 256)
	{MTPNAPROTOCOLYEAR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 3}},
#define   MTPNAPROTOCOLOPTIONS  (34 % 256)
	{MTPNAPROTOCOLOPTIONS, ASN_BIT_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 4}},
#define   MTPNANETWORKINDICATOR  (35 % 256)
	{MTPNANETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 5}},
#define   MTPNAPOINTCODEFORMAT  (36 % 256)
	{MTPNAPOINTCODEFORMAT, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 6}},
#define   MTPNASLSLENGTH        (37 % 256)
	{MTPNASLSLENGTH, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 7}},
#define   MTPNASPDEFAULT        (38 % 256)
	{MTPNASPDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 8}},
#define   MTPNANAME             (39 % 256)
	{MTPNANAME, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 9}},
#define   MTPNAROWSTATUS        (40 % 256)
	{MTPNAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 1, 1, 10}},
#define   MTPGSADMINISTRATIVESTATE  (45 % 256)
	{MTPGSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 2}},
#define   MTPGSTREATMENTOFOUTSIDERANGES  (46 % 256)
	{MTPGSTREATMENTOFOUTSIDERANGES, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 3}},
#define   MTPGSLISTMODE         (47 % 256)
	{MTPGSLISTMODE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 4}},
#define   MTPGSSCREENINGBYLINKSETORBYOPC  (48 % 256)
	{MTPGSSCREENINGBYLINKSETORBYOPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 5}},
#define   MTPGSGETSCREENEDOPCSORLINKSETSBYDPC  (49 % 256)
	{MTPGSGETSCREENEDOPCSORLINKSETSBYDPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 6}},
#define   MTPGSNAME             (50 % 256)
	{MTPGSNAME, ASN_OCTET_STR, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 7}},
#define   MTPGSROWSTATUS        (51 % 256)
	{MTPGSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 8}},
#define   MTPGSLINEOBJECT       (57 % 256)
	{MTPGSLINEOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpGsLineTable, 6, {1, 1, 4, 2, 1, 2}},
#define   MTPGSLINECONTENT      (58 % 256)
	{MTPGSLINECONTENT, ASN_UNSIGNED, RWRITE, var_mtpGsLineTable, 6, {1, 1, 4, 2, 1, 3}},
#define   MTPGSLINEROWSTATUS    (59 % 256)
	{MTPGSLINEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineTable, 6, {1, 1, 4, 2, 1, 4}},
#define   MTPGSLINECONTENTDESIGNATEDDPCFIRST  (66 % 256)
	{MTPGSLINECONTENTDESIGNATEDDPCFIRST, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 2}},
#define   MTPGSLINECONTENTDESIGNATEDDPCLAST  (67 % 256)
	{MTPGSLINECONTENTDESIGNATEDDPCLAST, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 3}},
#define   MTPGSLINECONTENTSIMASK  (68 % 256)
	{MTPGSLINECONTENTSIMASK, ASN_BIT_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 4}},
#define   MTPGSLINECONTENTMESSAGETREATMENT  (69 % 256)
	{MTPGSLINECONTENTMESSAGETREATMENT, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 5}},
#define   MTPGSLINECONTENTCOMMENT  (70 % 256)
	{MTPGSLINECONTENTCOMMENT, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 6}},
#define   MTPGSLINECONTENTROWSTATUS  (71 % 256)
	{MTPGSLINECONTENTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 4, 3, 1, 7}},
#define   MTPSPPROFILETIMERT1R  (75 % 256)
	{MTPSPPROFILETIMERT1R, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 2}},
#define   MTPSPPROFILETIMERT2   (76 % 256)
	{MTPSPPROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 3}},
#define   MTPSPPROFILETIMERT4   (77 % 256)
	{MTPSPPROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 4}},
#define   MTPSPPROFILETIMERT5   (78 % 256)
	{MTPSPPROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 5}},
#define   MTPSPPROFILETIMERT7   (79 % 256)
	{MTPSPPROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 6}},
#define   MTPSPPROFILETIMERT11  (80 % 256)
	{MTPSPPROFILETIMERT11, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 7}},
#define   MTPSPPROFILETIMERT12  (81 % 256)
	{MTPSPPROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 8}},
#define   MTPSPPROFILETIMERT13  (82 % 256)
	{MTPSPPROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 9}},
#define   MTPSPPROFILETIMERT14  (83 % 256)
	{MTPSPPROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 10}},
#define   MTPSPPROFILETIMERT15  (84 % 256)
	{MTPSPPROFILETIMERT15, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 11}},
#define   MTPSPPROFILETIMERT16  (85 % 256)
	{MTPSPPROFILETIMERT16, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 12}},
#define   MTPSPPROFILETIMERT18I  (86 % 256)
	{MTPSPPROFILETIMERT18I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 13}},
#define   MTPSPPROFILETIMERT19I  (87 % 256)
	{MTPSPPROFILETIMERT19I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 14}},
#define   MTPSPPROFILETIMERT20I  (88 % 256)
	{MTPSPPROFILETIMERT20I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 15}},
#define   MTPSPPROFILETIMERT21I  (89 % 256)
	{MTPSPPROFILETIMERT21I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 16}},
#define   MTPSPPROFILETIMERT22I  (90 % 256)
	{MTPSPPROFILETIMERT22I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 17}},
#define   MTPSPPROFILETIMERT23I  (91 % 256)
	{MTPSPPROFILETIMERT23I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 18}},
#define   MTPSPPROFILETIMERT20A  (92 % 256)
	{MTPSPPROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 19}},
#define   MTPSPPROFILETIMERT21A  (93 % 256)
	{MTPSPPROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 20}},
#define   MTPSPPROFILETIMERT22A  (94 % 256)
	{MTPSPPROFILETIMERT22A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 21}},
#define   MTPSPPROFILETIMERT23A  (95 % 256)
	{MTPSPPROFILETIMERT23A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 22}},
#define   MTPSPPROFILETIMERT24A  (96 % 256)
	{MTPSPPROFILETIMERT24A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 23}},
#define   MTPSPPROFILETIMERT26A  (97 % 256)
	{MTPSPPROFILETIMERT26A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 24}},
#define   MTPSPPROFILETIMERT27A  (98 % 256)
	{MTPSPPROFILETIMERT27A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 25}},
#define   MTPSPPROFILETIMERT1T  (99 % 256)
	{MTPSPPROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 26}},
#define   MTPSPPROFILETIMERT2T  (100 % 256)
	{MTPSPPROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 27}},
#define   MTPSPPROFILENAME      (101 % 256)
	{MTPSPPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 28}},
#define   MTPSPPROFILEROWSTATUS  (104 % 256)
	{MTPSPPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 1, 1, 31}},
#define   MTPSPPOINTCODE        (109 % 256)
	{MTPSPPOINTCODE, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 2}},
#define   MTPSPTYPE             (110 % 256)
	{MTPSPTYPE, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 3}},
#define   MTPSPOPERATIONALSTATE  (111 % 256)
	{MTPSPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 4}},
#define   MTPSPPROCEDURALSTATUS  (112 % 256)
	{MTPSPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 5}},
#define   MTPSPAVAILABILITYSTATUS  (113 % 256)
	{MTPSPAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 6}},
#define   MTPSPVERSION          (114 % 256)
	{MTPSPVERSION, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 7}},
#define   MTPSPNETWORKINDICATOR  (115 % 256)
	{MTPSPNETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 8}},
#define   MTPSPNAME             (116 % 256)
	{MTPSPNAME, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 9}},
#define   MTPSPMTPT1            (117 % 256)
	{MTPSPMTPT1, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 10}},
#define   MTPSPMTPT2            (118 % 256)
	{MTPSPMTPT2, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 11}},
#define   MTPSPMTPT3            (119 % 256)
	{MTPSPMTPT3, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 12}},
#define   MTPSPMTPT4            (120 % 256)
	{MTPSPMTPT4, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 13}},
#define   MTPSPMTPT5            (121 % 256)
	{MTPSPMTPT5, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 14}},
#define   MTPSPMTPT6            (122 % 256)
	{MTPSPMTPT6, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 15}},
#define   MTPSPMTPT7            (123 % 256)
	{MTPSPMTPT7, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 16}},
#define   MTPSPMTPT8            (124 % 256)
	{MTPSPMTPT8, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 17}},
#define   MTPSPMTPT10           (125 % 256)
	{MTPSPMTPT10, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 18}},
#define   MTPSPMTPT11           (126 % 256)
	{MTPSPMTPT11, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 19}},
#define   MTPSPMTPT12           (127 % 256)
	{MTPSPMTPT12, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 20}},
#define   MTPSPMTPT13           (128 % 256)
	{MTPSPMTPT13, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 21}},
#define   MTPSPMTPT14           (129 % 256)
	{MTPSPMTPT14, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 22}},
#define   MTPSPMTPT15           (130 % 256)
	{MTPSPMTPT15, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 23}},
#define   MTPSPMTPT16           (131 % 256)
	{MTPSPMTPT16, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 24}},
#define   MTPSPMTPT17           (132 % 256)
	{MTPSPMTPT17, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 25}},
#define   MTPSPMTPT19A          (133 % 256)
	{MTPSPMTPT19A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 26}},
#define   MTPSPMTPT31A          (134 % 256)
	{MTPSPMTPT31A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 27}},
#define   MTPSPMTPT32A          (135 % 256)
	{MTPSPMTPT32A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 28}},
#define   MTPSPMTPT33A          (136 % 256)
	{MTPSPMTPT33A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 29}},
#define   MTPSPMTPT34A          (137 % 256)
	{MTPSPMTPT34A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 30}},
#define   MTPSPMTPT18I          (138 % 256)
	{MTPSPMTPT18I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 31}},
#define   MTPSPMTPT19I          (139 % 256)
	{MTPSPMTPT19I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 32}},
#define   MTPSPMTPT20I          (140 % 256)
	{MTPSPMTPT20I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 33}},
#define   MTPSPMTPT21I          (141 % 256)
	{MTPSPMTPT21I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 34}},
#define   MTPSPMTPT22I          (142 % 256)
	{MTPSPMTPT22I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 35}},
#define   MTPSPMTPT23I          (143 % 256)
	{MTPSPMTPT23I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 36}},
#define   MTPSPMTPT20A          (144 % 256)
	{MTPSPMTPT20A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 37}},
#define   MTPSPMTPT21A          (145 % 256)
	{MTPSPMTPT21A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 38}},
#define   MTPSPMTPT24I          (146 % 256)
	{MTPSPMTPT24I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 39}},
#define   MTPSPMTPT1T           (147 % 256)
	{MTPSPMTPT1T, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 40}},
#define   MTPSPMTPT2T           (148 % 256)
	{MTPSPMTPT2T, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 41}},
#define   MTPSPMTPT1S           (149 % 256)
	{MTPSPMTPT1S, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 42}},
#define   MTPSPPROFILEPOINTER   (150 % 256)
	{MTPSPPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 43}},
#define   MTPSPNAPOINTER        (151 % 256)
	{MTPSPNAPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 44}},
#define   MTPSPFLAGS            (152 % 256)
	{MTPSPFLAGS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 45}},
#define   MTPSPUSERS            (153 % 256)
	{MTPSPUSERS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 46}},
#define   MTPSPALARMSTATUS      (154 % 256)
	{MTPSPALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 47}},
#define   MTPSPROWSTATUS        (155 % 256)
	{MTPSPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 2, 1, 48}},
#define   MTPL3ADMINISTRATIVESTATE  (159 % 256)
	{MTPL3ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 2}},
#define   MTPL3OPERATIONALSTATE  (160 % 256)
	{MTPL3OPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 3}},
#define   MTPL3USAGESTATE       (161 % 256)
	{MTPL3USAGESTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 4}},
#define   MTPL3PROCEDURALSTATUS  (162 % 256)
	{MTPL3PROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 5}},
#define   MTPL3ASAPROFILEPOINTER  (163 % 256)
	{MTPL3ASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 6}},
#define   MTPL3NAME             (164 % 256)
	{MTPL3NAME, ASN_OCTET_STR, RWRITE, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 7}},
#define   MTPL3ROWSTATUS        (165 % 256)
	{MTPL3ROWSTATUS, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 6, 1, 1, 8}},
#define   MTPRSPROFILENAME      (169 % 256)
	{MTPRSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 2}},
#define   MTPRSPROFILETIMERT8   (170 % 256)
	{MTPRSPROFILETIMERT8, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 3}},
#define   MTPRSPROFILETIMERT11  (171 % 256)
	{MTPRSPROFILETIMERT11, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 4}},
#define   MTPRSPROFILETIMERT15  (172 % 256)
	{MTPRSPROFILETIMERT15, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 5}},
#define   MTPRSPROFILETIMERT16  (173 % 256)
	{MTPRSPROFILETIMERT16, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 6}},
#define   MTPRSPROFILETIMERT18A  (174 % 256)
	{MTPRSPROFILETIMERT18A, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 7}},
#define   MTPRSPROFILERTDEFAULT  (175 % 256)
	{MTPRSPROFILERTDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 8}},
#define   MTPRSPROFILEROWSTATUS  (176 % 256)
	{MTPRSPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 9}},
#define   MTPRSDEST             (181 % 256)
	{MTPRSDEST, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 2}},
#define   MTPRSFLAGS            (182 % 256)
	{MTPRSFLAGS, ASN_BIT_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 3}},
#define   MTPRSADMINISTRATIVESTATE  (183 % 256)
	{MTPRSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 4}},
#define   MTPRSOPERATIONALSTATE  (184 % 256)
	{MTPRSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 5}},
#define   MTPRSASAPROFILEPOINTER  (185 % 256)
	{MTPRSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 6}},
#define   MTPRSCONGESTEDSTATE   (186 % 256)
	{MTPRSCONGESTEDSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 7}},
#define   MTPRSCONGESTIONLEVEL  (187 % 256)
	{MTPRSCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 8}},
#define   MTPRSLOADSHARINGINFORMATION  (188 % 256)
	{MTPRSLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 9}},
#define   MTPRSLOADSHARINGOBJECT  (189 % 256)
	{MTPRSLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 10}},
#define   MTPRSREMOTEEXCHANGELABEL  (190 % 256)
	{MTPRSREMOTEEXCHANGELABEL, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 11}},
#define   MTPRSNAME             (191 % 256)
	{MTPRSNAME, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 12}},
#define   MTPRSPROFILE          (192 % 256)
	{MTPRSPROFILE, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 13}},
#define   MTPRSALARMSTATUS      (193 % 256)
	{MTPRSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 14}},
#define   MTPRSROWSTATUS        (194 % 256)
	{MTPRSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 15}},
#define   MTPRTPROFILETIMERT6   (198 % 256)
	{MTPRTPROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 2}},
#define   MTPRTPROFILETIMERT10  (199 % 256)
	{MTPRTPROFILETIMERT10, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 3}},
#define   MTPRTPROFILEROWSTATUS  (200 % 256)
	{MTPRTPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 4}},
#define   MTPRTLSPOINTER        (206 % 256)
	{MTPRTLSPOINTER, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 2}},
#define   MTPRTADMINISTRATIVESTATE  (207 % 256)
	{MTPRTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 3}},
#define   MTPRTOPERATIONALSTATE  (208 % 256)
	{MTPRTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 4}},
#define   MTPRTAVAILABILITYSTATUS  (209 % 256)
	{MTPRTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 5}},
#define   MTPRTINCLSLOADSHARINGALGORITHM  (210 % 256)
	{MTPRTINCLSLOADSHARINGALGORITHM, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 6}},
#define   MTPRTFIXEDPRIORITY    (211 % 256)
	{MTPRTFIXEDPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 7}},
#define   MTPRTFLEXIBLEPRIORITY  (212 % 256)
	{MTPRTFLEXIBLEPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 8}},
#define   MTPRTPRIORITYMODE     (213 % 256)
	{MTPRTPRIORITYMODE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 9}},
#define   MTPRTLOADSHARINGINFORMATION  (214 % 256)
	{MTPRTLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 10}},
#define   MTPRTLOADSHARINGOBJECT  (215 % 256)
	{MTPRTLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 11}},
#define   MTPRTNAME             (216 % 256)
	{MTPRTNAME, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 12}},
#define   MTPRTSLSLIST          (217 % 256)
	{MTPRTSLSLIST, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 13}},
#define   MTPRTUSAGESTATE       (218 % 256)
	{MTPRTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 14}},
#define   MTPRTRLSLOT           (219 % 256)
	{MTPRTRLSLOT, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 15}},
#define   MTPRTPROFILE          (220 % 256)
	{MTPRTPROFILE, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 16}},
#define   MTPRTROWSTATUS        (221 % 256)
	{MTPRTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 17}},
#define   MTPRTLSANORMALSLCODE  (228 % 256)
	{MTPRTLSANORMALSLCODE, ASN_UNSIGNED, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 8, 3, 1, 2}},
#define   MTPRTLSAALTERNATIVESLCODELIST  (229 % 256)
	{MTPRTLSAALTERNATIVESLCODELIST, ASN_OCTET_STR, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 8, 3, 1, 3}},
#define   MTPLSPROFILETIMERT6   (233 % 256)
	{MTPLSPROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 2}},
#define   MTPLSPROFILETIMERT8   (234 % 256)
	{MTPLSPROFILETIMERT8, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 3}},
#define   MTPLSPROFILETIMERT10  (235 % 256)
	{MTPLSPROFILETIMERT10, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 4}},
#define   MTPLSPROFILETIMERT7   (236 % 256)
	{MTPLSPROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 5}},
#define   MTPLSPROFILETIMERT19I  (237 % 256)
	{MTPLSPROFILETIMERT19I, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 6}},
#define   MTPLSPROFILETIMERT21I  (238 % 256)
	{MTPLSPROFILETIMERT21I, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 7}},
#define   MTPLSPROFILETIMERT25A  (239 % 256)
	{MTPLSPROFILETIMERT25A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 8}},
#define   MTPLSPROFILETIMERT28A  (240 % 256)
	{MTPLSPROFILETIMERT28A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 9}},
#define   MTPLSPROFILETIMERT29A  (241 % 256)
	{MTPLSPROFILETIMERT29A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 10}},
#define   MTPLSPROFILETIMERT30A  (242 % 256)
	{MTPLSPROFILETIMERT30A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 11}},
#define   MTPLSPROFILENAME      (243 % 256)
	{MTPLSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 12}},
#define   MTPLSPROFILESLDEFAULT  (244 % 256)
	{MTPLSPROFILESLDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 13}},
#define   MTPLSPROFILEROWSTATUS  (245 % 256)
	{MTPLSPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 14}},
#define   MTPLSADJPC            (250 % 256)
	{MTPLSADJPC, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 2}},
#define   MTPLSRSID             (251 % 256)
	{MTPLSRSID, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 3}},
#define   MTPLSMAXCAPACITY      (252 % 256)
	{MTPLSMAXCAPACITY, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 4}},
#define   MTPLSCURRENTCAPACITY  (253 % 256)
	{MTPLSCURRENTCAPACITY, ASN_UNSIGNED, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 5}},
#define   MTPLSCONGESTIONCONTROLMETHOD  (254 % 256)
	{MTPLSCONGESTIONCONTROLMETHOD, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 6}},
#define   MTPLSUSAGESTATE       (255 % 256)
	{MTPLSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 7}},
#define   MTPLSOPERATIONALSTATE  (256 % 256)
	{MTPLSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 8}},
#define   MTPLSAVAILABILITYSTATUS  (257 % 256)
	{MTPLSAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 9}},
#define   MTPLSPERIODICLINKTESTFLAG  (258 % 256)
	{MTPLSPERIODICLINKTESTFLAG, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 10}},
#define   MTPLSPERIODICLINKTESTFAIL  (259 % 256)
	{MTPLSPERIODICLINKTESTFAIL, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 11}},
#define   MTPLSADMINISTRATIVESTATE  (260 % 256)
	{MTPLSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 12}},
#define   MTPLSINLSLOADSHAREALGORITHM  (261 % 256)
	{MTPLSINLSLOADSHAREALGORITHM, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 13}},
#define   MTPLSPROFILEPOINTER   (262 % 256)
	{MTPLSPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 14}},
#define   MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS  (263 % 256)
	{MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 15}},
#define   MTPLSNAME             (264 % 256)
	{MTPLSNAME, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 16}},
#define   MTPLSASAPROFILEPOINTER  (265 % 256)
	{MTPLSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 17}},
#define   MTPLSALARMSTATUS      (266 % 256)
	{MTPLSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 18}},
#define   MTPLSROWSTATUS        (267 % 256)
	{MTPLSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 19}},
#define   MTPSLL3PROFILETIMERT1  (271 % 256)
	{MTPSLL3PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 2}},
#define   MTPSLL3PROFILETIMERT3  (272 % 256)
	{MTPSLL3PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 3}},
#define   MTPSLL3PROFILETIMERT17  (273 % 256)
	{MTPSLL3PROFILETIMERT17, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 4}},
#define   MTPSLL3PROFILETIMERT24I  (274 % 256)
	{MTPSLL3PROFILETIMERT24I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 5}},
#define   MTPSLL3PROFILENAME    (275 % 256)
	{MTPSLL3PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 6}},
#define   MTPSLL3PROFILETIMERT2  (276 % 256)
	{MTPSLL3PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 7}},
#define   MTPSLL3PROFILETIMERT4  (277 % 256)
	{MTPSLL3PROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 8}},
#define   MTPSLL3PROFILETIMERT5  (278 % 256)
	{MTPSLL3PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 9}},
#define   MTPSLL3PROFILETIMERT12  (279 % 256)
	{MTPSLL3PROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 10}},
#define   MTPSLL3PROFILETIMERT13  (280 % 256)
	{MTPSLL3PROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 11}},
#define   MTPSLL3PROFILETIMERT14  (281 % 256)
	{MTPSLL3PROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 12}},
#define   MTPSLL3PROFILETIMERT19A  (282 % 256)
	{MTPSLL3PROFILETIMERT19A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 13}},
#define   MTPSLL3PROFILETIMERT20A  (283 % 256)
	{MTPSLL3PROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 14}},
#define   MTPSLL3PROFILETIMERT21A  (284 % 256)
	{MTPSLL3PROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 15}},
#define   MTPSLL3PROFILETIMERT22I  (285 % 256)
	{MTPSLL3PROFILETIMERT22I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 16}},
#define   MTPSLL3PROFILETIMERT23I  (286 % 256)
	{MTPSLL3PROFILETIMERT23I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 17}},
#define   MTPSLL3PROFILETIMERT31A  (287 % 256)
	{MTPSLL3PROFILETIMERT31A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 18}},
#define   MTPSLL3PROFILETIMERT32A  (288 % 256)
	{MTPSLL3PROFILETIMERT32A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 19}},
#define   MTPSLL3PROFILETIMERT33A  (289 % 256)
	{MTPSLL3PROFILETIMERT33A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 20}},
#define   MTPSLL3PROFILETIMERT34A  (290 % 256)
	{MTPSLL3PROFILETIMERT34A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 21}},
#define   MTPSLL3PROFILETIMERT1T  (291 % 256)
	{MTPSLL3PROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 22}},
#define   MTPSLL3PROFILETIMERT2T  (292 % 256)
	{MTPSLL3PROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 23}},
#define   MTPSLL3PROFILETIMERT1S  (293 % 256)
	{MTPSLL3PROFILETIMERT1S, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 24}},
#define   MTPSLL3PROFILEL2DEFAULT  (294 % 256)
	{MTPSLL3PROFILEL2DEFAULT, ASN_OCTET_STR, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 25}},
#define   MTPSLL3PROFILEROWSTATUS  (295 % 256)
	{MTPSLL3PROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 26}},
#define   MTPSLL2PROFILEERRORCORRECTIONMETHOD  (299 % 256)
	{MTPSLL2PROFILEERRORCORRECTIONMETHOD, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 2}},
#define   MTPSLL2PROFILETRANSMISSIONRATE  (300 % 256)
	{MTPSLL2PROFILETRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 3}},
#define   MTPSLL2PROFILETIMERT1  (301 % 256)
	{MTPSLL2PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 4}},
#define   MTPSLL2PROFILETIMERT2  (302 % 256)
	{MTPSLL2PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 5}},
#define   MTPSLL2PROFILETIMERT2L  (303 % 256)
	{MTPSLL2PROFILETIMERT2L, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 6}},
#define   MTPSLL2PROFILETIMERT2H  (304 % 256)
	{MTPSLL2PROFILETIMERT2H, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 7}},
#define   MTPSLL2PROFILETIMERT3  (305 % 256)
	{MTPSLL2PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 8}},
#define   MTPSLL2PROFILETIMERT4N  (306 % 256)
	{MTPSLL2PROFILETIMERT4N, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 9}},
#define   MTPSLL2PROFILETIMERT4E  (307 % 256)
	{MTPSLL2PROFILETIMERT4E, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 10}},
#define   MTPSLL2PROFILETIMERT5  (308 % 256)
	{MTPSLL2PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 11}},
#define   MTPSLL2PROFILETIMERT6  (309 % 256)
	{MTPSLL2PROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 12}},
#define   MTPSLL2PROFILETIMERT7  (310 % 256)
	{MTPSLL2PROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 13}},
#define   MTPSLL2PROFILETBONSET1  (311 % 256)
	{MTPSLL2PROFILETBONSET1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 14}},
#define   MTPSLL2PROFILETBABATE1  (312 % 256)
	{MTPSLL2PROFILETBABATE1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 15}},
#define   MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS  (313 % 256)
	{MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 16}},
#define   MTPSLL2PROFILECONGESTIONCOUNTING  (314 % 256)
	{MTPSLL2PROFILECONGESTIONCOUNTING, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 17}},
#define   MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT  (315 % 256)
	{MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 18}},
#define   MTPSLL2PROFILELOOPDELAY  (316 % 256)
	{MTPSLL2PROFILELOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 19}},
#define   MTPSLL2PROFILENAME    (317 % 256)
	{MTPSLL2PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 20}},
#define   MTPSLL2PROFILETBONSET2  (318 % 256)
	{MTPSLL2PROFILETBONSET2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 21}},
#define   MTPSLL2PROFILETBABATE2  (319 % 256)
	{MTPSLL2PROFILETBABATE2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 22}},
#define   MTPSLL2PROFILETBONSET3  (320 % 256)
	{MTPSLL2PROFILETBONSET3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 23}},
#define   MTPSLL2PROFILETBABATE3  (321 % 256)
	{MTPSLL2PROFILETBABATE3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 24}},
#define   MTPSLL2PROFILETBDISCARD1  (322 % 256)
	{MTPSLL2PROFILETBDISCARD1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 25}},
#define   MTPSLL2PROFILETBDISCARD2  (323 % 256)
	{MTPSLL2PROFILETBDISCARD2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 26}},
#define   MTPSLL2PROFILETBDISCARD3  (324 % 256)
	{MTPSLL2PROFILETBDISCARD3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 27}},
#define   MTPSLL2PROFILETIMERTX  (325 % 256)
	{MTPSLL2PROFILETIMERTX, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 28}},
#define   MTPSLL2PROFILETIMERTY  (326 % 256)
	{MTPSLL2PROFILETIMERTY, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 29}},
#define   MTPSLL2PROFILENUMBEROFCONGESTIONSTATES  (327 % 256)
	{MTPSLL2PROFILENUMBEROFCONGESTIONSTATES, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 30}},
#define   MTPSLL2PROFILEINITIALLEVELOFCONGESTION  (328 % 256)
	{MTPSLL2PROFILEINITIALLEVELOFCONGESTION, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 31}},
#define   MTPSLL2PROFILEMAXMSUSRETRANSN1  (329 % 256)
	{MTPSLL2PROFILEMAXMSUSRETRANSN1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 32}},
#define   MTPSLL2PROFILEMAXOCTRETRANSN2  (330 % 256)
	{MTPSLL2PROFILEMAXOCTRETRANSN2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 33}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET  (331 % 256)
	{MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 34}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE  (332 % 256)
	{MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 35}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD  (333 % 256)
	{MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 36}},
#define   MTPSLL2PROFILEM       (334 % 256)
	{MTPSLL2PROFILEM, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 37}},
#define   MTPSLL2PROFILEROWSTATUS  (335 % 256)
	{MTPSLL2PROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 38}},
#define   MTPSLSLSCODECURRENTLIST  (341 % 256)
	{MTPSLSLSCODECURRENTLIST, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 2}},
#define   MTPSLMAXCAPACITYSL    (342 % 256)
	{MTPSLMAXCAPACITYSL, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 3}},
#define   MTPSLCURRENTCAPACITYSL  (343 % 256)
	{MTPSLCURRENTCAPACITYSL, ASN_UNSIGNED, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 4}},
#define   MTPSLLINKTPSTATUS     (344 % 256)
	{MTPSLLINKTPSTATUS, ASN_BIT_STR, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 5}},
#define   MTPSLADMINISTRATIVESTATE  (345 % 256)
	{MTPSLADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 6}},
#define   MTPSLOPERATIONALSTATE  (346 % 256)
	{MTPSLOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 7}},
#define   MTPSLUSAGESTATE       (347 % 256)
	{MTPSLUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 8}},
#define   MTPSLPROCEDURALSTATUS  (348 % 256)
	{MTPSLPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 9}},
#define   MTPSLMTPL2PROTOCOLPROFILEPOINTER  (349 % 256)
	{MTPSLMTPL2PROTOCOLPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 10}},
#define   MTPSLSIGNTERMPOINTER  (350 % 256)
	{MTPSLSIGNTERMPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 11}},
#define   MTPSLSIGNDATALINKTPPOINTER  (351 % 256)
	{MTPSLSIGNDATALINKTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 12}},
#define   MTPSLLOCALINHIBIT     (352 % 256)
	{MTPSLLOCALINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 13}},
#define   MTPSLLOCALUNINHIBIT   (353 % 256)
	{MTPSLLOCALUNINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 14}},
#define   MTPSLREPLACEST        (354 % 256)
	{MTPSLREPLACEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 15}},
#define   MTPSLASAPROFILEPOINTER  (355 % 256)
	{MTPSLASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 16}},
#define   MTPSLCONGESTIONLEVEL  (356 % 256)
	{MTPSLCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 17}},
#define   MTPSLRELATEDLINKGROUPNUMBER  (357 % 256)
	{MTPSLRELATEDLINKGROUPNUMBER, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 18}},
#define   MTPSLSDLLIST          (358 % 256)
	{MTPSLSDLLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 19}},
#define   MTPSLTEST             (359 % 256)
	{MTPSLTEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 20}},
#define   MTPSLNAME             (360 % 256)
	{MTPSLNAME, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 21}},
#define   MTPSLSDTLIST          (361 % 256)
	{MTPSLSDTLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 22}},
#define   MTPSLSLSCODENORMALLIST  (362 % 256)
	{MTPSLSLSCODENORMALLIST, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 23}},
#define   MTPSLL3PROFILEPOINTER  (363 % 256)
	{MTPSLL3PROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 24}},
#define   MTPSLALARMSTATUS      (364 % 256)
	{MTPSLALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 25}},
#define   MTPSLROWSTATUS        (365 % 256)
	{MTPSLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 26}},
#define   MTPSLSDLLISTPOINTER   (372 % 256)
	{MTPSLSDLLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 10, 4, 1, 2}},
#define   MTPSLSDLLISTROWSTATUS  (373 % 256)
	{MTPSLSDLLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 10, 4, 1, 3}},
#define   MTPSLSDTLISTPOINTER   (380 % 256)
	{MTPSLSDTLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 10, 5, 1, 2}},
#define   MTPSLSDTLISTROWSTATUS  (381 % 256)
	{MTPSLSDTLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 10, 5, 1, 3}},
#define   MTPNBTRANSMISSIONRATE  (385 % 256)
	{MTPNBTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 2}},
#define   MTPNBTIMERT8          (386 % 256)
	{MTPNBTIMERT8, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 3}},
#define   MTPNBTIN              (387 % 256)
	{MTPNBTIN, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 4}},
#define   MTPNBTIE              (388 % 256)
	{MTPNBTIE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 5}},
#define   MTPNBT                (389 % 256)
	{MTPNBT, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 6}},
#define   MTPNBD                (390 % 256)
	{MTPNBD, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 7}},
#define   MTPNBTE               (391 % 256)
	{MTPNBTE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 8}},
#define   MTPNBDE               (392 % 256)
	{MTPNBDE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 9}},
#define   MTPNBUE               (393 % 256)
	{MTPNBUE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 10}},
#define   MTPNBN                (394 % 256)
	{MTPNBN, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 11}},
#define   MTPNBM                (395 % 256)
	{MTPNBM, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 12}},
#define   MTPNBB                (396 % 256)
	{MTPNBB, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 13}},
#define   MTPNBF                (397 % 256)
	{MTPNBF, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 14}},
#define   MTPNBROWSTATUS        (398 % 256)
	{MTPNBROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 15}},
#define   MTPSAALBUFFERRELEASE  (402 % 256)
	{MTPSAALBUFFERRELEASE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 1}},
#define   MTPSAALMAXCC          (403 % 256)
	{MTPSAALMAXCC, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 2}},
#define   MTPSAALMAXNRP         (404 % 256)
	{MTPSAALMAXNRP, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 3}},
#define   MTPSAALMAXINFORMATIONFIELDLENGTH  (405 % 256)
	{MTPSAALMAXINFORMATIONFIELDLENGTH, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 4}},
#define   MTPSAALMAXLENGTHSSCOPUUFIELD  (406 % 256)
	{MTPSAALMAXLENGTHSSCOPUUFIELD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 5}},
#define   MTPSAALMAXPD          (407 % 256)
	{MTPSAALMAXPD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 6}},
#define   MTPSAALMAXSSCOPCREDITTOPEER  (408 % 256)
	{MTPSAALMAXSSCOPCREDITTOPEER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 7}},
#define   MTPSAALMAXSTAT        (409 % 256)
	{MTPSAALMAXSTAT, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 8}},
#define   MTPSAALN1             (410 % 256)
	{MTPSAALN1, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 9}},
#define   MTPSAALNNILAYERMANAGEMENTPROVINGSTATE  (411 % 256)
	{MTPSAALNNILAYERMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 10}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT  (412 % 256)
	{MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 11}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC  (413 % 256)
	{MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 12}},
#define   MTPSAALNNITIMERT1     (414 % 256)
	{MTPSAALNNITIMERT1, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 13}},
#define   MTPSAALNNITIMERT2     (415 % 256)
	{MTPSAALNNITIMERT2, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 14}},
#define   MTPSAALNNITIMERT3     (416 % 256)
	{MTPSAALNNITIMERT3, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 15}},
#define   MTPSAALSSCOPTIMERCC   (417 % 256)
	{MTPSAALSSCOPTIMERCC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 16}},
#define   MTPSAALSSCOPTIMERIDLE  (418 % 256)
	{MTPSAALSSCOPTIMERIDLE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 17}},
#define   MTPSAALSSCOPTIMERKEEPALIVE  (419 % 256)
	{MTPSAALSSCOPTIMERKEEPALIVE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 18}},
#define   MTPSAALSSCOPTIMERNORESPONSE  (420 % 256)
	{MTPSAALSSCOPTIMERNORESPONSE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 19}},
#define   MTPSAALSSCOPTIMERPOLL  (421 % 256)
	{MTPSAALSSCOPTIMERPOLL, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 20}},
#define   MTPSAALTRANSMISSIONRATEINTERVALLOWER  (422 % 256)
	{MTPSAALTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 21}},
#define   MTPSAALTRANSMISSIONRATEINTERVALUPPER  (423 % 256)
	{MTPSAALTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 22}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER  (424 % 256)
	{MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 23}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER  (425 % 256)
	{MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 24}},
#define   MTPSAALPOLLAFTERRETRANSMISSION  (426 % 256)
	{MTPSAALPOLLAFTERRETRANSMISSION, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 25}},
#define   MTPSAALROWSTATUS      (427 % 256)
	{MTPSAALROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 26}},
#define   MTPM2PAN1             (431 % 256)
	{MTPM2PAN1, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 1}},
#define   MTPM2PAPROVING        (432 % 256)
	{MTPM2PAPROVING, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 2}},
#define   MTPM2PAMANAGEMENTPROVINGSTATE  (433 % 256)
	{MTPM2PAMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 3}},
#define   MTPM2PALOOPDELAYLOWER  (434 % 256)
	{MTPM2PALOOPDELAYLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 4}},
#define   MTPM2PALOOPDELAYUPPER  (435 % 256)
	{MTPM2PALOOPDELAYUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 5}},
#define   MTPM2PATRANSMISSIONRATEINTERVALLOWER  (436 % 256)
	{MTPM2PATRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 6}},
#define   MTPM2PATRANSMISSIONRATEINTERVALUPPER  (437 % 256)
	{MTPM2PATRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 7}},
#define   MTPM2PASCTPNODELAY    (438 % 256)
	{MTPM2PASCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 8}},
#define   MTPM2PASCTPMAXSEG     (439 % 256)
	{MTPM2PASCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 9}},
#define   MTPM2PASCTPHEARTBEATITVL  (440 % 256)
	{MTPM2PASCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 10}},
#define   MTPM2PASCTPHEARTBEAT  (441 % 256)
	{MTPM2PASCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 11}},
#define   MTPM2PASCTPRTOINITIAL  (442 % 256)
	{MTPM2PASCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 12}},
#define   MTPM2PASCTPRTOMIN     (443 % 256)
	{MTPM2PASCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 13}},
#define   MTPM2PASCTPRTOMAX     (444 % 256)
	{MTPM2PASCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 14}},
#define   MTPM2PASCTPPATHMAXRETRANS  (445 % 256)
	{MTPM2PASCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 15}},
#define   MTPM2PASCTPCOOKIELIFE  (446 % 256)
	{MTPM2PASCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 16}},
#define   MTPM2PASCTPCOOKIEINC  (447 % 256)
	{MTPM2PASCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 17}},
#define   MTPM2PASCTPMAXINITRETRIES  (448 % 256)
	{MTPM2PASCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 18}},
#define   MTPM2PASCTPMAXBURST   (449 % 256)
	{MTPM2PASCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 19}},
#define   MTPM2PASCTPASSOCMAXRETRANS  (450 % 256)
	{MTPM2PASCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 20}},
#define   MTPM2PASCTPSACKDELAY  (451 % 256)
	{MTPM2PASCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 21}},
#define   MTPM2PASCTPLIFETIME   (452 % 256)
	{MTPM2PASCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 22}},
#define   MTPM2PAPROVINGATTEMPTS  (453 % 256)
	{MTPM2PAPROVINGATTEMPTS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 23}},
#define   MTPM2PAROWSTATUS      (454 % 256)
	{MTPM2PAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 24}},
#define   MTPSDTADMINISTRATIVESTATE  (458 % 256)
	{MTPSDTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 2}},
#define   MTPSDTOPERATIONALSTATE  (459 % 256)
	{MTPSDTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 3}},
#define   MTPSDTUSAGESTATE      (460 % 256)
	{MTPSDTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 4}},
#define   MTPSDTPROCEDURALSTATUS  (461 % 256)
	{MTPSDTPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 5}},
#define   MTPSDTAVAILABILITYSTATUS  (462 % 256)
	{MTPSDTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 6}},
#define   MTPSDTEQUIPMENTPOINTER  (463 % 256)
	{MTPSDTEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 7}},
#define   MTPSDTNAME            (464 % 256)
	{MTPSDTNAME, ASN_OCTET_STR, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 8}},
#define   MTPSDTPROFILEPOINTER  (465 % 256)
	{MTPSDTPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 9}},
#define   MTPSDTROWSTATUS       (466 % 256)
	{MTPSDTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 10}},
#define   MTPSDLADJPC           (470 % 256)
	{MTPSDLADJPC, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 2}},
#define   MTPSDLTRANSMISSIONRATE  (471 % 256)
	{MTPSDLTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 3}},
#define   MTPSDLLOOPDELAY       (472 % 256)
	{MTPSDLLOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 4}},
#define   MTPSDLOPERATIONALSTATE  (473 % 256)
	{MTPSDLOPERATIONALSTATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 5}},
#define   MTPSDLEQUIPMENTPOINTER  (474 % 256)
	{MTPSDLEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 6}},
#define   MTPSDLCIC             (475 % 256)
	{MTPSDLCIC, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 7}},
#define   MTPSDLNAME            (476 % 256)
	{MTPSDLNAME, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 8}},
#define   MTPSDLSTMCHANNEL      (477 % 256)
	{MTPSDLSTMCHANNEL, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 9}},
#define   MTPSDLVCTTPPOINTER    (478 % 256)
	{MTPSDLVCTTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 10}},
#define   MTPSDLROWSTATUS       (479 % 256)
	{MTPSDLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 11}},
#define   MTPM2PADEFAULTSCTPNODELAY  (480 % 256)
	{MTPM2PADEFAULTSCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpMIB, 4, {1, 2, 1, 1}},
#define   MTPM2PADEFAULTSCTPMAXSEG  (481 % 256)
	{MTPM2PADEFAULTSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 2}},
#define   MTPM2PADEFAULTSCTPHEARTBEATITVL  (482 % 256)
	{MTPM2PADEFAULTSCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 3}},
#define   MTPM2PADEFAULTSCTPHEARTBEAT  (483 % 256)
	{MTPM2PADEFAULTSCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpMIB, 4, {1, 2, 1, 4}},
#define   MTPM2PADEFAULTSCTPRTOINITIAL  (484 % 256)
	{MTPM2PADEFAULTSCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 5}},
#define   MTPM2PADEFAULTSCTPRTOMIN  (485 % 256)
	{MTPM2PADEFAULTSCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 6}},
#define   MTPM2PADEFAULTSCTPRTOMAX  (486 % 256)
	{MTPM2PADEFAULTSCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 7}},
#define   MTPM2PADEFAULTSCTPPATHMAXRETRANS  (487 % 256)
	{MTPM2PADEFAULTSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 8}},
#define   MTPM2PADEFAULTSCTPCOOKIELIFE  (488 % 256)
	{MTPM2PADEFAULTSCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 9}},
#define   MTPM2PADEFAULTSCTPCOOKIEINC  (489 % 256)
	{MTPM2PADEFAULTSCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 10}},
#define   MTPM2PADEFAULTSCTPMAXINITRETRIES  (490 % 256)
	{MTPM2PADEFAULTSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 11}},
#define   MTPM2PADEFAULTSCTPMAXBURST  (491 % 256)
	{MTPM2PADEFAULTSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 12}},
#define   MTPM2PADEFAULTSCTPASSOCMAXRETRANS  (492 % 256)
	{MTPM2PADEFAULTSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 13}},
#define   MTPM2PADEFAULTSCTPSACKDELAY  (493 % 256)
	{MTPM2PADEFAULTSCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 14}},
#define   MTPM2PADEFAULTSCTPLIFETIME  (494 % 256)
	{MTPM2PADEFAULTSCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 15}},
};

/* (L = length of the oidsuffix) */
struct mtpMIB_data *mtpMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *mtpSapTableStorage = NULL;
struct header_complex_index *mtpMsTableStorage = NULL;
struct header_complex_index *mtpNaTableStorage = NULL;
struct header_complex_index *mtpGsTableStorage = NULL;
struct header_complex_index *mtpGsLineTableStorage = NULL;
struct header_complex_index *mtpGsLineContentTableStorage = NULL;
struct header_complex_index *mtpSpProfileTableStorage = NULL;
struct header_complex_index *mtpSpTableStorage = NULL;
struct header_complex_index *mtpL3TableStorage = NULL;
struct header_complex_index *mtpRsProfileTableStorage = NULL;
struct header_complex_index *mtpRsTableStorage = NULL;
struct header_complex_index *mtpRtProfileTableStorage = NULL;
struct header_complex_index *mtpRtTableStorage = NULL;
struct header_complex_index *mtpRtLsaTableStorage = NULL;
struct header_complex_index *mtpLsProfileTableStorage = NULL;
struct header_complex_index *mtpLsTableStorage = NULL;
struct header_complex_index *mtpSlL3ProfileTableStorage = NULL;
struct header_complex_index *mtpSlL2ProfileTableStorage = NULL;
struct header_complex_index *mtpSlTableStorage = NULL;
struct header_complex_index *mtpSlSdlListTableStorage = NULL;
struct header_complex_index *mtpSlSdtListTableStorage = NULL;
struct header_complex_index *mtpNbTableStorage = NULL;
struct header_complex_index *mtpSaalTableStorage = NULL;
struct header_complex_index *mtpM2paTableStorage = NULL;
struct header_complex_index *mtpSdtTableStorage = NULL;
struct header_complex_index *mtpSdlTableStorage = NULL;

/*
 * init_mtpMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_mtpMIB(void)
{
	DEBUGMSGTL(("mtpMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("mtpMIB", mtpMIB_variables, variable7, mtpMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_mtpMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("mtpMIB", parse_mtpMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSapTable", parse_mtpSapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpMsTable", parse_mtpMsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNaTable", parse_mtpNaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsTable", parse_mtpGsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineTable", parse_mtpGsLineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineContentTable", parse_mtpGsLineContentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpProfileTable", parse_mtpSpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpTable", parse_mtpSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL3Table", parse_mtpL3Table, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsProfileTable", parse_mtpRsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsTable", parse_mtpRsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtProfileTable", parse_mtpRtProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtTable", parse_mtpRtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtLsaTable", parse_mtpRtLsaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsProfileTable", parse_mtpLsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsTable", parse_mtpLsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL3ProfileTable", parse_mtpSlL3ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL2ProfileTable", parse_mtpSlL2ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlTable", parse_mtpSlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdlListTable", parse_mtpSlSdlListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdtListTable", parse_mtpSlSdtListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNbTable", parse_mtpNbTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSaalTable", parse_mtpSaalTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM2paTable", parse_mtpM2paTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdtTable", parse_mtpSdtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdlTable", parse_mtpSdlTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineContentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL3Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtLsaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL3ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL2ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdlListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdtListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNbTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSaalTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM2paTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdlTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * deinit_mtpMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_mtpMIB(void)
{
	DEBUGMSGTL(("mtpMIB", "deinitializating...  "));
	unregister_mib(mtpMIB_variables_oid, sizeof(mtpMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("mtpMIB");
	snmpd_unregister_config_handler("mtpSapTable");
	snmpd_unregister_config_handler("mtpMsTable");
	snmpd_unregister_config_handler("mtpNaTable");
	snmpd_unregister_config_handler("mtpGsTable");
	snmpd_unregister_config_handler("mtpGsLineTable");
	snmpd_unregister_config_handler("mtpGsLineContentTable");
	snmpd_unregister_config_handler("mtpSpProfileTable");
	snmpd_unregister_config_handler("mtpSpTable");
	snmpd_unregister_config_handler("mtpL3Table");
	snmpd_unregister_config_handler("mtpRsProfileTable");
	snmpd_unregister_config_handler("mtpRsTable");
	snmpd_unregister_config_handler("mtpRtProfileTable");
	snmpd_unregister_config_handler("mtpRtTable");
	snmpd_unregister_config_handler("mtpRtLsaTable");
	snmpd_unregister_config_handler("mtpLsProfileTable");
	snmpd_unregister_config_handler("mtpLsTable");
	snmpd_unregister_config_handler("mtpSlL3ProfileTable");
	snmpd_unregister_config_handler("mtpSlL2ProfileTable");
	snmpd_unregister_config_handler("mtpSlTable");
	snmpd_unregister_config_handler("mtpSlSdlListTable");
	snmpd_unregister_config_handler("mtpSlSdtListTable");
	snmpd_unregister_config_handler("mtpNbTable");
	snmpd_unregister_config_handler("mtpSaalTable");
	snmpd_unregister_config_handler("mtpM2paTable");
	snmpd_unregister_config_handler("mtpSdtTable");
	snmpd_unregister_config_handler("mtpSdlTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

int
term_mtpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_mtpMIB();
	return 0;
}

/**
 * @fn struct mtpMIB_data *mtpMIB_create(void)
 * @brief create a fresh data structure representing scalars in mtpMIB.
 * Creates a new mtpMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in mtpMIB.
 */
struct mtpMIB_data *
mtpMIB_create(void)
{
	struct mtpMIB_data *StorageNew = SNMP_MALLOC_STRUCT(mtpMIB_data);

	DEBUGMSGTL(("mtpMIB", "creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		StorageNew->mtpM2paDefaultSctpNoDelay = TV_TRUE;
		StorageNew->mtpM2paDefaultSctpMaxseg = 65536;
		StorageNew->mtpM2paDefaultSctpHeartbeatItvl = 60000;
		StorageNew->mtpM2paDefaultSctpRtoInitial = 3000;
		StorageNew->mtpM2paDefaultSctpRtoMin = 1000;
		StorageNew->mtpM2paDefaultSctpRtoMax = 60000;
		StorageNew->mtpM2paDefaultSctpPathMaxRetrans = 5;
		StorageNew->mtpM2paDefaultSctpCookieLife = 60000;
		StorageNew->mtpM2paDefaultSctpCookieInc = 1000;
		StorageNew->mtpM2paDefaultSctpMaxInitRetries = 8;
		StorageNew->mtpM2paDefaultSctpMaxBurst = 4;
		StorageNew->mtpM2paDefaultSctpAssocMaxRetrans = 10;
		StorageNew->mtpM2paDefaultSctpSackDelay = 200;

	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int mtpMIB_destroy(struct mtpMIB_data **thedata)
 * @brief delete a scalars structure from mtpMIB.
 * @param thedata pointer to the data structure in mtpMIB.
 * Frees scalars that were previously removed from mtpMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpMIB_destroy(struct mtpMIB_data **thedata)
{
	struct mtpMIB_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpMIB_add(struct mtpMIB_data *thedata)
 * @param thedata the structure representing mtpMIB scalars.
 * @brief adds node to the mtpMIB scalar data set.
 * Adds a scalar structure to the mtpMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
mtpMIB_add(struct mtpMIB_data *thedata)
{
	DEBUGMSGTL(("mtpMIB", "adding data...  "));
	mtpMIBStorage = thedata;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpMIB entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_mtpMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpMIB_data *StorageTmp = mtpMIB_create();

	DEBUGMSGTL(("mtpMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paDefaultSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paDefaultSctpHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpLifetime, &tmpsize);
	mtpMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_mtpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpMIB_data *StorageTmp;

	DEBUGMSGTL(("mtpMIB", "storing data...  "));
	refresh_mtpMIB();
	if ((StorageTmp = mtpMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "mtpMIB ");
		cptr = line + strlen(line);
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paDefaultSctpNoDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxseg, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paDefaultSctpHeartbeat, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoInitial, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoMin, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoMax, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpCookieLife, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpCookieInc, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxInitRetries, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxBurst, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpSackDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpLifetime, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_mtpMIB(void)
 * @brief refresh the scalar values of mtpMIB.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_mtpMIB(void)
{
	if (mtpMIBStorage == NULL) {
		struct mtpMIB_data *StorageNew;

		if ((StorageNew = mtpMIB_create()) == NULL)
			return;
		mtpMIBStorage = StorageNew;
		mtpMIB_refresh = 1;
	}
	if (mtpMIB_refresh == 0)
		return;
	mtpMIB_refresh = 0;
	/* XXX: Update scalars as required here... */
}

/**
* @fn u_char * var_mtpMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
* @param vp a pointer to the entry in the variables table for the requested variable.
* @param name the object identifier for which to find.
* @param length the length of the object identifier.
* @param exact whether the name is exact.
* @param var_len a pointer to the length of the representation of the object.
* @param write_method a pointer to a write method for the object.
* @brief locate variables in mtpMIB.
* This function returns a pointer to a memory area that is static across the request that contains
* the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
* GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
* telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
* overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
* writing.  Write-only objects can be effected in this way.
*/
u_char *
var_mtpMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_mtpMIB();
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPM2PADEFAULTSCTPNODELAY:
		*write_method = write_mtpM2paDefaultSctpNoDelay;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpNoDelay);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpNoDelay;
	case MTPM2PADEFAULTSCTPMAXSEG:
		*write_method = write_mtpM2paDefaultSctpMaxseg;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxseg);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxseg;
	case MTPM2PADEFAULTSCTPHEARTBEATITVL:
		*write_method = write_mtpM2paDefaultSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpHeartbeatItvl);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl;
	case MTPM2PADEFAULTSCTPHEARTBEAT:
		*write_method = write_mtpM2paDefaultSctpHeartbeat;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpHeartbeat);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpHeartbeat;
	case MTPM2PADEFAULTSCTPRTOINITIAL:
		*write_method = write_mtpM2paDefaultSctpRtoInitial;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoInitial);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoInitial;
	case MTPM2PADEFAULTSCTPRTOMIN:
		*write_method = write_mtpM2paDefaultSctpRtoMin;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoMin);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoMin;
	case MTPM2PADEFAULTSCTPRTOMAX:
		*write_method = write_mtpM2paDefaultSctpRtoMax;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoMax);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoMax;
	case MTPM2PADEFAULTSCTPPATHMAXRETRANS:
		*write_method = write_mtpM2paDefaultSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpPathMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans;
	case MTPM2PADEFAULTSCTPCOOKIELIFE:
		*write_method = write_mtpM2paDefaultSctpCookieLife;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpCookieLife);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpCookieLife;
	case MTPM2PADEFAULTSCTPCOOKIEINC:
		*write_method = write_mtpM2paDefaultSctpCookieInc;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpCookieInc);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpCookieInc;
	case MTPM2PADEFAULTSCTPMAXINITRETRIES:
		*write_method = write_mtpM2paDefaultSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxInitRetries);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxInitRetries;
	case MTPM2PADEFAULTSCTPMAXBURST:
		*write_method = write_mtpM2paDefaultSctpMaxBurst;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxBurst);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxBurst;
	case MTPM2PADEFAULTSCTPASSOCMAXRETRANS:
		*write_method = write_mtpM2paDefaultSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans;
	case MTPM2PADEFAULTSCTPSACKDELAY:
		*write_method = write_mtpM2paDefaultSctpSackDelay;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpSackDelay);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpSackDelay;
	case MTPM2PADEFAULTSCTPLIFETIME:
		*write_method = write_mtpM2paDefaultSctpLifetime;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpLifetime);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpLifetime;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn struct mtpSapTable_data *mtpSapTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSapTable table.
 * Creates a new mtpSapTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSapTable_data *
mtpSapTable_create(void)
{
	struct mtpSapTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSapTable_data);

	DEBUGMSGTL(("mtpSapTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpSapAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpSapAsaProfilePointerLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpSapRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSapTable_data *mtpSapTable_duplicate(struct mtpSapTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSapTable_data *
mtpSapTable_duplicate(struct mtpSapTable_data *thedata)
{
	struct mtpSapTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSapTable_data);

	DEBUGMSGTL(("mtpSapTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSapTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSapTable_destroy(struct mtpSapTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSapTable_destroy(struct mtpSapTable_data **thedata)
{
	struct mtpSapTable_data *StorageDel;

	DEBUGMSGTL(("mtpSapTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSapUserEntityNames);
		StorageDel->mtpSapUserEntityNamesLen = 0;
		SNMP_FREE(StorageDel->mtpSapProviderEntityNames);
		StorageDel->mtpSapProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel->mtpSapAsaProfilePointer);
		StorageDel->mtpSapAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSapName);
		StorageDel->mtpSapNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSapTable_add(struct mtpSapTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSapTable table data set.
 * Adds a table row structure to the mtpSapTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSapTable_add(struct mtpSapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSapId, sizeof(thedata->mtpSapId));
	header_complex_add_data(&mtpSapTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSapTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSapTable_del(struct mtpSapTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpSapTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSapTable_del(struct mtpSapTable_data *thedata)
{
	struct mtpSapTable_data *StorageDel;

	DEBUGMSGTL(("mtpSapTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSapTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSapTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSapTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSapTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSapTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSapTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSapTable_data *StorageTmp = mtpSapTable_create();

	DEBUGMSGTL(("mtpSapTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSapId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSap2Address, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUserPart, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUserPartStatus, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapUserEntityNames, &StorageTmp->mtpSapUserEntityNamesLen);
	if (StorageTmp->mtpSapUserEntityNames == NULL) {
		config_perror("invalid specification for mtpSapUserEntityNames");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapProviderEntityNames, &StorageTmp->mtpSapProviderEntityNamesLen);
	if (StorageTmp->mtpSapProviderEntityNames == NULL) {
		config_perror("invalid specification for mtpSapProviderEntityNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUsageState, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapAsaProfilePointer, &StorageTmp->mtpSapAsaProfilePointerLen);
	if (StorageTmp->mtpSapAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSapAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSapName, &StorageTmp->mtpSapNameLen);
	if (StorageTmp->mtpSapName == NULL) {
		config_perror("invalid specification for mtpSapName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapLongMessageSupported, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapRowStatus, &tmpsize);
	mtpSapTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
}

/*
 * store_mtpSapTable(): store configuraiton file for mtpSapTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSapTable", "storing data...  "));
	refresh_mtpSapTable();
	(void) tmpsize;
	for (hcindex = mtpSapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSapTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSapTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSapId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSap2Address, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUserPart, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUserPartStatus, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapUserEntityNames, &StorageTmp->mtpSapUserEntityNamesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapProviderEntityNames, &StorageTmp->mtpSapProviderEntityNamesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapAsaProfilePointer, &StorageTmp->mtpSapAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSapName, &StorageTmp->mtpSapNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapLongMessageSupported, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpMsTable_data *mtpMsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpMsTable table.
 * Creates a new mtpMsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpMsTable_data *
mtpMsTable_create(void)
{
	struct mtpMsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpMsTable_data);

	DEBUGMSGTL(("mtpMsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsOperationalState = MTPMSOPERATIONALSTATE_DISABLED;
		StorageNew->mtpMsUsageState = MTPMSUSAGESTATE_IDLE;
		if ((StorageNew->mtpMsAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpMsAsaProfilePointerLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpMsStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpMsTable_data *mtpMsTable_duplicate(struct mtpMsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpMsTable_data *
mtpMsTable_duplicate(struct mtpMsTable_data *thedata)
{
	struct mtpMsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpMsTable_data);

	DEBUGMSGTL(("mtpMsTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpMsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpMsTable_destroy(struct mtpMsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpMsTable_destroy(struct mtpMsTable_data **thedata)
{
	struct mtpMsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpMsName);
		StorageDel->mtpMsNameLen = 0;
		SNMP_FREE(StorageDel->mtpMsAlarmStatus);
		StorageDel->mtpMsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->mtpMsManagedElementType);
		StorageDel->mtpMsManagedElementTypeLen = 0;
		SNMP_FREE(StorageDel->mtpMsModelCode);
		StorageDel->mtpMsModelCodeLen = 0;
		SNMP_FREE(StorageDel->mtpMsVendorName);
		StorageDel->mtpMsVendorNameLen = 0;
		SNMP_FREE(StorageDel->mtpMsUserLabel);
		StorageDel->mtpMsUserLabelLen = 0;
		SNMP_FREE(StorageDel->mtpMsVersion);
		StorageDel->mtpMsVersionLen = 0;
		SNMP_FREE(StorageDel->mtpMsAsaProfilePointer);
		StorageDel->mtpMsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpMsNetworkElementAliases);
		StorageDel->mtpMsNetworkElementAliasesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpMsTable_add(struct mtpMsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpMsTable table data set.
 * Adds a table row structure to the mtpMsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpMsTable_add(struct mtpMsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	header_complex_add_data(&mtpMsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpMsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpMsTable_del(struct mtpMsTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpMsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpMsTable_del(struct mtpMsTable_data *thedata)
{
	struct mtpMsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpMsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpMsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpMsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpMsTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpMsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpMsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpMsTable_data *StorageTmp = mtpMsTable_create();

	DEBUGMSGTL(("mtpMsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsName, &StorageTmp->mtpMsNameLen);
	if (StorageTmp->mtpMsName == NULL) {
		config_perror("invalid specification for mtpMsName");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpMsAlarmStatus, &StorageTmp->mtpMsAlarmStatusLen);
	if (StorageTmp->mtpMsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpMsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsUsageState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsManagedElementType, &StorageTmp->mtpMsManagedElementTypeLen);
	if (StorageTmp->mtpMsManagedElementType == NULL) {
		config_perror("invalid specification for mtpMsManagedElementType");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsModelCode, &StorageTmp->mtpMsModelCodeLen);
	if (StorageTmp->mtpMsModelCode == NULL) {
		config_perror("invalid specification for mtpMsModelCode");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVendorName, &StorageTmp->mtpMsVendorNameLen);
	if (StorageTmp->mtpMsVendorName == NULL) {
		config_perror("invalid specification for mtpMsVendorName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsUserLabel, &StorageTmp->mtpMsUserLabelLen);
	if (StorageTmp->mtpMsUserLabel == NULL) {
		config_perror("invalid specification for mtpMsUserLabel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVersion, &StorageTmp->mtpMsVersionLen);
	if (StorageTmp->mtpMsVersion == NULL) {
		config_perror("invalid specification for mtpMsVersion");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpMsAsaProfilePointer, &StorageTmp->mtpMsAsaProfilePointerLen);
	if (StorageTmp->mtpMsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpMsAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsNetworkElementAliases, &StorageTmp->mtpMsNetworkElementAliasesLen);
	if (StorageTmp->mtpMsNetworkElementAliases == NULL) {
		config_perror("invalid specification for mtpMsNetworkElementAliases");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsStatus, &tmpsize);
	mtpMsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
}

/*
 * store_mtpMsTable(): store configuraiton file for mtpMsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpMsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpMsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMsTable", "storing data...  "));
	refresh_mtpMsTable();
	(void) tmpsize;
	for (hcindex = mtpMsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpMsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpMsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsName, &StorageTmp->mtpMsNameLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpMsAlarmStatus, &StorageTmp->mtpMsAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsManagedElementType, &StorageTmp->mtpMsManagedElementTypeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsModelCode, &StorageTmp->mtpMsModelCodeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVendorName, &StorageTmp->mtpMsVendorNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsUserLabel, &StorageTmp->mtpMsUserLabelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVersion, &StorageTmp->mtpMsVersionLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpMsAsaProfilePointer, &StorageTmp->mtpMsAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsNetworkElementAliases, &StorageTmp->mtpMsNetworkElementAliasesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpNaTable_data *mtpNaTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpNaTable table.
 * Creates a new mtpNaTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpNaTable_data *
mtpNaTable_create(void)
{
	struct mtpNaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNaTable_data);

	DEBUGMSGTL(("mtpNaTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		{
			static const oid tmpoid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 0, 1, 4, 1, 1, 0 };
			if ((StorageNew->mtpNaProtocolVariant = snmp_duplicate_objid(tmpoid, 15))) {
				StorageNew->mtpNaProtocolVariantLen = 15 * sizeof(oid);
			}
		}
		StorageNew->mtpNaProtocolYear = MTPNAPROTOCOLYEAR_YCURRENT;
		StorageNew->mtpNaRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpNaTable_data *mtpNaTable_duplicate(struct mtpNaTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpNaTable_data *
mtpNaTable_duplicate(struct mtpNaTable_data *thedata)
{
	struct mtpNaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNaTable_data);

	DEBUGMSGTL(("mtpNaTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpNaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpNaTable_destroy(struct mtpNaTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpNaTable_destroy(struct mtpNaTable_data **thedata)
{
	struct mtpNaTable_data *StorageDel;

	DEBUGMSGTL(("mtpNaTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpNaProtocolVariant);
		StorageDel->mtpNaProtocolVariantLen = 0;
		SNMP_FREE(StorageDel->mtpNaProtocolOptions);
		StorageDel->mtpNaProtocolOptionsLen = 0;
		SNMP_FREE(StorageDel->mtpNaPointCodeFormat);
		StorageDel->mtpNaPointCodeFormatLen = 0;
		SNMP_FREE(StorageDel->mtpNaSpDefault);
		StorageDel->mtpNaSpDefaultLen = 0;
		SNMP_FREE(StorageDel->mtpNaName);
		StorageDel->mtpNaNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNaTable_add(struct mtpNaTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpNaTable table data set.
 * Adds a table row structure to the mtpNaTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpNaTable_add(struct mtpNaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpNaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpNaId, sizeof(thedata->mtpNaId));
	header_complex_add_data(&mtpNaTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNaTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNaTable_del(struct mtpNaTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpNaTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpNaTable_del(struct mtpNaTable_data *thedata)
{
	struct mtpNaTable_data *StorageDel;

	DEBUGMSGTL(("mtpNaTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpNaTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpNaTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpNaTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpNaTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpNaTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpNaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpNaTable_data *StorageTmp = mtpNaTable_create();

	DEBUGMSGTL(("mtpNaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaId, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
	if (StorageTmp->mtpNaProtocolVariant == NULL) {
		config_perror("invalid specification for mtpNaProtocolVariant");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaProtocolYear, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
	if (StorageTmp->mtpNaProtocolOptions == NULL) {
		config_perror("invalid specification for mtpNaProtocolOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaNetworkIndicator, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
	if (StorageTmp->mtpNaPointCodeFormat == NULL) {
		config_perror("invalid specification for mtpNaPointCodeFormat");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaSlsLength, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaSpDefault, &StorageTmp->mtpNaSpDefaultLen);
	if (StorageTmp->mtpNaSpDefault == NULL) {
		config_perror("invalid specification for mtpNaSpDefault");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
	if (StorageTmp->mtpNaName == NULL) {
		config_perror("invalid specification for mtpNaName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaRowStatus, &tmpsize);
	mtpNaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
}

/*
 * store_mtpNaTable(): store configuraiton file for mtpNaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpNaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpNaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNaTable", "storing data...  "));
	refresh_mtpNaTable();
	(void) tmpsize;
	for (hcindex = mtpNaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNaTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpNaTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaProtocolYear, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaNetworkIndicator, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaSlsLength, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaSpDefault, &StorageTmp->mtpNaSpDefaultLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpGsTable_data *mtpGsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpGsTable table.
 * Creates a new mtpGsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpGsTable_data *
mtpGsTable_create(void)
{
	struct mtpGsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsTable_data);

	DEBUGMSGTL(("mtpGsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpGsAdministrativeState = MTPGSADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpGsRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpGsTable_data *mtpGsTable_duplicate(struct mtpGsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpGsTable_data *
mtpGsTable_duplicate(struct mtpGsTable_data *thedata)
{
	struct mtpGsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsTable_data);

	DEBUGMSGTL(("mtpGsTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpGsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpGsTable_destroy(struct mtpGsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpGsTable_destroy(struct mtpGsTable_data **thedata)
{
	struct mtpGsTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsName);
		StorageDel->mtpGsNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsTable_add(struct mtpGsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpGsTable table data set.
 * Adds a table row structure to the mtpGsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpGsTable_add(struct mtpGsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
	header_complex_add_data(&mtpGsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsTable_del(struct mtpGsTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpGsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpGsTable_del(struct mtpGsTable_data *thedata)
{
	struct mtpGsTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpGsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpGsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpGsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpGsTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpGsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpGsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsTable_data *StorageTmp = mtpGsTable_create();

	DEBUGMSGTL(("mtpGsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsListMode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
	if (StorageTmp->mtpGsName == NULL) {
		config_perror("invalid specification for mtpGsName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsRowStatus, &tmpsize);
	mtpGsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
}

/*
 * store_mtpGsTable(): store configuraiton file for mtpGsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsTable", "storing data...  "));
	refresh_mtpGsTable();
	(void) tmpsize;
	for (hcindex = mtpGsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsListMode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpGsLineTable_data *mtpGsLineTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpGsLineTable table.
 * Creates a new mtpGsLineTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpGsLineTable_data *
mtpGsLineTable_create(void)
{
	struct mtpGsLineTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineTable_data);

	DEBUGMSGTL(("mtpGsLineTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpGsLineObject = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpGsLineObjectLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpGsLineRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpGsLineTable_data *mtpGsLineTable_duplicate(struct mtpGsLineTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpGsLineTable_data *
mtpGsLineTable_duplicate(struct mtpGsLineTable_data *thedata)
{
	struct mtpGsLineTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineTable_data);

	DEBUGMSGTL(("mtpGsLineTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpGsLineTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpGsLineTable_destroy(struct mtpGsLineTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpGsLineTable_destroy(struct mtpGsLineTable_data **thedata)
{
	struct mtpGsLineTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsLineTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsLineObject);
		StorageDel->mtpGsLineObjectLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineTable_add(struct mtpGsLineTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpGsLineTable table data set.
 * Adds a table row structure to the mtpGsLineTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpGsLineTable_add(struct mtpGsLineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsLineTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
	/* mtpGsLineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineId, sizeof(thedata->mtpGsLineId));
	header_complex_add_data(&mtpGsLineTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsLineTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineTable_del(struct mtpGsLineTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpGsLineTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpGsLineTable_del(struct mtpGsLineTable_data *thedata)
{
	struct mtpGsLineTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsLineTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpGsLineTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpGsLineTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpGsLineTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpGsLineTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpGsLineTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpGsLineTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsLineTable_data *StorageTmp = mtpGsLineTable_create();

	DEBUGMSGTL(("mtpGsLineTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineId, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpGsLineObject, &StorageTmp->mtpGsLineObjectLen);
	if (StorageTmp->mtpGsLineObject == NULL) {
		config_perror("invalid specification for mtpGsLineObject");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineRowStatus, &tmpsize);
	mtpGsLineTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
}

/*
 * store_mtpGsLineTable(): store configuraiton file for mtpGsLineTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsLineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsLineTable", "storing data...  "));
	refresh_mtpGsLineTable();
	(void) tmpsize;
	for (hcindex = mtpGsLineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsLineTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpGsLineObject, &StorageTmp->mtpGsLineObjectLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContent, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpGsLineContentTable_data *mtpGsLineContentTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpGsLineContentTable table.
 * Creates a new mtpGsLineContentTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpGsLineContentTable_data *
mtpGsLineContentTable_create(void)
{
	struct mtpGsLineContentTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data);

	DEBUGMSGTL(("mtpGsLineContentTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpGsLineContentRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpGsLineContentTable_data *mtpGsLineContentTable_duplicate(struct mtpGsLineContentTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpGsLineContentTable_data *
mtpGsLineContentTable_duplicate(struct mtpGsLineContentTable_data *thedata)
{
	struct mtpGsLineContentTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data);

	DEBUGMSGTL(("mtpGsLineContentTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpGsLineContentTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpGsLineContentTable_destroy(struct mtpGsLineContentTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpGsLineContentTable_destroy(struct mtpGsLineContentTable_data **thedata)
{
	struct mtpGsLineContentTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsLineContentTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsLineContentDesignatedDPCFirst);
		StorageDel->mtpGsLineContentDesignatedDPCFirstLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentDesignatedDPCLast);
		StorageDel->mtpGsLineContentDesignatedDPCLastLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentSiMask);
		StorageDel->mtpGsLineContentSiMaskLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentComment);
		StorageDel->mtpGsLineContentCommentLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineContentTable_add(struct mtpGsLineContentTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpGsLineContentTable table data set.
 * Adds a table row structure to the mtpGsLineContentTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpGsLineContentTable_add(struct mtpGsLineContentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsLineContentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
	/* mtpGsLineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineId, sizeof(thedata->mtpGsLineId));
	/* mtpGsLineContentId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineContentId, sizeof(thedata->mtpGsLineContentId));
	header_complex_add_data(&mtpGsLineContentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsLineContentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineContentTable_del(struct mtpGsLineContentTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpGsLineContentTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpGsLineContentTable_del(struct mtpGsLineContentTable_data *thedata)
{
	struct mtpGsLineContentTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsLineContentTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpGsLineContentTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpGsLineContentTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpGsLineContentTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpGsLineContentTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpGsLineContentTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpGsLineContentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsLineContentTable_data *StorageTmp = mtpGsLineContentTable_create();

	DEBUGMSGTL(("mtpGsLineContentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContentId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &StorageTmp->mtpGsLineContentDesignatedDPCFirstLen);
	if (StorageTmp->mtpGsLineContentDesignatedDPCFirst == NULL) {
		config_perror("invalid specification for mtpGsLineContentDesignatedDPCFirst");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &StorageTmp->mtpGsLineContentDesignatedDPCLastLen);
	if (StorageTmp->mtpGsLineContentDesignatedDPCLast == NULL) {
		config_perror("invalid specification for mtpGsLineContentDesignatedDPCLast");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpGsLineContentSiMask, &StorageTmp->mtpGsLineContentSiMaskLen);
	if (StorageTmp->mtpGsLineContentSiMask == NULL) {
		config_perror("invalid specification for mtpGsLineContentSiMask");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentComment, &StorageTmp->mtpGsLineContentCommentLen);
	if (StorageTmp->mtpGsLineContentComment == NULL) {
		config_perror("invalid specification for mtpGsLineContentComment");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentRowStatus, &tmpsize);
	mtpGsLineContentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
}

/*
 * store_mtpGsLineContentTable(): store configuraiton file for mtpGsLineContentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineContentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsLineContentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsLineContentTable", "storing data...  "));
	refresh_mtpGsLineContentTable();
	(void) tmpsize;
	for (hcindex = mtpGsLineContentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineContentTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsLineContentTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContentId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &StorageTmp->mtpGsLineContentDesignatedDPCFirstLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &StorageTmp->mtpGsLineContentDesignatedDPCLastLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpGsLineContentSiMask, &StorageTmp->mtpGsLineContentSiMaskLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentComment, &StorageTmp->mtpGsLineContentCommentLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSpProfileTable_data *mtpSpProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSpProfileTable table.
 * Creates a new mtpSpProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSpProfileTable_data *
mtpSpProfileTable_create(void)
{
	struct mtpSpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);

	DEBUGMSGTL(("mtpSpProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpProfileTimerT1R = 80;
		StorageNew->mtpSpProfileTimerT18I = 60000;
		StorageNew->mtpSpProfileTimerT20I = 6000;
		StorageNew->mtpSpProfileTimerT20A = 10000;
		StorageNew->mtpSpProfileTimerT21A = 10000;
		StorageNew->mtpSpProfileTimerT22A = 60000;
		StorageNew->mtpSpProfileTimerT23A = 60000;
		StorageNew->mtpSpProfileTimerT24A = 60000;
		StorageNew->mtpSpProfileTimerT26A = 1350;
		StorageNew->mtpSpProfileTimerT27A = 300;
		StorageNew->mtpSpProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSpProfileTable_data *mtpSpProfileTable_duplicate(struct mtpSpProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSpProfileTable_data *
mtpSpProfileTable_duplicate(struct mtpSpProfileTable_data *thedata)
{
	struct mtpSpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);

	DEBUGMSGTL(("mtpSpProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSpProfileTable_destroy(struct mtpSpProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSpProfileTable_destroy(struct mtpSpProfileTable_data **thedata)
{
	struct mtpSpProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSpProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSpProfileId);
		StorageDel->mtpSpProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSpProfileName);
		StorageDel->mtpSpProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpSpRsDefault);
		StorageDel->mtpSpRsDefaultLen = 0;
		SNMP_FREE(StorageDel->mtpSpLsDefault);
		StorageDel->mtpSpLsDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpProfileTable_add(struct mtpSpProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSpProfileTable table data set.
 * Adds a table row structure to the mtpSpProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSpProfileTable_add(struct mtpSpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpProfileId, thedata->mtpSpProfileIdLen);
	header_complex_add_data(&mtpSpProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpProfileTable_del(struct mtpSpProfileTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpSpProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSpProfileTable_del(struct mtpSpProfileTable_data *thedata)
{
	struct mtpSpProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSpProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSpProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSpProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSpProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSpProfileTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSpProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSpProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpProfileTable_data *StorageTmp = mtpSpProfileTable_create();

	DEBUGMSGTL(("mtpSpProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileId, &StorageTmp->mtpSpProfileIdLen);
	if (StorageTmp->mtpSpProfileId == NULL) {
		config_perror("invalid specification for mtpSpProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT1R, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT12, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT13, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT14, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT18I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT19I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT20I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT21I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT22I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT23I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT20A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT21A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT22A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT23A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT24A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT26A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT27A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT2T, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
	if (StorageTmp->mtpSpProfileName == NULL) {
		config_perror("invalid specification for mtpSpProfileName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpRsDefault, &StorageTmp->mtpSpRsDefaultLen);
	if (StorageTmp->mtpSpRsDefault == NULL) {
		config_perror("invalid specification for mtpSpRsDefault");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpLsDefault, &StorageTmp->mtpSpLsDefaultLen);
	if (StorageTmp->mtpSpLsDefault == NULL) {
		config_perror("invalid specification for mtpSpLsDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileRowStatus, &tmpsize);
	mtpSpProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
}

/*
 * store_mtpSpProfileTable(): store configuraiton file for mtpSpProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpProfileTable", "storing data...  "));
	refresh_mtpSpProfileTable();
	(void) tmpsize;
	for (hcindex = mtpSpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSpProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileId, &StorageTmp->mtpSpProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT1R, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT11, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT12, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT13, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT14, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT15, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT16, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT18I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT19I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT20I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT21I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT22I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT23I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT20A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT21A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT22A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT23A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT24A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT26A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT27A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT1T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT2T, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpRsDefault, &StorageTmp->mtpSpRsDefaultLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpLsDefault, &StorageTmp->mtpSpLsDefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSpTable_data *mtpSpTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSpTable table.
 * Creates a new mtpSpTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSpTable_data *
mtpSpTable_create(void)
{
	struct mtpSpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpTable_data);

	DEBUGMSGTL(("mtpSpTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpOperationalState = MTPSPOPERATIONALSTATE_DISABLED;
		if (memdup((u_char **) &StorageNew->mtpSpProceduralStatus, (u_char *) "\x03\x01", 2) == SNMPERR_SUCCESS) {
			StorageNew->mtpSpProceduralStatusLen = 2;
		}
		StorageNew->mtpSpMtpT31A = 6000;
		StorageNew->mtpSpMtpT32A = 6000;
		StorageNew->mtpSpMtpT33A = 36000;
		StorageNew->mtpSpMtpT34A = 6000;
		StorageNew->mtpSpMtpT20A = 10000;
		StorageNew->mtpSpMtpT21A = 10000;
		StorageNew->mtpSpRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSpTable_data *mtpSpTable_duplicate(struct mtpSpTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSpTable_data *
mtpSpTable_duplicate(struct mtpSpTable_data *thedata)
{
	struct mtpSpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpTable_data);

	DEBUGMSGTL(("mtpSpTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSpTable_destroy(struct mtpSpTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSpTable_destroy(struct mtpSpTable_data **thedata)
{
	struct mtpSpTable_data *StorageDel;

	DEBUGMSGTL(("mtpSpTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSpPointCode);
		StorageDel->mtpSpPointCodeLen = 0;
		SNMP_FREE(StorageDel->mtpSpProceduralStatus);
		StorageDel->mtpSpProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSpAvailabilityStatus);
		StorageDel->mtpSpAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSpVersion);
		StorageDel->mtpSpVersionLen = 0;
		SNMP_FREE(StorageDel->mtpSpName);
		StorageDel->mtpSpNameLen = 0;
		SNMP_FREE(StorageDel->mtpSpProfilePointer);
		StorageDel->mtpSpProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSpNaPointer);
		StorageDel->mtpSpNaPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSpFlags);
		StorageDel->mtpSpFlagsLen = 0;
		SNMP_FREE(StorageDel->mtpSpUsers);
		StorageDel->mtpSpUsersLen = 0;
		SNMP_FREE(StorageDel->mtpSpAlarmStatus);
		StorageDel->mtpSpAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpTable_add(struct mtpSpTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSpTable table data set.
 * Adds a table row structure to the mtpSpTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSpTable_add(struct mtpSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	header_complex_add_data(&mtpSpTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpTable_del(struct mtpSpTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpSpTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSpTable_del(struct mtpSpTable_data *thedata)
{
	struct mtpSpTable_data *StorageDel;

	DEBUGMSGTL(("mtpSpTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSpTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSpTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSpTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSpTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSpTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpTable_data *StorageTmp = mtpSpTable_create();

	DEBUGMSGTL(("mtpSpTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpPointCode, &StorageTmp->mtpSpPointCodeLen);
	if (StorageTmp->mtpSpPointCode == NULL) {
		config_perror("invalid specification for mtpSpPointCode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
	if (StorageTmp->mtpSpProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSpProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
	if (StorageTmp->mtpSpAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSpAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpVersion, &StorageTmp->mtpSpVersionLen);
	if (StorageTmp->mtpSpVersion == NULL) {
		config_perror("invalid specification for mtpSpVersion");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpNetworkIndicator, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
	if (StorageTmp->mtpSpName == NULL) {
		config_perror("invalid specification for mtpSpName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT10, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT12, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT13, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT14, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT17, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT19A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT31A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT32A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT33A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT34A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT18I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT19I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT20I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT21I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT22I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT23I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT20A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT21A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT24I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT2T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1S, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfilePointer, &StorageTmp->mtpSpProfilePointerLen);
	if (StorageTmp->mtpSpProfilePointer == NULL) {
		config_perror("invalid specification for mtpSpProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpNaPointer, &StorageTmp->mtpSpNaPointerLen);
	if (StorageTmp->mtpSpNaPointer == NULL) {
		config_perror("invalid specification for mtpSpNaPointer");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpFlags, &StorageTmp->mtpSpFlagsLen);
	if (StorageTmp->mtpSpFlags == NULL) {
		config_perror("invalid specification for mtpSpFlags");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpUsers, &StorageTmp->mtpSpUsersLen);
	if (StorageTmp->mtpSpUsers == NULL) {
		config_perror("invalid specification for mtpSpUsers");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpAlarmStatus, &StorageTmp->mtpSpAlarmStatusLen);
	if (StorageTmp->mtpSpAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSpAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpRowStatus, &tmpsize);
	mtpSpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
}

/*
 * store_mtpSpTable(): store configuraiton file for mtpSpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpTable", "storing data...  "));
	refresh_mtpSpTable();
	(void) tmpsize;
	for (hcindex = mtpSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSpTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpPointCode, &StorageTmp->mtpSpPointCodeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpVersion, &StorageTmp->mtpSpVersionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpNetworkIndicator, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT7, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT8, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT10, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT11, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT12, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT13, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT14, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT15, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT16, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT17, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT19A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT31A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT32A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT33A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT34A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT18I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT19I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT20I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT21I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT22I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT23I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT20A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT21A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT24I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT2T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1S, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfilePointer, &StorageTmp->mtpSpProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpNaPointer, &StorageTmp->mtpSpNaPointerLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpFlags, &StorageTmp->mtpSpFlagsLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpUsers, &StorageTmp->mtpSpUsersLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpAlarmStatus, &StorageTmp->mtpSpAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpL3Table_data *mtpL3Table_create(void)
 * @brief create a fresh data structure representing a new row in the mtpL3Table table.
 * Creates a new mtpL3Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpL3Table_data *
mtpL3Table_create(void)
{
	struct mtpL3Table_data *StorageNew = SNMP_MALLOC_STRUCT(mtpL3Table_data);

	DEBUGMSGTL(("mtpL3Table", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpL3AdministrativeState = MTPL3ADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpL3OperationalState = MTPL3OPERATIONALSTATE_DISABLED;
		StorageNew->mtpL3UsageState = MTPL3USAGESTATE_IDLE;
		if (memdup((u_char **) &StorageNew->mtpL3ProceduralStatus, (u_char *) "\x03\x01", 2) == SNMPERR_SUCCESS) {
			StorageNew->mtpL3ProceduralStatusLen = 2;
		}
		if ((StorageNew->mtpL3AsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpL3AsaProfilePointerLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpL3RowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpL3Table_data *mtpL3Table_duplicate(struct mtpL3Table_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpL3Table_data *
mtpL3Table_duplicate(struct mtpL3Table_data *thedata)
{
	struct mtpL3Table_data *StorageNew = SNMP_MALLOC_STRUCT(mtpL3Table_data);

	DEBUGMSGTL(("mtpL3Table", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpL3Table_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpL3Table_destroy(struct mtpL3Table_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpL3Table_destroy(struct mtpL3Table_data **thedata)
{
	struct mtpL3Table_data *StorageDel;

	DEBUGMSGTL(("mtpL3Table", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpL3Id);
		StorageDel->mtpL3IdLen = 0;
		SNMP_FREE(StorageDel->mtpL3ProceduralStatus);
		StorageDel->mtpL3ProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpL3AsaProfilePointer);
		StorageDel->mtpL3AsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpL3Name);
		StorageDel->mtpL3NameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpL3Table_add(struct mtpL3Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpL3Table table data set.
 * Adds a table row structure to the mtpL3Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpL3Table_add(struct mtpL3Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpL3Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpL3Id */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpL3Id, thedata->mtpL3IdLen);
	header_complex_add_data(&mtpL3TableStorage, vars, thedata);
	DEBUGMSGTL(("mtpL3Table", "registered an entry\n"));
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpL3Table_del(struct mtpL3Table_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpL3Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpL3Table_del(struct mtpL3Table_data *thedata)
{
	struct mtpL3Table_data *StorageDel;

	DEBUGMSGTL(("mtpL3Table", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpL3TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpL3TableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpL3Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpL3Table entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpL3Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpL3Table(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpL3Table_data *StorageTmp = mtpL3Table_create();

	DEBUGMSGTL(("mtpL3Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
	if (StorageTmp->mtpL3Id == NULL) {
		config_perror("invalid specification for mtpL3Id");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3AdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3OperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3UsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpL3ProceduralStatus, &StorageTmp->mtpL3ProceduralStatusLen);
	if (StorageTmp->mtpL3ProceduralStatus == NULL) {
		config_perror("invalid specification for mtpL3ProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpL3AsaProfilePointer, &StorageTmp->mtpL3AsaProfilePointerLen);
	if (StorageTmp->mtpL3AsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpL3AsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Name, &StorageTmp->mtpL3NameLen);
	if (StorageTmp->mtpL3Name == NULL) {
		config_perror("invalid specification for mtpL3Name");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3RowStatus, &tmpsize);
	mtpL3Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
}

/*
 * store_mtpL3Table(): store configuraiton file for mtpL3Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpL3Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpL3Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpL3Table", "storing data...  "));
	refresh_mtpL3Table();
	(void) tmpsize;
	for (hcindex = mtpL3TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL3Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpL3Table ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3AdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3OperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3UsageState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpL3ProceduralStatus, &StorageTmp->mtpL3ProceduralStatusLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpL3AsaProfilePointer, &StorageTmp->mtpL3AsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Name, &StorageTmp->mtpL3NameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3RowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRsProfileTable_data *mtpRsProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRsProfileTable table.
 * Creates a new mtpRsProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRsProfileTable_data *
mtpRsProfileTable_create(void)
{
	struct mtpRsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data);

	DEBUGMSGTL(("mtpRsProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpRsProfileTimerT8 = 100;
		StorageNew->mtpRsProfileTimerT11 = 6000;
		StorageNew->mtpRsProfileTimerT15 = 250;
		StorageNew->mtpRsProfileTimerT16 = 175;
		StorageNew->mtpRsProfileTimerT18A = 1200;
		StorageNew->mtpRsProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpRsProfileTable_data *mtpRsProfileTable_duplicate(struct mtpRsProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRsProfileTable_data *
mtpRsProfileTable_duplicate(struct mtpRsProfileTable_data *thedata)
{
	struct mtpRsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data);

	DEBUGMSGTL(("mtpRsProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRsProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRsProfileTable_destroy(struct mtpRsProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRsProfileTable_destroy(struct mtpRsProfileTable_data **thedata)
{
	struct mtpRsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpRsProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRsProfileId);
		StorageDel->mtpRsProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfileName);
		StorageDel->mtpRsProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfileRtDefault);
		StorageDel->mtpRsProfileRtDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsProfileTable_add(struct mtpRsProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRsProfileTable table data set.
 * Adds a table row structure to the mtpRsProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRsProfileTable_add(struct mtpRsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpRsProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRsProfileId, thedata->mtpRsProfileIdLen);
	header_complex_add_data(&mtpRsProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsProfileTable_del(struct mtpRsProfileTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpRsProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRsProfileTable_del(struct mtpRsProfileTable_data *thedata)
{
	struct mtpRsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpRsProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRsProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRsProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRsProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRsProfileTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRsProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRsProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsProfileTable_data *StorageTmp = mtpRsProfileTable_create();

	DEBUGMSGTL(("mtpRsProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileId, &StorageTmp->mtpRsProfileIdLen);
	if (StorageTmp->mtpRsProfileId == NULL) {
		config_perror("invalid specification for mtpRsProfileId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileName, &StorageTmp->mtpRsProfileNameLen);
	if (StorageTmp->mtpRsProfileName == NULL) {
		config_perror("invalid specification for mtpRsProfileName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT18A, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileRtDefault, &StorageTmp->mtpRsProfileRtDefaultLen);
	if (StorageTmp->mtpRsProfileRtDefault == NULL) {
		config_perror("invalid specification for mtpRsProfileRtDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileRowStatus, &tmpsize);
	mtpRsProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
}

/*
 * store_mtpRsProfileTable(): store configuraiton file for mtpRsProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsProfileTable", "storing data...  "));
	refresh_mtpRsProfileTable();
	(void) tmpsize;
	for (hcindex = mtpRsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRsProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileId, &StorageTmp->mtpRsProfileIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileName, &StorageTmp->mtpRsProfileNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT11, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT15, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT16, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT18A, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileRtDefault, &StorageTmp->mtpRsProfileRtDefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRsTable_data *mtpRsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRsTable table.
 * Creates a new mtpRsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRsTable_data *
mtpRsTable_create(void)
{
	struct mtpRsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsTable_data);

	DEBUGMSGTL(("mtpRsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpRsAdministrativeState = MTPRSADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpRsOperationalState = MTPRSOPERATIONALSTATE_DISABLED;
		if ((StorageNew->mtpRsAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpRsAsaProfilePointerLen = sizeof(zeroDotZero_oid);
		}
		if ((StorageNew->mtpRsLoadsharingObject = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpRsLoadsharingObjectLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpRsRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpRsTable_data *mtpRsTable_duplicate(struct mtpRsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRsTable_data *
mtpRsTable_duplicate(struct mtpRsTable_data *thedata)
{
	struct mtpRsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsTable_data);

	DEBUGMSGTL(("mtpRsTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRsTable_destroy(struct mtpRsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRsTable_destroy(struct mtpRsTable_data **thedata)
{
	struct mtpRsTable_data *StorageDel;

	DEBUGMSGTL(("mtpRsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRsDest);
		StorageDel->mtpRsDestLen = 0;
		SNMP_FREE(StorageDel->mtpRsFlags);
		StorageDel->mtpRsFlagsLen = 0;
		SNMP_FREE(StorageDel->mtpRsAsaProfilePointer);
		StorageDel->mtpRsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpRsLoadsharingInformation);
		StorageDel->mtpRsLoadsharingInformationLen = 0;
		SNMP_FREE(StorageDel->mtpRsLoadsharingObject);
		StorageDel->mtpRsLoadsharingObjectLen = 0;
		SNMP_FREE(StorageDel->mtpRsRemoteExchangeLabel);
		StorageDel->mtpRsRemoteExchangeLabelLen = 0;
		SNMP_FREE(StorageDel->mtpRsName);
		StorageDel->mtpRsNameLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfile);
		StorageDel->mtpRsProfileLen = 0;
		SNMP_FREE(StorageDel->mtpRsAlarmStatus);
		StorageDel->mtpRsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsTable_add(struct mtpRsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRsTable table data set.
 * Adds a table row structure to the mtpRsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRsTable_add(struct mtpRsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	header_complex_add_data(&mtpRsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsTable_del(struct mtpRsTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpRsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRsTable_del(struct mtpRsTable_data *thedata)
{
	struct mtpRsTable_data *StorageDel;

	DEBUGMSGTL(("mtpRsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRsTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsTable_data *StorageTmp = mtpRsTable_create();

	DEBUGMSGTL(("mtpRsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsDest, &StorageTmp->mtpRsDestLen);
	if (StorageTmp->mtpRsDest == NULL) {
		config_perror("invalid specification for mtpRsDest");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRsFlags, &StorageTmp->mtpRsFlagsLen);
	if (StorageTmp->mtpRsFlags == NULL) {
		config_perror("invalid specification for mtpRsFlags");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsAsaProfilePointer, &StorageTmp->mtpRsAsaProfilePointerLen);
	if (StorageTmp->mtpRsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpRsAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestedState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestionLevel, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
	if (StorageTmp->mtpRsLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingInformation");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
	if (StorageTmp->mtpRsLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingObject");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
	if (StorageTmp->mtpRsRemoteExchangeLabel == NULL) {
		config_perror("invalid specification for mtpRsRemoteExchangeLabel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
	if (StorageTmp->mtpRsName == NULL) {
		config_perror("invalid specification for mtpRsName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfile, &StorageTmp->mtpRsProfileLen);
	if (StorageTmp->mtpRsProfile == NULL) {
		config_perror("invalid specification for mtpRsProfile");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRsAlarmStatus, &StorageTmp->mtpRsAlarmStatusLen);
	if (StorageTmp->mtpRsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpRsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsRowStatus, &tmpsize);
	mtpRsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
}

/*
 * store_mtpRsTable(): store configuraiton file for mtpRsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsTable", "storing data...  "));
	refresh_mtpRsTable();
	(void) tmpsize;
	for (hcindex = mtpRsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsDest, &StorageTmp->mtpRsDestLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRsFlags, &StorageTmp->mtpRsFlagsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsAsaProfilePointer, &StorageTmp->mtpRsAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestedState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestionLevel, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfile, &StorageTmp->mtpRsProfileLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRsAlarmStatus, &StorageTmp->mtpRsAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRtProfileTable_data *mtpRtProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRtProfileTable table.
 * Creates a new mtpRtProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRtProfileTable_data *
mtpRtProfileTable_create(void)
{
	struct mtpRtProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data);

	DEBUGMSGTL(("mtpRtProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpRtProfileTimerT6 = 80;
		StorageNew->mtpRtProfileTimerT10 = 4500;
		StorageNew->mtpRtProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpRtProfileTable_data *mtpRtProfileTable_duplicate(struct mtpRtProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRtProfileTable_data *
mtpRtProfileTable_duplicate(struct mtpRtProfileTable_data *thedata)
{
	struct mtpRtProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data);

	DEBUGMSGTL(("mtpRtProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRtProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRtProfileTable_destroy(struct mtpRtProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRtProfileTable_destroy(struct mtpRtProfileTable_data **thedata)
{
	struct mtpRtProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtProfileId);
		StorageDel->mtpRtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtProfileTable_add(struct mtpRtProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRtProfileTable table data set.
 * Adds a table row structure to the mtpRtProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRtProfileTable_add(struct mtpRtProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpRtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRtProfileId, thedata->mtpRtProfileIdLen);
	header_complex_add_data(&mtpRtProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtProfileTable_del(struct mtpRtProfileTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpRtProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRtProfileTable_del(struct mtpRtProfileTable_data *thedata)
{
	struct mtpRtProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRtProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRtProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRtProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRtProfileTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRtProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRtProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtProfileTable_data *StorageTmp = mtpRtProfileTable_create();

	DEBUGMSGTL(("mtpRtProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtProfileId, &StorageTmp->mtpRtProfileIdLen);
	if (StorageTmp->mtpRtProfileId == NULL) {
		config_perror("invalid specification for mtpRtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT10, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileRowStatus, &tmpsize);
	mtpRtProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
}

/*
 * store_mtpRtProfileTable(): store configuraiton file for mtpRtProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtProfileTable", "storing data...  "));
	refresh_mtpRtProfileTable();
	(void) tmpsize;
	for (hcindex = mtpRtProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtProfileId, &StorageTmp->mtpRtProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT10, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRtTable_data *mtpRtTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRtTable table.
 * Creates a new mtpRtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRtTable_data *
mtpRtTable_create(void)
{
	struct mtpRtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtTable_data);

	DEBUGMSGTL(("mtpRtTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpRtAdministrativeState = MTPRTADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpRtOperationalState = MTPRTOPERATIONALSTATE_DISABLED;
		if ((StorageNew->mtpRtLoadsharingObject = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpRtLoadsharingObjectLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpRtUsageState = MTPRTUSAGESTATE_IDLE;
		StorageNew->mtpRtRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpRtTable_data *mtpRtTable_duplicate(struct mtpRtTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRtTable_data *
mtpRtTable_duplicate(struct mtpRtTable_data *thedata)
{
	struct mtpRtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtTable_data);

	DEBUGMSGTL(("mtpRtTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRtTable_destroy(struct mtpRtTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRtTable_destroy(struct mtpRtTable_data **thedata)
{
	struct mtpRtTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtLsPointer);
		StorageDel->mtpRtLsPointerLen = 0;
		SNMP_FREE(StorageDel->mtpRtAvailabilityStatus);
		StorageDel->mtpRtAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpRtLoadsharingInformation);
		StorageDel->mtpRtLoadsharingInformationLen = 0;
		SNMP_FREE(StorageDel->mtpRtLoadsharingObject);
		StorageDel->mtpRtLoadsharingObjectLen = 0;
		SNMP_FREE(StorageDel->mtpRtName);
		StorageDel->mtpRtNameLen = 0;
		SNMP_FREE(StorageDel->mtpRtSlsList);
		StorageDel->mtpRtSlsListLen = 0;
		SNMP_FREE(StorageDel->mtpRtProfile);
		StorageDel->mtpRtProfileLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtTable_add(struct mtpRtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRtTable table data set.
 * Adds a table row structure to the mtpRtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRtTable_add(struct mtpRtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtId, sizeof(thedata->mtpRtId));
	header_complex_add_data(&mtpRtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtTable_del(struct mtpRtTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpRtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRtTable_del(struct mtpRtTable_data *thedata)
{
	struct mtpRtTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRtTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRtTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtTable_data *StorageTmp = mtpRtTable_create();

	DEBUGMSGTL(("mtpRtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLsPointer, &StorageTmp->mtpRtLsPointerLen);
	if (StorageTmp->mtpRtLsPointer == NULL) {
		config_perror("invalid specification for mtpRtLsPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
	if (StorageTmp->mtpRtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpRtAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFixedPriority, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFlexiblePriority, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtPriorityMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
	if (StorageTmp->mtpRtLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingInformation");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
	if (StorageTmp->mtpRtLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingObject");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
	if (StorageTmp->mtpRtName == NULL) {
		config_perror("invalid specification for mtpRtName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
	if (StorageTmp->mtpRtSlsList == NULL) {
		config_perror("invalid specification for mtpRtSlsList");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtUsageState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtRlSlot, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtProfile, &StorageTmp->mtpRtProfileLen);
	if (StorageTmp->mtpRtProfile == NULL) {
		config_perror("invalid specification for mtpRtProfile");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtRowStatus, &tmpsize);
	mtpRtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
}

/*
 * store_mtpRtTable(): store configuraiton file for mtpRtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtTable", "storing data...  "));
	refresh_mtpRtTable();
	(void) tmpsize;
	for (hcindex = mtpRtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLsPointer, &StorageTmp->mtpRtLsPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFixedPriority, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFlexiblePriority, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtPriorityMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtRlSlot, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtProfile, &StorageTmp->mtpRtProfileLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRtLsaTable_data *mtpRtLsaTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRtLsaTable table.
 * Creates a new mtpRtLsaTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRtLsaTable_data *
mtpRtLsaTable_create(void)
{
	struct mtpRtLsaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtLsaTable_data);

	DEBUGMSGTL(("mtpRtLsaTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpRtLsaTable_data *mtpRtLsaTable_duplicate(struct mtpRtLsaTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRtLsaTable_data *
mtpRtLsaTable_duplicate(struct mtpRtLsaTable_data *thedata)
{
	struct mtpRtLsaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtLsaTable_data);

	DEBUGMSGTL(("mtpRtLsaTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRtLsaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRtLsaTable_destroy(struct mtpRtLsaTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRtLsaTable_destroy(struct mtpRtLsaTable_data **thedata)
{
	struct mtpRtLsaTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtLsaTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtLsaAlternativeSlCodeList);
		StorageDel->mtpRtLsaAlternativeSlCodeListLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtLsaTable_add(struct mtpRtLsaTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRtLsaTable table data set.
 * Adds a table row structure to the mtpRtLsaTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRtLsaTable_add(struct mtpRtLsaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtLsaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtId, sizeof(thedata->mtpRtId));
	/* mtpRtLsaSlsCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtLsaSlsCode, sizeof(thedata->mtpRtLsaSlsCode));
	header_complex_add_data(&mtpRtLsaTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtLsaTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtLsaTable_del(struct mtpRtLsaTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpRtLsaTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRtLsaTable_del(struct mtpRtLsaTable_data *thedata)
{
	struct mtpRtLsaTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtLsaTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRtLsaTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRtLsaTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRtLsaTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRtLsaTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRtLsaTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRtLsaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtLsaTable_data *StorageTmp = mtpRtLsaTable_create();

	DEBUGMSGTL(("mtpRtLsaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtLsaSlsCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtLsaNormalSlCode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &StorageTmp->mtpRtLsaAlternativeSlCodeListLen);
	if (StorageTmp->mtpRtLsaAlternativeSlCodeList == NULL) {
		config_perror("invalid specification for mtpRtLsaAlternativeSlCodeList");
		return;
	}
	mtpRtLsaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
}

/*
 * store_mtpRtLsaTable(): store configuraiton file for mtpRtLsaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtLsaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtLsaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtLsaTable", "storing data...  "));
	refresh_mtpRtLsaTable();
	(void) tmpsize;
	for (hcindex = mtpRtLsaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtLsaTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtLsaTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtLsaSlsCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtLsaNormalSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &StorageTmp->mtpRtLsaAlternativeSlCodeListLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpLsProfileTable_data *mtpLsProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpLsProfileTable table.
 * Creates a new mtpLsProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpLsProfileTable_data *
mtpLsProfileTable_create(void)
{
	struct mtpLsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data);

	DEBUGMSGTL(("mtpLsProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpLsProfileTimerT8 = 100;
		StorageNew->mtpLsProfileTimerT10 = 4500;
		StorageNew->mtpLsProfileTimerT7 = 150;
		StorageNew->mtpLsProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpLsProfileTable_data *mtpLsProfileTable_duplicate(struct mtpLsProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpLsProfileTable_data *
mtpLsProfileTable_duplicate(struct mtpLsProfileTable_data *thedata)
{
	struct mtpLsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data);

	DEBUGMSGTL(("mtpLsProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpLsProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpLsProfileTable_destroy(struct mtpLsProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpLsProfileTable_destroy(struct mtpLsProfileTable_data **thedata)
{
	struct mtpLsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpLsProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpLsProfileId);
		StorageDel->mtpLsProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfileName);
		StorageDel->mtpLsProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfileSlDefault);
		StorageDel->mtpLsProfileSlDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsProfileTable_add(struct mtpLsProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpLsProfileTable table data set.
 * Adds a table row structure to the mtpLsProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpLsProfileTable_add(struct mtpLsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpLsProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpLsProfileId, thedata->mtpLsProfileIdLen);
	header_complex_add_data(&mtpLsProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsProfileTable_del(struct mtpLsProfileTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpLsProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpLsProfileTable_del(struct mtpLsProfileTable_data *thedata)
{
	struct mtpLsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpLsProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpLsProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpLsProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpLsProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpLsProfileTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpLsProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpLsProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpLsProfileTable_data *StorageTmp = mtpLsProfileTable_create();

	DEBUGMSGTL(("mtpLsProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileId, &StorageTmp->mtpLsProfileIdLen);
	if (StorageTmp->mtpLsProfileId == NULL) {
		config_perror("invalid specification for mtpLsProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT10, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT19I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT21I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT25A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT28A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT29A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT30A, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileName, &StorageTmp->mtpLsProfileNameLen);
	if (StorageTmp->mtpLsProfileName == NULL) {
		config_perror("invalid specification for mtpLsProfileName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileSlDefault, &StorageTmp->mtpLsProfileSlDefaultLen);
	if (StorageTmp->mtpLsProfileSlDefault == NULL) {
		config_perror("invalid specification for mtpLsProfileSlDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileRowStatus, &tmpsize);
	mtpLsProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
}

/*
 * store_mtpLsProfileTable(): store configuraiton file for mtpLsProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpLsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsProfileTable", "storing data...  "));
	refresh_mtpLsProfileTable();
	(void) tmpsize;
	for (hcindex = mtpLsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpLsProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileId, &StorageTmp->mtpLsProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT10, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT19I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT21I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT25A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT28A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT29A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT30A, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileName, &StorageTmp->mtpLsProfileNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileSlDefault, &StorageTmp->mtpLsProfileSlDefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpLsTable_data *mtpLsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpLsTable table.
 * Creates a new mtpLsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpLsTable_data *
mtpLsTable_create(void)
{
	struct mtpLsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsTable_data);

	DEBUGMSGTL(("mtpLsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpLsUsageState = MTPLSUSAGESTATE_IDLE;
		StorageNew->mtpLsOperationalState = MTPLSOPERATIONALSTATE_DISABLED;
		StorageNew->mtpLsPeriodicLinkTestFlag = MTPLSPERIODICLINKTESTFLAG_ON;
		StorageNew->mtpLsPeriodicLinkTestFail = TV_TRUE;
		StorageNew->mtpLsAdministrativeState = MTPLSADMINISTRATIVESTATE_LOCKED;
		if ((StorageNew->mtpLsAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpLsAsaProfilePointerLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpLsRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpLsTable_data *mtpLsTable_duplicate(struct mtpLsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpLsTable_data *
mtpLsTable_duplicate(struct mtpLsTable_data *thedata)
{
	struct mtpLsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsTable_data);

	DEBUGMSGTL(("mtpLsTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpLsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpLsTable_destroy(struct mtpLsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpLsTable_destroy(struct mtpLsTable_data **thedata)
{
	struct mtpLsTable_data *StorageDel;

	DEBUGMSGTL(("mtpLsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpLsAdjPc);
		StorageDel->mtpLsAdjPcLen = 0;
		SNMP_FREE(StorageDel->mtpLsRsId);
		StorageDel->mtpLsRsIdLen = 0;
		SNMP_FREE(StorageDel->mtpLsAvailabilityStatus);
		StorageDel->mtpLsAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpLsInLsLoadShareAlgorithm);
		StorageDel->mtpLsInLsLoadShareAlgorithmLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfilePointer);
		StorageDel->mtpLsProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpLsName);
		StorageDel->mtpLsNameLen = 0;
		SNMP_FREE(StorageDel->mtpLsAsaProfilePointer);
		StorageDel->mtpLsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpLsAlarmStatus);
		StorageDel->mtpLsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsTable_add(struct mtpLsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpLsTable table data set.
 * Adds a table row structure to the mtpLsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpLsTable_add(struct mtpLsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	header_complex_add_data(&mtpLsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsTable_del(struct mtpLsTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpLsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpLsTable_del(struct mtpLsTable_data *thedata)
{
	struct mtpLsTable_data *StorageDel;

	DEBUGMSGTL(("mtpLsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpLsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpLsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpLsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpLsTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpLsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpLsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpLsTable_data *StorageTmp = mtpLsTable_create();

	DEBUGMSGTL(("mtpLsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
	if (StorageTmp->mtpLsAdjPc == NULL) {
		config_perror("invalid specification for mtpLsAdjPc");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsRsId, &StorageTmp->mtpLsRsIdLen);
	if (StorageTmp->mtpLsRsId == NULL) {
		config_perror("invalid specification for mtpLsRsId");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsMaxCapacity, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsCurrentCapacity, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsCongestionControlMethod, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
	if (StorageTmp->mtpLsAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpLsAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFail, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
	if (StorageTmp->mtpLsInLsLoadShareAlgorithm == NULL) {
		config_perror("invalid specification for mtpLsInLsLoadShareAlgorithm");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfilePointer, &StorageTmp->mtpLsProfilePointerLen);
	if (StorageTmp->mtpLsProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
	if (StorageTmp->mtpLsName == NULL) {
		config_perror("invalid specification for mtpLsName");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsAsaProfilePointer, &StorageTmp->mtpLsAsaProfilePointerLen);
	if (StorageTmp->mtpLsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLsAlarmStatus, &StorageTmp->mtpLsAlarmStatusLen);
	if (StorageTmp->mtpLsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpLsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsRowStatus, &tmpsize);
	mtpLsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
}

/*
 * store_mtpLsTable(): store configuraiton file for mtpLsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpLsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsTable", "storing data...  "));
	refresh_mtpLsTable();
	(void) tmpsize;
	for (hcindex = mtpLsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpLsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsRsId, &StorageTmp->mtpLsRsIdLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsMaxCapacity, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsCurrentCapacity, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsCongestionControlMethod, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFail, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfilePointer, &StorageTmp->mtpLsProfilePointerLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsAsaProfilePointer, &StorageTmp->mtpLsAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLsAlarmStatus, &StorageTmp->mtpLsAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlL3ProfileTable_data *mtpSlL3ProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlL3ProfileTable table.
 * Creates a new mtpSlL3ProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlL3ProfileTable_data *
mtpSlL3ProfileTable_create(void)
{
	struct mtpSlL3ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL3ProfileTable_data);

	DEBUGMSGTL(("mtpSlL3ProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlL3ProfileTimerT24I = 50;
		StorageNew->mtpSlL3ProfileTimerT20A = 10000;
		StorageNew->mtpSlL3ProfileTimerT21A = 10000;
		StorageNew->mtpSlL3ProfileTimerT22I = 27000;
		StorageNew->mtpSlL3ProfileTimerT23I = 27000;
		StorageNew->mtpSlL3ProfileTimerT31A = 6000;
		StorageNew->mtpSlL3ProfileTimerT32A = 6000;
		StorageNew->mtpSlL3ProfileTimerT33A = 36000;
		StorageNew->mtpSlL3ProfileTimerT34A = 6000;
		StorageNew->mtpSlL3ProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSlL3ProfileTable_data *mtpSlL3ProfileTable_duplicate(struct mtpSlL3ProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlL3ProfileTable_data *
mtpSlL3ProfileTable_duplicate(struct mtpSlL3ProfileTable_data *thedata)
{
	struct mtpSlL3ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL3ProfileTable_data);

	DEBUGMSGTL(("mtpSlL3ProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlL3ProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlL3ProfileTable_destroy(struct mtpSlL3ProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlL3ProfileTable_destroy(struct mtpSlL3ProfileTable_data **thedata)
{
	struct mtpSlL3ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlL3ProfileId);
		StorageDel->mtpSlL3ProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfileName);
		StorageDel->mtpSlL3ProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfileL2Default);
		StorageDel->mtpSlL3ProfileL2DefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL3ProfileTable_add(struct mtpSlL3ProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlL3ProfileTable table data set.
 * Adds a table row structure to the mtpSlL3ProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlL3ProfileTable_add(struct mtpSlL3ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSlL3ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSlL3ProfileId, thedata->mtpSlL3ProfileIdLen);
	header_complex_add_data(&mtpSlL3ProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL3ProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL3ProfileTable_del(struct mtpSlL3ProfileTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpSlL3ProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlL3ProfileTable_del(struct mtpSlL3ProfileTable_data *thedata)
{
	struct mtpSlL3ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlL3ProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlL3ProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlL3ProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlL3ProfileTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlL3ProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlL3ProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL3ProfileTable_data *StorageTmp = mtpSlL3ProfileTable_create();

	DEBUGMSGTL(("mtpSlL3ProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileId, &StorageTmp->mtpSlL3ProfileIdLen);
	if (StorageTmp->mtpSlL3ProfileId == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT17, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT24I, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileName, &StorageTmp->mtpSlL3ProfileNameLen);
	if (StorageTmp->mtpSlL3ProfileName == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT12, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT13, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT14, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT19A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT20A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT21A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT22I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT23I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT31A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT32A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT33A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT34A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT2T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1S, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileL2Default, &StorageTmp->mtpSlL3ProfileL2DefaultLen);
	if (StorageTmp->mtpSlL3ProfileL2Default == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileL2Default");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileRowStatus, &tmpsize);
	mtpSlL3ProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
}

/*
 * store_mtpSlL3ProfileTable(): store configuraiton file for mtpSlL3ProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL3ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL3ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "storing data...  "));
	refresh_mtpSlL3ProfileTable();
	(void) tmpsize;
	for (hcindex = mtpSlL3ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL3ProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlL3ProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileId, &StorageTmp->mtpSlL3ProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT17, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT24I, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileName, &StorageTmp->mtpSlL3ProfileNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT12, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT13, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT14, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT19A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT20A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT21A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT22I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT23I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT31A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT32A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT33A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT34A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT2T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1S, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileL2Default, &StorageTmp->mtpSlL3ProfileL2DefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlL2ProfileTable_data *mtpSlL2ProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlL2ProfileTable table.
 * Creates a new mtpSlL2ProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlL2ProfileTable_data *
mtpSlL2ProfileTable_create(void)
{
	struct mtpSlL2ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL2ProfileTable_data);

	DEBUGMSGTL(("mtpSlL2ProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlL2ProfileM = 5;
		StorageNew->mtpSlL2ProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSlL2ProfileTable_data *mtpSlL2ProfileTable_duplicate(struct mtpSlL2ProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlL2ProfileTable_data *
mtpSlL2ProfileTable_duplicate(struct mtpSlL2ProfileTable_data *thedata)
{
	struct mtpSlL2ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL2ProfileTable_data);

	DEBUGMSGTL(("mtpSlL2ProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlL2ProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlL2ProfileTable_destroy(struct mtpSlL2ProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlL2ProfileTable_destroy(struct mtpSlL2ProfileTable_data **thedata)
{
	struct mtpSlL2ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlL2ProfileId);
		StorageDel->mtpSlL2ProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSlL2ProfileName);
		StorageDel->mtpSlL2ProfileNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL2ProfileTable_add(struct mtpSlL2ProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlL2ProfileTable table data set.
 * Adds a table row structure to the mtpSlL2ProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlL2ProfileTable_add(struct mtpSlL2ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSlL2ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSlL2ProfileId, thedata->mtpSlL2ProfileIdLen);
	/* mtpSlL2ProfileTransmissionRate */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpSlL2ProfileTransmissionRate, sizeof(thedata->mtpSlL2ProfileTransmissionRate));
	header_complex_add_data(&mtpSlL2ProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL2ProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL2ProfileTable_del(struct mtpSlL2ProfileTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpSlL2ProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlL2ProfileTable_del(struct mtpSlL2ProfileTable_data *thedata)
{
	struct mtpSlL2ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlL2ProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlL2ProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlL2ProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlL2ProfileTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlL2ProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlL2ProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL2ProfileTable_data *StorageTmp = mtpSlL2ProfileTable_create();

	DEBUGMSGTL(("mtpSlL2ProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL2ProfileId, &StorageTmp->mtpSlL2ProfileIdLen);
	if (StorageTmp->mtpSlL2ProfileId == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTransmissionRate, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2L, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2H, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT4N, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT4E, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileCongestionCounting, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileLoopDelay, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL2ProfileName, &StorageTmp->mtpSlL2ProfileNameLen);
	if (StorageTmp->mtpSlL2ProfileName == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset3, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate3, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerTx, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerTy, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileMaxOctRetransN2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileM, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileRowStatus, &tmpsize);
	mtpSlL2ProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
}

/*
 * store_mtpSlL2ProfileTable(): store configuraiton file for mtpSlL2ProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL2ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL2ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "storing data...  "));
	refresh_mtpSlL2ProfileTable();
	(void) tmpsize;
	for (hcindex = mtpSlL2ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL2ProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlL2ProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL2ProfileId, &StorageTmp->mtpSlL2ProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2L, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2H, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT4N, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT4E, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileCongestionCounting, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileLoopDelay, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL2ProfileName, &StorageTmp->mtpSlL2ProfileNameLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset3, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate3, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerTx, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerTy, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileMaxOctRetransN2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileM, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlTable_data *mtpSlTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlTable table.
 * Creates a new mtpSlTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlTable_data *
mtpSlTable_create(void)
{
	struct mtpSlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlTable_data);

	DEBUGMSGTL(("mtpSlTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlAdministrativeState = MTPSLADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpSlOperationalState = MTPSLOPERATIONALSTATE_DISABLED;
		StorageNew->mtpSlUsageState = MTPSLUSAGESTATE_IDLE;
		if (memdup((u_char **) &StorageNew->mtpSlProceduralStatus, (u_char *) "\x03\x01", 2) == SNMPERR_SUCCESS) {
			StorageNew->mtpSlProceduralStatusLen = 2;
		}
		if ((StorageNew->mtpSlSignTermPointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpSlSignTermPointerLen = sizeof(zeroDotZero_oid);
		}
		if ((StorageNew->mtpSlSignDataLinkTpPointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpSlSignDataLinkTpPointerLen = sizeof(zeroDotZero_oid);
		}
		if ((StorageNew->mtpSlAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpSlAsaProfilePointerLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpSlRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSlTable_data *mtpSlTable_duplicate(struct mtpSlTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlTable_data *
mtpSlTable_duplicate(struct mtpSlTable_data *thedata)
{
	struct mtpSlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlTable_data);

	DEBUGMSGTL(("mtpSlTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlTable_destroy(struct mtpSlTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlTable_destroy(struct mtpSlTable_data **thedata)
{
	struct mtpSlTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSlsCodeCurrentList);
		StorageDel->mtpSlSlsCodeCurrentListLen = 0;
		SNMP_FREE(StorageDel->mtpSlLinkTpStatus);
		StorageDel->mtpSlLinkTpStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSlProceduralStatus);
		StorageDel->mtpSlProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSlMtpL2ProtocolProfilePointer);
		StorageDel->mtpSlMtpL2ProtocolProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlSignTermPointer);
		StorageDel->mtpSlSignTermPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlSignDataLinkTpPointer);
		StorageDel->mtpSlSignDataLinkTpPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlAsaProfilePointer);
		StorageDel->mtpSlAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlName);
		StorageDel->mtpSlNameLen = 0;
		SNMP_FREE(StorageDel->mtpSlSlsCodeNormalList);
		StorageDel->mtpSlSlsCodeNormalListLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfilePointer);
		StorageDel->mtpSlL3ProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlAlarmStatus);
		StorageDel->mtpSlAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlTable_add(struct mtpSlTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlTable table data set.
 * Adds a table row structure to the mtpSlTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlTable_add(struct mtpSlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	header_complex_add_data(&mtpSlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlTable_del(struct mtpSlTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpSlTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlTable_del(struct mtpSlTable_data *thedata)
{
	struct mtpSlTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlTable_data *StorageTmp = mtpSlTable_create();

	DEBUGMSGTL(("mtpSlTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
	if (StorageTmp->mtpSlSlsCodeCurrentList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeCurrentList");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlMaxCapacitySL, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCurrentCapacitySL, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlLinkTpStatus, &StorageTmp->mtpSlLinkTpStatusLen);
	if (StorageTmp->mtpSlLinkTpStatus == NULL) {
		config_perror("invalid specification for mtpSlLinkTpStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlUsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
	if (StorageTmp->mtpSlProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSlProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlMtpL2ProtocolProfilePointer, &StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen);
	if (StorageTmp->mtpSlMtpL2ProtocolProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlMtpL2ProtocolProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSignTermPointer, &StorageTmp->mtpSlSignTermPointerLen);
	if (StorageTmp->mtpSlSignTermPointer == NULL) {
		config_perror("invalid specification for mtpSlSignTermPointer");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSignDataLinkTpPointer, &StorageTmp->mtpSlSignDataLinkTpPointerLen);
	if (StorageTmp->mtpSlSignDataLinkTpPointer == NULL) {
		config_perror("invalid specification for mtpSlSignDataLinkTpPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalInhibit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalUninhibit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlReplaceSt, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlAsaProfilePointer, &StorageTmp->mtpSlAsaProfilePointerLen);
	if (StorageTmp->mtpSlAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlCongestionLevel, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlList, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlTest, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
	if (StorageTmp->mtpSlName == NULL) {
		config_perror("invalid specification for mtpSlName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtList, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
	if (StorageTmp->mtpSlSlsCodeNormalList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeNormalList");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfilePointer, &StorageTmp->mtpSlL3ProfilePointerLen);
	if (StorageTmp->mtpSlL3ProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlL3ProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlAlarmStatus, &StorageTmp->mtpSlAlarmStatusLen);
	if (StorageTmp->mtpSlAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSlAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlRowStatus, &tmpsize);
	mtpSlTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
}

/*
 * store_mtpSlTable(): store configuraiton file for mtpSlTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlTable", "storing data...  "));
	refresh_mtpSlTable();
	(void) tmpsize;
	for (hcindex = mtpSlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlMaxCapacitySL, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCurrentCapacitySL, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlLinkTpStatus, &StorageTmp->mtpSlLinkTpStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlMtpL2ProtocolProfilePointer, &StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSignTermPointer, &StorageTmp->mtpSlSignTermPointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSignDataLinkTpPointer, &StorageTmp->mtpSlSignDataLinkTpPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalInhibit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalUninhibit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlReplaceSt, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlAsaProfilePointer, &StorageTmp->mtpSlAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlCongestionLevel, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlList, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlTest, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtList, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfilePointer, &StorageTmp->mtpSlL3ProfilePointerLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlAlarmStatus, &StorageTmp->mtpSlAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlSdlListTable_data *mtpSlSdlListTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlSdlListTable table.
 * Creates a new mtpSlSdlListTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlSdlListTable_data *
mtpSlSdlListTable_create(void)
{
	struct mtpSlSdlListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);

	DEBUGMSGTL(("mtpSlSdlListTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpSlSdlListPointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpSlSdlListPointerLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpSlSdlListRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSlSdlListTable_data *mtpSlSdlListTable_duplicate(struct mtpSlSdlListTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlSdlListTable_data *
mtpSlSdlListTable_duplicate(struct mtpSlSdlListTable_data *thedata)
{
	struct mtpSlSdlListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);

	DEBUGMSGTL(("mtpSlSdlListTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlSdlListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlSdlListTable_destroy(struct mtpSlSdlListTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlSdlListTable_destroy(struct mtpSlSdlListTable_data **thedata)
{
	struct mtpSlSdlListTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlSdlListTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSdlListPointer);
		StorageDel->mtpSlSdlListPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdlListTable_add(struct mtpSlSdlListTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlSdlListTable table data set.
 * Adds a table row structure to the mtpSlSdlListTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlSdlListTable_add(struct mtpSlSdlListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdlListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlSdlListId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdlListId, sizeof(thedata->mtpSlSdlListId));
	header_complex_add_data(&mtpSlSdlListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdlListTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdlListTable_del(struct mtpSlSdlListTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpSlSdlListTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlSdlListTable_del(struct mtpSlSdlListTable_data *thedata)
{
	struct mtpSlSdlListTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlSdlListTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlSdlListTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlSdlListTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlSdlListTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlSdlListTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlSdlListTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlSdlListTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlSdlListTable_data *StorageTmp = mtpSlSdlListTable_create();

	DEBUGMSGTL(("mtpSlSdlListTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlListId, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
	if (StorageTmp->mtpSlSdlListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdlListPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdlListRowStatus, &tmpsize);
	mtpSlSdlListTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
}

/*
 * store_mtpSlSdlListTable(): store configuraiton file for mtpSlSdlListTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdlListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlSdlListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdlListTable", "storing data...  "));
	refresh_mtpSlSdlListTable();
	(void) tmpsize;
	for (hcindex = mtpSlSdlListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdlListTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlSdlListTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlListId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdlListRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlSdtListTable_data *mtpSlSdtListTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlSdtListTable table.
 * Creates a new mtpSlSdtListTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlSdtListTable_data *
mtpSlSdtListTable_create(void)
{
	struct mtpSlSdtListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);

	DEBUGMSGTL(("mtpSlSdtListTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpSlSdtListPointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpSlSdtListPointerLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpSlSdtListRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSlSdtListTable_data *mtpSlSdtListTable_duplicate(struct mtpSlSdtListTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlSdtListTable_data *
mtpSlSdtListTable_duplicate(struct mtpSlSdtListTable_data *thedata)
{
	struct mtpSlSdtListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);

	DEBUGMSGTL(("mtpSlSdtListTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlSdtListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlSdtListTable_destroy(struct mtpSlSdtListTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlSdtListTable_destroy(struct mtpSlSdtListTable_data **thedata)
{
	struct mtpSlSdtListTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlSdtListTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSdtListPointer);
		StorageDel->mtpSlSdtListPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdtListTable_add(struct mtpSlSdtListTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlSdtListTable table data set.
 * Adds a table row structure to the mtpSlSdtListTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlSdtListTable_add(struct mtpSlSdtListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdtListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlSdtListId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdtListId, sizeof(thedata->mtpSlSdtListId));
	header_complex_add_data(&mtpSlSdtListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdtListTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdtListTable_del(struct mtpSlSdtListTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpSlSdtListTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlSdtListTable_del(struct mtpSlSdtListTable_data *thedata)
{
	struct mtpSlSdtListTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlSdtListTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlSdtListTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlSdtListTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlSdtListTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlSdtListTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlSdtListTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlSdtListTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlSdtListTable_data *StorageTmp = mtpSlSdtListTable_create();

	DEBUGMSGTL(("mtpSlSdtListTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtListId, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
	if (StorageTmp->mtpSlSdtListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdtListPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdtListRowStatus, &tmpsize);
	mtpSlSdtListTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
}

/*
 * store_mtpSlSdtListTable(): store configuraiton file for mtpSlSdtListTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdtListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlSdtListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdtListTable", "storing data...  "));
	refresh_mtpSlSdtListTable();
	(void) tmpsize;
	for (hcindex = mtpSlSdtListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdtListTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlSdtListTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtListId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdtListRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpNbTable_data *mtpNbTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpNbTable table.
 * Creates a new mtpNbTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpNbTable_data *
mtpNbTable_create(void)
{
	struct mtpNbTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNbTable_data);

	DEBUGMSGTL(("mtpNbTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpNbTin = 4;
		StorageNew->mtpNbTie = 1;
		StorageNew->mtpNbT = 256;
		StorageNew->mtpNbD = 64;
		StorageNew->mtpNbN = 16;
		StorageNew->mtpNbm = 272;
		StorageNew->mtpNbf = MTPNBF_ONE;
		StorageNew->mtpNbRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpNbTable_data *mtpNbTable_duplicate(struct mtpNbTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpNbTable_data *
mtpNbTable_duplicate(struct mtpNbTable_data *thedata)
{
	struct mtpNbTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNbTable_data);

	DEBUGMSGTL(("mtpNbTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpNbTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpNbTable_destroy(struct mtpNbTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpNbTable_destroy(struct mtpNbTable_data **thedata)
{
	struct mtpNbTable_data *StorageDel;

	DEBUGMSGTL(("mtpNbTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNbTable_add(struct mtpNbTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpNbTable table data set.
 * Adds a table row structure to the mtpNbTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpNbTable_add(struct mtpNbTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNbTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
	header_complex_add_data(&mtpNbTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNbTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNbTable_del(struct mtpNbTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpNbTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpNbTable_del(struct mtpNbTable_data *thedata)
{
	struct mtpNbTable_data *StorageDel;

	DEBUGMSGTL(("mtpNbTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpNbTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpNbTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpNbTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpNbTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpNbTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpNbTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpNbTable_data *StorageTmp = mtpNbTable_create();

	DEBUGMSGTL(("mtpNbTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbTransmissionRate, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTimerT8, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTie, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbT, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbD, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbDe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbUe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbN, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbm, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbb, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbf, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbRowStatus, &tmpsize);
	mtpNbTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
}

/*
 * store_mtpNbTable(): store configuraiton file for mtpNbTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpNbTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpNbTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNbTable", "storing data...  "));
	refresh_mtpNbTable();
	(void) tmpsize;
	for (hcindex = mtpNbTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNbTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpNbTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTin, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTie, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbT, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbD, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbDe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbUe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbN, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbm, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbb, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbf, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSaalTable_data *mtpSaalTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSaalTable table.
 * Creates a new mtpSaalTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSaalTable_data *
mtpSaalTable_create(void)
{
	struct mtpSaalTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSaalTable_data);

	DEBUGMSGTL(("mtpSaalTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSaalMaxCc = 4;
		StorageNew->mtpSaalMaxInformationFieldLength = 4096;
		StorageNew->mtpSaalMaxLengthSscopUuField = 4;
		StorageNew->mtpSaalMaxPd = 500;
		StorageNew->mtpSaalMaxStat = 67;
		StorageNew->mtpSaalN1 = 1000;
		StorageNew->mtpSaalNniTimerT1 = 500;
		StorageNew->mtpSaalNniTimerT2 = 3000;
		StorageNew->mtpSaalSscopTimerCc = 20;
		StorageNew->mtpSaalSscopTimerIdle = 10;
		StorageNew->mtpSaalSscopTimerKeepAlive = 10;
		StorageNew->mtpSaalSscopTimerNoResponse = 150;
		StorageNew->mtpSaalSscopTimerPoll = 10;
		StorageNew->mtpSaalTransmissionRateIntervalLower = 129;
		StorageNew->mtpSaalTransmissionRateIntervalUpper = 256;
		StorageNew->mtpSaalRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSaalTable_data *mtpSaalTable_duplicate(struct mtpSaalTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSaalTable_data *
mtpSaalTable_duplicate(struct mtpSaalTable_data *thedata)
{
	struct mtpSaalTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSaalTable_data);

	DEBUGMSGTL(("mtpSaalTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSaalTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSaalTable_destroy(struct mtpSaalTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSaalTable_destroy(struct mtpSaalTable_data **thedata)
{
	struct mtpSaalTable_data *StorageDel;

	DEBUGMSGTL(("mtpSaalTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSaalTable_add(struct mtpSaalTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSaalTable table data set.
 * Adds a table row structure to the mtpSaalTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSaalTable_add(struct mtpSaalTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSaalTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
	header_complex_add_data(&mtpSaalTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSaalTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSaalTable_del(struct mtpSaalTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpSaalTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSaalTable_del(struct mtpSaalTable_data *thedata)
{
	struct mtpSaalTable_data *StorageDel;

	DEBUGMSGTL(("mtpSaalTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSaalTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSaalTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSaalTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSaalTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSaalTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSaalTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSaalTable_data *StorageTmp = mtpSaalTable_create();

	DEBUGMSGTL(("mtpSaalTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalBufferRelease, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxCc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxNrp, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxPd, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxStat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerCc, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerIdle, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerPoll, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalRowStatus, &tmpsize);
	mtpSaalTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
}

/*
 * store_mtpSaalTable(): store configuraiton file for mtpSaalTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSaalTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSaalTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSaalTable", "storing data...  "));
	refresh_mtpSaalTable();
	(void) tmpsize;
	for (hcindex = mtpSaalTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSaalTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSaalTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalBufferRelease, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxCc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxNrp, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxPd, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxStat, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalN1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerCc, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerIdle, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerPoll, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpM2paTable_data *mtpM2paTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpM2paTable table.
 * Creates a new mtpM2paTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpM2paTable_data *
mtpM2paTable_create(void)
{
	struct mtpM2paTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2paTable_data);

	DEBUGMSGTL(("mtpM2paTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpM2paN1 = 1000;
		StorageNew->mtpM2paProving = TV_TRUE;
		StorageNew->mtpM2paSctpAssocMaxRetrans = 20;
		StorageNew->mtpM2paSctpSackDelay = 20;
		StorageNew->mtpM2paRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpM2paTable_data *mtpM2paTable_duplicate(struct mtpM2paTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpM2paTable_data *
mtpM2paTable_duplicate(struct mtpM2paTable_data *thedata)
{
	struct mtpM2paTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2paTable_data);

	DEBUGMSGTL(("mtpM2paTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpM2paTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpM2paTable_destroy(struct mtpM2paTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpM2paTable_destroy(struct mtpM2paTable_data **thedata)
{
	struct mtpM2paTable_data *StorageDel;

	DEBUGMSGTL(("mtpM2paTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2paTable_add(struct mtpM2paTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpM2paTable table data set.
 * Adds a table row structure to the mtpM2paTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpM2paTable_add(struct mtpM2paTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpM2paTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
	header_complex_add_data(&mtpM2paTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpM2paTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2paTable_del(struct mtpM2paTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpM2paTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpM2paTable_del(struct mtpM2paTable_data *thedata)
{
	struct mtpM2paTable_data *StorageDel;

	DEBUGMSGTL(("mtpM2paTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpM2paTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpM2paTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpM2paTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpM2paTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpM2paTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpM2paTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM2paTable_data *StorageTmp = mtpM2paTable_create();

	DEBUGMSGTL(("mtpM2paTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paProving, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paManagementProvingState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayUpper, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpLifetime, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paProvingAttempts, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paRowStatus, &tmpsize);
	mtpM2paTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
}

/*
 * store_mtpM2paTable(): store configuraiton file for mtpM2paTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM2paTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM2paTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpM2paTable", "storing data...  "));
	refresh_mtpM2paTable();
	(void) tmpsize;
	for (hcindex = mtpM2paTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM2paTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM2paTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paN1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paProving, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paManagementProvingState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayUpper, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpNoDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxseg, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpHeartbeat, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoInitial, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMin, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMax, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieLife, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieInc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxBurst, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpSackDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paProvingAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSdtTable_data *mtpSdtTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSdtTable table.
 * Creates a new mtpSdtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSdtTable_data *
mtpSdtTable_create(void)
{
	struct mtpSdtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdtTable_data);

	DEBUGMSGTL(("mtpSdtTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSdtAdministrativeState = MTPSDTADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpSdtOperationalState = MTPSDTOPERATIONALSTATE_DISABLED;
		StorageNew->mtpSdtUsageState = MTPSDTUSAGESTATE_IDLE;
		if ((StorageNew->mtpSdtEquipmentPointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpSdtEquipmentPointerLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpSdtRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSdtTable_data *mtpSdtTable_duplicate(struct mtpSdtTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSdtTable_data *
mtpSdtTable_duplicate(struct mtpSdtTable_data *thedata)
{
	struct mtpSdtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdtTable_data);

	DEBUGMSGTL(("mtpSdtTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSdtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSdtTable_destroy(struct mtpSdtTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSdtTable_destroy(struct mtpSdtTable_data **thedata)
{
	struct mtpSdtTable_data *StorageDel;

	DEBUGMSGTL(("mtpSdtTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProceduralStatus);
		StorageDel->mtpSdtProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSdtAvailabilityStatus);
		StorageDel->mtpSdtAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSdtEquipmentPointer);
		StorageDel->mtpSdtEquipmentPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdtName);
		StorageDel->mtpSdtNameLen = 0;
		SNMP_FREE(StorageDel->mtpSdtProfilePointer);
		StorageDel->mtpSdtProfilePointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdtTable_add(struct mtpSdtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSdtTable table data set.
 * Adds a table row structure to the mtpSdtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSdtTable_add(struct mtpSdtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSdtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSdtId, sizeof(thedata->mtpSdtId));
	header_complex_add_data(&mtpSdtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdtTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdtTable_del(struct mtpSdtTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpSdtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSdtTable_del(struct mtpSdtTable_data *thedata)
{
	struct mtpSdtTable_data *StorageDel;

	DEBUGMSGTL(("mtpSdtTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSdtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSdtTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSdtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSdtTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSdtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSdtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSdtTable_data *StorageTmp = mtpSdtTable_create();

	DEBUGMSGTL(("mtpSdtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtUsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtProceduralStatus, &StorageTmp->mtpSdtProceduralStatusLen);
	if (StorageTmp->mtpSdtProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSdtProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtAvailabilityStatus, &StorageTmp->mtpSdtAvailabilityStatusLen);
	if (StorageTmp->mtpSdtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSdtAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
	if (StorageTmp->mtpSdtEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdtEquipmentPointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
	if (StorageTmp->mtpSdtName == NULL) {
		config_perror("invalid specification for mtpSdtName");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtProfilePointer, &StorageTmp->mtpSdtProfilePointerLen);
	if (StorageTmp->mtpSdtProfilePointer == NULL) {
		config_perror("invalid specification for mtpSdtProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtRowStatus, &tmpsize);
	mtpSdtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
}

/*
 * store_mtpSdtTable(): store configuraiton file for mtpSdtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSdtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdtTable", "storing data...  "));
	refresh_mtpSdtTable();
	(void) tmpsize;
	for (hcindex = mtpSdtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSdtTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtProceduralStatus, &StorageTmp->mtpSdtProceduralStatusLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtAvailabilityStatus, &StorageTmp->mtpSdtAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtProfilePointer, &StorageTmp->mtpSdtProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSdlTable_data *mtpSdlTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSdlTable table.
 * Creates a new mtpSdlTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSdlTable_data *
mtpSdlTable_create(void)
{
	struct mtpSdlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdlTable_data);

	DEBUGMSGTL(("mtpSdlTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSdlOperationalState = MTPSDLOPERATIONALSTATE_DISABLED;
		if ((StorageNew->mtpSdlEquipmentPointer = snmp_duplicate_objid(zeroDotZero_oid, 2))) {
			StorageNew->mtpSdlEquipmentPointerLen = sizeof(zeroDotZero_oid);
		}
		StorageNew->mtpSdlRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSdlTable_data *mtpSdlTable_duplicate(struct mtpSdlTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSdlTable_data *
mtpSdlTable_duplicate(struct mtpSdlTable_data *thedata)
{
	struct mtpSdlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdlTable_data);

	DEBUGMSGTL(("mtpSdlTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSdlTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSdlTable_destroy(struct mtpSdlTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSdlTable_destroy(struct mtpSdlTable_data **thedata)
{
	struct mtpSdlTable_data *StorageDel;

	DEBUGMSGTL(("mtpSdlTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdlAdjPc);
		StorageDel->mtpSdlAdjPcLen = 0;
		SNMP_FREE(StorageDel->mtpSdlEquipmentPointer);
		StorageDel->mtpSdlEquipmentPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdlName);
		StorageDel->mtpSdlNameLen = 0;
		SNMP_FREE(StorageDel->mtpSdlStmChannel);
		StorageDel->mtpSdlStmChannelLen = 0;
		SNMP_FREE(StorageDel->mtpSdlVcTTpPointer);
		StorageDel->mtpSdlVcTTpPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdlTable_add(struct mtpSdlTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSdlTable table data set.
 * Adds a table row structure to the mtpSdlTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSdlTable_add(struct mtpSdlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSdlId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSdlId, sizeof(thedata->mtpSdlId));
	header_complex_add_data(&mtpSdlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdlTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdlTable_del(struct mtpSdlTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mtpSdlTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSdlTable_del(struct mtpSdlTable_data *thedata)
{
	struct mtpSdlTable_data *StorageDel;

	DEBUGMSGTL(("mtpSdlTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSdlTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSdlTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSdlTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSdlTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSdlTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSdlTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSdlTable_data *StorageTmp = mtpSdlTable_create();

	DEBUGMSGTL(("mtpSdlTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
	if (StorageTmp->mtpSdlAdjPc == NULL) {
		config_perror("invalid specification for mtpSdlAdjPc");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlTransmissionRate, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlLoopDelay, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlOperationalState, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
	if (StorageTmp->mtpSdlEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdlEquipmentPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlCIC, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
	if (StorageTmp->mtpSdlName == NULL) {
		config_perror("invalid specification for mtpSdlName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlStmChannel, &StorageTmp->mtpSdlStmChannelLen);
	if (StorageTmp->mtpSdlStmChannel == NULL) {
		config_perror("invalid specification for mtpSdlStmChannel");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
	if (StorageTmp->mtpSdlVcTTpPointer == NULL) {
		config_perror("invalid specification for mtpSdlVcTTpPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlRowStatus, &tmpsize);
	mtpSdlTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
}

/*
 * store_mtpSdlTable(): store configuraiton file for mtpSdlTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSdlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdlTable", "storing data...  "));
	refresh_mtpSdlTable();
	(void) tmpsize;
	for (hcindex = mtpSdlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdlTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSdlTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlLoopDelay, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlCIC, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlStmChannel, &StorageTmp->mtpSdlStmChannelLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_mtpSapTable(void)
 * @brief refresh the scalar values of the mtpSapTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSapTable(void)
{
	if (mtpSapTable_refresh == 0)
		return;
	mtpSapTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
 * @brief refresh the contents of the mtpSapTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
{
	if (StorageTmp->mtpSapTable_request == sa_request)
		return;
	StorageTmp->mtpSapTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpSapTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSapTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSapTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSapTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpSapTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSapTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSAP2ADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSap2Address);
		return (u_char *) &StorageTmp->mtpSap2Address;
	case MTPSAPUSERPART:
		*write_method = write_mtpSapUserPart;
		*var_len = sizeof(StorageTmp->mtpSapUserPart);
		return (u_char *) &StorageTmp->mtpSapUserPart;
	case MTPSAPUSERPARTSTATUS:
		*write_method = write_mtpSapUserPartStatus;
		*var_len = sizeof(StorageTmp->mtpSapUserPartStatus);
		return (u_char *) &StorageTmp->mtpSapUserPartStatus;
	case MTPSAPUSERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSapUserEntityNamesLen;
		return (u_char *) StorageTmp->mtpSapUserEntityNames;
	case MTPSAPPROVIDERENTITYNAMES:
		*write_method = write_mtpSapProviderEntityNames;
		*var_len = StorageTmp->mtpSapProviderEntityNamesLen;
		return (u_char *) StorageTmp->mtpSapProviderEntityNames;
	case MTPSAPUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSapUsageState);
		return (u_char *) &StorageTmp->mtpSapUsageState;
	case MTPSAPASAPROFILEPOINTER:
		*write_method = write_mtpSapAsaProfilePointer;
		*var_len = StorageTmp->mtpSapAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpSapAsaProfilePointer;
	case MTPSAPNAME:
		*write_method = write_mtpSapName;
		*var_len = StorageTmp->mtpSapNameLen;
		return (u_char *) StorageTmp->mtpSapName;
	case MTPSAPLONGMESSAGESUPPORTED:
		*write_method = write_mtpSapLongMessageSupported;
		*var_len = sizeof(StorageTmp->mtpSapLongMessageSupported);
		return (u_char *) &StorageTmp->mtpSapLongMessageSupported;
	case MTPSAPROWSTATUS:
		*write_method = write_mtpSapRowStatus;
		*var_len = sizeof(StorageTmp->mtpSapRowStatus);
		return (u_char *) &StorageTmp->mtpSapRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpMsTable(void)
 * @brief refresh the scalar values of the mtpMsTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpMsTable(void)
{
	if (mtpMsTable_refresh == 0)
		return;
	mtpMsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
 * @brief refresh the contents of the mtpMsTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
{
	if (StorageTmp->mtpMsTable_request == sa_request)
		return;
	StorageTmp->mtpMsTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpMsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpMsTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpMsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpMsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpMsTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpMsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpMsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPMSNAME:
		*write_method = write_mtpMsName;
		*var_len = StorageTmp->mtpMsNameLen;
		return (u_char *) StorageTmp->mtpMsName;
	case MTPMSALARMSTATUS:
		*write_method = write_mtpMsAlarmStatus;
		*var_len = StorageTmp->mtpMsAlarmStatusLen;
		return (u_char *) StorageTmp->mtpMsAlarmStatus;
	case MTPMSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpMsOperationalState);
		return (u_char *) &StorageTmp->mtpMsOperationalState;
	case MTPMSUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpMsUsageState);
		return (u_char *) &StorageTmp->mtpMsUsageState;
	case MTPMSMANAGEDELEMENTTYPE:
		*write_method = write_mtpMsManagedElementType;
		*var_len = StorageTmp->mtpMsManagedElementTypeLen;
		return (u_char *) StorageTmp->mtpMsManagedElementType;
	case MTPMSMODELCODE:
		*write_method = write_mtpMsModelCode;
		*var_len = StorageTmp->mtpMsModelCodeLen;
		return (u_char *) StorageTmp->mtpMsModelCode;
	case MTPMSVENDORNAME:
		*write_method = write_mtpMsVendorName;
		*var_len = StorageTmp->mtpMsVendorNameLen;
		return (u_char *) StorageTmp->mtpMsVendorName;
	case MTPMSUSERLABEL:
		*write_method = write_mtpMsUserLabel;
		*var_len = StorageTmp->mtpMsUserLabelLen;
		return (u_char *) StorageTmp->mtpMsUserLabel;
	case MTPMSVERSION:
		*write_method = write_mtpMsVersion;
		*var_len = StorageTmp->mtpMsVersionLen;
		return (u_char *) StorageTmp->mtpMsVersion;
	case MTPMSASAPROFILEPOINTER:
		*write_method = write_mtpMsAsaProfilePointer;
		*var_len = StorageTmp->mtpMsAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpMsAsaProfilePointer;
	case MTPMSNETWORKELEMENTALIASES:
		*write_method = write_mtpMsNetworkElementAliases;
		*var_len = StorageTmp->mtpMsNetworkElementAliasesLen;
		return (u_char *) StorageTmp->mtpMsNetworkElementAliases;
	case MTPMSSTATUS:
		*write_method = write_mtpMsStatus;
		*var_len = sizeof(StorageTmp->mtpMsStatus);
		return (u_char *) &StorageTmp->mtpMsStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpNaTable(void)
 * @brief refresh the scalar values of the mtpNaTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpNaTable(void)
{
	if (mtpNaTable_refresh == 0)
		return;
	mtpNaTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
 * @brief refresh the contents of the mtpNaTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
{
	if (StorageTmp->mtpNaTable_request == sa_request)
		return;
	StorageTmp->mtpNaTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpNaTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpNaTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpNaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpNaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpNaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpNaTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpNaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpNaTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPNAPROTOCOLVARIANT:
		*write_method = write_mtpNaProtocolVariant;
		*var_len = StorageTmp->mtpNaProtocolVariantLen;
		return (u_char *) StorageTmp->mtpNaProtocolVariant;
	case MTPNAPROTOCOLYEAR:
		*write_method = write_mtpNaProtocolYear;
		*var_len = sizeof(StorageTmp->mtpNaProtocolYear);
		return (u_char *) &StorageTmp->mtpNaProtocolYear;
	case MTPNAPROTOCOLOPTIONS:
		*write_method = write_mtpNaProtocolOptions;
		*var_len = StorageTmp->mtpNaProtocolOptionsLen;
		return (u_char *) StorageTmp->mtpNaProtocolOptions;
	case MTPNANETWORKINDICATOR:
		*write_method = write_mtpNaNetworkIndicator;
		*var_len = sizeof(StorageTmp->mtpNaNetworkIndicator);
		return (u_char *) &StorageTmp->mtpNaNetworkIndicator;
	case MTPNAPOINTCODEFORMAT:
		*write_method = write_mtpNaPointCodeFormat;
		*var_len = StorageTmp->mtpNaPointCodeFormatLen;
		return (u_char *) StorageTmp->mtpNaPointCodeFormat;
	case MTPNASLSLENGTH:
		*write_method = write_mtpNaSlsLength;
		*var_len = sizeof(StorageTmp->mtpNaSlsLength);
		return (u_char *) &StorageTmp->mtpNaSlsLength;
	case MTPNASPDEFAULT:
		*write_method = write_mtpNaSpDefault;
		*var_len = StorageTmp->mtpNaSpDefaultLen;
		return (u_char *) StorageTmp->mtpNaSpDefault;
	case MTPNANAME:
		*write_method = write_mtpNaName;
		*var_len = StorageTmp->mtpNaNameLen;
		return (u_char *) StorageTmp->mtpNaName;
	case MTPNAROWSTATUS:
		*write_method = write_mtpNaRowStatus;
		*var_len = sizeof(StorageTmp->mtpNaRowStatus);
		return (u_char *) &StorageTmp->mtpNaRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpGsTable(void)
 * @brief refresh the scalar values of the mtpGsTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsTable(void)
{
	if (mtpGsTable_refresh == 0)
		return;
	mtpGsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
 * @brief refresh the contents of the mtpGsTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsTable_request == sa_request)
		return;
	StorageTmp->mtpGsTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpGsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpGsTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpGsTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpGsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPGSADMINISTRATIVESTATE:
		*write_method = write_mtpGsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpGsAdministrativeState);
		return (u_char *) &StorageTmp->mtpGsAdministrativeState;
	case MTPGSTREATMENTOFOUTSIDERANGES:
		*write_method = write_mtpGsTreatmentOfOutsideRanges;
		*var_len = sizeof(StorageTmp->mtpGsTreatmentOfOutsideRanges);
		return (u_char *) &StorageTmp->mtpGsTreatmentOfOutsideRanges;
	case MTPGSLISTMODE:
		*write_method = write_mtpGsListMode;
		*var_len = sizeof(StorageTmp->mtpGsListMode);
		return (u_char *) &StorageTmp->mtpGsListMode;
	case MTPGSSCREENINGBYLINKSETORBYOPC:
		*write_method = write_mtpGsScreeningByLinkSetOrByOpc;
		*var_len = sizeof(StorageTmp->mtpGsScreeningByLinkSetOrByOpc);
		return (u_char *) &StorageTmp->mtpGsScreeningByLinkSetOrByOpc;
	case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC:
		*write_method = write_mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		*var_len = sizeof(StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc);
		return (u_char *) &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
	case MTPGSNAME:
		*write_method = write_mtpGsName;
		*var_len = StorageTmp->mtpGsNameLen;
		return (u_char *) StorageTmp->mtpGsName;
	case MTPGSROWSTATUS:
		*write_method = write_mtpGsRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsRowStatus);
		return (u_char *) &StorageTmp->mtpGsRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpGsLineTable(void)
 * @brief refresh the scalar values of the mtpGsLineTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsLineTable(void)
{
	if (mtpGsLineTable_refresh == 0)
		return;
	mtpGsLineTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
 * @brief refresh the contents of the mtpGsLineTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsLineTable_request == sa_request)
		return;
	StorageTmp->mtpGsLineTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpGsLineTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpGsLineTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsLineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsLineTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsLineTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpGsLineTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsLineTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpGsLineTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPGSLINEOBJECT:
		*write_method = write_mtpGsLineObject;
		*var_len = StorageTmp->mtpGsLineObjectLen;
		return (u_char *) StorageTmp->mtpGsLineObject;
	case MTPGSLINECONTENT:
		*write_method = write_mtpGsLineContent;
		*var_len = sizeof(StorageTmp->mtpGsLineContent);
		return (u_char *) &StorageTmp->mtpGsLineContent;
	case MTPGSLINEROWSTATUS:
		*write_method = write_mtpGsLineRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsLineRowStatus);
		return (u_char *) &StorageTmp->mtpGsLineRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpGsLineContentTable(void)
 * @brief refresh the scalar values of the mtpGsLineContentTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsLineContentTable(void)
{
	if (mtpGsLineContentTable_refresh == 0)
		return;
	mtpGsLineContentTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
 * @brief refresh the contents of the mtpGsLineContentTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsLineContentTable_request == sa_request)
		return;
	StorageTmp->mtpGsLineContentTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpGsLineContentTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpGsLineContentTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsLineContentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsLineContentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpGsLineContentTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpGsLineContentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPGSLINECONTENTDESIGNATEDDPCFIRST:
		*write_method = write_mtpGsLineContentDesignatedDPCFirst;
		*var_len = StorageTmp->mtpGsLineContentDesignatedDPCFirstLen;
		return (u_char *) StorageTmp->mtpGsLineContentDesignatedDPCFirst;
	case MTPGSLINECONTENTDESIGNATEDDPCLAST:
		*write_method = write_mtpGsLineContentDesignatedDPCLast;
		*var_len = StorageTmp->mtpGsLineContentDesignatedDPCLastLen;
		return (u_char *) StorageTmp->mtpGsLineContentDesignatedDPCLast;
	case MTPGSLINECONTENTSIMASK:
		*write_method = write_mtpGsLineContentSiMask;
		*var_len = StorageTmp->mtpGsLineContentSiMaskLen;
		return (u_char *) StorageTmp->mtpGsLineContentSiMask;
	case MTPGSLINECONTENTMESSAGETREATMENT:
		*write_method = write_mtpGsLineContentMessageTreatment;
		*var_len = sizeof(StorageTmp->mtpGsLineContentMessageTreatment);
		return (u_char *) &StorageTmp->mtpGsLineContentMessageTreatment;
	case MTPGSLINECONTENTCOMMENT:
		*write_method = write_mtpGsLineContentComment;
		*var_len = StorageTmp->mtpGsLineContentCommentLen;
		return (u_char *) StorageTmp->mtpGsLineContentComment;
	case MTPGSLINECONTENTROWSTATUS:
		*write_method = write_mtpGsLineContentRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsLineContentRowStatus);
		return (u_char *) &StorageTmp->mtpGsLineContentRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpSpProfileTable(void)
 * @brief refresh the scalar values of the mtpSpProfileTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSpProfileTable(void)
{
	if (mtpSpProfileTable_refresh == 0)
		return;
	mtpSpProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
 * @brief refresh the contents of the mtpSpProfileTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSpProfileTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpSpProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSpProfileTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSpProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSPPROFILETIMERT1R:
		*write_method = write_mtpSpProfileTimerT1R;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT1R);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT1R;
	case MTPSPPROFILETIMERT2:
		*write_method = write_mtpSpProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT2);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT2;
	case MTPSPPROFILETIMERT4:
		*write_method = write_mtpSpProfileTimerT4;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT4);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT4;
	case MTPSPPROFILETIMERT5:
		*write_method = write_mtpSpProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT5);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT5;
	case MTPSPPROFILETIMERT7:
		*write_method = write_mtpSpProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT7);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT7;
	case MTPSPPROFILETIMERT11:
		*write_method = write_mtpSpProfileTimerT11;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT11);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT11;
	case MTPSPPROFILETIMERT12:
		*write_method = write_mtpSpProfileTimerT12;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT12);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT12;
	case MTPSPPROFILETIMERT13:
		*write_method = write_mtpSpProfileTimerT13;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT13);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT13;
	case MTPSPPROFILETIMERT14:
		*write_method = write_mtpSpProfileTimerT14;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT14);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT14;
	case MTPSPPROFILETIMERT15:
		*write_method = write_mtpSpProfileTimerT15;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT15);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT15;
	case MTPSPPROFILETIMERT16:
		*write_method = write_mtpSpProfileTimerT16;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT16);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT16;
	case MTPSPPROFILETIMERT18I:
		*write_method = write_mtpSpProfileTimerT18I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT18I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT18I;
	case MTPSPPROFILETIMERT19I:
		*write_method = write_mtpSpProfileTimerT19I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT19I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT19I;
	case MTPSPPROFILETIMERT20I:
		*write_method = write_mtpSpProfileTimerT20I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT20I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT20I;
	case MTPSPPROFILETIMERT21I:
		*write_method = write_mtpSpProfileTimerT21I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT21I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT21I;
	case MTPSPPROFILETIMERT22I:
		*write_method = write_mtpSpProfileTimerT22I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT22I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT22I;
	case MTPSPPROFILETIMERT23I:
		*write_method = write_mtpSpProfileTimerT23I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT23I);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT23I;
	case MTPSPPROFILETIMERT20A:
		*write_method = write_mtpSpProfileTimerT20A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT20A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT20A;
	case MTPSPPROFILETIMERT21A:
		*write_method = write_mtpSpProfileTimerT21A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT21A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT21A;
	case MTPSPPROFILETIMERT22A:
		*write_method = write_mtpSpProfileTimerT22A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT22A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT22A;
	case MTPSPPROFILETIMERT23A:
		*write_method = write_mtpSpProfileTimerT23A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT23A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT23A;
	case MTPSPPROFILETIMERT24A:
		*write_method = write_mtpSpProfileTimerT24A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT24A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT24A;
	case MTPSPPROFILETIMERT26A:
		*write_method = write_mtpSpProfileTimerT26A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT26A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT26A;
	case MTPSPPROFILETIMERT27A:
		*write_method = write_mtpSpProfileTimerT27A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT27A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT27A;
	case MTPSPPROFILETIMERT1T:
		*write_method = write_mtpSpProfileTimerT1T;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT1T);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT1T;
	case MTPSPPROFILETIMERT2T:
		*write_method = write_mtpSpProfileTimerT2T;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT2T);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT2T;
	case MTPSPPROFILENAME:
		*write_method = write_mtpSpProfileName;
		*var_len = StorageTmp->mtpSpProfileNameLen;
		return (u_char *) StorageTmp->mtpSpProfileName;
	case MTPSPPROFILEROWSTATUS:
		*write_method = write_mtpSpProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpSpProfileRowStatus);
		return (u_char *) &StorageTmp->mtpSpProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpSpTable(void)
 * @brief refresh the scalar values of the mtpSpTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSpTable(void)
{
	if (mtpSpTable_refresh == 0)
		return;
	mtpSpTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
 * @brief refresh the contents of the mtpSpTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpTable_request == sa_request)
		return;
	StorageTmp->mtpSpTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpSpTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSpTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSpTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSPPOINTCODE:
		*write_method = write_mtpSpPointCode;
		*var_len = StorageTmp->mtpSpPointCodeLen;
		return (u_char *) StorageTmp->mtpSpPointCode;
	case MTPSPTYPE:
		*write_method = write_mtpSpType;
		*var_len = sizeof(StorageTmp->mtpSpType);
		return (u_char *) &StorageTmp->mtpSpType;
	case MTPSPOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpOperationalState);
		return (u_char *) &StorageTmp->mtpSpOperationalState;
	case MTPSPPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSpProceduralStatusLen;
		return (u_char *) StorageTmp->mtpSpProceduralStatus;
	case MTPSPAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSpAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpSpAvailabilityStatus;
	case MTPSPVERSION:
		*write_method = write_mtpSpVersion;
		*var_len = StorageTmp->mtpSpVersionLen;
		return (u_char *) StorageTmp->mtpSpVersion;
	case MTPSPNETWORKINDICATOR:
		*write_method = write_mtpSpNetworkIndicator;
		*var_len = sizeof(StorageTmp->mtpSpNetworkIndicator);
		return (u_char *) &StorageTmp->mtpSpNetworkIndicator;
	case MTPSPNAME:
		*write_method = write_mtpSpName;
		*var_len = StorageTmp->mtpSpNameLen;
		return (u_char *) StorageTmp->mtpSpName;
	case MTPSPMTPT1:
		*write_method = write_mtpSpMtpT1;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1);
		return (u_char *) &StorageTmp->mtpSpMtpT1;
	case MTPSPMTPT2:
		*write_method = write_mtpSpMtpT2;
		*var_len = sizeof(StorageTmp->mtpSpMtpT2);
		return (u_char *) &StorageTmp->mtpSpMtpT2;
	case MTPSPMTPT3:
		*write_method = write_mtpSpMtpT3;
		*var_len = sizeof(StorageTmp->mtpSpMtpT3);
		return (u_char *) &StorageTmp->mtpSpMtpT3;
	case MTPSPMTPT4:
		*write_method = write_mtpSpMtpT4;
		*var_len = sizeof(StorageTmp->mtpSpMtpT4);
		return (u_char *) &StorageTmp->mtpSpMtpT4;
	case MTPSPMTPT5:
		*write_method = write_mtpSpMtpT5;
		*var_len = sizeof(StorageTmp->mtpSpMtpT5);
		return (u_char *) &StorageTmp->mtpSpMtpT5;
	case MTPSPMTPT6:
		*write_method = write_mtpSpMtpT6;
		*var_len = sizeof(StorageTmp->mtpSpMtpT6);
		return (u_char *) &StorageTmp->mtpSpMtpT6;
	case MTPSPMTPT7:
		*write_method = write_mtpSpMtpT7;
		*var_len = sizeof(StorageTmp->mtpSpMtpT7);
		return (u_char *) &StorageTmp->mtpSpMtpT7;
	case MTPSPMTPT8:
		*write_method = write_mtpSpMtpT8;
		*var_len = sizeof(StorageTmp->mtpSpMtpT8);
		return (u_char *) &StorageTmp->mtpSpMtpT8;
	case MTPSPMTPT10:
		*write_method = write_mtpSpMtpT10;
		*var_len = sizeof(StorageTmp->mtpSpMtpT10);
		return (u_char *) &StorageTmp->mtpSpMtpT10;
	case MTPSPMTPT11:
		*write_method = write_mtpSpMtpT11;
		*var_len = sizeof(StorageTmp->mtpSpMtpT11);
		return (u_char *) &StorageTmp->mtpSpMtpT11;
	case MTPSPMTPT12:
		*write_method = write_mtpSpMtpT12;
		*var_len = sizeof(StorageTmp->mtpSpMtpT12);
		return (u_char *) &StorageTmp->mtpSpMtpT12;
	case MTPSPMTPT13:
		*write_method = write_mtpSpMtpT13;
		*var_len = sizeof(StorageTmp->mtpSpMtpT13);
		return (u_char *) &StorageTmp->mtpSpMtpT13;
	case MTPSPMTPT14:
		*write_method = write_mtpSpMtpT14;
		*var_len = sizeof(StorageTmp->mtpSpMtpT14);
		return (u_char *) &StorageTmp->mtpSpMtpT14;
	case MTPSPMTPT15:
		*write_method = write_mtpSpMtpT15;
		*var_len = sizeof(StorageTmp->mtpSpMtpT15);
		return (u_char *) &StorageTmp->mtpSpMtpT15;
	case MTPSPMTPT16:
		*write_method = write_mtpSpMtpT16;
		*var_len = sizeof(StorageTmp->mtpSpMtpT16);
		return (u_char *) &StorageTmp->mtpSpMtpT16;
	case MTPSPMTPT17:
		*write_method = write_mtpSpMtpT17;
		*var_len = sizeof(StorageTmp->mtpSpMtpT17);
		return (u_char *) &StorageTmp->mtpSpMtpT17;
	case MTPSPMTPT19A:
		*write_method = write_mtpSpMtpT19A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT19A);
		return (u_char *) &StorageTmp->mtpSpMtpT19A;
	case MTPSPMTPT31A:
		*write_method = write_mtpSpMtpT31A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT31A);
		return (u_char *) &StorageTmp->mtpSpMtpT31A;
	case MTPSPMTPT32A:
		*write_method = write_mtpSpMtpT32A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT32A);
		return (u_char *) &StorageTmp->mtpSpMtpT32A;
	case MTPSPMTPT33A:
		*write_method = write_mtpSpMtpT33A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT33A);
		return (u_char *) &StorageTmp->mtpSpMtpT33A;
	case MTPSPMTPT34A:
		*write_method = write_mtpSpMtpT34A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT34A);
		return (u_char *) &StorageTmp->mtpSpMtpT34A;
	case MTPSPMTPT18I:
		*write_method = write_mtpSpMtpT18I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT18I);
		return (u_char *) &StorageTmp->mtpSpMtpT18I;
	case MTPSPMTPT19I:
		*write_method = write_mtpSpMtpT19I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT19I);
		return (u_char *) &StorageTmp->mtpSpMtpT19I;
	case MTPSPMTPT20I:
		*write_method = write_mtpSpMtpT20I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT20I);
		return (u_char *) &StorageTmp->mtpSpMtpT20I;
	case MTPSPMTPT21I:
		*write_method = write_mtpSpMtpT21I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT21I);
		return (u_char *) &StorageTmp->mtpSpMtpT21I;
	case MTPSPMTPT22I:
		*write_method = write_mtpSpMtpT22I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT22I);
		return (u_char *) &StorageTmp->mtpSpMtpT22I;
	case MTPSPMTPT23I:
		*write_method = write_mtpSpMtpT23I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT23I);
		return (u_char *) &StorageTmp->mtpSpMtpT23I;
	case MTPSPMTPT20A:
		*write_method = write_mtpSpMtpT20A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT20A);
		return (u_char *) &StorageTmp->mtpSpMtpT20A;
	case MTPSPMTPT21A:
		*write_method = write_mtpSpMtpT21A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT21A);
		return (u_char *) &StorageTmp->mtpSpMtpT21A;
	case MTPSPMTPT24I:
		*write_method = write_mtpSpMtpT24I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT24I);
		return (u_char *) &StorageTmp->mtpSpMtpT24I;
	case MTPSPMTPT1T:
		*write_method = write_mtpSpMtpT1T;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1T);
		return (u_char *) &StorageTmp->mtpSpMtpT1T;
	case MTPSPMTPT2T:
		*write_method = write_mtpSpMtpT2T;
		*var_len = sizeof(StorageTmp->mtpSpMtpT2T);
		return (u_char *) &StorageTmp->mtpSpMtpT2T;
	case MTPSPMTPT1S:
		*write_method = write_mtpSpMtpT1S;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1S);
		return (u_char *) &StorageTmp->mtpSpMtpT1S;
	case MTPSPPROFILEPOINTER:
		*write_method = write_mtpSpProfilePointer;
		*var_len = StorageTmp->mtpSpProfilePointerLen;
		return (u_char *) StorageTmp->mtpSpProfilePointer;
	case MTPSPNAPOINTER:
		*write_method = write_mtpSpNaPointer;
		*var_len = StorageTmp->mtpSpNaPointerLen;
		return (u_char *) StorageTmp->mtpSpNaPointer;
	case MTPSPFLAGS:
		*write_method = write_mtpSpFlags;
		*var_len = StorageTmp->mtpSpFlagsLen;
		return (u_char *) StorageTmp->mtpSpFlags;
	case MTPSPUSERS:
		*write_method = write_mtpSpUsers;
		*var_len = StorageTmp->mtpSpUsersLen;
		return (u_char *) StorageTmp->mtpSpUsers;
	case MTPSPALARMSTATUS:
		*write_method = write_mtpSpAlarmStatus;
		*var_len = StorageTmp->mtpSpAlarmStatusLen;
		return (u_char *) StorageTmp->mtpSpAlarmStatus;
	case MTPSPROWSTATUS:
		*write_method = write_mtpSpRowStatus;
		*var_len = sizeof(StorageTmp->mtpSpRowStatus);
		return (u_char *) &StorageTmp->mtpSpRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpL3Table(void)
 * @brief refresh the scalar values of the mtpL3Table.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpL3Table(void)
{
	if (mtpL3Table_refresh == 0)
		return;
	mtpL3Table_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
 * @brief refresh the contents of the mtpL3Table row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
{
	if (StorageTmp->mtpL3Table_request == sa_request)
		return;
	StorageTmp->mtpL3Table_request = sa_request;
}

/**
 * @fn u_char *var_mtpL3Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpL3Table.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpL3Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpL3Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpL3Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpL3Table();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpL3TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpL3Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPL3ADMINISTRATIVESTATE:
		*write_method = write_mtpL3AdministrativeState;
		*var_len = sizeof(StorageTmp->mtpL3AdministrativeState);
		return (u_char *) &StorageTmp->mtpL3AdministrativeState;
	case MTPL3OPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL3OperationalState);
		return (u_char *) &StorageTmp->mtpL3OperationalState;
	case MTPL3USAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL3UsageState);
		return (u_char *) &StorageTmp->mtpL3UsageState;
	case MTPL3PROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpL3ProceduralStatusLen;
		return (u_char *) StorageTmp->mtpL3ProceduralStatus;
	case MTPL3ASAPROFILEPOINTER:
		*write_method = write_mtpL3AsaProfilePointer;
		*var_len = StorageTmp->mtpL3AsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpL3AsaProfilePointer;
	case MTPL3NAME:
		*write_method = write_mtpL3Name;
		*var_len = StorageTmp->mtpL3NameLen;
		return (u_char *) StorageTmp->mtpL3Name;
	case MTPL3ROWSTATUS:
		*write_method = write_mtpL3RowStatus;
		*var_len = sizeof(StorageTmp->mtpL3RowStatus);
		return (u_char *) &StorageTmp->mtpL3RowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpRsProfileTable(void)
 * @brief refresh the scalar values of the mtpRsProfileTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRsProfileTable(void)
{
	if (mtpRsProfileTable_refresh == 0)
		return;
	mtpRsProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
 * @brief refresh the contents of the mtpRsProfileTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsProfileTable_request == sa_request)
		return;
	StorageTmp->mtpRsProfileTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpRsProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRsProfileTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRsProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPRSPROFILENAME:
		*write_method = write_mtpRsProfileName;
		*var_len = StorageTmp->mtpRsProfileNameLen;
		return (u_char *) StorageTmp->mtpRsProfileName;
	case MTPRSPROFILETIMERT8:
		*write_method = write_mtpRsProfileTimerT8;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT8);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT8;
	case MTPRSPROFILETIMERT11:
		*write_method = write_mtpRsProfileTimerT11;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT11);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT11;
	case MTPRSPROFILETIMERT15:
		*write_method = write_mtpRsProfileTimerT15;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT15);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT15;
	case MTPRSPROFILETIMERT16:
		*write_method = write_mtpRsProfileTimerT16;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT16);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT16;
	case MTPRSPROFILETIMERT18A:
		*write_method = write_mtpRsProfileTimerT18A;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT18A);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT18A;
	case MTPRSPROFILERTDEFAULT:
		*write_method = write_mtpRsProfileRtDefault;
		*var_len = StorageTmp->mtpRsProfileRtDefaultLen;
		return (u_char *) StorageTmp->mtpRsProfileRtDefault;
	case MTPRSPROFILEROWSTATUS:
		*write_method = write_mtpRsProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpRsProfileRowStatus);
		return (u_char *) &StorageTmp->mtpRsProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpRsTable(void)
 * @brief refresh the scalar values of the mtpRsTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRsTable(void)
{
	if (mtpRsTable_refresh == 0)
		return;
	mtpRsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
 * @brief refresh the contents of the mtpRsTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsTable_request == sa_request)
		return;
	StorageTmp->mtpRsTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpRsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRsTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRsTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPRSDEST:
		*write_method = write_mtpRsDest;
		*var_len = StorageTmp->mtpRsDestLen;
		return (u_char *) StorageTmp->mtpRsDest;
	case MTPRSFLAGS:
		*write_method = write_mtpRsFlags;
		*var_len = StorageTmp->mtpRsFlagsLen;
		return (u_char *) StorageTmp->mtpRsFlags;
	case MTPRSADMINISTRATIVESTATE:
		*write_method = write_mtpRsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpRsAdministrativeState);
		return (u_char *) &StorageTmp->mtpRsAdministrativeState;
	case MTPRSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsOperationalState);
		return (u_char *) &StorageTmp->mtpRsOperationalState;
	case MTPRSASAPROFILEPOINTER:
		*write_method = write_mtpRsAsaProfilePointer;
		*var_len = StorageTmp->mtpRsAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpRsAsaProfilePointer;
	case MTPRSCONGESTEDSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCongestedState);
		return (u_char *) &StorageTmp->mtpRsCongestedState;
	case MTPRSCONGESTIONLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCongestionLevel);
		return (u_char *) &StorageTmp->mtpRsCongestionLevel;
	case MTPRSLOADSHARINGINFORMATION:
		*write_method = write_mtpRsLoadsharingInformation;
		*var_len = StorageTmp->mtpRsLoadsharingInformationLen;
		return (u_char *) StorageTmp->mtpRsLoadsharingInformation;
	case MTPRSLOADSHARINGOBJECT:
		*write_method = write_mtpRsLoadsharingObject;
		*var_len = StorageTmp->mtpRsLoadsharingObjectLen;
		return (u_char *) StorageTmp->mtpRsLoadsharingObject;
	case MTPRSREMOTEEXCHANGELABEL:
		*write_method = write_mtpRsRemoteExchangeLabel;
		*var_len = StorageTmp->mtpRsRemoteExchangeLabelLen;
		return (u_char *) StorageTmp->mtpRsRemoteExchangeLabel;
	case MTPRSNAME:
		*write_method = write_mtpRsName;
		*var_len = StorageTmp->mtpRsNameLen;
		return (u_char *) StorageTmp->mtpRsName;
	case MTPRSPROFILE:
		*write_method = write_mtpRsProfile;
		*var_len = StorageTmp->mtpRsProfileLen;
		return (u_char *) StorageTmp->mtpRsProfile;
	case MTPRSALARMSTATUS:
		*write_method = write_mtpRsAlarmStatus;
		*var_len = StorageTmp->mtpRsAlarmStatusLen;
		return (u_char *) StorageTmp->mtpRsAlarmStatus;
	case MTPRSROWSTATUS:
		*write_method = write_mtpRsRowStatus;
		*var_len = sizeof(StorageTmp->mtpRsRowStatus);
		return (u_char *) &StorageTmp->mtpRsRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpRtProfileTable(void)
 * @brief refresh the scalar values of the mtpRtProfileTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtProfileTable(void)
{
	if (mtpRtProfileTable_refresh == 0)
		return;
	mtpRtProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
 * @brief refresh the contents of the mtpRtProfileTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtProfileTable_request == sa_request)
		return;
	StorageTmp->mtpRtProfileTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpRtProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRtProfileTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRtProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRtProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPRTPROFILETIMERT6:
		*write_method = write_mtpRtProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT6);
		return (u_char *) &StorageTmp->mtpRtProfileTimerT6;
	case MTPRTPROFILETIMERT10:
		*write_method = write_mtpRtProfileTimerT10;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT10);
		return (u_char *) &StorageTmp->mtpRtProfileTimerT10;
	case MTPRTPROFILEROWSTATUS:
		*write_method = write_mtpRtProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpRtProfileRowStatus);
		return (u_char *) &StorageTmp->mtpRtProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpRtTable(void)
 * @brief refresh the scalar values of the mtpRtTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtTable(void)
{
	if (mtpRtTable_refresh == 0)
		return;
	mtpRtTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
 * @brief refresh the contents of the mtpRtTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtTable_request == sa_request)
		return;
	StorageTmp->mtpRtTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpRtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRtTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRtTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPRTLSPOINTER:
		*write_method = write_mtpRtLsPointer;
		*var_len = StorageTmp->mtpRtLsPointerLen;
		return (u_char *) StorageTmp->mtpRtLsPointer;
	case MTPRTADMINISTRATIVESTATE:
		*write_method = write_mtpRtAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpRtAdministrativeState);
		return (u_char *) &StorageTmp->mtpRtAdministrativeState;
	case MTPRTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRtOperationalState);
		return (u_char *) &StorageTmp->mtpRtOperationalState;
	case MTPRTAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpRtAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpRtAvailabilityStatus;
	case MTPRTINCLSLOADSHARINGALGORITHM:
		*write_method = write_mtpRtInClsLoadsharingAlgorithm;
		*var_len = sizeof(StorageTmp->mtpRtInClsLoadsharingAlgorithm);
		return (u_char *) &StorageTmp->mtpRtInClsLoadsharingAlgorithm;
	case MTPRTFIXEDPRIORITY:
		*write_method = write_mtpRtFixedPriority;
		*var_len = sizeof(StorageTmp->mtpRtFixedPriority);
		return (u_char *) &StorageTmp->mtpRtFixedPriority;
	case MTPRTFLEXIBLEPRIORITY:
		*write_method = write_mtpRtFlexiblePriority;
		*var_len = sizeof(StorageTmp->mtpRtFlexiblePriority);
		return (u_char *) &StorageTmp->mtpRtFlexiblePriority;
	case MTPRTPRIORITYMODE:
		*write_method = write_mtpRtPriorityMode;
		*var_len = sizeof(StorageTmp->mtpRtPriorityMode);
		return (u_char *) &StorageTmp->mtpRtPriorityMode;
	case MTPRTLOADSHARINGINFORMATION:
		*write_method = write_mtpRtLoadsharingInformation;
		*var_len = StorageTmp->mtpRtLoadsharingInformationLen;
		return (u_char *) StorageTmp->mtpRtLoadsharingInformation;
	case MTPRTLOADSHARINGOBJECT:
		*write_method = write_mtpRtLoadsharingObject;
		*var_len = StorageTmp->mtpRtLoadsharingObjectLen;
		return (u_char *) StorageTmp->mtpRtLoadsharingObject;
	case MTPRTNAME:
		*write_method = write_mtpRtName;
		*var_len = StorageTmp->mtpRtNameLen;
		return (u_char *) StorageTmp->mtpRtName;
	case MTPRTSLSLIST:
		*write_method = write_mtpRtSlsList;
		*var_len = StorageTmp->mtpRtSlsListLen;
		return (u_char *) StorageTmp->mtpRtSlsList;
	case MTPRTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRtUsageState);
		return (u_char *) &StorageTmp->mtpRtUsageState;
	case MTPRTRLSLOT:
		*write_method = write_mtpRtRlSlot;
		*var_len = sizeof(StorageTmp->mtpRtRlSlot);
		return (u_char *) &StorageTmp->mtpRtRlSlot;
	case MTPRTPROFILE:
		*write_method = write_mtpRtProfile;
		*var_len = StorageTmp->mtpRtProfileLen;
		return (u_char *) StorageTmp->mtpRtProfile;
	case MTPRTROWSTATUS:
		*write_method = write_mtpRtRowStatus;
		*var_len = sizeof(StorageTmp->mtpRtRowStatus);
		return (u_char *) &StorageTmp->mtpRtRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpRtLsaTable(void)
 * @brief refresh the scalar values of the mtpRtLsaTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtLsaTable(void)
{
	if (mtpRtLsaTable_refresh == 0)
		return;
	mtpRtLsaTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp)
 * @brief refresh the contents of the mtpRtLsaTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtLsaTable_request == sa_request)
		return;
	StorageTmp->mtpRtLsaTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpRtLsaTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRtLsaTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtLsaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtLsaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtLsaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRtLsaTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRtLsaTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPRTLSANORMALSLCODE:
		*write_method = write_mtpRtLsaNormalSlCode;
		*var_len = sizeof(StorageTmp->mtpRtLsaNormalSlCode);
		return (u_char *) &StorageTmp->mtpRtLsaNormalSlCode;
	case MTPRTLSAALTERNATIVESLCODELIST:
		*write_method = write_mtpRtLsaAlternativeSlCodeList;
		*var_len = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
		return (u_char *) StorageTmp->mtpRtLsaAlternativeSlCodeList;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpLsProfileTable(void)
 * @brief refresh the scalar values of the mtpLsProfileTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpLsProfileTable(void)
{
	if (mtpLsProfileTable_refresh == 0)
		return;
	mtpLsProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
 * @brief refresh the contents of the mtpLsProfileTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsProfileTable_request == sa_request)
		return;
	StorageTmp->mtpLsProfileTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpLsProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpLsProfileTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpLsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpLsProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPLSPROFILETIMERT6:
		*write_method = write_mtpLsProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT6);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT6;
	case MTPLSPROFILETIMERT8:
		*write_method = write_mtpLsProfileTimerT8;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT8);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT8;
	case MTPLSPROFILETIMERT10:
		*write_method = write_mtpLsProfileTimerT10;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT10);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT10;
	case MTPLSPROFILETIMERT7:
		*write_method = write_mtpLsProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT7);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT7;
	case MTPLSPROFILETIMERT19I:
		*write_method = write_mtpLsProfileTimerT19I;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT19I);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT19I;
	case MTPLSPROFILETIMERT21I:
		*write_method = write_mtpLsProfileTimerT21I;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT21I);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT21I;
	case MTPLSPROFILETIMERT25A:
		*write_method = write_mtpLsProfileTimerT25A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT25A);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT25A;
	case MTPLSPROFILETIMERT28A:
		*write_method = write_mtpLsProfileTimerT28A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT28A);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT28A;
	case MTPLSPROFILETIMERT29A:
		*write_method = write_mtpLsProfileTimerT29A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT29A);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT29A;
	case MTPLSPROFILETIMERT30A:
		*write_method = write_mtpLsProfileTimerT30A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT30A);
		return (u_char *) &StorageTmp->mtpLsProfileTimerT30A;
	case MTPLSPROFILENAME:
		*write_method = write_mtpLsProfileName;
		*var_len = StorageTmp->mtpLsProfileNameLen;
		return (u_char *) StorageTmp->mtpLsProfileName;
	case MTPLSPROFILESLDEFAULT:
		*write_method = write_mtpLsProfileSlDefault;
		*var_len = StorageTmp->mtpLsProfileSlDefaultLen;
		return (u_char *) StorageTmp->mtpLsProfileSlDefault;
	case MTPLSPROFILEROWSTATUS:
		*write_method = write_mtpLsProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpLsProfileRowStatus);
		return (u_char *) &StorageTmp->mtpLsProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpLsTable(void)
 * @brief refresh the scalar values of the mtpLsTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpLsTable(void)
{
	if (mtpLsTable_refresh == 0)
		return;
	mtpLsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
 * @brief refresh the contents of the mtpLsTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsTable_request == sa_request)
		return;
	StorageTmp->mtpLsTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpLsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpLsTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpLsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpLsTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPLSADJPC:
		*write_method = write_mtpLsAdjPc;
		*var_len = StorageTmp->mtpLsAdjPcLen;
		return (u_char *) StorageTmp->mtpLsAdjPc;
	case MTPLSRSID:
		*write_method = write_mtpLsRsId;
		*var_len = StorageTmp->mtpLsRsIdLen;
		return (u_char *) StorageTmp->mtpLsRsId;
	case MTPLSMAXCAPACITY:
		*write_method = write_mtpLsMaxCapacity;
		*var_len = sizeof(StorageTmp->mtpLsMaxCapacity);
		return (u_char *) &StorageTmp->mtpLsMaxCapacity;
	case MTPLSCURRENTCAPACITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsCurrentCapacity);
		return (u_char *) &StorageTmp->mtpLsCurrentCapacity;
	case MTPLSCONGESTIONCONTROLMETHOD:
		*write_method = write_mtpLsCongestionControlMethod;
		*var_len = sizeof(StorageTmp->mtpLsCongestionControlMethod);
		return (u_char *) &StorageTmp->mtpLsCongestionControlMethod;
	case MTPLSUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsUsageState);
		return (u_char *) &StorageTmp->mtpLsUsageState;
	case MTPLSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsOperationalState);
		return (u_char *) &StorageTmp->mtpLsOperationalState;
	case MTPLSAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpLsAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpLsAvailabilityStatus;
	case MTPLSPERIODICLINKTESTFLAG:
		*write_method = write_mtpLsPeriodicLinkTestFlag;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFlag);
		return (u_char *) &StorageTmp->mtpLsPeriodicLinkTestFlag;
	case MTPLSPERIODICLINKTESTFAIL:
		*write_method = write_mtpLsPeriodicLinkTestFail;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFail);
		return (u_char *) &StorageTmp->mtpLsPeriodicLinkTestFail;
	case MTPLSADMINISTRATIVESTATE:
		*write_method = write_mtpLsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpLsAdministrativeState);
		return (u_char *) &StorageTmp->mtpLsAdministrativeState;
	case MTPLSINLSLOADSHAREALGORITHM:
		*write_method = write_mtpLsInLsLoadShareAlgorithm;
		*var_len = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
		return (u_char *) StorageTmp->mtpLsInLsLoadShareAlgorithm;
	case MTPLSPROFILEPOINTER:
		*write_method = write_mtpLsProfilePointer;
		*var_len = StorageTmp->mtpLsProfilePointerLen;
		return (u_char *) StorageTmp->mtpLsProfilePointer;
	case MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS:
		*write_method = write_mtpLsNumberOfNormallyActiveSignLinks;
		*var_len = sizeof(StorageTmp->mtpLsNumberOfNormallyActiveSignLinks);
		return (u_char *) &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks;
	case MTPLSNAME:
		*write_method = write_mtpLsName;
		*var_len = StorageTmp->mtpLsNameLen;
		return (u_char *) StorageTmp->mtpLsName;
	case MTPLSASAPROFILEPOINTER:
		*write_method = write_mtpLsAsaProfilePointer;
		*var_len = StorageTmp->mtpLsAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpLsAsaProfilePointer;
	case MTPLSALARMSTATUS:
		*write_method = write_mtpLsAlarmStatus;
		*var_len = StorageTmp->mtpLsAlarmStatusLen;
		return (u_char *) StorageTmp->mtpLsAlarmStatus;
	case MTPLSROWSTATUS:
		*write_method = write_mtpLsRowStatus;
		*var_len = sizeof(StorageTmp->mtpLsRowStatus);
		return (u_char *) &StorageTmp->mtpLsRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpSlL3ProfileTable(void)
 * @brief refresh the scalar values of the mtpSlL3ProfileTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlL3ProfileTable(void)
{
	if (mtpSlL3ProfileTable_refresh == 0)
		return;
	mtpSlL3ProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
 * @brief refresh the contents of the mtpSlL3ProfileTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL3ProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSlL3ProfileTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpSlL3ProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlL3ProfileTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlL3ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlL3ProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlL3ProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL3ProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSLL3PROFILETIMERT1:
		*write_method = write_mtpSlL3ProfileTimerT1;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1;
	case MTPSLL3PROFILETIMERT3:
		*write_method = write_mtpSlL3ProfileTimerT3;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT3);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT3;
	case MTPSLL3PROFILETIMERT17:
		*write_method = write_mtpSlL3ProfileTimerT17;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT17);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT17;
	case MTPSLL3PROFILETIMERT24I:
		*write_method = write_mtpSlL3ProfileTimerT24I;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT24I);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT24I;
	case MTPSLL3PROFILENAME:
		*write_method = write_mtpSlL3ProfileName;
		*var_len = StorageTmp->mtpSlL3ProfileNameLen;
		return (u_char *) StorageTmp->mtpSlL3ProfileName;
	case MTPSLL3PROFILETIMERT2:
		*write_method = write_mtpSlL3ProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT2);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT2;
	case MTPSLL3PROFILETIMERT4:
		*write_method = write_mtpSlL3ProfileTimerT4;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT4);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT4;
	case MTPSLL3PROFILETIMERT5:
		*write_method = write_mtpSlL3ProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT5);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT5;
	case MTPSLL3PROFILETIMERT12:
		*write_method = write_mtpSlL3ProfileTimerT12;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT12);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT12;
	case MTPSLL3PROFILETIMERT13:
		*write_method = write_mtpSlL3ProfileTimerT13;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT13);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT13;
	case MTPSLL3PROFILETIMERT14:
		*write_method = write_mtpSlL3ProfileTimerT14;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT14);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT14;
	case MTPSLL3PROFILETIMERT19A:
		*write_method = write_mtpSlL3ProfileTimerT19A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT19A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT19A;
	case MTPSLL3PROFILETIMERT20A:
		*write_method = write_mtpSlL3ProfileTimerT20A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT20A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT20A;
	case MTPSLL3PROFILETIMERT21A:
		*write_method = write_mtpSlL3ProfileTimerT21A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT21A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT21A;
	case MTPSLL3PROFILETIMERT22I:
		*write_method = write_mtpSlL3ProfileTimerT22I;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT22I);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT22I;
	case MTPSLL3PROFILETIMERT23I:
		*write_method = write_mtpSlL3ProfileTimerT23I;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT23I);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT23I;
	case MTPSLL3PROFILETIMERT31A:
		*write_method = write_mtpSlL3ProfileTimerT31A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT31A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT31A;
	case MTPSLL3PROFILETIMERT32A:
		*write_method = write_mtpSlL3ProfileTimerT32A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT32A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT32A;
	case MTPSLL3PROFILETIMERT33A:
		*write_method = write_mtpSlL3ProfileTimerT33A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT33A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT33A;
	case MTPSLL3PROFILETIMERT34A:
		*write_method = write_mtpSlL3ProfileTimerT34A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT34A);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT34A;
	case MTPSLL3PROFILETIMERT1T:
		*write_method = write_mtpSlL3ProfileTimerT1T;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1T);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1T;
	case MTPSLL3PROFILETIMERT2T:
		*write_method = write_mtpSlL3ProfileTimerT2T;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT2T);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT2T;
	case MTPSLL3PROFILETIMERT1S:
		*write_method = write_mtpSlL3ProfileTimerT1S;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1S);
		return (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1S;
	case MTPSLL3PROFILEL2DEFAULT:
		*write_method = write_mtpSlL3ProfileL2Default;
		*var_len = StorageTmp->mtpSlL3ProfileL2DefaultLen;
		return (u_char *) StorageTmp->mtpSlL3ProfileL2Default;
	case MTPSLL3PROFILEROWSTATUS:
		*write_method = write_mtpSlL3ProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileRowStatus);
		return (u_char *) &StorageTmp->mtpSlL3ProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpSlL2ProfileTable(void)
 * @brief refresh the scalar values of the mtpSlL2ProfileTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlL2ProfileTable(void)
{
	if (mtpSlL2ProfileTable_refresh == 0)
		return;
	mtpSlL2ProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
 * @brief refresh the contents of the mtpSlL2ProfileTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL2ProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSlL2ProfileTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpSlL2ProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlL2ProfileTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlL2ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlL2ProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlL2ProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL2ProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSLL2PROFILEERRORCORRECTIONMETHOD:
		*write_method = write_mtpSlL2ProfileErrorCorrectionMethod;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileErrorCorrectionMethod);
		return (u_char *) &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod;
	case MTPSLL2PROFILETRANSMISSIONRATE:
		*write_method = write_mtpSlL2ProfileTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTransmissionRate);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTransmissionRate;
	case MTPSLL2PROFILETIMERT1:
		*write_method = write_mtpSlL2ProfileTimerT1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT1);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT1;
	case MTPSLL2PROFILETIMERT2:
		*write_method = write_mtpSlL2ProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2;
	case MTPSLL2PROFILETIMERT2L:
		*write_method = write_mtpSlL2ProfileTimerT2L;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2L);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2L;
	case MTPSLL2PROFILETIMERT2H:
		*write_method = write_mtpSlL2ProfileTimerT2H;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2H);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2H;
	case MTPSLL2PROFILETIMERT3:
		*write_method = write_mtpSlL2ProfileTimerT3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT3);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT3;
	case MTPSLL2PROFILETIMERT4N:
		*write_method = write_mtpSlL2ProfileTimerT4N;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT4N);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT4N;
	case MTPSLL2PROFILETIMERT4E:
		*write_method = write_mtpSlL2ProfileTimerT4E;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT4E);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT4E;
	case MTPSLL2PROFILETIMERT5:
		*write_method = write_mtpSlL2ProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT5);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT5;
	case MTPSLL2PROFILETIMERT6:
		*write_method = write_mtpSlL2ProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT6);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT6;
	case MTPSLL2PROFILETIMERT7:
		*write_method = write_mtpSlL2ProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT7);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerT7;
	case MTPSLL2PROFILETBONSET1:
		*write_method = write_mtpSlL2ProfileTbOnset1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset1);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset1;
	case MTPSLL2PROFILETBABATE1:
		*write_method = write_mtpSlL2ProfileTbAbate1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate1);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate1;
	case MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS:
		*write_method = write_mtpSlL2ProfileNumberOfThresholdLevels;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels);
		return (u_char *) &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels;
	case MTPSLL2PROFILECONGESTIONCOUNTING:
		*write_method = write_mtpSlL2ProfileCongestionCounting;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileCongestionCounting);
		return (u_char *) &StorageTmp->mtpSlL2ProfileCongestionCounting;
	case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT:
		*write_method = write_mtpSlL2ProfileCongestionReportingBaseObject;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject);
		return (u_char *) &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject;
	case MTPSLL2PROFILELOOPDELAY:
		*write_method = write_mtpSlL2ProfileLoopDelay;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileLoopDelay);
		return (u_char *) &StorageTmp->mtpSlL2ProfileLoopDelay;
	case MTPSLL2PROFILENAME:
		*write_method = write_mtpSlL2ProfileName;
		*var_len = StorageTmp->mtpSlL2ProfileNameLen;
		return (u_char *) StorageTmp->mtpSlL2ProfileName;
	case MTPSLL2PROFILETBONSET2:
		*write_method = write_mtpSlL2ProfileTbOnset2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset2);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset2;
	case MTPSLL2PROFILETBABATE2:
		*write_method = write_mtpSlL2ProfileTbAbate2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate2);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate2;
	case MTPSLL2PROFILETBONSET3:
		*write_method = write_mtpSlL2ProfileTbOnset3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset3);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset3;
	case MTPSLL2PROFILETBABATE3:
		*write_method = write_mtpSlL2ProfileTbAbate3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate3);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate3;
	case MTPSLL2PROFILETBDISCARD1:
		*write_method = write_mtpSlL2ProfileTbDiscard1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard1);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard1;
	case MTPSLL2PROFILETBDISCARD2:
		*write_method = write_mtpSlL2ProfileTbDiscard2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard2);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard2;
	case MTPSLL2PROFILETBDISCARD3:
		*write_method = write_mtpSlL2ProfileTbDiscard3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard3);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard3;
	case MTPSLL2PROFILETIMERTX:
		*write_method = write_mtpSlL2ProfileTimerTx;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerTx);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerTx;
	case MTPSLL2PROFILETIMERTY:
		*write_method = write_mtpSlL2ProfileTimerTy;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerTy);
		return (u_char *) &StorageTmp->mtpSlL2ProfileTimerTy;
	case MTPSLL2PROFILENUMBEROFCONGESTIONSTATES:
		*write_method = write_mtpSlL2ProfileNumberOfCongestionStates;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileNumberOfCongestionStates);
		return (u_char *) &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates;
	case MTPSLL2PROFILEINITIALLEVELOFCONGESTION:
		*write_method = write_mtpSlL2ProfileInitialLevelOfCongestion;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion);
		return (u_char *) &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion;
	case MTPSLL2PROFILEMAXMSUSRETRANSN1:
		*write_method = write_mtpSlL2ProfileMaxMSUsRetransN1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1);
		return (u_char *) &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1;
	case MTPSLL2PROFILEMAXOCTRETRANSN2:
		*write_method = write_mtpSlL2ProfileMaxOctRetransN2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileMaxOctRetransN2);
		return (u_char *) &StorageTmp->mtpSlL2ProfileMaxOctRetransN2;
	case MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET:
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdOnset;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset);
		return (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset;
	case MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE:
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdAbate;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate);
		return (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate;
	case MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD:
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard);
		return (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard;
	case MTPSLL2PROFILEM:
		*write_method = write_mtpSlL2ProfileM;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileM);
		return (u_char *) &StorageTmp->mtpSlL2ProfileM;
	case MTPSLL2PROFILEROWSTATUS:
		*write_method = write_mtpSlL2ProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileRowStatus);
		return (u_char *) &StorageTmp->mtpSlL2ProfileRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpSlTable(void)
 * @brief refresh the scalar values of the mtpSlTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlTable(void)
{
	if (mtpSlTable_refresh == 0)
		return;
	mtpSlTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
 * @brief refresh the contents of the mtpSlTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlTable_request == sa_request)
		return;
	StorageTmp->mtpSlTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpSlTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSLSLSCODECURRENTLIST:
		*write_method = write_mtpSlSlsCodeCurrentList;
		*var_len = StorageTmp->mtpSlSlsCodeCurrentListLen;
		return (u_char *) StorageTmp->mtpSlSlsCodeCurrentList;
	case MTPSLMAXCAPACITYSL:
		*write_method = write_mtpSlMaxCapacitySL;
		*var_len = sizeof(StorageTmp->mtpSlMaxCapacitySL);
		return (u_char *) &StorageTmp->mtpSlMaxCapacitySL;
	case MTPSLCURRENTCAPACITYSL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentCapacitySL);
		return (u_char *) &StorageTmp->mtpSlCurrentCapacitySL;
	case MTPSLLINKTPSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSlLinkTpStatusLen;
		return (u_char *) StorageTmp->mtpSlLinkTpStatus;
	case MTPSLADMINISTRATIVESTATE:
		*write_method = write_mtpSlAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpSlAdministrativeState);
		return (u_char *) &StorageTmp->mtpSlAdministrativeState;
	case MTPSLOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlOperationalState);
		return (u_char *) &StorageTmp->mtpSlOperationalState;
	case MTPSLUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlUsageState);
		return (u_char *) &StorageTmp->mtpSlUsageState;
	case MTPSLPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSlProceduralStatusLen;
		return (u_char *) StorageTmp->mtpSlProceduralStatus;
	case MTPSLMTPL2PROTOCOLPROFILEPOINTER:
		*write_method = write_mtpSlMtpL2ProtocolProfilePointer;
		*var_len = StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen;
		return (u_char *) StorageTmp->mtpSlMtpL2ProtocolProfilePointer;
	case MTPSLSIGNTERMPOINTER:
		*write_method = write_mtpSlSignTermPointer;
		*var_len = StorageTmp->mtpSlSignTermPointerLen;
		return (u_char *) StorageTmp->mtpSlSignTermPointer;
	case MTPSLSIGNDATALINKTPPOINTER:
		*write_method = write_mtpSlSignDataLinkTpPointer;
		*var_len = StorageTmp->mtpSlSignDataLinkTpPointerLen;
		return (u_char *) StorageTmp->mtpSlSignDataLinkTpPointer;
	case MTPSLLOCALINHIBIT:
		*write_method = write_mtpSlLocalInhibit;
		*var_len = sizeof(StorageTmp->mtpSlLocalInhibit);
		return (u_char *) &StorageTmp->mtpSlLocalInhibit;
	case MTPSLLOCALUNINHIBIT:
		*write_method = write_mtpSlLocalUninhibit;
		*var_len = sizeof(StorageTmp->mtpSlLocalUninhibit);
		return (u_char *) &StorageTmp->mtpSlLocalUninhibit;
	case MTPSLREPLACEST:
		*write_method = write_mtpSlReplaceSt;
		*var_len = sizeof(StorageTmp->mtpSlReplaceSt);
		return (u_char *) &StorageTmp->mtpSlReplaceSt;
	case MTPSLASAPROFILEPOINTER:
		*write_method = write_mtpSlAsaProfilePointer;
		*var_len = StorageTmp->mtpSlAsaProfilePointerLen;
		return (u_char *) StorageTmp->mtpSlAsaProfilePointer;
	case MTPSLCONGESTIONLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCongestionLevel);
		return (u_char *) &StorageTmp->mtpSlCongestionLevel;
	case MTPSLRELATEDLINKGROUPNUMBER:
		*write_method = write_mtpSlRelatedLinkGroupNumber;
		*var_len = sizeof(StorageTmp->mtpSlRelatedLinkGroupNumber);
		return (u_char *) &StorageTmp->mtpSlRelatedLinkGroupNumber;
	case MTPSLSDLLIST:
		*write_method = write_mtpSlSdlList;
		*var_len = sizeof(StorageTmp->mtpSlSdlList);
		return (u_char *) &StorageTmp->mtpSlSdlList;
	case MTPSLTEST:
		*write_method = write_mtpSlTest;
		*var_len = sizeof(StorageTmp->mtpSlTest);
		return (u_char *) &StorageTmp->mtpSlTest;
	case MTPSLNAME:
		*write_method = write_mtpSlName;
		*var_len = StorageTmp->mtpSlNameLen;
		return (u_char *) StorageTmp->mtpSlName;
	case MTPSLSDTLIST:
		*write_method = write_mtpSlSdtList;
		*var_len = sizeof(StorageTmp->mtpSlSdtList);
		return (u_char *) &StorageTmp->mtpSlSdtList;
	case MTPSLSLSCODENORMALLIST:
		*write_method = write_mtpSlSlsCodeNormalList;
		*var_len = StorageTmp->mtpSlSlsCodeNormalListLen;
		return (u_char *) StorageTmp->mtpSlSlsCodeNormalList;
	case MTPSLL3PROFILEPOINTER:
		*write_method = write_mtpSlL3ProfilePointer;
		*var_len = StorageTmp->mtpSlL3ProfilePointerLen;
		return (u_char *) StorageTmp->mtpSlL3ProfilePointer;
	case MTPSLALARMSTATUS:
		*write_method = write_mtpSlAlarmStatus;
		*var_len = StorageTmp->mtpSlAlarmStatusLen;
		return (u_char *) StorageTmp->mtpSlAlarmStatus;
	case MTPSLROWSTATUS:
		*write_method = write_mtpSlRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlRowStatus);
		return (u_char *) &StorageTmp->mtpSlRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpSlSdlListTable(void)
 * @brief refresh the scalar values of the mtpSlSdlListTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlSdlListTable(void)
{
	if (mtpSlSdlListTable_refresh == 0)
		return;
	mtpSlSdlListTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
 * @brief refresh the contents of the mtpSlSdlListTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlSdlListTable_request == sa_request)
		return;
	StorageTmp->mtpSlSdlListTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpSlSdlListTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlSdlListTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlSdlListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlSdlListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlSdlListTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlSdlListTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlSdlListTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSLSDLLISTPOINTER:
		*write_method = write_mtpSlSdlListPointer;
		*var_len = StorageTmp->mtpSlSdlListPointerLen;
		return (u_char *) StorageTmp->mtpSlSdlListPointer;
	case MTPSLSDLLISTROWSTATUS:
		*write_method = write_mtpSlSdlListRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlSdlListRowStatus);
		return (u_char *) &StorageTmp->mtpSlSdlListRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpSlSdtListTable(void)
 * @brief refresh the scalar values of the mtpSlSdtListTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlSdtListTable(void)
{
	if (mtpSlSdtListTable_refresh == 0)
		return;
	mtpSlSdtListTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
 * @brief refresh the contents of the mtpSlSdtListTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlSdtListTable_request == sa_request)
		return;
	StorageTmp->mtpSlSdtListTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpSlSdtListTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlSdtListTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlSdtListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlSdtListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlSdtListTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlSdtListTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlSdtListTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSLSDTLISTPOINTER:
		*write_method = write_mtpSlSdtListPointer;
		*var_len = StorageTmp->mtpSlSdtListPointerLen;
		return (u_char *) StorageTmp->mtpSlSdtListPointer;
	case MTPSLSDTLISTROWSTATUS:
		*write_method = write_mtpSlSdtListRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlSdtListRowStatus);
		return (u_char *) &StorageTmp->mtpSlSdtListRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpNbTable(void)
 * @brief refresh the scalar values of the mtpNbTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpNbTable(void)
{
	if (mtpNbTable_refresh == 0)
		return;
	mtpNbTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
 * @brief refresh the contents of the mtpNbTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
{
	if (StorageTmp->mtpNbTable_request == sa_request)
		return;
	StorageTmp->mtpNbTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpNbTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpNbTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpNbTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpNbTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpNbTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpNbTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpNbTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpNbTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPNBTRANSMISSIONRATE:
		*write_method = write_mtpNbTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpNbTransmissionRate);
		return (u_char *) &StorageTmp->mtpNbTransmissionRate;
	case MTPNBTIMERT8:
		*write_method = write_mtpNbTimerT8;
		*var_len = sizeof(StorageTmp->mtpNbTimerT8);
		return (u_char *) &StorageTmp->mtpNbTimerT8;
	case MTPNBTIN:
		*write_method = write_mtpNbTin;
		*var_len = sizeof(StorageTmp->mtpNbTin);
		return (u_char *) &StorageTmp->mtpNbTin;
	case MTPNBTIE:
		*write_method = write_mtpNbTie;
		*var_len = sizeof(StorageTmp->mtpNbTie);
		return (u_char *) &StorageTmp->mtpNbTie;
	case MTPNBT:
		*write_method = write_mtpNbT;
		*var_len = sizeof(StorageTmp->mtpNbT);
		return (u_char *) &StorageTmp->mtpNbT;
	case MTPNBD:
		*write_method = write_mtpNbD;
		*var_len = sizeof(StorageTmp->mtpNbD);
		return (u_char *) &StorageTmp->mtpNbD;
	case MTPNBTE:
		*write_method = write_mtpNbTe;
		*var_len = sizeof(StorageTmp->mtpNbTe);
		return (u_char *) &StorageTmp->mtpNbTe;
	case MTPNBDE:
		*write_method = write_mtpNbDe;
		*var_len = sizeof(StorageTmp->mtpNbDe);
		return (u_char *) &StorageTmp->mtpNbDe;
	case MTPNBUE:
		*write_method = write_mtpNbUe;
		*var_len = sizeof(StorageTmp->mtpNbUe);
		return (u_char *) &StorageTmp->mtpNbUe;
	case MTPNBN:
		*write_method = write_mtpNbN;
		*var_len = sizeof(StorageTmp->mtpNbN);
		return (u_char *) &StorageTmp->mtpNbN;
	case MTPNBM:
		*write_method = write_mtpNbm;
		*var_len = sizeof(StorageTmp->mtpNbm);
		return (u_char *) &StorageTmp->mtpNbm;
	case MTPNBB:
		*write_method = write_mtpNbb;
		*var_len = sizeof(StorageTmp->mtpNbb);
		return (u_char *) &StorageTmp->mtpNbb;
	case MTPNBF:
		*write_method = write_mtpNbf;
		*var_len = sizeof(StorageTmp->mtpNbf);
		return (u_char *) &StorageTmp->mtpNbf;
	case MTPNBROWSTATUS:
		*write_method = write_mtpNbRowStatus;
		*var_len = sizeof(StorageTmp->mtpNbRowStatus);
		return (u_char *) &StorageTmp->mtpNbRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpSaalTable(void)
 * @brief refresh the scalar values of the mtpSaalTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSaalTable(void)
{
	if (mtpSaalTable_refresh == 0)
		return;
	mtpSaalTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
 * @brief refresh the contents of the mtpSaalTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
{
	if (StorageTmp->mtpSaalTable_request == sa_request)
		return;
	StorageTmp->mtpSaalTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpSaalTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSaalTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSaalTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSaalTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSaalTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSaalTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpSaalTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSaalTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSAALBUFFERRELEASE:
		*write_method = write_mtpSaalBufferRelease;
		*var_len = sizeof(StorageTmp->mtpSaalBufferRelease);
		return (u_char *) &StorageTmp->mtpSaalBufferRelease;
	case MTPSAALMAXCC:
		*write_method = write_mtpSaalMaxCc;
		*var_len = sizeof(StorageTmp->mtpSaalMaxCc);
		return (u_char *) &StorageTmp->mtpSaalMaxCc;
	case MTPSAALMAXNRP:
		*write_method = write_mtpSaalMaxNrp;
		*var_len = sizeof(StorageTmp->mtpSaalMaxNrp);
		return (u_char *) &StorageTmp->mtpSaalMaxNrp;
	case MTPSAALMAXINFORMATIONFIELDLENGTH:
		*write_method = write_mtpSaalMaxInformationFieldLength;
		*var_len = sizeof(StorageTmp->mtpSaalMaxInformationFieldLength);
		return (u_char *) &StorageTmp->mtpSaalMaxInformationFieldLength;
	case MTPSAALMAXLENGTHSSCOPUUFIELD:
		*write_method = write_mtpSaalMaxLengthSscopUuField;
		*var_len = sizeof(StorageTmp->mtpSaalMaxLengthSscopUuField);
		return (u_char *) &StorageTmp->mtpSaalMaxLengthSscopUuField;
	case MTPSAALMAXPD:
		*write_method = write_mtpSaalMaxPd;
		*var_len = sizeof(StorageTmp->mtpSaalMaxPd);
		return (u_char *) &StorageTmp->mtpSaalMaxPd;
	case MTPSAALMAXSSCOPCREDITTOPEER:
		*write_method = write_mtpSaalMaxSscopCreditToPeer;
		*var_len = sizeof(StorageTmp->mtpSaalMaxSscopCreditToPeer);
		return (u_char *) &StorageTmp->mtpSaalMaxSscopCreditToPeer;
	case MTPSAALMAXSTAT:
		*write_method = write_mtpSaalMaxStat;
		*var_len = sizeof(StorageTmp->mtpSaalMaxStat);
		return (u_char *) &StorageTmp->mtpSaalMaxStat;
	case MTPSAALN1:
		*write_method = write_mtpSaalN1;
		*var_len = sizeof(StorageTmp->mtpSaalN1);
		return (u_char *) &StorageTmp->mtpSaalN1;
	case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE:
		*write_method = write_mtpSaalNniLayerManagementProvingState;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementProvingState);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementProvingState;
	case MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT:
		*write_method = write_mtpSaalNniLayerManagementTimerNoCredit;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerNoCredit);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;
	case MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC:
		*write_method = write_mtpSaalNniLayerManagementTimerRepeatSrec;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;
	case MTPSAALNNITIMERT1:
		*write_method = write_mtpSaalNniTimerT1;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT1);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT1;
	case MTPSAALNNITIMERT2:
		*write_method = write_mtpSaalNniTimerT2;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT2);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT2;
	case MTPSAALNNITIMERT3:
		*write_method = write_mtpSaalNniTimerT3;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT3);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT3;
	case MTPSAALSSCOPTIMERCC:
		*write_method = write_mtpSaalSscopTimerCc;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerCc);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerCc;
	case MTPSAALSSCOPTIMERIDLE:
		*write_method = write_mtpSaalSscopTimerIdle;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerIdle);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerIdle;
	case MTPSAALSSCOPTIMERKEEPALIVE:
		*write_method = write_mtpSaalSscopTimerKeepAlive;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerKeepAlive);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerKeepAlive;
	case MTPSAALSSCOPTIMERNORESPONSE:
		*write_method = write_mtpSaalSscopTimerNoResponse;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerNoResponse);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerNoResponse;
	case MTPSAALSSCOPTIMERPOLL:
		*write_method = write_mtpSaalSscopTimerPoll;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerPoll);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerPoll;
	case MTPSAALTRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpSaalTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalLower;
	case MTPSAALTRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpSaalTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalUpper;
	case MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpSaalEgressTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;
	case MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpSaalEgressTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;
	case MTPSAALPOLLAFTERRETRANSMISSION:
		*write_method = write_mtpSaalPollAfterRetransmission;
		*var_len = sizeof(StorageTmp->mtpSaalPollAfterRetransmission);
		return (u_char *) &StorageTmp->mtpSaalPollAfterRetransmission;
	case MTPSAALROWSTATUS:
		*write_method = write_mtpSaalRowStatus;
		*var_len = sizeof(StorageTmp->mtpSaalRowStatus);
		return (u_char *) &StorageTmp->mtpSaalRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpM2paTable(void)
 * @brief refresh the scalar values of the mtpM2paTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM2paTable(void)
{
	if (mtpM2paTable_refresh == 0)
		return;
	mtpM2paTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
 * @brief refresh the contents of the mtpM2paTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
{
	if (StorageTmp->mtpM2paTable_request == sa_request)
		return;
	StorageTmp->mtpM2paTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpM2paTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpM2paTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM2paTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM2paTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpM2paTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpM2paTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpM2paTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpM2paTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPM2PAN1:
		*write_method = write_mtpM2paN1;
		*var_len = sizeof(StorageTmp->mtpM2paN1);
		return (u_char *) &StorageTmp->mtpM2paN1;
	case MTPM2PAPROVING:
		*write_method = write_mtpM2paProving;
		*var_len = sizeof(StorageTmp->mtpM2paProving);
		return (u_char *) &StorageTmp->mtpM2paProving;
	case MTPM2PAMANAGEMENTPROVINGSTATE:
		*write_method = write_mtpM2paManagementProvingState;
		*var_len = sizeof(StorageTmp->mtpM2paManagementProvingState);
		return (u_char *) &StorageTmp->mtpM2paManagementProvingState;
	case MTPM2PALOOPDELAYLOWER:
		*write_method = write_mtpM2paLoopDelayLower;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayLower);
		return (u_char *) &StorageTmp->mtpM2paLoopDelayLower;
	case MTPM2PALOOPDELAYUPPER:
		*write_method = write_mtpM2paLoopDelayUpper;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayUpper);
		return (u_char *) &StorageTmp->mtpM2paLoopDelayUpper;
	case MTPM2PATRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpM2paTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalLower;
	case MTPM2PATRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpM2paTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalUpper;
	case MTPM2PASCTPNODELAY:
		*write_method = write_mtpM2paSctpNoDelay;
		*var_len = sizeof(StorageTmp->mtpM2paSctpNoDelay);
		return (u_char *) &StorageTmp->mtpM2paSctpNoDelay;
	case MTPM2PASCTPMAXSEG:
		*write_method = write_mtpM2paSctpMaxseg;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxseg);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxseg;
	case MTPM2PASCTPHEARTBEATITVL:
		*write_method = write_mtpM2paSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeatItvl);
		return (u_char *) &StorageTmp->mtpM2paSctpHeartbeatItvl;
	case MTPM2PASCTPHEARTBEAT:
		*write_method = write_mtpM2paSctpHeartbeat;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeat);
		return (u_char *) &StorageTmp->mtpM2paSctpHeartbeat;
	case MTPM2PASCTPRTOINITIAL:
		*write_method = write_mtpM2paSctpRtoInitial;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoInitial);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoInitial;
	case MTPM2PASCTPRTOMIN:
		*write_method = write_mtpM2paSctpRtoMin;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMin);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoMin;
	case MTPM2PASCTPRTOMAX:
		*write_method = write_mtpM2paSctpRtoMax;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMax);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoMax;
	case MTPM2PASCTPPATHMAXRETRANS:
		*write_method = write_mtpM2paSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paSctpPathMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paSctpPathMaxRetrans;
	case MTPM2PASCTPCOOKIELIFE:
		*write_method = write_mtpM2paSctpCookieLife;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieLife);
		return (u_char *) &StorageTmp->mtpM2paSctpCookieLife;
	case MTPM2PASCTPCOOKIEINC:
		*write_method = write_mtpM2paSctpCookieInc;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieInc);
		return (u_char *) &StorageTmp->mtpM2paSctpCookieInc;
	case MTPM2PASCTPMAXINITRETRIES:
		*write_method = write_mtpM2paSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxInitRetries);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxInitRetries;
	case MTPM2PASCTPMAXBURST:
		*write_method = write_mtpM2paSctpMaxBurst;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxBurst);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxBurst;
	case MTPM2PASCTPASSOCMAXRETRANS:
		*write_method = write_mtpM2paSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paSctpAssocMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paSctpAssocMaxRetrans;
	case MTPM2PASCTPSACKDELAY:
		*write_method = write_mtpM2paSctpSackDelay;
		*var_len = sizeof(StorageTmp->mtpM2paSctpSackDelay);
		return (u_char *) &StorageTmp->mtpM2paSctpSackDelay;
	case MTPM2PASCTPLIFETIME:
		*write_method = write_mtpM2paSctpLifetime;
		*var_len = sizeof(StorageTmp->mtpM2paSctpLifetime);
		return (u_char *) &StorageTmp->mtpM2paSctpLifetime;
	case MTPM2PAPROVINGATTEMPTS:
		*write_method = write_mtpM2paProvingAttempts;
		*var_len = sizeof(StorageTmp->mtpM2paProvingAttempts);
		return (u_char *) &StorageTmp->mtpM2paProvingAttempts;
	case MTPM2PAROWSTATUS:
		*write_method = write_mtpM2paRowStatus;
		*var_len = sizeof(StorageTmp->mtpM2paRowStatus);
		return (u_char *) &StorageTmp->mtpM2paRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpSdtTable(void)
 * @brief refresh the scalar values of the mtpSdtTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSdtTable(void)
{
	if (mtpSdtTable_refresh == 0)
		return;
	mtpSdtTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
 * @brief refresh the contents of the mtpSdtTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdtTable_request == sa_request)
		return;
	StorageTmp->mtpSdtTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpSdtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSdtTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSdtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSdtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSdtTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSdtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSDTADMINISTRATIVESTATE:
		*write_method = write_mtpSdtAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpSdtAdministrativeState);
		return (u_char *) &StorageTmp->mtpSdtAdministrativeState;
	case MTPSDTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtOperationalState);
		return (u_char *) &StorageTmp->mtpSdtOperationalState;
	case MTPSDTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtUsageState);
		return (u_char *) &StorageTmp->mtpSdtUsageState;
	case MTPSDTPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSdtProceduralStatusLen;
		return (u_char *) StorageTmp->mtpSdtProceduralStatus;
	case MTPSDTAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSdtAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpSdtAvailabilityStatus;
	case MTPSDTEQUIPMENTPOINTER:
		*write_method = write_mtpSdtEquipmentPointer;
		*var_len = StorageTmp->mtpSdtEquipmentPointerLen;
		return (u_char *) StorageTmp->mtpSdtEquipmentPointer;
	case MTPSDTNAME:
		*write_method = write_mtpSdtName;
		*var_len = StorageTmp->mtpSdtNameLen;
		return (u_char *) StorageTmp->mtpSdtName;
	case MTPSDTPROFILEPOINTER:
		*write_method = write_mtpSdtProfilePointer;
		*var_len = StorageTmp->mtpSdtProfilePointerLen;
		return (u_char *) StorageTmp->mtpSdtProfilePointer;
	case MTPSDTROWSTATUS:
		*write_method = write_mtpSdtRowStatus;
		*var_len = sizeof(StorageTmp->mtpSdtRowStatus);
		return (u_char *) &StorageTmp->mtpSdtRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mtpSdlTable(void)
 * @brief refresh the scalar values of the mtpSdlTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSdlTable(void)
{
	if (mtpSdlTable_refresh == 0)
		return;
	mtpSdlTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
 * @brief refresh the contents of the mtpSdlTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdlTable_request == sa_request)
		return;
	StorageTmp->mtpSdlTable_request = sa_request;
}

/**
 * @fn u_char *var_mtpSdlTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSdlTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSdlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB", "var_mtpSdlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSdlTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSdlTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MTPSDLADJPC:
		*write_method = write_mtpSdlAdjPc;
		*var_len = StorageTmp->mtpSdlAdjPcLen;
		return (u_char *) StorageTmp->mtpSdlAdjPc;
	case MTPSDLTRANSMISSIONRATE:
		*write_method = write_mtpSdlTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpSdlTransmissionRate);
		return (u_char *) &StorageTmp->mtpSdlTransmissionRate;
	case MTPSDLLOOPDELAY:
		*write_method = write_mtpSdlLoopDelay;
		*var_len = sizeof(StorageTmp->mtpSdlLoopDelay);
		return (u_char *) &StorageTmp->mtpSdlLoopDelay;
	case MTPSDLOPERATIONALSTATE:
		*write_method = write_mtpSdlOperationalState;
		*var_len = sizeof(StorageTmp->mtpSdlOperationalState);
		return (u_char *) &StorageTmp->mtpSdlOperationalState;
	case MTPSDLEQUIPMENTPOINTER:
		*write_method = write_mtpSdlEquipmentPointer;
		*var_len = StorageTmp->mtpSdlEquipmentPointerLen;
		return (u_char *) StorageTmp->mtpSdlEquipmentPointer;
	case MTPSDLCIC:
		*write_method = write_mtpSdlCIC;
		*var_len = sizeof(StorageTmp->mtpSdlCIC);
		return (u_char *) &StorageTmp->mtpSdlCIC;
	case MTPSDLNAME:
		*write_method = write_mtpSdlName;
		*var_len = StorageTmp->mtpSdlNameLen;
		return (u_char *) StorageTmp->mtpSdlName;
	case MTPSDLSTMCHANNEL:
		*write_method = write_mtpSdlStmChannel;
		*var_len = StorageTmp->mtpSdlStmChannelLen;
		return (u_char *) StorageTmp->mtpSdlStmChannel;
	case MTPSDLVCTTPPOINTER:
		*write_method = write_mtpSdlVcTTpPointer;
		*var_len = StorageTmp->mtpSdlVcTTpPointerLen;
		return (u_char *) StorageTmp->mtpSdlVcTTpPointer;
	case MTPSDLROWSTATUS:
		*write_method = write_mtpSdlRowStatus;
		*var_len = sizeof(StorageTmp->mtpSdlRowStatus);
		return (u_char *) &StorageTmp->mtpSdlRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn int write_mtpSapUserPart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapUserPart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSapUserPart entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAPUSERPART_SNMM:
		case MTPSAPUSERPART_SNTM:
		case MTPSAPUSERPART_SNSM:
		case MTPSAPUSERPART_SCCP:
		case MTPSAPUSERPART_TUP:
		case MTPSAPUSERPART_ISUP:
		case MTPSAPUSERPART_DUP1:
		case MTPSAPUSERPART_DUP2:
		case MTPSAPUSERPART_MTUP:
		case MTPSAPUSERPART_BISUP:
		case MTPSAPUSERPART_SIUP:
		case MTPSAPUSERPART_USER11:
		case MTPSAPUSERPART_USER12:
		case MTPSAPUSERPART_USER13:
		case MTPSAPUSERPART_USER14:
		case MTPSAPUSERPART_USER15:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSapUserPart;
		StorageTmp->mtpSapUserPart = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapUserPart = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapUserPartStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapUserPartStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSapUserPartStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAPUSERPARTSTATUS_UNKNOWN:
		case MTPSAPUSERPARTSTATUS_INACCESSIBLE:
		case MTPSAPUSERPARTSTATUS_UNEQUIPPED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSapUserPartStatus;
		StorageTmp->mtpSapUserPartStatus = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapUserPartStatus = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapProviderEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpSapProviderEntityNames;
		old_length = StorageTmp->mtpSapProviderEntityNamesLen;
		StorageTmp->mtpSapProviderEntityNames = objid;
		StorageTmp->mtpSapProviderEntityNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapProviderEntityNames = old_value;
		StorageTmp->mtpSapProviderEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpSapAsaProfilePointer;
		old_length = StorageTmp->mtpSapAsaProfilePointerLen;
		StorageTmp->mtpSapAsaProfilePointer = objid;
		StorageTmp->mtpSapAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapAsaProfilePointer = old_value;
		StorageTmp->mtpSapAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSapName;
		old_length = StorageTmp->mtpSapNameLen;
		StorageTmp->mtpSapName = string;
		StorageTmp->mtpSapNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapName = old_value;
		StorageTmp->mtpSapNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapLongMessageSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapLongMessageSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSapLongMessageSupported entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSapLongMessageSupported;
		StorageTmp->mtpSapLongMessageSupported = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapLongMessageSupported = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpMsName;
		old_length = StorageTmp->mtpMsNameLen;
		StorageTmp->mtpMsName = string;
		StorageTmp->mtpMsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsName = old_value;
		StorageTmp->mtpMsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpMsAlarmStatus;
		old_length = StorageTmp->mtpMsAlarmStatusLen;
		StorageTmp->mtpMsAlarmStatus = string;
		StorageTmp->mtpMsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsAlarmStatus = old_value;
		StorageTmp->mtpMsAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsManagedElementType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsManagedElementType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsManagedElementType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsManagedElementType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsManagedElementType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsManagedElementType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpMsManagedElementType;
		old_length = StorageTmp->mtpMsManagedElementTypeLen;
		StorageTmp->mtpMsManagedElementType = string;
		StorageTmp->mtpMsManagedElementTypeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsManagedElementType = old_value;
		StorageTmp->mtpMsManagedElementTypeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsModelCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsModelCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsModelCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsModelCode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsModelCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsModelCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpMsModelCode;
		old_length = StorageTmp->mtpMsModelCodeLen;
		StorageTmp->mtpMsModelCode = string;
		StorageTmp->mtpMsModelCodeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsModelCode = old_value;
		StorageTmp->mtpMsModelCodeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsVendorName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsVendorName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsVendorName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVendorName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVendorName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVendorName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpMsVendorName;
		old_length = StorageTmp->mtpMsVendorNameLen;
		StorageTmp->mtpMsVendorName = string;
		StorageTmp->mtpMsVendorNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsVendorName = old_value;
		StorageTmp->mtpMsVendorNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsUserLabel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpMsUserLabel;
		old_length = StorageTmp->mtpMsUserLabelLen;
		StorageTmp->mtpMsUserLabel = string;
		StorageTmp->mtpMsUserLabelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsUserLabel = old_value;
		StorageTmp->mtpMsUserLabelLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVersion not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpMsVersion;
		old_length = StorageTmp->mtpMsVersionLen;
		StorageTmp->mtpMsVersion = string;
		StorageTmp->mtpMsVersionLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsVersion = old_value;
		StorageTmp->mtpMsVersionLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpMsAsaProfilePointer;
		old_length = StorageTmp->mtpMsAsaProfilePointerLen;
		StorageTmp->mtpMsAsaProfilePointer = objid;
		StorageTmp->mtpMsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsAsaProfilePointer = old_value;
		StorageTmp->mtpMsAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsNetworkElementAliases entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpMsNetworkElementAliases;
		old_length = StorageTmp->mtpMsNetworkElementAliasesLen;
		StorageTmp->mtpMsNetworkElementAliases = string;
		StorageTmp->mtpMsNetworkElementAliasesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsNetworkElementAliases = old_value;
		StorageTmp->mtpMsNetworkElementAliasesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolVariant entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 14..15 */
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid) || ((14 * sizeof(oid) > var_val_len || var_val_len > 15 * sizeof(oid)))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { OPENSS7-SS7-MIB : ss7ProtocolItut 0 } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpNaProtocolVariant;
		old_length = StorageTmp->mtpNaProtocolVariantLen;
		StorageTmp->mtpNaProtocolVariant = objid;
		StorageTmp->mtpNaProtocolVariantLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolVariant = old_value;
		StorageTmp->mtpNaProtocolVariantLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaProtocolYear(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaProtocolYear(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolYear entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value yCurrent */
		switch (set_value) {
		case MTPNAPROTOCOLYEAR_YCURRENT:
		case MTPNAPROTOCOLYEAR_Y1980:
		case MTPNAPROTOCOLYEAR_Y1984:
		case MTPNAPROTOCOLYEAR_Y1988:
		case MTPNAPROTOCOLYEAR_Y1992:
		case MTPNAPROTOCOLYEAR_Y1996:
		case MTPNAPROTOCOLYEAR_Y2000:
		case MTPNAPROTOCOLYEAR_Y2004:
		case MTPNAPROTOCOLYEAR_Y2008:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNaProtocolYear;
		StorageTmp->mtpNaProtocolYear = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolYear = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaProtocolOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaProtocolOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolOptions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((25 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (25 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpNaProtocolOptions;
		old_length = StorageTmp->mtpNaProtocolOptionsLen;
		StorageTmp->mtpNaProtocolOptions = string;
		StorageTmp->mtpNaProtocolOptionsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolOptions = old_value;
		StorageTmp->mtpNaProtocolOptionsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNaNetworkIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPNANETWORKINDICATOR_INTERNATIONALNETWORK1:
		case MTPNANETWORKINDICATOR_INTERNATIONALNETWORK2:
		case MTPNANETWORKINDICATOR_NATIONALNETWORK1:
		case MTPNANETWORKINDICATOR_NATIONALNETWORK2:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNaNetworkIndicator;
		StorageTmp->mtpNaNetworkIndicator = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaNetworkIndicator = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaPointCodeFormat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 3..3 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 3)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpNaPointCodeFormat;
		old_length = StorageTmp->mtpNaPointCodeFormatLen;
		StorageTmp->mtpNaPointCodeFormat = string;
		StorageTmp->mtpNaPointCodeFormatLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaPointCodeFormat = old_value;
		StorageTmp->mtpNaPointCodeFormatLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaSlsLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaSlsLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNaSlsLength entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPNASLSLENGTH_SLS4BITS:
		case MTPNASLSLENGTH_SLS5BITS:
		case MTPNASLSLENGTH_SLS8BITS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNaSlsLength;
		StorageTmp->mtpNaSlsLength = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaSlsLength = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaSpDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaSpDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaSpDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpNaSpDefault;
		old_length = StorageTmp->mtpNaSpDefaultLen;
		StorageTmp->mtpNaSpDefault = string;
		StorageTmp->mtpNaSpDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaSpDefault = old_value;
		StorageTmp->mtpNaSpDefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpNaName;
		old_length = StorageTmp->mtpNaNameLen;
		StorageTmp->mtpNaName = string;
		StorageTmp->mtpNaNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaName = old_value;
		StorageTmp->mtpNaNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPGSADMINISTRATIVESTATE_LOCKED:
		case MTPGSADMINISTRATIVESTATE_UNLOCKED:
		case MTPGSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpGsAdministrativeState;
		StorageTmp->mtpGsAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsTreatmentOfOutsideRanges(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsTreatmentOfOutsideRanges(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsTreatmentOfOutsideRanges entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPGSTREATMENTOFOUTSIDERANGES_NORMAL:
		case MTPGSTREATMENTOFOUTSIDERANGES_DISCARD:
		case MTPGSTREATMENTOFOUTSIDERANGES_PROHIBIT:
		case MTPGSTREATMENTOFOUTSIDERANGES_UNEQUIPPED:
		case MTPGSTREATMENTOFOUTSIDERANGES_INACCESSIBLE:
		case MTPGSTREATMENTOFOUTSIDERANGES_CONGEST:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpGsTreatmentOfOutsideRanges;
		StorageTmp->mtpGsTreatmentOfOutsideRanges = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsTreatmentOfOutsideRanges = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsListMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsListMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsListMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpGsListMode;
		StorageTmp->mtpGsListMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsListMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsScreeningByLinkSetOrByOpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsScreeningByLinkSetOrByOpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsScreeningByLinkSetOrByOpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYOPC:
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYINCOMINGLINKSET:
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYOUTGOINGLINKSET:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpGsScreeningByLinkSetOrByOpc;
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsGetScreenedOpcsOrLinkSetsByDpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsGetScreenedOpcsOrLinkSetsByDpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsGetScreenedOpcsOrLinkSetsByDpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SUCCESS:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_UNSUCCESSFUL:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_NOTPERFORMED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_LINKALREADYINHIBITED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_LINKNOTINHIBITED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_WRONGCLASSREFERENCED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SIGNTERMNONEXISTING:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SIGNTERMALREADYREFERENCED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpGsName;
		old_length = StorageTmp->mtpGsNameLen;
		StorageTmp->mtpGsName = string;
		StorageTmp->mtpGsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsName = old_value;
		StorageTmp->mtpGsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpGsLineTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpGsLineObject;
		old_length = StorageTmp->mtpGsLineObjectLen;
		StorageTmp->mtpGsLineObject = objid;
		StorageTmp->mtpGsLineObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineObject = old_value;
		StorageTmp->mtpGsLineObjectLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpGsLineTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContent entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpGsLineContent;
		StorageTmp->mtpGsLineContent = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContent = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentDesignatedDPCFirst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentDesignatedDPCFirst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentDesignatedDPCFirst entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpGsLineContentDesignatedDPCFirst;
		old_length = StorageTmp->mtpGsLineContentDesignatedDPCFirstLen;
		StorageTmp->mtpGsLineContentDesignatedDPCFirst = string;
		StorageTmp->mtpGsLineContentDesignatedDPCFirstLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentDesignatedDPCFirst = old_value;
		StorageTmp->mtpGsLineContentDesignatedDPCFirstLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentDesignatedDPCLast(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentDesignatedDPCLast(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentDesignatedDPCLast entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpGsLineContentDesignatedDPCLast;
		old_length = StorageTmp->mtpGsLineContentDesignatedDPCLastLen;
		StorageTmp->mtpGsLineContentDesignatedDPCLast = string;
		StorageTmp->mtpGsLineContentDesignatedDPCLastLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentDesignatedDPCLast = old_value;
		StorageTmp->mtpGsLineContentDesignatedDPCLastLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentSiMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentSiMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentSiMask entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((15 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (15 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpGsLineContentSiMask;
		old_length = StorageTmp->mtpGsLineContentSiMaskLen;
		StorageTmp->mtpGsLineContentSiMask = string;
		StorageTmp->mtpGsLineContentSiMaskLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentSiMask = old_value;
		StorageTmp->mtpGsLineContentSiMaskLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentMessageTreatment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentMessageTreatment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentMessageTreatment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPGSLINECONTENTMESSAGETREATMENT_NORMAL:
		case MTPGSLINECONTENTMESSAGETREATMENT_DISCARD:
		case MTPGSLINECONTENTMESSAGETREATMENT_PROHIBIT:
		case MTPGSLINECONTENTMESSAGETREATMENT_UNEQUIPPED:
		case MTPGSLINECONTENTMESSAGETREATMENT_INACCESSIBLE:
		case MTPGSLINECONTENTMESSAGETREATMENT_CONGEST:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpGsLineContentMessageTreatment;
		StorageTmp->mtpGsLineContentMessageTreatment = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentMessageTreatment = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentComment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentComment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentComment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpGsLineContentComment;
		old_length = StorageTmp->mtpGsLineContentCommentLen;
		StorageTmp->mtpGsLineContentComment = string;
		StorageTmp->mtpGsLineContentCommentLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentComment = old_value;
		StorageTmp->mtpGsLineContentCommentLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT1R(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT1R(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT1R entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT1R;
		StorageTmp->mtpSpProfileTimerT1R = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT1R = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT2;
		StorageTmp->mtpSpProfileTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT4;
		StorageTmp->mtpSpProfileTimerT4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT5;
		StorageTmp->mtpSpProfileTimerT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT7;
		StorageTmp->mtpSpProfileTimerT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT11;
		StorageTmp->mtpSpProfileTimerT11 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT11 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT12;
		StorageTmp->mtpSpProfileTimerT12 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT12 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT13;
		StorageTmp->mtpSpProfileTimerT13 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT13 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT14;
		StorageTmp->mtpSpProfileTimerT14 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT14 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT15;
		StorageTmp->mtpSpProfileTimerT15 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT15 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT16;
		StorageTmp->mtpSpProfileTimerT16 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT16 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT18I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT18I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT18I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT18I;
		StorageTmp->mtpSpProfileTimerT18I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT18I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT19I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT19I;
		StorageTmp->mtpSpProfileTimerT19I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT19I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT20I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT20I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT20I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 5900..6100 */
		if ((5900 > set_value || set_value > 6100)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT20I;
		StorageTmp->mtpSpProfileTimerT20I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT20I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT21I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT21I;
		StorageTmp->mtpSpProfileTimerT21I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT21I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT22I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT22I;
		StorageTmp->mtpSpProfileTimerT22I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT22I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT23I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT23I;
		StorageTmp->mtpSpProfileTimerT23I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT23I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT20A;
		StorageTmp->mtpSpProfileTimerT20A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT20A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT21A;
		StorageTmp->mtpSpProfileTimerT21A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT21A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT22A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT22A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT22A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT22A;
		StorageTmp->mtpSpProfileTimerT22A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT22A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT23A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT23A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT23A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT23A;
		StorageTmp->mtpSpProfileTimerT23A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT23A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT24A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT24A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT24A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT24A;
		StorageTmp->mtpSpProfileTimerT24A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT24A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT26A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT26A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT26A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1350 */
		/* Note: ranges 1200..1500 */
		if ((1200 > set_value || set_value > 1500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT26A;
		StorageTmp->mtpSpProfileTimerT26A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT26A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT27A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT27A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT27A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 300 */
		/* Note: ranges 200..500 */
		if ((200 > set_value || set_value > 500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT27A;
		StorageTmp->mtpSpProfileTimerT27A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT27A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT1T;
		StorageTmp->mtpSpProfileTimerT1T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT1T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT2T;
		StorageTmp->mtpSpProfileTimerT2T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT2T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSpProfileName;
		old_length = StorageTmp->mtpSpProfileNameLen;
		StorageTmp->mtpSpProfileName = string;
		StorageTmp->mtpSpProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileName = old_value;
		StorageTmp->mtpSpProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpPointCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSpPointCode;
		old_length = StorageTmp->mtpSpPointCodeLen;
		StorageTmp->mtpSpPointCode = string;
		StorageTmp->mtpSpPointCodeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpPointCode = old_value;
		StorageTmp->mtpSpPointCodeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSPTYPE_SEP:
		case MTPSPTYPE_STEP:
		case MTPSPTYPE_STP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpType;
		StorageTmp->mtpSpType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSpVersion;
		old_length = StorageTmp->mtpSpVersionLen;
		StorageTmp->mtpSpVersion = string;
		StorageTmp->mtpSpVersionLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpVersion = old_value;
		StorageTmp->mtpSpVersionLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpNetworkIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSPNETWORKINDICATOR_INTERNATIONALNETWORK1:
		case MTPSPNETWORKINDICATOR_INTERNATIONALNETWORK2:
		case MTPSPNETWORKINDICATOR_NATIONALNETWORK1:
		case MTPSPNETWORKINDICATOR_NATIONALNETWORK2:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpNetworkIndicator;
		StorageTmp->mtpSpNetworkIndicator = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpNetworkIndicator = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSpName;
		old_length = StorageTmp->mtpSpNameLen;
		StorageTmp->mtpSpName = string;
		StorageTmp->mtpSpNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpName = old_value;
		StorageTmp->mtpSpNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT1;
		StorageTmp->mtpSpMtpT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT2;
		StorageTmp->mtpSpMtpT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT3;
		StorageTmp->mtpSpMtpT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT4: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT4: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT4;
		StorageTmp->mtpSpMtpT4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT5;
		StorageTmp->mtpSpMtpT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT6: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT6;
		StorageTmp->mtpSpMtpT6 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT6 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT7: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT7;
		StorageTmp->mtpSpMtpT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT8: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT8: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT8;
		StorageTmp->mtpSpMtpT8 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT8 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT10: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT10: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT10: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT10;
		StorageTmp->mtpSpMtpT10 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT10 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT11: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT11: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT11: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT11;
		StorageTmp->mtpSpMtpT11 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT11 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT12: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT12: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT12: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT12;
		StorageTmp->mtpSpMtpT12 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT12 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT13: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT13: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT13: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT13;
		StorageTmp->mtpSpMtpT13 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT13 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT14: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT14: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT14: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT14;
		StorageTmp->mtpSpMtpT14 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT14 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT15: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT15: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT15: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT15;
		StorageTmp->mtpSpMtpT15 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT15 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT16: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT16: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT16: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT16;
		StorageTmp->mtpSpMtpT16 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT16 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT17 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT17: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT17 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT17: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT17: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT17;
		StorageTmp->mtpSpMtpT17 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT17 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT19A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT19A;
		StorageTmp->mtpSpMtpT19A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT19A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT31A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT31A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT31A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 1000..12000 */
		if ((1000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT31A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT31A;
		StorageTmp->mtpSpMtpT31A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT31A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT32A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT32A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT32A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT32A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT32A;
		StorageTmp->mtpSpMtpT32A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT32A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT33A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT33A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT33A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 36000 */
		/* Note: ranges 6000..60000 */
		if ((6000 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT33A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT33A;
		StorageTmp->mtpSpMtpT33A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT33A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT34A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT34A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT34A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT34A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT34A;
		StorageTmp->mtpSpMtpT34A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT34A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT18I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT18I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT18I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT18I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT18I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT18I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT18I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT18I;
		StorageTmp->mtpSpMtpT18I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT18I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT19I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT19I;
		StorageTmp->mtpSpMtpT19I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT19I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT20I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT20I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT20I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT20I;
		StorageTmp->mtpSpMtpT20I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT20I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT21I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT21I;
		StorageTmp->mtpSpMtpT21I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT21I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT22I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT22I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT22I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT22I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT22I;
		StorageTmp->mtpSpMtpT22I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT22I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT23I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT23I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT23I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT23I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT23I;
		StorageTmp->mtpSpMtpT23I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT23I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT20A;
		StorageTmp->mtpSpMtpT20A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT20A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT21A;
		StorageTmp->mtpSpMtpT21A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT21A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT24I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT24I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT24I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT24I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT24I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT24I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT24I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT24I;
		StorageTmp->mtpSpMtpT24I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT24I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT1T;
		StorageTmp->mtpSpMtpT1T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT2T;
		StorageTmp->mtpSpMtpT2T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT2T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpMtpT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpMtpT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpMtpT1S entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1S: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1S not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1S: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1S: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSpMtpT1S;
		StorageTmp->mtpSpMtpT1S = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1S = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSpProfilePointer;
		old_length = StorageTmp->mtpSpProfilePointerLen;
		StorageTmp->mtpSpProfilePointer = string;
		StorageTmp->mtpSpProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfilePointer = old_value;
		StorageTmp->mtpSpProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpNaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpNaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpNaPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSpNaPointer;
		old_length = StorageTmp->mtpSpNaPointerLen;
		StorageTmp->mtpSpNaPointer = string;
		StorageTmp->mtpSpNaPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpNaPointer = old_value;
		StorageTmp->mtpSpNaPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpFlags(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpFlags(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpFlags entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpFlags: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpFlags not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpFlags: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpFlags: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSpFlags;
		old_length = StorageTmp->mtpSpFlagsLen;
		StorageTmp->mtpSpFlags = string;
		StorageTmp->mtpSpFlagsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpFlags = old_value;
		StorageTmp->mtpSpFlagsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpUsers(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpUsers(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpUsers entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((15 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (15 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSpUsers;
		old_length = StorageTmp->mtpSpUsersLen;
		StorageTmp->mtpSpUsers = string;
		StorageTmp->mtpSpUsersLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpUsers = old_value;
		StorageTmp->mtpSpUsersLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSpAlarmStatus;
		old_length = StorageTmp->mtpSpAlarmStatusLen;
		StorageTmp->mtpSpAlarmStatus = string;
		StorageTmp->mtpSpAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpAlarmStatus = old_value;
		StorageTmp->mtpSpAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpL3AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpL3Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpL3AdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpL3RowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPL3ADMINISTRATIVESTATE_LOCKED:
		case MTPL3ADMINISTRATIVESTATE_UNLOCKED:
		case MTPL3ADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpL3AdministrativeState;
		StorageTmp->mtpL3AdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL3AdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3AsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpL3AsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpL3Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpL3AsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpL3RowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpL3AsaProfilePointer;
		old_length = StorageTmp->mtpL3AsaProfilePointerLen;
		StorageTmp->mtpL3AsaProfilePointer = objid;
		StorageTmp->mtpL3AsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL3AsaProfilePointer = old_value;
		StorageTmp->mtpL3AsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpL3Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpL3Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpL3Name entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpL3RowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpL3Name;
		old_length = StorageTmp->mtpL3NameLen;
		StorageTmp->mtpL3Name = string;
		StorageTmp->mtpL3NameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL3Name = old_value;
		StorageTmp->mtpL3NameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRsProfileName;
		old_length = StorageTmp->mtpRsProfileNameLen;
		StorageTmp->mtpRsProfileName = string;
		StorageTmp->mtpRsProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileName = old_value;
		StorageTmp->mtpRsProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 80..120 */
		if ((80 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT8;
		StorageTmp->mtpRsProfileTimerT8 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT8 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 3000..9000 */
		if ((3000 > set_value || set_value > 9000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT11;
		StorageTmp->mtpRsProfileTimerT11 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT11 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 250 */
		/* Note: ranges 200..300 */
		if ((200 > set_value || set_value > 300)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT15;
		StorageTmp->mtpRsProfileTimerT15 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT15 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 175 */
		/* Note: ranges 140..200 */
		if ((140 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT16;
		StorageTmp->mtpRsProfileTimerT16 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT16 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT18A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT18A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT18A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1200 */
		/* Note: ranges 200..2000 */
		if ((200 > set_value || set_value > 2000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT18A;
		StorageTmp->mtpRsProfileTimerT18A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT18A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileRtDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileRtDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileRtDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRsProfileRtDefault;
		old_length = StorageTmp->mtpRsProfileRtDefaultLen;
		StorageTmp->mtpRsProfileRtDefault = string;
		StorageTmp->mtpRsProfileRtDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileRtDefault = old_value;
		StorageTmp->mtpRsProfileRtDefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsDest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsDest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsDest entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRsDest;
		old_length = StorageTmp->mtpRsDestLen;
		StorageTmp->mtpRsDest = string;
		StorageTmp->mtpRsDestLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsDest = old_value;
		StorageTmp->mtpRsDestLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsFlags(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsFlags(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsFlags entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsFlags: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsFlags not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((3 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsFlags: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (3 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsFlags: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRsFlags;
		old_length = StorageTmp->mtpRsFlagsLen;
		StorageTmp->mtpRsFlags = string;
		StorageTmp->mtpRsFlagsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsFlags = old_value;
		StorageTmp->mtpRsFlagsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPRSADMINISTRATIVESTATE_LOCKED:
		case MTPRSADMINISTRATIVESTATE_UNLOCKED:
		case MTPRSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRsAdministrativeState;
		StorageTmp->mtpRsAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpRsAsaProfilePointer;
		old_length = StorageTmp->mtpRsAsaProfilePointerLen;
		StorageTmp->mtpRsAsaProfilePointer = objid;
		StorageTmp->mtpRsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAsaProfilePointer = old_value;
		StorageTmp->mtpRsAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsLoadsharingInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRsLoadsharingInformation;
		old_length = StorageTmp->mtpRsLoadsharingInformationLen;
		StorageTmp->mtpRsLoadsharingInformation = string;
		StorageTmp->mtpRsLoadsharingInformationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsLoadsharingInformation = old_value;
		StorageTmp->mtpRsLoadsharingInformationLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsLoadsharingObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpRsLoadsharingObject;
		old_length = StorageTmp->mtpRsLoadsharingObjectLen;
		StorageTmp->mtpRsLoadsharingObject = objid;
		StorageTmp->mtpRsLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsLoadsharingObject = old_value;
		StorageTmp->mtpRsLoadsharingObjectLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsRemoteExchangeLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsRemoteExchangeLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsRemoteExchangeLabel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRsRemoteExchangeLabel;
		old_length = StorageTmp->mtpRsRemoteExchangeLabelLen;
		StorageTmp->mtpRsRemoteExchangeLabel = string;
		StorageTmp->mtpRsRemoteExchangeLabelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsRemoteExchangeLabel = old_value;
		StorageTmp->mtpRsRemoteExchangeLabelLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRsName;
		old_length = StorageTmp->mtpRsNameLen;
		StorageTmp->mtpRsName = string;
		StorageTmp->mtpRsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsName = old_value;
		StorageTmp->mtpRsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRsProfile;
		old_length = StorageTmp->mtpRsProfileLen;
		StorageTmp->mtpRsProfile = string;
		StorageTmp->mtpRsProfileLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfile = old_value;
		StorageTmp->mtpRsProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRsAlarmStatus;
		old_length = StorageTmp->mtpRsAlarmStatusLen;
		StorageTmp->mtpRsAlarmStatus = string;
		StorageTmp->mtpRsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAlarmStatus = old_value;
		StorageTmp->mtpRsAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRtProfileTimerT6;
		StorageTmp->mtpRtProfileTimerT6 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfileTimerT6 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfileTimerT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4500 */
		/* Note: ranges 3000..6000 */
		if ((3000 > set_value || set_value > 6000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRtProfileTimerT10;
		StorageTmp->mtpRtProfileTimerT10 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfileTimerT10 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLsPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLsPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRtLsPointer;
		old_length = StorageTmp->mtpRtLsPointerLen;
		StorageTmp->mtpRtLsPointer = string;
		StorageTmp->mtpRtLsPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLsPointer = old_value;
		StorageTmp->mtpRtLsPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPRTADMINISTRATIVESTATE_LOCKED:
		case MTPRTADMINISTRATIVESTATE_UNLOCKED:
		case MTPRTADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRtAdministrativeState;
		StorageTmp->mtpRtAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtInClsLoadsharingAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtInClsLoadsharingAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtInClsLoadsharingAlgorithm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..0 16..16 32..32 256..256 */
		if (set_value != 0 && set_value != 16 && set_value != 32 && set_value != 256) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRtInClsLoadsharingAlgorithm;
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtFixedPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtFixedPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtFixedPriority entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRtFixedPriority;
		StorageTmp->mtpRtFixedPriority = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFixedPriority = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtFlexiblePriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtFlexiblePriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtFlexiblePriority entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRtFlexiblePriority;
		StorageTmp->mtpRtFlexiblePriority = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFlexiblePriority = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtPriorityMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtPriorityMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtPriorityMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPRTPRIORITYMODE_INSERT:
		case MTPRTPRIORITYMODE_EQUAL:
		case MTPRTPRIORITYMODE_EXCHANGESINGLE:
		case MTPRTPRIORITYMODE_EXCHANGEGROUP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRtPriorityMode;
		StorageTmp->mtpRtPriorityMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtPriorityMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLoadsharingInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRtLoadsharingInformation;
		old_length = StorageTmp->mtpRtLoadsharingInformationLen;
		StorageTmp->mtpRtLoadsharingInformation = string;
		StorageTmp->mtpRtLoadsharingInformationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLoadsharingInformation = old_value;
		StorageTmp->mtpRtLoadsharingInformationLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLoadsharingObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpRtLoadsharingObject;
		old_length = StorageTmp->mtpRtLoadsharingObjectLen;
		StorageTmp->mtpRtLoadsharingObject = objid;
		StorageTmp->mtpRtLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLoadsharingObject = old_value;
		StorageTmp->mtpRtLoadsharingObjectLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRtName;
		old_length = StorageTmp->mtpRtNameLen;
		StorageTmp->mtpRtName = string;
		StorageTmp->mtpRtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtName = old_value;
		StorageTmp->mtpRtNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtSlsList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtSlsList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtSlsList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..256 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 256))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRtSlsList;
		old_length = StorageTmp->mtpRtSlsListLen;
		StorageTmp->mtpRtSlsList = string;
		StorageTmp->mtpRtSlsListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtSlsList = old_value;
		StorageTmp->mtpRtSlsListLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtRlSlot(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtRlSlot(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtRlSlot entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..3 */
		if ((0 > set_value || set_value > 3)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRtRlSlot;
		StorageTmp->mtpRtRlSlot = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtRlSlot = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRtProfile;
		old_length = StorageTmp->mtpRtProfileLen;
		StorageTmp->mtpRtProfile = string;
		StorageTmp->mtpRtProfileLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfile = old_value;
		StorageTmp->mtpRtProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLsaNormalSlCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLsaNormalSlCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsaNormalSlCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..15 */
		if ((0 > set_value || set_value > 15)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpRtLsaNormalSlCode;
		StorageTmp->mtpRtLsaNormalSlCode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLsaNormalSlCode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLsaAlternativeSlCodeList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLsaAlternativeSlCodeList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsaAlternativeSlCodeList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaAlternativeSlCodeList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..31 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 31))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaAlternativeSlCodeList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpRtLsaAlternativeSlCodeList;
		old_length = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
		StorageTmp->mtpRtLsaAlternativeSlCodeList = string;
		StorageTmp->mtpRtLsaAlternativeSlCodeListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLsaAlternativeSlCodeList = old_value;
		StorageTmp->mtpRtLsaAlternativeSlCodeListLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT6;
		StorageTmp->mtpLsProfileTimerT6 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT6 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT8;
		StorageTmp->mtpLsProfileTimerT8 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT8 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4500 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT10;
		StorageTmp->mtpLsProfileTimerT10 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT10 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 150 */
		/* Note: ranges 100..200 */
		if ((100 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT7;
		StorageTmp->mtpLsProfileTimerT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT19I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT19I;
		StorageTmp->mtpLsProfileTimerT19I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT19I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT21I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT21I;
		StorageTmp->mtpLsProfileTimerT21I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT21I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT25A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT25A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT25A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT25A;
		StorageTmp->mtpLsProfileTimerT25A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT25A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT28A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT28A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT28A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT28A;
		StorageTmp->mtpLsProfileTimerT28A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT28A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT29A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT29A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT29A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT29A;
		StorageTmp->mtpLsProfileTimerT29A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT29A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT30A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT30A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT30A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT30A;
		StorageTmp->mtpLsProfileTimerT30A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT30A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpLsProfileName;
		old_length = StorageTmp->mtpLsProfileNameLen;
		StorageTmp->mtpLsProfileName = string;
		StorageTmp->mtpLsProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileName = old_value;
		StorageTmp->mtpLsProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileSlDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileSlDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileSlDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpLsProfileSlDefault;
		old_length = StorageTmp->mtpLsProfileSlDefaultLen;
		StorageTmp->mtpLsProfileSlDefault = string;
		StorageTmp->mtpLsProfileSlDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileSlDefault = old_value;
		StorageTmp->mtpLsProfileSlDefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAdjPc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpLsAdjPc;
		old_length = StorageTmp->mtpLsAdjPcLen;
		StorageTmp->mtpLsAdjPc = string;
		StorageTmp->mtpLsAdjPcLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAdjPc = old_value;
		StorageTmp->mtpLsAdjPcLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsRsId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsRsId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsRsId entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpLsRsId;
		old_length = StorageTmp->mtpLsRsIdLen;
		StorageTmp->mtpLsRsId = string;
		StorageTmp->mtpLsRsIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsRsId = old_value;
		StorageTmp->mtpLsRsIdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsMaxCapacity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..128000 */
		if ((0 > set_value || set_value > 128000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsMaxCapacity;
		StorageTmp->mtpLsMaxCapacity = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsMaxCapacity = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsCongestionControlMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsCongestionControlMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsCongestionControlMethod entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPLSCONGESTIONCONTROLMETHOD_UNKNOWN:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704INTERNATIONAL:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALWITHPRIO:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALNOPRIOBUFFERMECHANISM:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALNOPRIOTIMERMECHANISM:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsCongestionControlMethod;
		StorageTmp->mtpLsCongestionControlMethod = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCongestionControlMethod = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsPeriodicLinkTestFlag(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsPeriodicLinkTestFlag(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsPeriodicLinkTestFlag entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value on */
		switch (set_value) {
		case MTPLSPERIODICLINKTESTFLAG_ON:
		case MTPLSPERIODICLINKTESTFLAG_OFF:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsPeriodicLinkTestFlag;
		StorageTmp->mtpLsPeriodicLinkTestFlag = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsPeriodicLinkTestFlag = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsPeriodicLinkTestFail(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsPeriodicLinkTestFail(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsPeriodicLinkTestFail entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsPeriodicLinkTestFail;
		StorageTmp->mtpLsPeriodicLinkTestFail = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsPeriodicLinkTestFail = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPLSADMINISTRATIVESTATE_LOCKED:
		case MTPLSADMINISTRATIVESTATE_UNLOCKED:
		case MTPLSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsAdministrativeState;
		StorageTmp->mtpLsAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsInLsLoadShareAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsInLsLoadShareAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsInLsLoadShareAlgorithm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpLsInLsLoadShareAlgorithm;
		old_length = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
		StorageTmp->mtpLsInLsLoadShareAlgorithm = objid;
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsInLsLoadShareAlgorithm = old_value;
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpLsProfilePointer;
		old_length = StorageTmp->mtpLsProfilePointerLen;
		StorageTmp->mtpLsProfilePointer = string;
		StorageTmp->mtpLsProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfilePointer = old_value;
		StorageTmp->mtpLsProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsNumberOfNormallyActiveSignLinks(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsNumberOfNormallyActiveSignLinks(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsNumberOfNormallyActiveSignLinks entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..32 */
		if ((0 > set_value || set_value > 32)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpLsNumberOfNormallyActiveSignLinks;
		StorageTmp->mtpLsNumberOfNormallyActiveSignLinks = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsNumberOfNormallyActiveSignLinks = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpLsName;
		old_length = StorageTmp->mtpLsNameLen;
		StorageTmp->mtpLsName = string;
		StorageTmp->mtpLsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsName = old_value;
		StorageTmp->mtpLsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpLsAsaProfilePointer;
		old_length = StorageTmp->mtpLsAsaProfilePointerLen;
		StorageTmp->mtpLsAsaProfilePointer = objid;
		StorageTmp->mtpLsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAsaProfilePointer = old_value;
		StorageTmp->mtpLsAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpLsAlarmStatus;
		old_length = StorageTmp->mtpLsAlarmStatusLen;
		StorageTmp->mtpLsAlarmStatus = string;
		StorageTmp->mtpLsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAlarmStatus = old_value;
		StorageTmp->mtpLsAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT1;
		StorageTmp->mtpSlL3ProfileTimerT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT3;
		StorageTmp->mtpSlL3ProfileTimerT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT17 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT17;
		StorageTmp->mtpSlL3ProfileTimerT17 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT17 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT24I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT24I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT24I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 50 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT24I;
		StorageTmp->mtpSlL3ProfileTimerT24I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT24I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileName;
		old_length = StorageTmp->mtpSlL3ProfileNameLen;
		StorageTmp->mtpSlL3ProfileName = string;
		StorageTmp->mtpSlL3ProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileName = old_value;
		StorageTmp->mtpSlL3ProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT2;
		StorageTmp->mtpSlL3ProfileTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT4;
		StorageTmp->mtpSlL3ProfileTimerT4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT5;
		StorageTmp->mtpSlL3ProfileTimerT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT12;
		StorageTmp->mtpSlL3ProfileTimerT12 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT12 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT13;
		StorageTmp->mtpSlL3ProfileTimerT13 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT13 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT14;
		StorageTmp->mtpSlL3ProfileTimerT14 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT14 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT19A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT19A;
		StorageTmp->mtpSlL3ProfileTimerT19A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT19A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT20A;
		StorageTmp->mtpSlL3ProfileTimerT20A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT20A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT21A;
		StorageTmp->mtpSlL3ProfileTimerT21A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT21A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT22I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT22I;
		StorageTmp->mtpSlL3ProfileTimerT22I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT22I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT23I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT23I;
		StorageTmp->mtpSlL3ProfileTimerT23I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT23I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT31A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 1000..12000 */
		if ((1000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT31A;
		StorageTmp->mtpSlL3ProfileTimerT31A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT31A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT32A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT32A;
		StorageTmp->mtpSlL3ProfileTimerT32A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT32A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT33A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 36000 */
		/* Note: ranges 6000..60000 */
		if ((6000 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT33A;
		StorageTmp->mtpSlL3ProfileTimerT33A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT33A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT34A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT34A;
		StorageTmp->mtpSlL3ProfileTimerT34A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT34A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT1T;
		StorageTmp->mtpSlL3ProfileTimerT1T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT2T;
		StorageTmp->mtpSlL3ProfileTimerT2T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT2T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1S entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT1S;
		StorageTmp->mtpSlL3ProfileTimerT1S = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1S = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileL2Default(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileL2Default(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileL2Default entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileL2Default;
		old_length = StorageTmp->mtpSlL3ProfileL2DefaultLen;
		StorageTmp->mtpSlL3ProfileL2Default = string;
		StorageTmp->mtpSlL3ProfileL2DefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileL2Default = old_value;
		StorageTmp->mtpSlL3ProfileL2DefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileErrorCorrectionMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileErrorCorrectionMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileErrorCorrectionMethod entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLL2PROFILEERRORCORRECTIONMETHOD_BASICRETR:
		case MTPSLL2PROFILEERRORCORRECTIONMETHOD_PREVCYCLRETR:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileErrorCorrectionMethod;
		StorageTmp->mtpSlL2ProfileErrorCorrectionMethod = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileErrorCorrectionMethod = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTransmissionRate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLL2PROFILETRANSMISSIONRATE_KBITS4POINT8:
		case MTPSLL2PROFILETRANSMISSIONRATE_KBITS56:
		case MTPSLL2PROFILETRANSMISSIONRATE_KBITS64:
		case MTPSLL2PROFILETRANSMISSIONRATE_KBITS1544:
		case MTPSLL2PROFILETRANSMISSIONRATE_KBITS2048:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTransmissionRate;
		StorageTmp->mtpSlL2ProfileTransmissionRate = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTransmissionRate = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1290..60000 */
		if ((1290 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT1;
		StorageTmp->mtpSlL2ProfileTimerT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 500..15000 */
		if ((500 > set_value || set_value > 15000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT2;
		StorageTmp->mtpSlL2ProfileTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT2L(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT2L(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2L entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT2L;
		StorageTmp->mtpSlL2ProfileTimerT2L = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2L = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT2H(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT2H(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2H entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT2H;
		StorageTmp->mtpSlL2ProfileTimerT2H = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2H = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 100..1400 */
		if ((100 > set_value || set_value > 1400)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT3;
		StorageTmp->mtpSlL2ProfileTimerT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT4N(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT4N(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT4N entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 230..12000 */
		if ((230 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT4N;
		StorageTmp->mtpSlL2ProfileTimerT4N = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT4N = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT4E(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT4E(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT4E entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 40..800 */
		if ((40 > set_value || set_value > 800)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT4E;
		StorageTmp->mtpSlL2ProfileTimerT4E = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT4E = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..12 */
		if ((8 > set_value || set_value > 12)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT5;
		StorageTmp->mtpSlL2ProfileTimerT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 300..1200 */
		if ((300 > set_value || set_value > 1200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT6;
		StorageTmp->mtpSlL2ProfileTimerT6 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT6 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 50..600 */
		if ((50 > set_value || set_value > 600)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT7;
		StorageTmp->mtpSlL2ProfileTimerT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbOnset1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbOnset1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbOnset1;
		StorageTmp->mtpSlL2ProfileTbOnset1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbAbate1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbAbate1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbAbate1;
		StorageTmp->mtpSlL2ProfileTbAbate1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileNumberOfThresholdLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileNumberOfThresholdLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileNumberOfThresholdLevels entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels;
		StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileCongestionCounting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileCongestionCounting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileCongestionCounting entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLL2PROFILECONGESTIONCOUNTING_OCTET:
		case MTPSLL2PROFILECONGESTIONCOUNTING_MESSAGE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileCongestionCounting;
		StorageTmp->mtpSlL2ProfileCongestionCounting = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileCongestionCounting = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileCongestionReportingBaseObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileCongestionReportingBaseObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileCongestionReportingBaseObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_ROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_LINKSETOFCONGESTEDROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_LINKOFCONGESTEDROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_CONGESTEDLINKOFCONGESTEDROUTE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject;
		StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileLoopDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileLoopDelay;
		StorageTmp->mtpSlL2ProfileLoopDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileLoopDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileName;
		old_length = StorageTmp->mtpSlL2ProfileNameLen;
		StorageTmp->mtpSlL2ProfileName = string;
		StorageTmp->mtpSlL2ProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileName = old_value;
		StorageTmp->mtpSlL2ProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbOnset2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbOnset2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbOnset2;
		StorageTmp->mtpSlL2ProfileTbOnset2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbAbate2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbAbate2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbAbate2;
		StorageTmp->mtpSlL2ProfileTbAbate2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbOnset3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbOnset3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbOnset3;
		StorageTmp->mtpSlL2ProfileTbOnset3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbAbate3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbAbate3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbAbate3;
		StorageTmp->mtpSlL2ProfileTbAbate3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbDiscard1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbDiscard1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbDiscard1;
		StorageTmp->mtpSlL2ProfileTbDiscard1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbDiscard2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbDiscard2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbDiscard2;
		StorageTmp->mtpSlL2ProfileTbDiscard2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbDiscard3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbDiscard3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbDiscard3;
		StorageTmp->mtpSlL2ProfileTbDiscard3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerTx(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerTx(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerTx entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerTx;
		StorageTmp->mtpSlL2ProfileTimerTx = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerTx = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerTy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerTy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerTy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerTy;
		StorageTmp->mtpSlL2ProfileTimerTy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerTy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileNumberOfCongestionStates(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileNumberOfCongestionStates(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileNumberOfCongestionStates entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileNumberOfCongestionStates;
		StorageTmp->mtpSlL2ProfileNumberOfCongestionStates = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileNumberOfCongestionStates = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileInitialLevelOfCongestion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileInitialLevelOfCongestion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileInitialLevelOfCongestion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion;
		StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileMaxMSUsRetransN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileMaxMSUsRetransN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileMaxMSUsRetransN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..16777215 */
		if ((0 > set_value || set_value > 16777215)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1;
		StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileMaxOctRetransN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileMaxOctRetransN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileMaxOctRetransN2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileMaxOctRetransN2;
		StorageTmp->mtpSlL2ProfileMaxOctRetransN2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileMaxOctRetransN2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileReceiveCongestionThresholdOnset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileReceiveCongestionThresholdOnset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdOnset entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileReceiveCongestionThresholdAbate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileReceiveCongestionThresholdAbate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdAbate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileReceiveCongestionThresholdDiscard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileReceiveCongestionThresholdDiscard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdDiscard entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileM entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileM;
		StorageTmp->mtpSlL2ProfileM = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileM = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSlsCodeCurrentList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSlsCodeCurrentList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSlsCodeCurrentList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeCurrentList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeCurrentList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..256 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 256))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeCurrentList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSlSlsCodeCurrentList;
		old_length = StorageTmp->mtpSlSlsCodeCurrentListLen;
		StorageTmp->mtpSlSlsCodeCurrentList = string;
		StorageTmp->mtpSlSlsCodeCurrentListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSlsCodeCurrentList = old_value;
		StorageTmp->mtpSlSlsCodeCurrentListLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlMaxCapacitySL(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlMaxCapacitySL(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlMaxCapacitySL entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMaxCapacitySL: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMaxCapacitySL not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMaxCapacitySL: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..512000 */
		if ((0 > set_value || set_value > 512000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMaxCapacitySL: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlMaxCapacitySL;
		StorageTmp->mtpSlMaxCapacitySL = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlMaxCapacitySL = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPSLADMINISTRATIVESTATE_LOCKED:
		case MTPSLADMINISTRATIVESTATE_UNLOCKED:
		case MTPSLADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlAdministrativeState;
		StorageTmp->mtpSlAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlMtpL2ProtocolProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlMtpL2ProtocolProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlMtpL2ProtocolProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSlMtpL2ProtocolProfilePointer;
		old_length = StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen;
		StorageTmp->mtpSlMtpL2ProtocolProfilePointer = string;
		StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlMtpL2ProtocolProfilePointer = old_value;
		StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSignTermPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSignTermPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSignTermPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpSlSignTermPointer;
		old_length = StorageTmp->mtpSlSignTermPointerLen;
		StorageTmp->mtpSlSignTermPointer = objid;
		StorageTmp->mtpSlSignTermPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSignTermPointer = old_value;
		StorageTmp->mtpSlSignTermPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSignDataLinkTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSignDataLinkTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSignDataLinkTpPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpSlSignDataLinkTpPointer;
		old_length = StorageTmp->mtpSlSignDataLinkTpPointerLen;
		StorageTmp->mtpSlSignDataLinkTpPointer = objid;
		StorageTmp->mtpSlSignDataLinkTpPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSignDataLinkTpPointer = old_value;
		StorageTmp->mtpSlSignDataLinkTpPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlLocalInhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlLocalInhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlLocalInhibit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLLOCALINHIBIT_SUCCESS:
		case MTPSLLOCALINHIBIT_UNSUCCESSFUL:
		case MTPSLLOCALINHIBIT_NOTPERFORMED:
		case MTPSLLOCALINHIBIT_LINKALREADYINHIBITED:
		case MTPSLLOCALINHIBIT_LINKNOTINHIBITED:
		case MTPSLLOCALINHIBIT_WRONGCLASSREFERENCED:
		case MTPSLLOCALINHIBIT_SIGNTERMNONEXISTING:
		case MTPSLLOCALINHIBIT_SIGNTERMALREADYREFERENCED:
		case MTPSLLOCALINHIBIT_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlLocalInhibit;
		StorageTmp->mtpSlLocalInhibit = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalInhibit = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlLocalUninhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlLocalUninhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlLocalUninhibit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLLOCALUNINHIBIT_SUCCESS:
		case MTPSLLOCALUNINHIBIT_UNSUCCESSFUL:
		case MTPSLLOCALUNINHIBIT_NOTPERFORMED:
		case MTPSLLOCALUNINHIBIT_LINKALREADYINHIBITED:
		case MTPSLLOCALUNINHIBIT_LINKNOTINHIBITED:
		case MTPSLLOCALUNINHIBIT_WRONGCLASSREFERENCED:
		case MTPSLLOCALUNINHIBIT_SIGNTERMNONEXISTING:
		case MTPSLLOCALUNINHIBIT_SIGNTERMALREADYREFERENCED:
		case MTPSLLOCALUNINHIBIT_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlLocalUninhibit;
		StorageTmp->mtpSlLocalUninhibit = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalUninhibit = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlReplaceSt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlReplaceSt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlReplaceSt entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLREPLACEST_SUCCESS:
		case MTPSLREPLACEST_UNSUCCESSFUL:
		case MTPSLREPLACEST_NOTPERFORMED:
		case MTPSLREPLACEST_LINKALREADYINHIBITED:
		case MTPSLREPLACEST_LINKNOTINHIBITED:
		case MTPSLREPLACEST_WRONGCLASSREFERENCED:
		case MTPSLREPLACEST_SIGNTERMNONEXISTING:
		case MTPSLREPLACEST_SIGNTERMALREADYREFERENCED:
		case MTPSLREPLACEST_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlReplaceSt;
		StorageTmp->mtpSlReplaceSt = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlReplaceSt = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpSlAsaProfilePointer;
		old_length = StorageTmp->mtpSlAsaProfilePointerLen;
		StorageTmp->mtpSlAsaProfilePointer = objid;
		StorageTmp->mtpSlAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAsaProfilePointer = old_value;
		StorageTmp->mtpSlAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlRelatedLinkGroupNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlRelatedLinkGroupNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlRelatedLinkGroupNumber entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..15 */
		if ((0 > set_value || set_value > 15)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlRelatedLinkGroupNumber;
		StorageTmp->mtpSlRelatedLinkGroupNumber = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlRelatedLinkGroupNumber = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdlList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdlList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdlList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlSdlList;
		StorageTmp->mtpSlSdlList = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdlList = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlTest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlTest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlTest entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLTEST_SUCCESS:
		case MTPSLTEST_UNSUCCESSFUL:
		case MTPSLTEST_NOTPERFORMED:
		case MTPSLTEST_LINKALREADYINHIBITED:
		case MTPSLTEST_LINKNOTINHIBITED:
		case MTPSLTEST_WRONGCLASSREFERENCED:
		case MTPSLTEST_SIGNTERMNONEXISTING:
		case MTPSLTEST_SIGNTERMALREADYREFERENCED:
		case MTPSLTEST_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlTest;
		StorageTmp->mtpSlTest = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlTest = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSlName;
		old_length = StorageTmp->mtpSlNameLen;
		StorageTmp->mtpSlName = string;
		StorageTmp->mtpSlNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlName = old_value;
		StorageTmp->mtpSlNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdtList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdtList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdtList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSlSdtList;
		StorageTmp->mtpSlSdtList = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdtList = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSlsCodeNormalList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSlsCodeNormalList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSlsCodeNormalList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..256 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 256))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSlSlsCodeNormalList;
		old_length = StorageTmp->mtpSlSlsCodeNormalListLen;
		StorageTmp->mtpSlSlsCodeNormalList = string;
		StorageTmp->mtpSlSlsCodeNormalListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSlsCodeNormalList = old_value;
		StorageTmp->mtpSlSlsCodeNormalListLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSlL3ProfilePointer;
		old_length = StorageTmp->mtpSlL3ProfilePointerLen;
		StorageTmp->mtpSlL3ProfilePointer = string;
		StorageTmp->mtpSlL3ProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfilePointer = old_value;
		StorageTmp->mtpSlL3ProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSlAlarmStatus;
		old_length = StorageTmp->mtpSlAlarmStatusLen;
		StorageTmp->mtpSlAlarmStatus = string;
		StorageTmp->mtpSlAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAlarmStatus = old_value;
		StorageTmp->mtpSlAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdlListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdlListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdlListPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlSdlListRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpSlSdlListPointer;
		old_length = StorageTmp->mtpSlSdlListPointerLen;
		StorageTmp->mtpSlSdlListPointer = objid;
		StorageTmp->mtpSlSdlListPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdlListPointer = old_value;
		StorageTmp->mtpSlSdlListPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdtListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdtListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdtListPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlSdtListRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpSlSdtListPointer;
		old_length = StorageTmp->mtpSlSdtListPointerLen;
		StorageTmp->mtpSlSdtListPointer = objid;
		StorageTmp->mtpSlSdtListPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdtListPointer = old_value;
		StorageTmp->mtpSlSdtListPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPNBTRANSMISSIONRATE_KBITS4POINT8:
		case MTPNBTRANSMISSIONRATE_KBITS56:
		case MTPNBTRANSMISSIONRATE_KBITS64:
		case MTPNBTRANSMISSIONRATE_KBITS1544:
		case MTPNBTRANSMISSIONRATE_KBITS2048:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbTransmissionRate;
		StorageTmp->mtpNbTransmissionRate = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTransmissionRate = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTimerT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTimerT8: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTimerT8 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTimerT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbTimerT8;
		StorageTmp->mtpNbTimerT8 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTimerT8 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbTin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbTin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTin: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* Note: ranges 4..4 */
		if (set_value != 4) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTin: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbTin;
		StorageTmp->mtpNbTin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbTie(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbTie(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTie entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTie: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTie not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTie: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		/* Note: ranges 1..1 */
		if (set_value != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTie: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbTie;
		StorageTmp->mtpNbTie = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTie = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbT not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		/* Note: ranges 256..256 */
		if (set_value != 256) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbT: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbT;
		StorageTmp->mtpNbT = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbT = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbD(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbD(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbD entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbD: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbD not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbD: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 64 */
		/* Note: ranges 64..64 */
		if (set_value != 64) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbD: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbD;
		StorageTmp->mtpNbD = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbD = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbTe(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbTe(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTe entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTe: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTe not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTe: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbTe;
		StorageTmp->mtpNbTe = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTe = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbDe(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbDe(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbDe entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbDe: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbDe not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbDe: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbDe;
		StorageTmp->mtpNbDe = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbDe = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbUe(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbUe(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbUe entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbUe: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbUe not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbUe: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbUe;
		StorageTmp->mtpNbUe = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbUe = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbN(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbN(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbN entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbN: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbN not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbN: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 16 */
		/* Note: ranges 16..16 */
		if (set_value != 16) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbN: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbN;
		StorageTmp->mtpNbN = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbN = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbm: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbm not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 272 */
		/* Note: ranges 272..272 4096..4096 */
		if (set_value != 272 && set_value != 4096) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbm: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbm;
		StorageTmp->mtpNbm = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbm = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbb(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbb(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbb entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbb: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbb not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbb: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..8 192..192 256..256 */
		if (set_value != 8 && set_value != 192 && set_value != 256) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbb: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbb;
		StorageTmp->mtpNbb = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbb = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbf(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbf(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbf entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value one */
		switch (set_value) {
		case MTPNBF_ONE:
		case MTPNBF_SHARED:
		case MTPNBF_TWO:
		case MTPNBF_THREE:
		case MTPNBF_FOUR:
		case MTPNBF_FIVE:
		case MTPNBF_SIX:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpNbf;
		StorageTmp->mtpNbf = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbf = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalBufferRelease(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalBufferRelease(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalBufferRelease entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalBufferRelease;
		StorageTmp->mtpSaalBufferRelease = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalBufferRelease = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxCc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalMaxCc;
		StorageTmp->mtpSaalMaxCc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxCc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxNrp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxNrp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxNrp entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalMaxNrp;
		StorageTmp->mtpSaalMaxNrp = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxNrp = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxInformationFieldLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxInformationFieldLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxInformationFieldLength entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4096 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalMaxInformationFieldLength;
		StorageTmp->mtpSaalMaxInformationFieldLength = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxInformationFieldLength = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxLengthSscopUuField(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxLengthSscopUuField(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxLengthSscopUuField entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalMaxLengthSscopUuField;
		StorageTmp->mtpSaalMaxLengthSscopUuField = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxLengthSscopUuField = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxPd(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxPd(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxPd entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalMaxPd;
		StorageTmp->mtpSaalMaxPd = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxPd = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxSscopCreditToPeer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxSscopCreditToPeer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxSscopCreditToPeer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalMaxSscopCreditToPeer;
		StorageTmp->mtpSaalMaxSscopCreditToPeer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxSscopCreditToPeer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxStat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxStat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxStat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 67 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalMaxStat;
		StorageTmp->mtpSaalMaxStat = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxStat = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalN1;
		StorageTmp->mtpSaalN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniLayerManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniLayerManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementProvingState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_NORMAL:
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_EMERGENCY:
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_NEUTRAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalNniLayerManagementProvingState;
		StorageTmp->mtpSaalNniLayerManagementProvingState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementProvingState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniLayerManagementTimerNoCredit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniLayerManagementTimerNoCredit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementTimerNoCredit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniLayerManagementTimerRepeatSrec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniLayerManagementTimerRepeatSrec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementTimerRepeatSrec entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalNniTimerT1;
		StorageTmp->mtpSaalNniTimerT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalNniTimerT2;
		StorageTmp->mtpSaalNniTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalNniTimerT3;
		StorageTmp->mtpSaalNniTimerT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerCc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerCc;
		StorageTmp->mtpSaalSscopTimerCc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerCc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerIdle entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerIdle;
		StorageTmp->mtpSaalSscopTimerIdle = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerIdle = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerKeepAlive entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerKeepAlive;
		StorageTmp->mtpSaalSscopTimerKeepAlive = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerKeepAlive = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerNoResponse(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerNoResponse(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerNoResponse entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 150 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerNoResponse;
		StorageTmp->mtpSaalSscopTimerNoResponse = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerNoResponse = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerPoll(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerPoll(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerPoll entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerPoll;
		StorageTmp->mtpSaalSscopTimerPoll = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerPoll = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 129 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalTransmissionRateIntervalLower;
		StorageTmp->mtpSaalTransmissionRateIntervalLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalEgressTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalEgressTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalEgressTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalEgressTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalEgressTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalEgressTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalPollAfterRetransmission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalPollAfterRetransmission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalPollAfterRetransmission entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSaalPollAfterRetransmission;
		StorageTmp->mtpSaalPollAfterRetransmission = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalPollAfterRetransmission = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paN1;
		StorageTmp->mtpM2paN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paProving(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paProving(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paProving entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paProving;
		StorageTmp->mtpM2paProving = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProving = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paManagementProvingState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPM2PAMANAGEMENTPROVINGSTATE_NORMAL:
		case MTPM2PAMANAGEMENTPROVINGSTATE_EMERGENCY:
		case MTPM2PAMANAGEMENTPROVINGSTATE_NEUTRAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paManagementProvingState;
		StorageTmp->mtpM2paManagementProvingState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paManagementProvingState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paLoopDelayLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paLoopDelayLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paLoopDelayLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paLoopDelayLower;
		StorageTmp->mtpM2paLoopDelayLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paLoopDelayUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paLoopDelayUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paLoopDelayUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paLoopDelayUpper;
		StorageTmp->mtpM2paLoopDelayUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paTransmissionRateIntervalLower;
		StorageTmp->mtpM2paTransmissionRateIntervalLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paTransmissionRateIntervalUpper;
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpNoDelay;
		StorageTmp->mtpM2paSctpNoDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpNoDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..65536 */
		if ((1 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpMaxseg;
		StorageTmp->mtpM2paSctpMaxseg = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxseg = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpHeartbeatItvl;
		StorageTmp->mtpM2paSctpHeartbeatItvl = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeatItvl = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpHeartbeat;
		StorageTmp->mtpM2paSctpHeartbeat = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeat = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpRtoInitial;
		StorageTmp->mtpM2paSctpRtoInitial = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoInitial = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpRtoMin;
		StorageTmp->mtpM2paSctpRtoMin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpRtoMax;
		StorageTmp->mtpM2paSctpRtoMax = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMax = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpPathMaxRetrans;
		StorageTmp->mtpM2paSctpPathMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpPathMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpCookieLife;
		StorageTmp->mtpM2paSctpCookieLife = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieLife = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpCookieInc;
		StorageTmp->mtpM2paSctpCookieInc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieInc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpMaxInitRetries;
		StorageTmp->mtpM2paSctpMaxInitRetries = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxInitRetries = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpMaxBurst;
		StorageTmp->mtpM2paSctpMaxBurst = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxBurst = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpAssocMaxRetrans;
		StorageTmp->mtpM2paSctpAssocMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpAssocMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 0..50 */
		if ((0 > set_value || set_value > 50)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpSackDelay;
		StorageTmp->mtpM2paSctpSackDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpSackDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paSctpLifetime;
		StorageTmp->mtpM2paSctpLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paProvingAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paProvingAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paProvingAttempts entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paProvingAttempts;
		StorageTmp->mtpM2paProvingAttempts = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProvingAttempts = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPSDTADMINISTRATIVESTATE_LOCKED:
		case MTPSDTADMINISTRATIVESTATE_UNLOCKED:
		case MTPSDTADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSdtAdministrativeState;
		StorageTmp->mtpSdtAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtEquipmentPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpSdtEquipmentPointer;
		old_length = StorageTmp->mtpSdtEquipmentPointerLen;
		StorageTmp->mtpSdtEquipmentPointer = objid;
		StorageTmp->mtpSdtEquipmentPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtEquipmentPointer = old_value;
		StorageTmp->mtpSdtEquipmentPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSdtName;
		old_length = StorageTmp->mtpSdtNameLen;
		StorageTmp->mtpSdtName = string;
		StorageTmp->mtpSdtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtName = old_value;
		StorageTmp->mtpSdtNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpSdtProfilePointer;
		old_length = StorageTmp->mtpSdtProfilePointerLen;
		StorageTmp->mtpSdtProfilePointer = objid;
		StorageTmp->mtpSdtProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtProfilePointer = old_value;
		StorageTmp->mtpSdtProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlAdjPc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSdlAdjPc;
		old_length = StorageTmp->mtpSdlAdjPcLen;
		StorageTmp->mtpSdlAdjPc = string;
		StorageTmp->mtpSdlAdjPcLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlAdjPc = old_value;
		StorageTmp->mtpSdlAdjPcLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSDLTRANSMISSIONRATE_KBITS4POINT8:
		case MTPSDLTRANSMISSIONRATE_KBITS56:
		case MTPSDLTRANSMISSIONRATE_KBITS64:
		case MTPSDLTRANSMISSIONRATE_KBITS1544:
		case MTPSDLTRANSMISSIONRATE_KBITS2048:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSdlTransmissionRate;
		StorageTmp->mtpSdlTransmissionRate = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlTransmissionRate = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlLoopDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSdlLoopDelay;
		StorageTmp->mtpSdlLoopDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlLoopDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlOperationalState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlOperationalState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlOperationalState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlOperationalState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlOperationalState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlOperationalState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value disabled */
		switch (set_value) {
		case MTPSDLOPERATIONALSTATE_DISABLED:
		case MTPSDLOPERATIONALSTATE_ENABLED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlOperationalState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSdlOperationalState;
		StorageTmp->mtpSdlOperationalState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlOperationalState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlEquipmentPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpSdlEquipmentPointer;
		old_length = StorageTmp->mtpSdlEquipmentPointerLen;
		StorageTmp->mtpSdlEquipmentPointer = objid;
		StorageTmp->mtpSdlEquipmentPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlEquipmentPointer = old_value;
		StorageTmp->mtpSdlEquipmentPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlCIC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..16383 */
		if ((0 > set_value || set_value > 16383)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpSdlCIC;
		StorageTmp->mtpSdlCIC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlCIC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSdlName;
		old_length = StorageTmp->mtpSdlNameLen;
		StorageTmp->mtpSdlName = string;
		StorageTmp->mtpSdlNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlName = old_value;
		StorageTmp->mtpSdlNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlStmChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlStmChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlStmChannel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->mtpSdlStmChannel;
		old_length = StorageTmp->mtpSdlStmChannelLen;
		StorageTmp->mtpSdlStmChannel = string;
		StorageTmp->mtpSdlStmChannelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlStmChannel = old_value;
		StorageTmp->mtpSdlStmChannelLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlVcTTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlVcTTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlVcTTpPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpSdlVcTTpPointer;
		old_length = StorageTmp->mtpSdlVcTTpPointerLen;
		StorageTmp->mtpSdlVcTTpPointer = objid;
		StorageTmp->mtpSdlVcTTpPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlVcTTpPointer = old_value;
		StorageTmp->mtpSdlVcTTpPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpNoDelay;
		StorageTmp->mtpM2paDefaultSctpNoDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpNoDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		if ((1 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpMaxseg;
		StorageTmp->mtpM2paDefaultSctpMaxseg = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxseg = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpHeartbeatItvl;
		StorageTmp->mtpM2paDefaultSctpHeartbeatItvl = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpHeartbeatItvl = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpHeartbeat;
		StorageTmp->mtpM2paDefaultSctpHeartbeat = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpHeartbeat = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpRtoInitial;
		StorageTmp->mtpM2paDefaultSctpRtoInitial = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoInitial = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpRtoMin;
		StorageTmp->mtpM2paDefaultSctpRtoMin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoMin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpRtoMax;
		StorageTmp->mtpM2paDefaultSctpRtoMax = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoMax = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpPathMaxRetrans;
		StorageTmp->mtpM2paDefaultSctpPathMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpPathMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpCookieLife;
		StorageTmp->mtpM2paDefaultSctpCookieLife = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpCookieLife = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpCookieInc;
		StorageTmp->mtpM2paDefaultSctpCookieInc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpCookieInc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpMaxInitRetries;
		StorageTmp->mtpM2paDefaultSctpMaxInitRetries = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxInitRetries = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpMaxBurst;
		StorageTmp->mtpM2paDefaultSctpMaxBurst = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxBurst = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans;
		StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..50 */
		if ((0 > set_value || set_value > 50)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpSackDelay;
		StorageTmp->mtpM2paDefaultSctpSackDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpSackDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paDefaultSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpM2paDefaultSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paDefaultSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpM2paDefaultSctpLifetime;
		StorageTmp->mtpM2paDefaultSctpLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL;
	static struct mtpSapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSapRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSapTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSapTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpSapTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSapId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSapTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSapTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSapRowStatus;
			StorageTmp->mtpSapRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSapTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpSapTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSapRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSapTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSapRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSapRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSapTable_destroy(&StorageDel);
			/* mtpSapTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpMsStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMsTable_data *StorageTmp = NULL;
	static struct mtpMsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpMsStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpMsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpMsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpMsTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpMsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpMsTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpMsStatus;
			StorageTmp->mtpMsStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpMsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpMsTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpMsStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpMsTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpMsStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpMsStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpMsTable_destroy(&StorageDel);
			/* mtpMsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpNaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL;
	static struct mtpNaTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpNaRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpNaTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpNaTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpNaId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpNaTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpNaId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpNaTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpNaTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpNaRowStatus;
			StorageTmp->mtpNaRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpNaTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpNaTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpNaRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpNaTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpNaRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpNaRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpNaTable_destroy(&StorageDel);
			/* mtpNaTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpGsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL;
	static struct mtpGsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpGsTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpGsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpGsTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpGsRowStatus;
			StorageTmp->mtpGsRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpGsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpGsTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpGsRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpGsTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpGsTable_destroy(&StorageDel);
			/* mtpGsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpGsLineRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineTable_data *StorageTmp = NULL;
	static struct mtpGsLineTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsLineRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsLineTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsLineTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsLineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpGsLineTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpGsLineTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpGsLineTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpGsLineRowStatus;
			StorageTmp->mtpGsLineRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpGsLineTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpGsLineTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpGsLineRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpGsLineTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsLineRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsLineRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpGsLineTable_destroy(&StorageDel);
			/* mtpGsLineTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpGsLineContentRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static struct mtpGsLineContentTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsLineContentRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsLineContentTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsLineContentTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsLineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpGsLineContentId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpGsLineContentTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineContentId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpGsLineContentTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpGsLineContentTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpGsLineContentRowStatus;
			StorageTmp->mtpGsLineContentRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpGsLineContentTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpGsLineContentTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpGsLineContentRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpGsLineContentTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsLineContentRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpGsLineContentRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpGsLineContentTable_destroy(&StorageDel);
			/* mtpGsLineContentTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static struct mtpSpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSpProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSpProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSpProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpSpProfileTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSpProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSpProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSpProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSpProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSpProfileRowStatus;
			StorageTmp->mtpSpProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSpProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpSpProfileTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSpProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSpProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSpProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSpProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSpProfileTable_destroy(&StorageDel);
			/* mtpSpProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL;
	static struct mtpSpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSpTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSpTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpSpTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSpTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSpTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSpRowStatus;
			StorageTmp->mtpSpRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSpTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpSpTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSpRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSpTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSpRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSpRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSpTable_destroy(&StorageDel);
			/* mtpSpTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpL3RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpL3Table_data *StorageTmp = NULL;
	static struct mtpL3Table_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3RowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3RowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpL3RowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpL3Table_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpL3Table_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpL3Id */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpL3Table_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpL3Id, vp->val.string, vp->val_len);
			StorageNew->mtpL3IdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpL3Table_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpL3Table_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpL3RowStatus;
			StorageTmp->mtpL3RowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpL3Table_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpL3Table_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpL3RowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpL3Table_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpL3RowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpL3RowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpL3Table_destroy(&StorageDel);
			/* mtpL3Table_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static struct mtpRsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRsProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRsProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRsProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpRsProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpRsProfileTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpRsProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpRsProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRsProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpRsProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRsProfileRowStatus;
			StorageTmp->mtpRsProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRsProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpRsProfileTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRsProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRsProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRsProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRsProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRsProfileTable_destroy(&StorageDel);
			/* mtpRsProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL;
	static struct mtpRsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpRsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpRsTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpRsTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRsRowStatus;
			StorageTmp->mtpRsRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpRsTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRsRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRsTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRsTable_destroy(&StorageDel);
			/* mtpRsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRtProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	static struct mtpRtProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRtProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRtProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRtProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpRtProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpRtProfileTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpRtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpRtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRtProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpRtProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRtProfileRowStatus;
			StorageTmp->mtpRtProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRtProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpRtProfileTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRtProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRtProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRtProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRtProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRtProfileTable_destroy(&StorageDel);
			/* mtpRtProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL;
	static struct mtpRtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRtRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpRsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpRtId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpRtTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRtId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRtTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpRtTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRtRowStatus;
			StorageTmp->mtpRtRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpRtTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRtRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRtTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRtRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpRtRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRtTable_destroy(&StorageDel);
			/* mtpRtTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpLsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static struct mtpLsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpLsProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpLsProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpLsProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpLsProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpLsProfileTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpLsProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpLsProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpLsProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpLsProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpLsProfileRowStatus;
			StorageTmp->mtpLsProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpLsProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpLsProfileTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpLsProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpLsProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpLsProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpLsProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpLsProfileTable_destroy(&StorageDel);
			/* mtpLsProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpLsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL;
	static struct mtpLsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpLsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpLsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpLsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpLsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpLsTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpLsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpLsTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpLsRowStatus;
			StorageTmp->mtpLsRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpLsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpLsTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpLsRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpLsTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpLsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpLsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpLsTable_destroy(&StorageDel);
			/* mtpLsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlL3ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static struct mtpSlL3ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlL3ProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpSlL3ProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlL3ProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlL3ProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlL3ProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSlL3ProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSlL3ProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpSlL3ProfileTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSlL3ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSlL3ProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlL3ProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSlL3ProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlL3ProfileRowStatus;
			StorageTmp->mtpSlL3ProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlL3ProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpSlL3ProfileTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlL3ProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlL3ProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlL3ProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlL3ProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlL3ProfileTable_destroy(&StorageDel);
			/* mtpSlL3ProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlL2ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static struct mtpSlL2ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlL2ProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpSlL2ProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlL2ProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlL2ProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlL2ProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSlL2ProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* mtpSlL2ProfileTransmissionRate */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSlL2ProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpSlL2ProfileTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSlL2ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSlL2ProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			StorageNew->mtpSlL2ProfileTransmissionRate = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlL2ProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSlL2ProfileTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlL2ProfileRowStatus;
			StorageTmp->mtpSlL2ProfileRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlL2ProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpSlL2ProfileTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlL2ProfileRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlL2ProfileTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlL2ProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlL2ProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlL2ProfileTable_destroy(&StorageDel);
			/* mtpSlL2ProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL;
	static struct mtpSlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpLsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSlSlCode */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpSlTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSlCode = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSlTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlRowStatus;
			StorageTmp->mtpSlRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpSlTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlTable_destroy(&StorageDel);
			/* mtpSlTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdlListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlSdlListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	static struct mtpSlSdlListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlSdlListRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlSdlListTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlSdlListTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpLsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSlSlCode */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSlSdlListId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpSlSdlListTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSlCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdlListId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlSdlListTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSlSdlListTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdlListRowStatus;
			StorageTmp->mtpSlSdlListRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlSdlListTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpSlSdlListTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlSdlListRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlSdlListTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlSdlListRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlSdlListRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlSdlListTable_destroy(&StorageDel);
			/* mtpSlSdlListTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdtListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlSdtListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	static struct mtpSlSdtListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlSdtListRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlSdtListTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlSdtListTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpLsId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSlSlCode */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* mtpSlSdtListId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpSlSdtListTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSlCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdtListId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlSdtListTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSlSdtListTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdtListRowStatus;
			StorageTmp->mtpSlSdtListRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlSdtListTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpSlSdtListTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlSdtListRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlSdtListTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlSdtListRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSlSdtListRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlSdtListTable_destroy(&StorageDel);
			/* mtpSlSdtListTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpNbRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNbTable_data *StorageTmp = NULL;
	static struct mtpNbTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpNbTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpNbTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpNbRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpNbTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpNbTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpNbTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpNbTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpNbTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpNbTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpNbRowStatus;
			StorageTmp->mtpNbRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpNbTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpNbTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpNbRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpNbTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpNbRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpNbRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpNbTable_destroy(&StorageDel);
			/* mtpNbTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSaalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL;
	static struct mtpSaalTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSaalRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSaalTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSaalTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpSaalTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSaalTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSaalTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSaalRowStatus;
			StorageTmp->mtpSaalRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSaalTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpSaalTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSaalRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSaalTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSaalRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSaalRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSaalTable_destroy(&StorageDel);
			/* mtpSaalTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpM2paRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL;
	static struct mtpM2paTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM2paRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM2paTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM2paTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpM2paTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpM2paTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpM2paTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpM2paRowStatus;
			StorageTmp->mtpM2paRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpM2paTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpM2paTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpM2paRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpM2paTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpM2paRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpM2paRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpM2paTable_destroy(&StorageDel);
			/* mtpM2paTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSdtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdtTable_data *StorageTmp = NULL;
	static struct mtpSdtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSdtRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSdtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSdtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdtId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpSdtTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSdtId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSdtTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSdtTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSdtRowStatus;
			StorageTmp->mtpSdtRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSdtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpSdtTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSdtRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSdtTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSdtRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSdtRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSdtTable_destroy(&StorageDel);
			/* mtpSdtTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSdlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL;
	static struct mtpSdlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSdlRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSdlTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSdlTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdlId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mtpSdlTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSdlId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSdlTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpSdlTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSdlRowStatus;
			StorageTmp->mtpSdlRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSdlTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mtpSdlTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSdlRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSdlTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSdlRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpSdlRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSdlTable_destroy(&StorageDel);
			/* mtpSdlTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
