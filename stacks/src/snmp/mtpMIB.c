/*****************************************************************************

 @(#) $RCSfile: mtpMIB.c,v $ $Name:  $($Revision: 0.9.2.12 $) $Date: 2009-01-16 20:44:53 $

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2009  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2009-01-16 20:44:53 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: mtpMIB.c,v $
 Revision 0.9.2.12  2009-01-16 20:44:53  brian
 - updating mibs and agents

 Revision 0.9.2.11  2009-01-14 14:29:59  brian
 - working up agents

 Revision 0.9.2.10  2009-01-10 18:18:35  brian
 - corrections

 Revision 0.9.2.9  2009-01-10 17:09:14  brian
 - updated agents

 Revision 0.9.2.8  2009-01-04 13:16:01  brian
 - updated agents

 Revision 0.9.2.7  2009-01-03 10:51:01  brian
 - updated agent

 Revision 0.9.2.6  2009-01-02 15:46:39  brian
 - corrections

 Revision 0.9.2.5  2009-01-02 15:04:11  brian
 - updated agents

 Revision 0.9.2.4  2008-12-31 16:04:43  brian
 - updated mibs

 *****************************************************************************/

#ident "@(#) $RCSfile: mtpMIB.c,v $ $Name:  $($Revision: 0.9.2.12 $) $Date: 2009-01-16 20:44:53 $"

static char const ident[] = "$RCSfile: mtpMIB.c,v $ $Name:  $($Revision: 0.9.2.12 $) $Date: 2009-01-16 20:44:53 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "mtpMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#undef MASTER
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;
#endif				/* !defined MODULE */
extern int sa_fclose;			/* default close files between requests */
static int my_fd;			/* file descriptor for this MIB's use */
extern int sa_fd;			/* file descriptor for MIB use */
extern int sa_readfd;			/* file descriptor for autonomnous events */
extern int sa_changed;			/* indication to reread MIB configuration */
extern int sa_stats_refresh;		/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_request;			/* request number for per-request actions */
volatile int mtpMIB_refresh = 1;
volatile int mtpSapTable_refresh = 1;
volatile int mtpNaTable_refresh = 1;
volatile int mtpMsTable_refresh = 1;
volatile int mtpSpProfileTable_refresh = 1;
volatile int mtpSpTable_refresh = 1;
volatile int mtpL3Table_refresh = 1;
volatile int mtpGsTable_refresh = 1;
volatile int mtpGsLineTable_refresh = 1;
volatile int mtpGsLineContentTable_refresh = 1;
volatile int mtpRsProfileTable_refresh = 1;
volatile int mtpRsTable_refresh = 1;
volatile int mtpRtProfileTable_refresh = 1;
volatile int mtpRtTable_refresh = 1;
volatile int mtpRtLsaTable_refresh = 1;
volatile int mtpLsProfileTable_refresh = 1;
volatile int mtpLsTable_refresh = 1;
volatile int mtpSlL3ProfileTable_refresh = 1;
volatile int mtpSlL2ProfileTable_refresh = 1;
volatile int mtpSlTable_refresh = 1;
volatile int mtpSlSdlListTable_refresh = 1;
volatile int mtpSlSdtListTable_refresh = 1;
volatile int mtpNbTable_refresh = 1;
volatile int mtpSaalTable_refresh = 1;
volatile int mtpM2paTable_refresh = 1;
volatile int mtpSdtTable_refresh = 1;
volatile int mtpSdlTable_refresh = 1;
volatile int mtpSctpProfileTable_refresh = 1;
volatile int mtpSctpTable_refresh = 1;
volatile int mtpSctpLocalTable_refresh = 1;
volatile int mtpSctpRemoteTable_refresh = 1;
volatile int mtpM2uaAspTable_refresh = 1;
volatile int mtpM2uaAsTable_refresh = 1;
volatile int mtpM3uaAspTable_refresh = 1;
volatile int mtpM3uaAsTable_refresh = 1;

/*
 * mtpMIB_variables_oid: object identifier for mtpMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid mtpMIB_variables_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3 };
oid mtpSapTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 1, 1, 1 };
oid mtpNaTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 2, 1, 1 };
oid mtpMsTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 3, 1, 1 };
oid mtpSpProfileTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 4, 1, 1 };
oid mtpSpTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 4, 2, 1 };
oid mtpL3Table_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 5, 1, 1 };
oid mtpGsTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 6, 1, 1 };
oid mtpGsLineTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 6, 2, 1 };
oid mtpGsLineContentTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 6, 3, 1 };
oid mtpRsProfileTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 7, 1, 1 };
oid mtpRsTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 7, 2, 1 };
oid mtpRtProfileTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 8, 1, 1 };
oid mtpRtTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 8, 2, 1 };
oid mtpLsProfileTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 9, 1, 1 };
oid mtpLsTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 9, 2, 1 };
oid mtpSlL3ProfileTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 1, 1 };
oid mtpSlL2ProfileTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 2, 1 };
oid mtpSlTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 3, 1 };
oid mtpSlSdlListTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 4, 1 };
oid mtpSlSdtListTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 10, 5, 1 };
oid mtpNbTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 1, 1 };
oid mtpSaalTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 2, 1 };
oid mtpM2paTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 3, 1 };
oid mtpSdtTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 11, 4, 1 };
oid mtpSdlTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 12, 1, 1 };
oid mtpSctpProfileTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 13, 1, 1 };
oid mtpSctpTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 13, 2, 1 };
oid mtpSctpLocalTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 13, 3, 1 };
oid mtpSctpRemoteTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 13, 4, 1 };
oid mtpM2uaAspTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 13, 5, 1 };
oid mtpM2uaAsTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 13, 6, 1 };
oid mtpM3uaAspTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 13, 7, 1 };
oid mtpM3uaAsTable_variables_oid[16] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 1, 13, 8, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid mtpRestarting_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 1 };
oid ss7OnOccEvent_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 2 };
oid sdlEventLostSync_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 3 };
oid sdlEventSuError_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 4 };
oid sdlEventTxFail_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 5 };
oid sdlEventRxFail_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 6 };
oid sdtEventLostSync_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 7 };
oid sdtEventSuError_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 8 };
oid sdtEventTxFail_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 9 };
oid sdtEventRxFail_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 10 };
oid sdtEventCarrier_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 11 };
oid slEventFailureAllReasons_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 12 };
oid slEventFailureAbnormalBsnrFibr_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 13 };
oid slEventFailureExcessiveDelayOfAck_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 14 };
oid slEventFailureExcessiveErrorRate_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 15 };
oid slEventFailureExcessiveDurationCongestion_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 16 };
oid slEventLocalAutomaticChangeover_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 17 };
oid slEventLocalAutomaticChangeback_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 18 };
oid slEventRestoration_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 19 };
oid slEventRpoStartEvent_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 20 };
oid slEventRpoStopEvent_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 21 };
oid slEventLocalInhibitionStart_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 22 };
oid slEventLocalInhibitionStop_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 23 };
oid slEventRemoteInhibitionStart_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 24 };
oid slEventRemoteInhibitionStop_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 25 };
oid slEventCongestionStart_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 26 };
oid slEventCongestionStop_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 27 };
oid slEventCongestionLoss_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 28 };
oid lkEventFailureStart_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 29 };
oid lkEventFailureStop_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 30 };
oid lkEventSendTFP_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 31 };
oid lkEventSendTFA_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 32 };
oid rsEventUnavailableStart_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 33 };
oid rsEventUnavailableStop_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 34 };
oid rsEventAdjSpLinkSetChange_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 35 };
oid rsEventAdjSPInaccessibleStart_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 36 };
oid rsEventAdjSpInaccessibleStop_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 37 };
oid rsEventRecvTFC_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 38 };
oid spEventMsuDiscard_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 39 };
oid spEventUpuSent_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 40 };
oid spEventUpuRecv_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 0, 41 };

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid changeInLsToAdjSp_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3, 1 };
oid oldLs_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3, 2 };
oid newLs_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3, 3 };
oid inaccessibleSp_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3, 4 };
oid remoteUnavailableUserPart_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3, 5 };
oid congestionStatus_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3, 6 };
oid networkPointCode_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3, 7 };
oid userPart_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3, 8 };
oid userPartStatus_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3, 9 };
oid linkFailureReason_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 3, 10 };

/*
 * Other oids defined in this MIB.
 */
oid mtpProtocolItut_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1, 1 };
oid mtpProtocolEtsi_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1, 2 };
oid mtpProtocolAnsi_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1, 3 };
oid mtpProtocolJttc_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1, 4 };
oid mtpProtocolChin_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1, 5 };
oid mtpProtocolPnoc_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1, 6 };
oid mtpProtocolSing_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1, 7 };
oid mtpProtocolSpan_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 1, 8 };
oid localUserPartUnavailable_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 2, 1 };
oid remoteUserPartUnavailable_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 2, 2 };
oid abnormalFIBRorBSNR_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3, 3 };
oid excessiveAckDelay_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3, 4 };
oid excessiveErrorRate_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3, 5 };
oid excessiveCongDuration_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3, 6 };
oid remoteUPUnknown_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3, 7 };
oid remoteUPUnequipped_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3, 8 };
oid remoteUPInaccessible_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 3, 9 };
oid defaultInLsLoadShareAlgorithm_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 4, 1 };
oid mtpLsProfileCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 1 };
oid mtpSapCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 2 };
oid mtpL2ProfocolProfileCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 3 };
oid mtpNbProfileCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 4 };
oid mtpSaalProfileCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 5 };
oid mtpM2paProfileCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 6 };
oid mtpL3Compliacne_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 7 };
oid mtpSpCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 8 };
oid mtpSdlCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 9 };
oid mtpLsCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 10 };
oid mtpSlCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 11 };
oid mtpSlL3ProfileCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 12 };
oid mtpSpProfileCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 13 };
oid mtpRtCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 14 };
oid mtpSignRouteSetNetPartCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 15 };
oid mtpStCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 16 };
oid mtpGsCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 17 };
oid mtpGsLineCompliance_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 1, 18 };
oid mtpLsProfilePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 1 };
oid mtpSapPkg_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 2 };
oid mtpSlL2ProfilePkg_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 3 };
oid mtpL3Package_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 4 };
oid mtpSpPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 5 };
oid mtpSdlPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 6 };
oid mtpLsPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 7 };
oid mtpSlPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 8 };
oid mtpSlL3ProfilePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 9 };
oid mtpSpProfilePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 10 };
oid mtpRtPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 11 };
oid mtpRsPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 12 };
oid mtpStPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 13 };
oid mtpGsPkg_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 14 };
oid mtpGsLinePkg_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 15 };
oid administrativeStatePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 16 };
oid bufferMechanismPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 17 };
oid cICPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 18 };
oid clsLoadsharingInformationPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 19 };
oid congestedStatePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 20 };
oid congestionHandlingPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 21 };
oid congestionLevelPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 22 };
oid getScreenedOpcsOrLinkSetsByDpcActionPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 23 };
oid fixedRouteNePartPriorityPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 24 };
oid flexibleRouteNePartPriorityPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 25 };
oid inLsLoadShareAlgorithmPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 26 };
oid linkCongestionLevelPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 27 };
oid loadsharingInformationRouteNePartPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 28 };
oid loadsharingInformationRouteSetNePartPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 29 };
oid loopDelayPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 30 };
oid mtpLsProfileNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 31 };
oid mtpLsProfilePointerPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 32 };
oid mtpSapNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 33 };
oid mtpSlL2ProfileNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 34 };
oid mtpL3NamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 35 };
oid mtpLoadsharingObjectForRouteNePartPointerPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 36 };
oid mtpLoadsharingObjectForRouteSetNePartPointerPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 37 };
oid mtpSpNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 38 };
oid multipleTransmissionCongestionLevelsPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 39 };
oid multipleTransmissionCongestionLevelsWithPrioPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 40 };
oid multipleTransmissionCongestionStatesPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 41 };
oid noBasicLinkAllocationPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 42 };
oid pCRPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 43 };
oid receiveCongestionLevelsPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 44 };
oid relatedLinkGroupNumberPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 45 };
oid remoteExchangeLabelPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 46 };
oid mtpSdlListPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 47 };
oid mtpSdlNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 48 };
oid mtpLsNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 49 };
oid mtpSignLinkTestPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 50 };
oid mtpSlNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 51 };
oid mtpRtNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 52 };
oid mtpRsNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 53 };
oid mtpStListPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 54 };
oid mtpStNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 55 };
oid slsCodeNormalListPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 56 };
oid slsListPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 57 };
oid mtpSlL3ProfileNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 58 };
oid mtpSlL3ProfilePointerPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 59 };
oid mtpRestartingNotification_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 60 };
oid mtpSpProfileNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 62 };
oid mtpSpProfilePointerPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 63 };
oid ss7OnOccEventPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 64 };
oid stmChannelPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 65 };
oid mtpGsNamePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 66 };
oid usageStatePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 67 };
oid broadbandSpecificPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 68 };
oid egressTransmissionRateIntervalPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 69 };
oid longMessageSupportedPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 70 };
oid narrowbandSpecificPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 71 };
oid pollAfterRetransmissionPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 72 };
oid mtpSaalProfilePackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 73 };
oid saalSdlPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 74 };
oid m2paSctpDefaultsPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 75 };
oid mtpM2paProfilePkg_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 76 };
oid m2paProvingPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 77 };
oid providerEntityNamesPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 78 };
oid mtpRestartingParameters_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 79 };
oid ss7OnOccEventParameters_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 80 };
oid mtpSapAsaPointerPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 81 };
oid mtpL3AsaPointerPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 82 };
oid mtpSlAsaPointerPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 83 };
oid mtpRsAsaPointerPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 84 };
oid mtpLsAsaPointerPackage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 2, 2, 85 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 mtpMIB_variables: tree for mtpMIB
 * This variable defines function callbacks and type return information for the mtpMIB mib section
 */
struct variable7 mtpMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   MTPSAP2ADDRESS        1
	{(u_char) MTPSAP2ADDRESS, ASN_UNSIGNED, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 2}},
#define   MTPSAPUSERPART        2
	{(u_char) MTPSAPUSERPART, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 3}},
#define   MTPSAPUSERPARTSTATUS  3
	{(u_char) MTPSAPUSERPARTSTATUS, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 4}},
#define   MTPSAPUSERENTITYNAMES  4
	{(u_char) MTPSAPUSERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 5}},
#define   MTPSAPPROVIDERENTITYNAMES  5
	{(u_char) MTPSAPPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 6}},
#define   MTPSAPUSAGESTATE      6
	{(u_char) MTPSAPUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 7}},
#define   MTPSAPASAPROFILEPOINTER  7
	{(u_char) MTPSAPASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 8}},
#define   MTPSAPNAME            8
	{(u_char) MTPSAPNAME, ASN_OCTET_STR, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 9}},
#define   MTPSAPLONGMESSAGESUPPORTED  9
	{(u_char) MTPSAPLONGMESSAGESUPPORTED, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 10}},
#define   MTPSAPROWSTATUS       10
	{(u_char) MTPSAPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 11}},
#define   MTPNAPROTOCOLVARIANT  11
	{(u_char) MTPNAPROTOCOLVARIANT, ASN_OBJECT_ID, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 2}},
#define   MTPNAPROTOCOLYEAR     12
	{(u_char) MTPNAPROTOCOLYEAR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 3}},
#define   MTPNAPROTOCOLOPTIONS  13
	{(u_char) MTPNAPROTOCOLOPTIONS, ASN_BIT_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 4}},
#define   MTPNANETWORKINDICATOR  14
	{(u_char) MTPNANETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 5}},
#define   MTPNAPOINTCODEFORMAT  15
	{(u_char) MTPNAPOINTCODEFORMAT, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 6}},
#define   MTPNASLSLENGTH        16
	{(u_char) MTPNASLSLENGTH, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 7}},
#define   MTPNASPDEFAULT        17
	{(u_char) MTPNASPDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 8}},
#define   MTPNANAME             18
	{(u_char) MTPNANAME, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 9}},
#define   MTPNAROWSTATUS        19
	{(u_char) MTPNAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 10}},
#define   MTPMSNAME             20
	{(u_char) MTPMSNAME, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 2}},
#define   MTPMSALARMSTATUS      21
	{(u_char) MTPMSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 3}},
#define   MTPMSOPERATIONALSTATE  22
	{(u_char) MTPMSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 4}},
#define   MTPMSUSAGESTATE       23
	{(u_char) MTPMSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 5}},
#define   MTPMSMANAGEDELEMENTTYPE  24
	{(u_char) MTPMSMANAGEDELEMENTTYPE, ASN_OCTET_STR, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 6}},
#define   MTPMSMODELCODE        25
	{(u_char) MTPMSMODELCODE, ASN_OCTET_STR, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 7}},
#define   MTPMSVENDORNAME       26
	{(u_char) MTPMSVENDORNAME, ASN_OCTET_STR, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 8}},
#define   MTPMSUSERLABEL        27
	{(u_char) MTPMSUSERLABEL, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 9}},
#define   MTPMSVERSION          28
	{(u_char) MTPMSVERSION, ASN_OCTET_STR, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 10}},
#define   MTPMSASAPROFILEPOINTER  29
	{(u_char) MTPMSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 11}},
#define   MTPMSNETWORKELEMENTALIASES  30
	{(u_char) MTPMSNETWORKELEMENTALIASES, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 12}},
#define   MTPMSROWSTATUS        31
	{(u_char) MTPMSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 13}},
#define   MTPSPPROFILETIMERT1R  32
	{(u_char) MTPSPPROFILETIMERT1R, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 2}},
#define   MTPSPPROFILETIMERT2   33
	{(u_char) MTPSPPROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 3}},
#define   MTPSPPROFILETIMERT4   34
	{(u_char) MTPSPPROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 4}},
#define   MTPSPPROFILETIMERT5   35
	{(u_char) MTPSPPROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 5}},
#define   MTPSPPROFILETIMERT7   36
	{(u_char) MTPSPPROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 6}},
#define   MTPSPPROFILETIMERT11  37
	{(u_char) MTPSPPROFILETIMERT11, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 7}},
#define   MTPSPPROFILETIMERT12  38
	{(u_char) MTPSPPROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 8}},
#define   MTPSPPROFILETIMERT13  39
	{(u_char) MTPSPPROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 9}},
#define   MTPSPPROFILETIMERT14  40
	{(u_char) MTPSPPROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 10}},
#define   MTPSPPROFILETIMERT15  41
	{(u_char) MTPSPPROFILETIMERT15, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 11}},
#define   MTPSPPROFILETIMERT16  42
	{(u_char) MTPSPPROFILETIMERT16, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 12}},
#define   MTPSPPROFILETIMERT18I  43
	{(u_char) MTPSPPROFILETIMERT18I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 13}},
#define   MTPSPPROFILETIMERT19I  44
	{(u_char) MTPSPPROFILETIMERT19I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 14}},
#define   MTPSPPROFILETIMERT20I  45
	{(u_char) MTPSPPROFILETIMERT20I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 15}},
#define   MTPSPPROFILETIMERT21I  46
	{(u_char) MTPSPPROFILETIMERT21I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 16}},
#define   MTPSPPROFILETIMERT22I  47
	{(u_char) MTPSPPROFILETIMERT22I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 17}},
#define   MTPSPPROFILETIMERT23I  48
	{(u_char) MTPSPPROFILETIMERT23I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 18}},
#define   MTPSPPROFILETIMERT20A  49
	{(u_char) MTPSPPROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 19}},
#define   MTPSPPROFILETIMERT21A  50
	{(u_char) MTPSPPROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 20}},
#define   MTPSPPROFILETIMERT22A  51
	{(u_char) MTPSPPROFILETIMERT22A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 21}},
#define   MTPSPPROFILETIMERT23A  52
	{(u_char) MTPSPPROFILETIMERT23A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 22}},
#define   MTPSPPROFILETIMERT24A  53
	{(u_char) MTPSPPROFILETIMERT24A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 23}},
#define   MTPSPPROFILETIMERT26A  54
	{(u_char) MTPSPPROFILETIMERT26A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 24}},
#define   MTPSPPROFILETIMERT27A  55
	{(u_char) MTPSPPROFILETIMERT27A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 25}},
#define   MTPSPPROFILETIMERT1T  56
	{(u_char) MTPSPPROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 26}},
#define   MTPSPPROFILETIMERT2T  57
	{(u_char) MTPSPPROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 27}},
#define   MTPSPPROFILENAME      58
	{(u_char) MTPSPPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 28}},
#define   MTPSPPROFILECIRCULARRTEDETECT  59
	{(u_char) MTPSPPROFILECIRCULARRTEDETECT, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 29}},
#define   MTPSPPROFILEROWSTATUS  60
	{(u_char) MTPSPPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 32}},
#define   MTPSPPOINTCODE        61
	{(u_char) MTPSPPOINTCODE, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 2}},
#define   MTPSPTYPE             62
	{(u_char) MTPSPTYPE, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 3}},
#define   MTPSPOPERATIONALSTATE  63
	{(u_char) MTPSPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 4}},
#define   MTPSPPROCEDURALSTATUS  64
	{(u_char) MTPSPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 5}},
#define   MTPSPAVAILABILITYSTATUS  65
	{(u_char) MTPSPAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 6}},
#define   MTPSPVERSION          66
	{(u_char) MTPSPVERSION, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 7}},
#define   MTPSPNETWORKINDICATOR  67
	{(u_char) MTPSPNETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 8}},
#define   MTPSPNAME             68
	{(u_char) MTPSPNAME, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 9}},
#define   MTPSPPROFILEPOINTER   69
	{(u_char) MTPSPPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 10}},
#define   MTPSPNAPOINTER        70
	{(u_char) MTPSPNAPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 11}},
#define   MTPSPOPTIONS          71
	{(u_char) MTPSPOPTIONS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 12}},
#define   MTPSPUSERS            72
	{(u_char) MTPSPUSERS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 13}},
#define   MTPSPALARMSTATUS      73
	{(u_char) MTPSPALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 14}},
#define   MTPSPROWSTATUS        74
	{(u_char) MTPSPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 15}},
#define   MTPL3ADMINISTRATIVESTATE  75
	{(u_char) MTPL3ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 2}},
#define   MTPL3OPERATIONALSTATE  76
	{(u_char) MTPL3OPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 3}},
#define   MTPL3USAGESTATE       77
	{(u_char) MTPL3USAGESTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 4}},
#define   MTPL3PROCEDURALSTATUS  78
	{(u_char) MTPL3PROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 5}},
#define   MTPL3ASAPROFILEPOINTER  79
	{(u_char) MTPL3ASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 6}},
#define   MTPL3NAME             80
	{(u_char) MTPL3NAME, ASN_OCTET_STR, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 7}},
#define   MTPL3ROWSTATUS        81
	{(u_char) MTPL3ROWSTATUS, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 8}},
#define   MTPGSADMINISTRATIVESTATE  82
	{(u_char) MTPGSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 2}},
#define   MTPGSTREATMENTOFOUTSIDERANGES  83
	{(u_char) MTPGSTREATMENTOFOUTSIDERANGES, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 3}},
#define   MTPGSLISTMODE         84
	{(u_char) MTPGSLISTMODE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 4}},
#define   MTPGSSCREENINGBYLINKSETORBYOPC  85
	{(u_char) MTPGSSCREENINGBYLINKSETORBYOPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 5}},
#define   MTPGSGETSCREENEDOPCSORLINKSETSBYDPC  86
	{(u_char) MTPGSGETSCREENEDOPCSORLINKSETSBYDPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 6}},
#define   MTPGSNAME             87
	{(u_char) MTPGSNAME, ASN_OCTET_STR, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 7}},
#define   MTPGSROWSTATUS        88
	{(u_char) MTPGSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 8}},
#define   MTPGSLINEOBJECT       89
	{(u_char) MTPGSLINEOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpGsLineTable, 6, {1, 1, 6, 2, 1, 2}},
#define   MTPGSLINECONTENT      90
	{(u_char) MTPGSLINECONTENT, ASN_UNSIGNED, RWRITE, var_mtpGsLineTable, 6, {1, 1, 6, 2, 1, 3}},
#define   MTPGSLINEROWSTATUS    91
	{(u_char) MTPGSLINEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineTable, 6, {1, 1, 6, 2, 1, 4}},
#define   MTPGSLINECONTENTDESIGNATEDDPCFIRST  92
	{(u_char) MTPGSLINECONTENTDESIGNATEDDPCFIRST, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 2}},
#define   MTPGSLINECONTENTDESIGNATEDDPCLAST  93
	{(u_char) MTPGSLINECONTENTDESIGNATEDDPCLAST, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 3}},
#define   MTPGSLINECONTENTSIMASK  94
	{(u_char) MTPGSLINECONTENTSIMASK, ASN_BIT_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 4}},
#define   MTPGSLINECONTENTMESSAGETREATMENT  95
	{(u_char) MTPGSLINECONTENTMESSAGETREATMENT, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 5}},
#define   MTPGSLINECONTENTCOMMENT  96
	{(u_char) MTPGSLINECONTENTCOMMENT, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 6}},
#define   MTPGSLINECONTENTROWSTATUS  97
	{(u_char) MTPGSLINECONTENTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 7}},
#define   MTPRSPROFILENAME      98
	{(u_char) MTPRSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 2}},
#define   MTPRSPROFILETIMERT8   99
	{(u_char) MTPRSPROFILETIMERT8, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 3}},
#define   MTPRSPROFILETIMERT11  100
	{(u_char) MTPRSPROFILETIMERT11, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 4}},
#define   MTPRSPROFILETIMERT15  101
	{(u_char) MTPRSPROFILETIMERT15, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 5}},
#define   MTPRSPROFILETIMERT16  102
	{(u_char) MTPRSPROFILETIMERT16, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 6}},
#define   MTPRSPROFILETIMERT18A  103
	{(u_char) MTPRSPROFILETIMERT18A, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 7}},
#define   MTPRSPROFILERTDEFAULT  104
	{(u_char) MTPRSPROFILERTDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 8}},
#define   MTPRSPROFILEROWSTATUS  105
	{(u_char) MTPRSPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 9}},
#define   MTPRSDEST             106
	{(u_char) MTPRSDEST, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 2}},
#define   MTPRSOPTIONS          107
	{(u_char) MTPRSOPTIONS, ASN_BIT_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 3}},
#define   MTPRSADMINISTRATIVESTATE  108
	{(u_char) MTPRSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 4}},
#define   MTPRSOPERATIONALSTATE  109
	{(u_char) MTPRSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 5}},
#define   MTPRSASAPROFILEPOINTER  110
	{(u_char) MTPRSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 6}},
#define   MTPRSCONGESTEDSTATE   111
	{(u_char) MTPRSCONGESTEDSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 7}},
#define   MTPRSCONGESTIONLEVEL  112
	{(u_char) MTPRSCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 8}},
#define   MTPRSLOADSHARINGINFORMATION  113
	{(u_char) MTPRSLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 9}},
#define   MTPRSLOADSHARINGOBJECT  114
	{(u_char) MTPRSLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 10}},
#define   MTPRSREMOTEEXCHANGELABEL  115
	{(u_char) MTPRSREMOTEEXCHANGELABEL, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 11}},
#define   MTPRSNAME             116
	{(u_char) MTPRSNAME, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 12}},
#define   MTPRSPROFILE          117
	{(u_char) MTPRSPROFILE, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 13}},
#define   MTPRSALARMSTATUS      118
	{(u_char) MTPRSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 14}},
#define   MTPRSROWSTATUS        119
	{(u_char) MTPRSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 15}},
#define   MTPRTPROFILETIMERT6   120
	{(u_char) MTPRTPROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 2}},
#define   MTPRTPROFILETIMERT10  121
	{(u_char) MTPRTPROFILETIMERT10, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 3}},
#define   MTPRTPROFILEROWSTATUS  122
	{(u_char) MTPRTPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 4}},
#define   MTPRTLSPOINTER        123
	{(u_char) MTPRTLSPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 2}},
#define   MTPRTADMINISTRATIVESTATE  124
	{(u_char) MTPRTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 3}},
#define   MTPRTOPERATIONALSTATE  125
	{(u_char) MTPRTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 4}},
#define   MTPRTAVAILABILITYSTATUS  126
	{(u_char) MTPRTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 5}},
#define   MTPRTINCLSLOADSHARINGALGORITHM  127
	{(u_char) MTPRTINCLSLOADSHARINGALGORITHM, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 6}},
#define   MTPRTFIXEDPRIORITY    128
	{(u_char) MTPRTFIXEDPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 7}},
#define   MTPRTFLEXIBLEPRIORITY  129
	{(u_char) MTPRTFLEXIBLEPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 8}},
#define   MTPRTPRIORITYMODE     130
	{(u_char) MTPRTPRIORITYMODE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 9}},
#define   MTPRTLOADSHARINGINFORMATION  131
	{(u_char) MTPRTLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 10}},
#define   MTPRTLOADSHARINGOBJECT  132
	{(u_char) MTPRTLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 11}},
#define   MTPRTNAME             133
	{(u_char) MTPRTNAME, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 12}},
#define   MTPRTSLSLIST          134
	{(u_char) MTPRTSLSLIST, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 13}},
#define   MTPRTUSAGESTATE       135
	{(u_char) MTPRTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 14}},
#define   MTPRTRLSLOT           136
	{(u_char) MTPRTRLSLOT, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 15}},
#define   MTPRTPROFILE          137
	{(u_char) MTPRTPROFILE, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 16}},
#define   MTPRTROWSTATUS        138
	{(u_char) MTPRTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 17}},
#define   MTPRTLSANORMALSLCODE  139
	{(u_char) MTPRTLSANORMALSLCODE, ASN_INTEGER, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 8, 3, 1, 2}},
#define   MTPRTLSAALTERNATIVESLCODELIST  140
	{(u_char) MTPRTLSAALTERNATIVESLCODELIST, ASN_OCTET_STR, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 8, 3, 1, 3}},
#define   MTPLSPROFILETIMERT6   141
	{(u_char) MTPLSPROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 2}},
#define   MTPLSPROFILETIMERT8   142
	{(u_char) MTPLSPROFILETIMERT8, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 3}},
#define   MTPLSPROFILETIMERT10  143
	{(u_char) MTPLSPROFILETIMERT10, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 4}},
#define   MTPLSPROFILETIMERT7   144
	{(u_char) MTPLSPROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 5}},
#define   MTPLSPROFILETIMERT19I  145
	{(u_char) MTPLSPROFILETIMERT19I, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 6}},
#define   MTPLSPROFILETIMERT21I  146
	{(u_char) MTPLSPROFILETIMERT21I, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 7}},
#define   MTPLSPROFILETIMERT25A  147
	{(u_char) MTPLSPROFILETIMERT25A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 8}},
#define   MTPLSPROFILETIMERT28A  148
	{(u_char) MTPLSPROFILETIMERT28A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 9}},
#define   MTPLSPROFILETIMERT29A  149
	{(u_char) MTPLSPROFILETIMERT29A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 10}},
#define   MTPLSPROFILETIMERT30A  150
	{(u_char) MTPLSPROFILETIMERT30A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 11}},
#define   MTPLSPROFILEPARAMETERN  151
	{(u_char) MTPLSPROFILEPARAMETERN, ASN_UNSIGNED, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 12}},
#define   MTPLSPROFILEPARAMETERM  152
	{(u_char) MTPLSPROFILEPARAMETERM, ASN_UNSIGNED, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 13}},
#define   MTPLSPROFILENAME      153
	{(u_char) MTPLSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 14}},
#define   MTPLSPROFILESLDEFAULT  154
	{(u_char) MTPLSPROFILESLDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 15}},
#define   MTPLSPROFILEROWSTATUS  155
	{(u_char) MTPLSPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 16}},
#define   MTPLSADJPC            156
	{(u_char) MTPLSADJPC, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 2}},
#define   MTPLSRSID             157
	{(u_char) MTPLSRSID, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 3}},
#define   MTPLSMAXCAPACITY      158
	{(u_char) MTPLSMAXCAPACITY, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 4}},
#define   MTPLSCURRENTCAPACITY  159
	{(u_char) MTPLSCURRENTCAPACITY, ASN_UNSIGNED, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 5}},
#define   MTPLSCONGESTIONCONTROLMETHOD  160
	{(u_char) MTPLSCONGESTIONCONTROLMETHOD, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 6}},
#define   MTPLSUSAGESTATE       161
	{(u_char) MTPLSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 7}},
#define   MTPLSOPERATIONALSTATE  162
	{(u_char) MTPLSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 8}},
#define   MTPLSAVAILABILITYSTATUS  163
	{(u_char) MTPLSAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 9}},
#define   MTPLSPERIODICLINKTESTFLAG  164
	{(u_char) MTPLSPERIODICLINKTESTFLAG, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 10}},
#define   MTPLSPERIODICLINKTESTFAIL  165
	{(u_char) MTPLSPERIODICLINKTESTFAIL, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 11}},
#define   MTPLSADMINISTRATIVESTATE  166
	{(u_char) MTPLSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 12}},
#define   MTPLSINLSLOADSHAREALGORITHM  167
	{(u_char) MTPLSINLSLOADSHAREALGORITHM, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 13}},
#define   MTPLSPROFILEPOINTER   168
	{(u_char) MTPLSPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 14}},
#define   MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS  169
	{(u_char) MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 15}},
#define   MTPLSNAME             170
	{(u_char) MTPLSNAME, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 16}},
#define   MTPLSASAPROFILEPOINTER  171
	{(u_char) MTPLSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 17}},
#define   MTPLSALARMSTATUS      172
	{(u_char) MTPLSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 18}},
#define   MTPLSROWSTATUS        173
	{(u_char) MTPLSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 19}},
#define   MTPSLL3PROFILETIMERT1  174
	{(u_char) MTPSLL3PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 2}},
#define   MTPSLL3PROFILETIMERT3  175
	{(u_char) MTPSLL3PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 3}},
#define   MTPSLL3PROFILETIMERT17  176
	{(u_char) MTPSLL3PROFILETIMERT17, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 4}},
#define   MTPSLL3PROFILETIMERT24I  177
	{(u_char) MTPSLL3PROFILETIMERT24I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 5}},
#define   MTPSLL3PROFILENAME    178
	{(u_char) MTPSLL3PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 6}},
#define   MTPSLL3PROFILETIMERT2  179
	{(u_char) MTPSLL3PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 7}},
#define   MTPSLL3PROFILETIMERT4  180
	{(u_char) MTPSLL3PROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 8}},
#define   MTPSLL3PROFILETIMERT5  181
	{(u_char) MTPSLL3PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 9}},
#define   MTPSLL3PROFILETIMERT12  182
	{(u_char) MTPSLL3PROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 10}},
#define   MTPSLL3PROFILETIMERT13  183
	{(u_char) MTPSLL3PROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 11}},
#define   MTPSLL3PROFILETIMERT14  184
	{(u_char) MTPSLL3PROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 12}},
#define   MTPSLL3PROFILETIMERT19A  185
	{(u_char) MTPSLL3PROFILETIMERT19A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 13}},
#define   MTPSLL3PROFILETIMERT20A  186
	{(u_char) MTPSLL3PROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 14}},
#define   MTPSLL3PROFILETIMERT21A  187
	{(u_char) MTPSLL3PROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 15}},
#define   MTPSLL3PROFILETIMERT22I  188
	{(u_char) MTPSLL3PROFILETIMERT22I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 16}},
#define   MTPSLL3PROFILETIMERT23I  189
	{(u_char) MTPSLL3PROFILETIMERT23I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 17}},
#define   MTPSLL3PROFILETIMERT31A  190
	{(u_char) MTPSLL3PROFILETIMERT31A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 18}},
#define   MTPSLL3PROFILETIMERT32A  191
	{(u_char) MTPSLL3PROFILETIMERT32A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 19}},
#define   MTPSLL3PROFILETIMERT33A  192
	{(u_char) MTPSLL3PROFILETIMERT33A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 20}},
#define   MTPSLL3PROFILETIMERT34A  193
	{(u_char) MTPSLL3PROFILETIMERT34A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 21}},
#define   MTPSLL3PROFILETIMERT1T  194
	{(u_char) MTPSLL3PROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 22}},
#define   MTPSLL3PROFILETIMERT2T  195
	{(u_char) MTPSLL3PROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 23}},
#define   MTPSLL3PROFILETIMERT1S  196
	{(u_char) MTPSLL3PROFILETIMERT1S, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 24}},
#define   MTPSLL3PROFILEL2DEFAULT  197
	{(u_char) MTPSLL3PROFILEL2DEFAULT, ASN_OCTET_STR, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 25}},
#define   MTPSLL3PROFILEROWSTATUS  198
	{(u_char) MTPSLL3PROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 26}},
#define   MTPSLL2PROFILEERRORCORRECTIONMETHOD  199
	{(u_char) MTPSLL2PROFILEERRORCORRECTIONMETHOD, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 3}},
#define   MTPSLL2PROFILEPROTOCOLVARIANT  200
	{(u_char) MTPSLL2PROFILEPROTOCOLVARIANT, ASN_OBJECT_ID, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 4}},
#define   MTPSLL2PROFILETIMERT1  201
	{(u_char) MTPSLL2PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 5}},
#define   MTPSLL2PROFILETIMERT2  202
	{(u_char) MTPSLL2PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 6}},
#define   MTPSLL2PROFILETIMERT2L  203
	{(u_char) MTPSLL2PROFILETIMERT2L, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 7}},
#define   MTPSLL2PROFILETIMERT2H  204
	{(u_char) MTPSLL2PROFILETIMERT2H, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 8}},
#define   MTPSLL2PROFILETIMERT3  205
	{(u_char) MTPSLL2PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 9}},
#define   MTPSLL2PROFILETIMERT4N  206
	{(u_char) MTPSLL2PROFILETIMERT4N, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 10}},
#define   MTPSLL2PROFILETIMERT4E  207
	{(u_char) MTPSLL2PROFILETIMERT4E, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 11}},
#define   MTPSLL2PROFILETIMERT5  208
	{(u_char) MTPSLL2PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 12}},
#define   MTPSLL2PROFILETIMERT6  209
	{(u_char) MTPSLL2PROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 13}},
#define   MTPSLL2PROFILETIMERT7  210
	{(u_char) MTPSLL2PROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 14}},
#define   MTPSLL2PROFILETBONSET1  211
	{(u_char) MTPSLL2PROFILETBONSET1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 15}},
#define   MTPSLL2PROFILETBABATE1  212
	{(u_char) MTPSLL2PROFILETBABATE1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 16}},
#define   MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS  213
	{(u_char) MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 17}},
#define   MTPSLL2PROFILECONGESTIONCOUNTING  214
	{(u_char) MTPSLL2PROFILECONGESTIONCOUNTING, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 18}},
#define   MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT  215
	{(u_char) MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 19}},
#define   MTPSLL2PROFILELOOPDELAY  216
	{(u_char) MTPSLL2PROFILELOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 20}},
#define   MTPSLL2PROFILENAME    217
	{(u_char) MTPSLL2PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 21}},
#define   MTPSLL2PROFILETBONSET2  218
	{(u_char) MTPSLL2PROFILETBONSET2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 22}},
#define   MTPSLL2PROFILETBABATE2  219
	{(u_char) MTPSLL2PROFILETBABATE2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 23}},
#define   MTPSLL2PROFILETBONSET3  220
	{(u_char) MTPSLL2PROFILETBONSET3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 24}},
#define   MTPSLL2PROFILETBABATE3  221
	{(u_char) MTPSLL2PROFILETBABATE3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 25}},
#define   MTPSLL2PROFILETBDISCARD1  222
	{(u_char) MTPSLL2PROFILETBDISCARD1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 26}},
#define   MTPSLL2PROFILETBDISCARD2  223
	{(u_char) MTPSLL2PROFILETBDISCARD2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 27}},
#define   MTPSLL2PROFILETBDISCARD3  224
	{(u_char) MTPSLL2PROFILETBDISCARD3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 28}},
#define   MTPSLL2PROFILETIMERTX  225
	{(u_char) MTPSLL2PROFILETIMERTX, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 29}},
#define   MTPSLL2PROFILETIMERTY  226
	{(u_char) MTPSLL2PROFILETIMERTY, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 30}},
#define   MTPSLL2PROFILENUMBEROFCONGESTIONSTATES  227
	{(u_char) MTPSLL2PROFILENUMBEROFCONGESTIONSTATES, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 31}},
#define   MTPSLL2PROFILEINITIALLEVELOFCONGESTION  228
	{(u_char) MTPSLL2PROFILEINITIALLEVELOFCONGESTION, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 32}},
#define   MTPSLL2PROFILEMAXMSUSRETRANSN1  229
	{(u_char) MTPSLL2PROFILEMAXMSUSRETRANSN1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 33}},
#define   MTPSLL2PROFILEMAXOCTRETRANSN2  230
	{(u_char) MTPSLL2PROFILEMAXOCTRETRANSN2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 34}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET  231
	{(u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 35}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE  232
	{(u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 36}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD  233
	{(u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 37}},
#define   MTPSLL2PROFILEM       234
	{(u_char) MTPSLL2PROFILEM, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 38}},
#define   MTPSLL2PROFILEROWSTATUS  235
	{(u_char) MTPSLL2PROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 39}},
#define   MTPSLSLSCODECURRENTLIST  236
	{(u_char) MTPSLSLSCODECURRENTLIST, ASN_OCTET_STR, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 3}},
#define   MTPSLMAXCAPACITYSL    237
	{(u_char) MTPSLMAXCAPACITYSL, ASN_UNSIGNED, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 4}},
#define   MTPSLCURRENTCAPACITYSL  238
	{(u_char) MTPSLCURRENTCAPACITYSL, ASN_UNSIGNED, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 5}},
#define   MTPSLLINKTPSTATUS     239
	{(u_char) MTPSLLINKTPSTATUS, ASN_BIT_STR, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 6}},
#define   MTPSLADMINISTRATIVESTATE  240
	{(u_char) MTPSLADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 7}},
#define   MTPSLOPERATIONALSTATE  241
	{(u_char) MTPSLOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 8}},
#define   MTPSLUSAGESTATE       242
	{(u_char) MTPSLUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 9}},
#define   MTPSLPROCEDURALSTATUS  243
	{(u_char) MTPSLPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 10}},
#define   MTPSLMTPL2PROTOCOLPROFILEPOINTER  244
	{(u_char) MTPSLMTPL2PROTOCOLPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 11}},
#define   MTPSLSIGNTERMPOINTER  245
	{(u_char) MTPSLSIGNTERMPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 12}},
#define   MTPSLSIGNDATALINKTPPOINTER  246
	{(u_char) MTPSLSIGNDATALINKTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 13}},
#define   MTPSLLOCALINHIBIT     247
	{(u_char) MTPSLLOCALINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 14}},
#define   MTPSLLOCALUNINHIBIT   248
	{(u_char) MTPSLLOCALUNINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 15}},
#define   MTPSLREPLACEST        249
	{(u_char) MTPSLREPLACEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 16}},
#define   MTPSLASAPROFILEPOINTER  250
	{(u_char) MTPSLASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 17}},
#define   MTPSLCONGESTIONLEVEL  251
	{(u_char) MTPSLCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 18}},
#define   MTPSLRELATEDLINKGROUPNUMBER  252
	{(u_char) MTPSLRELATEDLINKGROUPNUMBER, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 19}},
#define   MTPSLSDLLIST          253
	{(u_char) MTPSLSDLLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 20}},
#define   MTPSLTEST             254
	{(u_char) MTPSLTEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 21}},
#define   MTPSLNAME             255
	{(u_char) MTPSLNAME, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 22}},
#define   MTPSLSDTLIST          256
	{(u_char) MTPSLSDTLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 23}},
#define   MTPSLSLSCODENORMALLIST  257
	{(u_char) MTPSLSLSCODENORMALLIST, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 24}},
#define   MTPSLL3PROFILEPOINTER  258
	{(u_char) MTPSLL3PROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 25}},
#define   MTPSLALARMSTATUS      259
	{(u_char) MTPSLALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 26}},
#define   MTPSLROWSTATUS        260
	{(u_char) MTPSLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 27}},
#define   MTPSLSDLLISTPOINTER   261
	{(u_char) MTPSLSDLLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 10, 4, 1, 2}},
#define   MTPSLSDLLISTROWSTATUS  262
	{(u_char) MTPSLSDLLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 10, 4, 1, 3}},
#define   MTPSLSDTLISTPOINTER   263
	{(u_char) MTPSLSDTLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 10, 5, 1, 2}},
#define   MTPSLSDTLISTROWSTATUS  264
	{(u_char) MTPSLSDTLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 10, 5, 1, 3}},
#define   MTPNBTRANSMISSIONRATE  265
	{(u_char) MTPNBTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 2}},
#define   MTPNBTIMERT8          266
	{(u_char) MTPNBTIMERT8, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 3}},
#define   MTPNBTIN              267
	{(u_char) MTPNBTIN, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 4}},
#define   MTPNBTIE              268
	{(u_char) MTPNBTIE, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 5}},
#define   MTPNBT                269
	{(u_char) MTPNBT, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 6}},
#define   MTPNBD                270
	{(u_char) MTPNBD, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 7}},
#define   MTPNBTE               271
	{(u_char) MTPNBTE, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 8}},
#define   MTPNBDE               272
	{(u_char) MTPNBDE, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 9}},
#define   MTPNBUE               273
	{(u_char) MTPNBUE, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 10}},
#define   MTPNBN                274
	{(u_char) MTPNBN, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 11}},
#define   MTPNBM                275
	{(u_char) MTPNBM, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 12}},
#define   MTPNBB                276
	{(u_char) MTPNBB, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 13}},
#define   MTPNBF                277
	{(u_char) MTPNBF, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 14}},
#define   MTPNBROWSTATUS        278
	{(u_char) MTPNBROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 15}},
#define   MTPSAALBUFFERRELEASE  279
	{(u_char) MTPSAALBUFFERRELEASE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 1}},
#define   MTPSAALMAXCC          280
	{(u_char) MTPSAALMAXCC, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 2}},
#define   MTPSAALMAXNRP         281
	{(u_char) MTPSAALMAXNRP, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 3}},
#define   MTPSAALMAXINFORMATIONFIELDLENGTH  282
	{(u_char) MTPSAALMAXINFORMATIONFIELDLENGTH, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 4}},
#define   MTPSAALMAXLENGTHSSCOPUUFIELD  283
	{(u_char) MTPSAALMAXLENGTHSSCOPUUFIELD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 5}},
#define   MTPSAALMAXPD          284
	{(u_char) MTPSAALMAXPD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 6}},
#define   MTPSAALMAXSSCOPCREDITTOPEER  285
	{(u_char) MTPSAALMAXSSCOPCREDITTOPEER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 7}},
#define   MTPSAALMAXSTAT        286
	{(u_char) MTPSAALMAXSTAT, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 8}},
#define   MTPSAALN1             287
	{(u_char) MTPSAALN1, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 9}},
#define   MTPSAALNNILAYERMANAGEMENTPROVINGSTATE  288
	{(u_char) MTPSAALNNILAYERMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 10}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT  289
	{(u_char) MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 11}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC  290
	{(u_char) MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 12}},
#define   MTPSAALNNITIMERT1     291
	{(u_char) MTPSAALNNITIMERT1, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 13}},
#define   MTPSAALNNITIMERT2     292
	{(u_char) MTPSAALNNITIMERT2, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 14}},
#define   MTPSAALNNITIMERT3     293
	{(u_char) MTPSAALNNITIMERT3, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 15}},
#define   MTPSAALSSCOPTIMERCC   294
	{(u_char) MTPSAALSSCOPTIMERCC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 16}},
#define   MTPSAALSSCOPTIMERIDLE  295
	{(u_char) MTPSAALSSCOPTIMERIDLE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 17}},
#define   MTPSAALSSCOPTIMERKEEPALIVE  296
	{(u_char) MTPSAALSSCOPTIMERKEEPALIVE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 18}},
#define   MTPSAALSSCOPTIMERNORESPONSE  297
	{(u_char) MTPSAALSSCOPTIMERNORESPONSE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 19}},
#define   MTPSAALSSCOPTIMERPOLL  298
	{(u_char) MTPSAALSSCOPTIMERPOLL, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 20}},
#define   MTPSAALTRANSMISSIONRATEINTERVALLOWER  299
	{(u_char) MTPSAALTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 21}},
#define   MTPSAALTRANSMISSIONRATEINTERVALUPPER  300
	{(u_char) MTPSAALTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 22}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER  301
	{(u_char) MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 23}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER  302
	{(u_char) MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 24}},
#define   MTPSAALPOLLAFTERRETRANSMISSION  303
	{(u_char) MTPSAALPOLLAFTERRETRANSMISSION, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 25}},
#define   MTPSAALROWSTATUS      304
	{(u_char) MTPSAALROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 26}},
#define   MTPM2PAN1             305
	{(u_char) MTPM2PAN1, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 1}},
#define   MTPM2PAPROVING        306
	{(u_char) MTPM2PAPROVING, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 2}},
#define   MTPM2PAMANAGEMENTPROVINGSTATE  307
	{(u_char) MTPM2PAMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 3}},
#define   MTPM2PAPROVINGATTEMPTS  308
	{(u_char) MTPM2PAPROVINGATTEMPTS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 4}},
#define   MTPM2PASCTPNODELAY    309
	{(u_char) MTPM2PASCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 5}},
#define   MTPM2PASCTPMAXSEG     310
	{(u_char) MTPM2PASCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 6}},
#define   MTPM2PASCTPHEARTBEATITVL  311
	{(u_char) MTPM2PASCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 7}},
#define   MTPM2PASCTPHEARTBEAT  312
	{(u_char) MTPM2PASCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 8}},
#define   MTPM2PASCTPRTOINITIAL  313
	{(u_char) MTPM2PASCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 9}},
#define   MTPM2PASCTPRTOMIN     314
	{(u_char) MTPM2PASCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 10}},
#define   MTPM2PASCTPRTOMAX     315
	{(u_char) MTPM2PASCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 11}},
#define   MTPM2PASCTPPATHMAXRETRANS  316
	{(u_char) MTPM2PASCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 12}},
#define   MTPM2PASCTPCOOKIELIFE  317
	{(u_char) MTPM2PASCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 13}},
#define   MTPM2PASCTPCOOKIEINC  318
	{(u_char) MTPM2PASCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 14}},
#define   MTPM2PASCTPMAXINITRETRIES  319
	{(u_char) MTPM2PASCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 15}},
#define   MTPM2PASCTPMAXBURST   320
	{(u_char) MTPM2PASCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 16}},
#define   MTPM2PASCTPASSOCMAXRETRANS  321
	{(u_char) MTPM2PASCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 17}},
#define   MTPM2PASCTPSACKDELAY  322
	{(u_char) MTPM2PASCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 18}},
#define   MTPM2PASCTPLIFETIME   323
	{(u_char) MTPM2PASCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 19}},
#define   MTPM2PALOOPDELAYLOWER  324
	{(u_char) MTPM2PALOOPDELAYLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 20}},
#define   MTPM2PALOOPDELAYUPPER  325
	{(u_char) MTPM2PALOOPDELAYUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 21}},
#define   MTPM2PATRANSMISSIONRATEINTERVALLOWER  326
	{(u_char) MTPM2PATRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 22}},
#define   MTPM2PATRANSMISSIONRATEINTERVALUPPER  327
	{(u_char) MTPM2PATRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 23}},
#define   MTPM2PAROWSTATUS      328
	{(u_char) MTPM2PAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 24}},
#define   MTPSDTADMINISTRATIVESTATE  329
	{(u_char) MTPSDTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 3}},
#define   MTPSDTOPERATIONALSTATE  330
	{(u_char) MTPSDTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 4}},
#define   MTPSDTUSAGESTATE      331
	{(u_char) MTPSDTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 5}},
#define   MTPSDTPROCEDURALSTATUS  332
	{(u_char) MTPSDTPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 6}},
#define   MTPSDTAVAILABILITYSTATUS  333
	{(u_char) MTPSDTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 7}},
#define   MTPSDTEQUIPMENTPOINTER  334
	{(u_char) MTPSDTEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 8}},
#define   MTPSDTNAME            335
	{(u_char) MTPSDTNAME, ASN_OCTET_STR, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 9}},
#define   MTPSDTSTANDBYSTATUS   336
	{(u_char) MTPSDTSTANDBYSTATUS, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 10}},
#define   MTPSDTPRIMARYID       337
	{(u_char) MTPSDTPRIMARYID, ASN_UNSIGNED, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 11}},
#define   MTPSDTPROFILEPOINTER  338
	{(u_char) MTPSDTPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 12}},
#define   MTPSDTROWSTATUS       339
	{(u_char) MTPSDTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 13}},
#define   MTPSDLTYPE            340
	{(u_char) MTPSDLTYPE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 2}},
#define   MTPSDLADJPC           341
	{(u_char) MTPSDLADJPC, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 3}},
#define   MTPSDLLOOPDELAY       342
	{(u_char) MTPSDLLOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 4}},
#define   MTPSDLOPERATIONALSTATE  343
	{(u_char) MTPSDLOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 5}},
#define   MTPSDLEQUIPMENTPOINTER  344
	{(u_char) MTPSDLEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 6}},
#define   MTPSDLCIC             345
	{(u_char) MTPSDLCIC, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 7}},
#define   MTPSDLTRANSMISSIONRATE  346
	{(u_char) MTPSDLTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 8}},
#define   MTPSDLSTMCHANNEL      347
	{(u_char) MTPSDLSTMCHANNEL, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 9}},
#define   MTPSDLVCTTPPOINTER    348
	{(u_char) MTPSDLVCTTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 10}},
#define   MTPSDLSCTPPOINTER     349
	{(u_char) MTPSDLSCTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 11}},
#define   MTPSDLNAME            350
	{(u_char) MTPSDLNAME, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 12}},
#define   MTPSDLROWSTATUS       351
	{(u_char) MTPSDLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 13}},
#define   MTPSCTPPROFILENODELAY  352
	{(u_char) MTPSCTPPROFILENODELAY, ASN_INTEGER, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 2}},
#define   MTPSCTPPROFILEMAXSEG  353
	{(u_char) MTPSCTPPROFILEMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 3}},
#define   MTPSCTPPROFILEHEARTBEATITVL  354
	{(u_char) MTPSCTPPROFILEHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 4}},
#define   MTPSCTPPROFILEHEARTBEAT  355
	{(u_char) MTPSCTPPROFILEHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 5}},
#define   MTPSCTPPROFILERTOINITIAL  356
	{(u_char) MTPSCTPPROFILERTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 6}},
#define   MTPSCTPPROFILERTOMIN  357
	{(u_char) MTPSCTPPROFILERTOMIN, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 7}},
#define   MTPSCTPPROFILERTOMAX  358
	{(u_char) MTPSCTPPROFILERTOMAX, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 8}},
#define   MTPSCTPPROFILEPATHMAXRETRANS  359
	{(u_char) MTPSCTPPROFILEPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 9}},
#define   MTPSCTPPROFILECOOKIELIFE  360
	{(u_char) MTPSCTPPROFILECOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 10}},
#define   MTPSCTPPROFILECOOKIEINC  361
	{(u_char) MTPSCTPPROFILECOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 11}},
#define   MTPSCTPPROFILEMAXINITRETRIES  362
	{(u_char) MTPSCTPPROFILEMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 12}},
#define   MTPSCTPPROFILEMAXBURST  363
	{(u_char) MTPSCTPPROFILEMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 13}},
#define   MTPSCTPPROFILEASSOCMAXRETRANS  364
	{(u_char) MTPSCTPPROFILEASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 14}},
#define   MTPSCTPPROFILESACKDELAY  365
	{(u_char) MTPSCTPPROFILESACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 15}},
#define   MTPSCTPPROFILELIFETIME  366
	{(u_char) MTPSCTPPROFILELIFETIME, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 16}},
#define   MTPSCTPPROFILEMINOSTREAMS  367
	{(u_char) MTPSCTPPROFILEMINOSTREAMS, ASN_INTEGER, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 17}},
#define   MTPSCTPPROFILEMAXISTREAMS  368
	{(u_char) MTPSCTPPROFILEMAXISTREAMS, ASN_INTEGER, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 18}},
#define   MTPSCTPPROFILEROWSTATUS  369
	{(u_char) MTPSCTPPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 19}},
#define   MTPSCTPADMINISTRATIVESTATE  370
	{(u_char) MTPSCTPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 2}},
#define   MTPSCTPOPERATIONALSTATE  371
	{(u_char) MTPSCTPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 3}},
#define   MTPSCTPUSAGESTATE     372
	{(u_char) MTPSCTPUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 4}},
#define   MTPSCTPPROCEDURALSTATUS  373
	{(u_char) MTPSCTPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 5}},
#define   MTPSCTPLOCALPORT      374
	{(u_char) MTPSCTPLOCALPORT, ASN_INTEGER, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 6}},
#define   MTPSCTPREMOTEPORT     375
	{(u_char) MTPSCTPREMOTEPORT, ASN_INTEGER, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 7}},
#define   MTPSCTPPROFILE        376
	{(u_char) MTPSCTPPROFILE, ASN_OCTET_STR, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 8}},
#define   MTPSCTPPROTOCOLPAYLOADID  377
	{(u_char) MTPSCTPPROTOCOLPAYLOADID, ASN_UNSIGNED, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 9}},
#define   MTPSCTPROWSTATUS      378
	{(u_char) MTPSCTPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 10}},
#define   MTPSCTPLOCALADDRESS   379
	{(u_char) MTPSCTPLOCALADDRESS, ASN_IPADDRESS, RWRITE, var_mtpSctpLocalTable, 6, {1, 1, 13, 3, 1, 2}},
#define   MTPSCTPLOCALROWSTATUS  380
	{(u_char) MTPSCTPLOCALROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSctpLocalTable, 6, {1, 1, 13, 3, 1, 3}},
#define   MTPSCTPREMOTEADDRESS  381
	{(u_char) MTPSCTPREMOTEADDRESS, ASN_IPADDRESS, RWRITE, var_mtpSctpRemoteTable, 6, {1, 1, 13, 4, 1, 2}},
#define   MTPSCTPREMOTEROWSTATUS  382
	{(u_char) MTPSCTPREMOTEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSctpRemoteTable, 6, {1, 1, 13, 4, 1, 3}},
#define   MTPM2UAASPSTATE       383
	{(u_char) MTPM2UAASPSTATE, ASN_INTEGER, RONLY, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 1}},
#define   MTPM2UAASPID          384
	{(u_char) MTPM2UAASPID, ASN_UNSIGNED, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 2}},
#define   MTPM2UAASPCAPABILITIES  385
	{(u_char) MTPM2UAASPCAPABILITIES, ASN_BIT_STR, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 3}},
#define   MTPM2UAASPSGVERSION   386
	{(u_char) MTPM2UAASPSGVERSION, ASN_OBJECT_ID, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 4}},
#define   MTPM2UAASPSGOPTIONS   387
	{(u_char) MTPM2UAASPSGOPTIONS, ASN_BIT_STR, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 5}},
#define   MTPM2UAASPSGREGISTRATIONPOLICY  388
	{(u_char) MTPM2UAASPSGREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 6}},
#define   MTPM2UAASPSGASPIDPOLICY  389
	{(u_char) MTPM2UAASPSGASPIDPOLICY, ASN_INTEGER, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 7}},
#define   MTPM2UAASPASSOCIATIONPOLICY  390
	{(u_char) MTPM2UAASPASSOCIATIONPOLICY, ASN_INTEGER, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 8}},
#define   MTPM2UAASPPROTOCOLPAYLOADID  391
	{(u_char) MTPM2UAASPPROTOCOLPAYLOADID, ASN_INTEGER, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 9}},
#define   MTPM2UAASPROWSTATUS   392
	{(u_char) MTPM2UAASPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 10}},
#define   MTPM2UAASSTATE        393
	{(u_char) MTPM2UAASSTATE, ASN_INTEGER, RONLY, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 2}},
#define   MTPM2UAASINTERFACEIDENTIFIER  394
	{(u_char) MTPM2UAASINTERFACEIDENTIFIER, ASN_INTEGER, RWRITE, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 3}},
#define   MTPM2UAINTERFACEIDENTIFIERTEXT  395
	{(u_char) MTPM2UAINTERFACEIDENTIFIERTEXT, ASN_OCTET_STR, RWRITE, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 4}},
#define   MTPM2UAASSDTI         396
	{(u_char) MTPM2UAASSDTI, ASN_INTEGER, RWRITE, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 5}},
#define   MTPM2UAASTRAFFICMODE  397
	{(u_char) MTPM2UAASTRAFFICMODE, ASN_OBJECT_ID, RWRITE, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 6}},
#define   MTPM2UAASROWSTATUS    398
	{(u_char) MTPM2UAASROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 7}},
#define   MTPM3UAASPSTATE       399
	{(u_char) MTPM3UAASPSTATE, ASN_INTEGER, RONLY, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 1}},
#define   MTPM3UAASTYPE         400
	{(u_char) MTPM3UAASTYPE, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 2}},
#define   MTPM3UAASPID          401
	{(u_char) MTPM3UAASPID, ASN_UNSIGNED, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 3}},
#define   MTPM3UAASPCAPABILITIES  402
	{(u_char) MTPM3UAASPCAPABILITIES, ASN_BIT_STR, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 4}},
#define   MTPM3UAASPSGVERSION   403
	{(u_char) MTPM3UAASPSGVERSION, ASN_OBJECT_ID, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 5}},
#define   MTPM3UAASPSGOPTIONS   404
	{(u_char) MTPM3UAASPSGOPTIONS, ASN_BIT_STR, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 6}},
#define   MTPM3UAASPSGREGISTRATIONPOLICY  405
	{(u_char) MTPM3UAASPSGREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 7}},
#define   MTPM3UAASPSGASPIDPOLICY  406
	{(u_char) MTPM3UAASPSGASPIDPOLICY, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 8}},
#define   MTPM3UAASPASSOCIATIONPOLICY  407
	{(u_char) MTPM3UAASPASSOCIATIONPOLICY, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 9}},
#define   MTPM3UAASPPROTOCOLPAYLOADID  408
	{(u_char) MTPM3UAASPPROTOCOLPAYLOADID, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 10}},
#define   MTPM3UAASPROWSTATUS   409
	{(u_char) MTPM3UAASPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 11}},
#define   MTPM3UAASSTATE        410
	{(u_char) MTPM3UAASSTATE, ASN_INTEGER, RONLY, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 2}},
#define   MTPM3UAASROUTINGCONTEXT  411
	{(u_char) MTPM3UAASROUTINGCONTEXT, ASN_UNSIGNED, RWRITE, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 3}},
#define   MTPM3UAASNETWORKAPPEARANCE  412
	{(u_char) MTPM3UAASNETWORKAPPEARANCE, ASN_UNSIGNED, RWRITE, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 4}},
#define   MTPM3UAASNETWORKPOINTCODE  413
	{(u_char) MTPM3UAASNETWORKPOINTCODE, ASN_OCTET_STR, RWRITE, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 5}},
#define   MTPM3UAASTRAFFICMODE  414
	{(u_char) MTPM3UAASTRAFFICMODE, ASN_OBJECT_ID, RWRITE, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 6}},
#define   MTPM3UAASROWSTATUS    415
	{(u_char) MTPM3UAASROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 7}},
#define   MTPDEFAULTSCTPNODELAY  416
	{(u_char) MTPDEFAULTSCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpMIB, 4, {1, 2, 1, 1}},
#define   MTPDEFAULTSCTPMAXSEG  417
	{(u_char) MTPDEFAULTSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 2}},
#define   MTPDEFAULTSCTPHEARTBEATITVL  418
	{(u_char) MTPDEFAULTSCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 3}},
#define   MTPDEFAULTSCTPHEARTBEAT  419
	{(u_char) MTPDEFAULTSCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpMIB, 4, {1, 2, 1, 4}},
#define   MTPDEFAULTSCTPRTOINITIAL  420
	{(u_char) MTPDEFAULTSCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 5}},
#define   MTPDEFAULTSCTPRTOMIN  421
	{(u_char) MTPDEFAULTSCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 6}},
#define   MTPDEFAULTSCTPRTOMAX  422
	{(u_char) MTPDEFAULTSCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 7}},
#define   MTPDEFAULTSCTPPATHMAXRETRANS  423
	{(u_char) MTPDEFAULTSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 8}},
#define   MTPDEFAULTSCTPCOOKIELIFE  424
	{(u_char) MTPDEFAULTSCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 9}},
#define   MTPDEFAULTSCTPCOOKIEINC  425
	{(u_char) MTPDEFAULTSCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 10}},
#define   MTPDEFAULTSCTPMAXINITRETRIES  426
	{(u_char) MTPDEFAULTSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 11}},
#define   MTPDEFAULTSCTPMAXBURST  427
	{(u_char) MTPDEFAULTSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 12}},
#define   MTPDEFAULTSCTPASSOCMAXRETRANS  428
	{(u_char) MTPDEFAULTSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 13}},
#define   MTPDEFAULTSCTPSACKDELAY  429
	{(u_char) MTPDEFAULTSCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 14}},
#define   MTPDEFAULTSCTPLIFETIME  430
	{(u_char) MTPDEFAULTSCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 15}},
};

/* (L = length of the oidsuffix) */
struct mtpMIB_data *mtpMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *mtpSapTableStorage = NULL;
struct header_complex_index *mtpNaTableStorage = NULL;
struct header_complex_index *mtpMsTableStorage = NULL;
struct header_complex_index *mtpSpProfileTableStorage = NULL;
struct header_complex_index *mtpSpTableStorage = NULL;
struct header_complex_index *mtpL3TableStorage = NULL;
struct header_complex_index *mtpGsTableStorage = NULL;
struct header_complex_index *mtpGsLineTableStorage = NULL;
struct header_complex_index *mtpGsLineContentTableStorage = NULL;
struct header_complex_index *mtpRsProfileTableStorage = NULL;
struct header_complex_index *mtpRsTableStorage = NULL;
struct header_complex_index *mtpRtProfileTableStorage = NULL;
struct header_complex_index *mtpRtTableStorage = NULL;
struct header_complex_index *mtpRtLsaTableStorage = NULL;
struct header_complex_index *mtpLsProfileTableStorage = NULL;
struct header_complex_index *mtpLsTableStorage = NULL;
struct header_complex_index *mtpSlL3ProfileTableStorage = NULL;
struct header_complex_index *mtpSlL2ProfileTableStorage = NULL;
struct header_complex_index *mtpSlTableStorage = NULL;
struct header_complex_index *mtpSlSdlListTableStorage = NULL;
struct header_complex_index *mtpSlSdtListTableStorage = NULL;
struct header_complex_index *mtpNbTableStorage = NULL;
struct header_complex_index *mtpSaalTableStorage = NULL;
struct header_complex_index *mtpM2paTableStorage = NULL;
struct header_complex_index *mtpSdtTableStorage = NULL;
struct header_complex_index *mtpSdlTableStorage = NULL;
struct header_complex_index *mtpSctpProfileTableStorage = NULL;
struct header_complex_index *mtpSctpTableStorage = NULL;
struct header_complex_index *mtpSctpLocalTableStorage = NULL;
struct header_complex_index *mtpSctpRemoteTableStorage = NULL;
struct header_complex_index *mtpM2uaAspTableStorage = NULL;
struct header_complex_index *mtpM2uaAsTableStorage = NULL;
struct header_complex_index *mtpM3uaAspTableStorage = NULL;
struct header_complex_index *mtpM3uaAsTableStorage = NULL;

#if defined MODULE
void (*mtpMIBold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void mtpMIB_loop_handler(int);
void mtpMIB_fd_handler(int, void *);
#endif				/* defined MOUDLE */
/**
 * @fn void init_mtpMIB(void)
 * @brief mtpMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (mtpMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_mtpMIB(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("mtpMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("mtpMIB", mtpMIB_variables, variable7, mtpMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_mtpMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("mtpMIB", parse_mtpMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSapTable", parse_mtpSapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNaTable", parse_mtpNaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpMsTable", parse_mtpMsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpProfileTable", parse_mtpSpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpTable", parse_mtpSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL3Table", parse_mtpL3Table, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsTable", parse_mtpGsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineTable", parse_mtpGsLineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineContentTable", parse_mtpGsLineContentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsProfileTable", parse_mtpRsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsTable", parse_mtpRsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtProfileTable", parse_mtpRtProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtTable", parse_mtpRtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtLsaTable", parse_mtpRtLsaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsProfileTable", parse_mtpLsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsTable", parse_mtpLsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL3ProfileTable", parse_mtpSlL3ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL2ProfileTable", parse_mtpSlL2ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlTable", parse_mtpSlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdlListTable", parse_mtpSlSdlListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdtListTable", parse_mtpSlSdtListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNbTable", parse_mtpNbTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSaalTable", parse_mtpSaalTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM2paTable", parse_mtpM2paTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdtTable", parse_mtpSdtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdlTable", parse_mtpSdlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSctpProfileTable", parse_mtpSctpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSctpTable", parse_mtpSctpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSctpLocalTable", parse_mtpSctpLocalTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSctpRemoteTable", parse_mtpSctpRemoteTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM2uaAspTable", parse_mtpM2uaAspTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM2uaAsTable", parse_mtpM2uaAsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM3uaAspTable", parse_mtpM3uaAspTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM3uaAsTable", parse_mtpM3uaAsTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL3Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineContentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtLsaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL3ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL2ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdlListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdtListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNbTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSaalTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM2paTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSctpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSctpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSctpLocalTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSctpRemoteTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM2uaAspTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM2uaAsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM3uaAspTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM3uaAsTable, NULL);

	/* place any other initialization junk you need here */
#if defined MODULE
	if (sa_readfd != 0) {
		register_readfd(sa_readfd, mtpMIB_fd_handler, (void *) 0);
		register_exceptfd(sa_readfd, mtpMIB_fd_handler, (void *) 1);
	}
#if defined MASTER
	mtpMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &mtpMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
#endif				/* defined MASTER */
#endif				/* defined MODULE */
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/**
 * @fn void deinit_mtpMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (mtpMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_mtpMIB(void)
{
	DEBUGMSGTL(("mtpMIB", "deinitializating...  "));
#if defined MODULE
#if defined MASTER
	external_signal_handler[SIGCHLD] = mtpMIBold_signal_handler;
#endif				/* defined MASTER */
	if (sa_readfd != 0) {
		unregister_exceptfd(sa_readfd);
		unregister_readfd(sa_readfd);
		close(sa_readfd);
		sa_readfd = 0;
	}
#endif				/* defined MODULE */
	unregister_mib(mtpMIB_variables_oid, sizeof(mtpMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("mtpMIB");
	snmpd_unregister_config_handler("mtpSapTable");
	snmpd_unregister_config_handler("mtpNaTable");
	snmpd_unregister_config_handler("mtpMsTable");
	snmpd_unregister_config_handler("mtpSpProfileTable");
	snmpd_unregister_config_handler("mtpSpTable");
	snmpd_unregister_config_handler("mtpL3Table");
	snmpd_unregister_config_handler("mtpGsTable");
	snmpd_unregister_config_handler("mtpGsLineTable");
	snmpd_unregister_config_handler("mtpGsLineContentTable");
	snmpd_unregister_config_handler("mtpRsProfileTable");
	snmpd_unregister_config_handler("mtpRsTable");
	snmpd_unregister_config_handler("mtpRtProfileTable");
	snmpd_unregister_config_handler("mtpRtTable");
	snmpd_unregister_config_handler("mtpRtLsaTable");
	snmpd_unregister_config_handler("mtpLsProfileTable");
	snmpd_unregister_config_handler("mtpLsTable");
	snmpd_unregister_config_handler("mtpSlL3ProfileTable");
	snmpd_unregister_config_handler("mtpSlL2ProfileTable");
	snmpd_unregister_config_handler("mtpSlTable");
	snmpd_unregister_config_handler("mtpSlSdlListTable");
	snmpd_unregister_config_handler("mtpSlSdtListTable");
	snmpd_unregister_config_handler("mtpNbTable");
	snmpd_unregister_config_handler("mtpSaalTable");
	snmpd_unregister_config_handler("mtpM2paTable");
	snmpd_unregister_config_handler("mtpSdtTable");
	snmpd_unregister_config_handler("mtpSdlTable");
	snmpd_unregister_config_handler("mtpSctpProfileTable");
	snmpd_unregister_config_handler("mtpSctpTable");
	snmpd_unregister_config_handler("mtpSctpLocalTable");
	snmpd_unregister_config_handler("mtpSctpRemoteTable");
	snmpd_unregister_config_handler("mtpM2uaAspTable");
	snmpd_unregister_config_handler("mtpM2uaAsTable");
	snmpd_unregister_config_handler("mtpM3uaAspTable");
	snmpd_unregister_config_handler("mtpM3uaAsTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

int
term_mtpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_mtpMIB();
	return 0;
}

/**
 * @fn struct mtpMIB_data *mtpMIB_create(void)
 * @brief create a fresh data structure representing scalars in mtpMIB.
 *
 * Creates a new mtpMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in mtpMIB.
 */
struct mtpMIB_data *
mtpMIB_create(void)
{
	struct mtpMIB_data *StorageNew = SNMP_MALLOC_STRUCT(mtpMIB_data);

	DEBUGMSGTL(("mtpMIB", "creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		StorageNew->mtpDefaultSctpNoDelay = TV_TRUE;
		StorageNew->mtpDefaultSctpMaxseg = 65536;
		StorageNew->mtpDefaultSctpHeartbeatItvl = 60000;
		StorageNew->mtpDefaultSctpHeartbeat = TV_TRUE;
		StorageNew->mtpDefaultSctpRtoInitial = 3000;
		StorageNew->mtpDefaultSctpRtoMin = 1000;
		StorageNew->mtpDefaultSctpRtoMax = 60000;
		StorageNew->mtpDefaultSctpPathMaxRetrans = 5;
		StorageNew->mtpDefaultSctpCookieLife = 60000;
		StorageNew->mtpDefaultSctpCookieInc = 1000;
		StorageNew->mtpDefaultSctpMaxInitRetries = 8;
		StorageNew->mtpDefaultSctpMaxBurst = 4;
		StorageNew->mtpDefaultSctpAssocMaxRetrans = 10;
		StorageNew->mtpDefaultSctpSackDelay = 200;
		StorageNew->mtpDefaultSctpLifetime = 0;

	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int mtpMIB_destroy(struct mtpMIB_data **thedata)
 * @param thedata pointer to the data structure in mtpMIB.
 * @brief delete a scalars structure from mtpMIB.
 *
 * Frees scalars that were previously removed from mtpMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpMIB_destroy(struct mtpMIB_data **thedata)
{
	struct mtpMIB_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpMIB_add(struct mtpMIB_data *thedata)
 * @param thedata the structure representing mtpMIB scalars.
 * @brief adds node to the mtpMIB scalar data set.
 *
 * Adds a scalar structure to the mtpMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
mtpMIB_add(struct mtpMIB_data *thedata)
{
	DEBUGMSGTL(("mtpMIB", "adding data...  "));
	mtpMIBStorage = thedata;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpMIB entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_mtpMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpMIB_data *StorageTmp = mtpMIB_create();

	DEBUGMSGTL(("mtpMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpDefaultSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpDefaultSctpHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpLifetime, &tmpsize);
	mtpMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_mtpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpMIB_data *StorageTmp;

	DEBUGMSGTL(("mtpMIB", "storing data...  "));
	refresh_mtpMIB(1);
	if ((StorageTmp = mtpMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "mtpMIB ");
		cptr = line + strlen(line);
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpDefaultSctpNoDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpMaxseg, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpHeartbeatItvl, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpDefaultSctpHeartbeat, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpRtoInitial, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpRtoMin, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpRtoMax, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpPathMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpCookieLife, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpCookieInc, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpMaxInitRetries, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpMaxBurst, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpAssocMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpSackDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpLifetime, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_mtpMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of mtpMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_mtpMIB(int force)
{
	if (mtpMIBStorage == NULL) {
		struct mtpMIB_data *StorageNew;

		if ((StorageNew = mtpMIB_create()) == NULL)
			return;
		mtpMIBStorage = StorageNew;
		mtpMIB_refresh = 1;
	}
	if (!force && mtpMIB_refresh == 0)
		return;
	mtpMIB_refresh = 0;
	/* XXX: Update scalars as required here... */
}

/**
 * @fn u_char * var_mtpMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in mtpMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_mtpMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMIB_data *StorageTmp;
	u_char *rval;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_mtpMIB(0);
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return NULL;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPDEFAULTSCTPNODELAY:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpNoDelay);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpNoDelay;
		break;
	case (u_char) MTPDEFAULTSCTPMAXSEG:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpMaxseg);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpMaxseg;
		break;
	case (u_char) MTPDEFAULTSCTPHEARTBEATITVL:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpHeartbeatItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpHeartbeatItvl);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpHeartbeatItvl;
		break;
	case (u_char) MTPDEFAULTSCTPHEARTBEAT:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpHeartbeat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpHeartbeat);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpHeartbeat;
		break;
	case (u_char) MTPDEFAULTSCTPRTOINITIAL:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpRtoInitial;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpRtoInitial);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpRtoInitial;
		break;
	case (u_char) MTPDEFAULTSCTPRTOMIN:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpRtoMin;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpRtoMin);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpRtoMin;
		break;
	case (u_char) MTPDEFAULTSCTPRTOMAX:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpRtoMax;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpRtoMax);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpRtoMax;
		break;
	case (u_char) MTPDEFAULTSCTPPATHMAXRETRANS:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpPathMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpPathMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpPathMaxRetrans;
		break;
	case (u_char) MTPDEFAULTSCTPCOOKIELIFE:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpCookieLife;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpCookieLife);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpCookieLife;
		break;
	case (u_char) MTPDEFAULTSCTPCOOKIEINC:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpCookieInc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpCookieInc);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpCookieInc;
		break;
	case (u_char) MTPDEFAULTSCTPMAXINITRETRIES:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpMaxInitRetries;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpMaxInitRetries);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpMaxInitRetries;
		break;
	case (u_char) MTPDEFAULTSCTPMAXBURST:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpMaxBurst;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpMaxBurst);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpMaxBurst;
		break;
	case (u_char) MTPDEFAULTSCTPASSOCMAXRETRANS:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpAssocMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpAssocMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpAssocMaxRetrans;
		break;
	case (u_char) MTPDEFAULTSCTPSACKDELAY:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpSackDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpSackDelay);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpSackDelay;
		break;
	case (u_char) MTPDEFAULTSCTPLIFETIME:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpLifetime);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpLifetime;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn struct mtpSapTable_data *mtpSapTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSapTable table.
 *
 * Creates a new mtpSapTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSapTable_data *
mtpSapTable_create(void)
{
	struct mtpSapTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSapTable_data);

	DEBUGMSGTL(("mtpSapTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpSap2Address = 0;
		StorageNew->mtpSapUserPart = 0;
		StorageNew->mtpSapUserPartStatus = 0;
		if ((StorageNew->mtpSapUserEntityNames = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSapUserEntityNamesLen = 2;
		if ((StorageNew->mtpSapProviderEntityNames = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSapProviderEntityNamesLen = 2;
		StorageNew->mtpSapUsageState = 0;
		if ((StorageNew->mtpSapAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSapAsaProfilePointerLen = 2;
		if ((StorageNew->mtpSapName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSapNameLen = strlen("");
		StorageNew->mtpSapLongMessageSupported = 0;
		StorageNew->mtpSapRowStatus = 0;
		StorageNew->mtpSapRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSapTable_data *mtpSapTable_duplicate(struct mtpSapTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSapTable_data *
mtpSapTable_duplicate(struct mtpSapTable_data *thedata)
{
	struct mtpSapTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSapTable_data);

	DEBUGMSGTL(("mtpSapTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSapTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSapTable_destroy(struct mtpSapTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSapTable_destroy(struct mtpSapTable_data **thedata)
{
	struct mtpSapTable_data *StorageDel;

	DEBUGMSGTL(("mtpSapTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSapUserEntityNames);
		StorageDel->mtpSapUserEntityNamesLen = 0;
		SNMP_FREE(StorageDel->mtpSapProviderEntityNames);
		StorageDel->mtpSapProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel->mtpSapAsaProfilePointer);
		StorageDel->mtpSapAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSapName);
		StorageDel->mtpSapNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSapTable_add(struct mtpSapTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSapTable table data set.
 *
 * Adds a table row structure to the mtpSapTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSapTable_add(struct mtpSapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSapId, sizeof(thedata->mtpSapId));
	header_complex_add_data(&mtpSapTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSapTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSapTable_del(struct mtpSapTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSapTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSapTable_del(struct mtpSapTable_data *thedata)
{
	struct mtpSapTable_data *StorageDel;

	DEBUGMSGTL(("mtpSapTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSapTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSapTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSapTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSapTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSapTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSapTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSapTable_data *StorageTmp = mtpSapTable_create();

	DEBUGMSGTL(("mtpSapTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSapId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSap2Address, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUserPart, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUserPartStatus, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSapUserEntityNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapUserEntityNames, &StorageTmp->mtpSapUserEntityNamesLen);
	if (StorageTmp->mtpSapUserEntityNames == NULL) {
		config_perror("invalid specification for mtpSapUserEntityNames");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSapProviderEntityNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapProviderEntityNames, &StorageTmp->mtpSapProviderEntityNamesLen);
	if (StorageTmp->mtpSapProviderEntityNames == NULL) {
		config_perror("invalid specification for mtpSapProviderEntityNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSapAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapAsaProfilePointer, &StorageTmp->mtpSapAsaProfilePointerLen);
	if (StorageTmp->mtpSapAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSapAsaProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSapName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSapName, &StorageTmp->mtpSapNameLen);
	if (StorageTmp->mtpSapName == NULL) {
		config_perror("invalid specification for mtpSapName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapLongMessageSupported, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapRowStatus, &tmpsize);
	mtpSapTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
}

/*
 * store_mtpSapTable(): store configuraiton file for mtpSapTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSapTable", "storing data...  "));
	refresh_mtpSapTable(1);
	(void) tmpsize;
	for (hcindex = mtpSapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSapTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSapTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSapId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSap2Address, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUserPart, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUserPartStatus, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapUserEntityNames, &StorageTmp->mtpSapUserEntityNamesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapProviderEntityNames, &StorageTmp->mtpSapProviderEntityNamesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapAsaProfilePointer, &StorageTmp->mtpSapAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSapName, &StorageTmp->mtpSapNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapLongMessageSupported, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpNaTable_data *mtpNaTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpNaTable table.
 *
 * Creates a new mtpNaTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpNaTable_data *
mtpNaTable_create(void)
{
	struct mtpNaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNaTable_data);

	DEBUGMSGTL(("mtpNaTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		{
			static oid tmpoid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 0, 1, 4, 1, 1, 0 };
			if ((StorageNew->mtpNaProtocolVariant = snmp_duplicate_objid(tmpoid, 15)))
				StorageNew->mtpNaProtocolVariantLen = 15;
		}
		StorageNew->mtpNaProtocolYear = MTPNAPROTOCOLYEAR_YCURRENT;
		if (memdup((u_char **) &StorageNew->mtpNaProtocolOptions, (u_char *) "\x80\x00\x07\x81", 4) == SNMPERR_SUCCESS)
			StorageNew->mtpNaProtocolOptionsLen = 4;
		StorageNew->mtpNaNetworkIndicator = MTPNANETWORKINDICATOR_INTERNATIONALNETWORK1;
		if (memdup((u_char **) &StorageNew->mtpNaPointCodeFormat, (u_char *) "\x03\x08\x03", 3) == SNMPERR_SUCCESS)
			StorageNew->mtpNaPointCodeFormatLen = 3;
		StorageNew->mtpNaSlsLength = MTPNASLSLENGTH_SLS4BITS;
		StorageNew->mtpNaSpDefault = (uint8_t *) strdup("");
		StorageNew->mtpNaSpDefaultLen = strlen("");
		StorageNew->mtpNaName = (uint8_t *) strdup("");
		StorageNew->mtpNaNameLen = strlen("");
		StorageNew->mtpNaRowStatus = 0;
		StorageNew->mtpNaRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpNaTable_data *mtpNaTable_duplicate(struct mtpNaTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpNaTable_data *
mtpNaTable_duplicate(struct mtpNaTable_data *thedata)
{
	struct mtpNaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNaTable_data);

	DEBUGMSGTL(("mtpNaTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpNaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpNaTable_destroy(struct mtpNaTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpNaTable_destroy(struct mtpNaTable_data **thedata)
{
	struct mtpNaTable_data *StorageDel;

	DEBUGMSGTL(("mtpNaTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpNaProtocolVariant);
		StorageDel->mtpNaProtocolVariantLen = 0;
		SNMP_FREE(StorageDel->mtpNaProtocolOptions);
		StorageDel->mtpNaProtocolOptionsLen = 0;
		SNMP_FREE(StorageDel->mtpNaPointCodeFormat);
		StorageDel->mtpNaPointCodeFormatLen = 0;
		SNMP_FREE(StorageDel->mtpNaSpDefault);
		StorageDel->mtpNaSpDefaultLen = 0;
		SNMP_FREE(StorageDel->mtpNaName);
		StorageDel->mtpNaNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNaTable_add(struct mtpNaTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpNaTable table data set.
 *
 * Adds a table row structure to the mtpNaTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpNaTable_add(struct mtpNaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpNaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpNaId, sizeof(thedata->mtpNaId));
	header_complex_add_data(&mtpNaTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNaTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNaTable_del(struct mtpNaTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpNaTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpNaTable_del(struct mtpNaTable_data *thedata)
{
	struct mtpNaTable_data *StorageDel;

	DEBUGMSGTL(("mtpNaTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpNaTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpNaTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpNaTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpNaTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpNaTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpNaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpNaTable_data *StorageTmp = mtpNaTable_create();

	DEBUGMSGTL(("mtpNaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpNaProtocolVariant);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
	if (StorageTmp->mtpNaProtocolVariant == NULL) {
		config_perror("invalid specification for mtpNaProtocolVariant");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaProtocolYear, &tmpsize);
	SNMP_FREE(StorageTmp->mtpNaProtocolOptions);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
	if (StorageTmp->mtpNaProtocolOptions == NULL) {
		config_perror("invalid specification for mtpNaProtocolOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaNetworkIndicator, &tmpsize);
	SNMP_FREE(StorageTmp->mtpNaPointCodeFormat);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
	if (StorageTmp->mtpNaPointCodeFormat == NULL) {
		config_perror("invalid specification for mtpNaPointCodeFormat");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaSlsLength, &tmpsize);
	SNMP_FREE(StorageTmp->mtpNaSpDefault);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaSpDefault, &StorageTmp->mtpNaSpDefaultLen);
	if (StorageTmp->mtpNaSpDefault == NULL) {
		config_perror("invalid specification for mtpNaSpDefault");
		return;
	}
	SNMP_FREE(StorageTmp->mtpNaName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
	if (StorageTmp->mtpNaName == NULL) {
		config_perror("invalid specification for mtpNaName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaRowStatus, &tmpsize);
	mtpNaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
}

/*
 * store_mtpNaTable(): store configuraiton file for mtpNaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpNaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpNaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNaTable", "storing data...  "));
	refresh_mtpNaTable(1);
	(void) tmpsize;
	for (hcindex = mtpNaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNaTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpNaTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaProtocolYear, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaNetworkIndicator, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaSlsLength, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaSpDefault, &StorageTmp->mtpNaSpDefaultLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpMsTable_data *mtpMsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpMsTable table.
 *
 * Creates a new mtpMsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpMsTable_data *
mtpMsTable_create(void)
{
	struct mtpMsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpMsTable_data);

	DEBUGMSGTL(("mtpMsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpMsName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpMsNameLen = strlen("");
		if (memdup((u_char **) &StorageNew->mtpMsAlarmStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpMsAlarmStatusLen = 1;
		StorageNew->mtpMsOperationalState = MTPMSOPERATIONALSTATE_DISABLED;
		StorageNew->mtpMsUsageState = MTPMSUSAGESTATE_IDLE;
		if ((StorageNew->mtpMsManagedElementType = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpMsManagedElementTypeLen = strlen("");
		if ((StorageNew->mtpMsModelCode = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpMsModelCodeLen = strlen("");
		if ((StorageNew->mtpMsVendorName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpMsVendorNameLen = strlen("");
		if ((StorageNew->mtpMsUserLabel = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpMsUserLabelLen = strlen("");
		if ((StorageNew->mtpMsVersion = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpMsVersionLen = strlen("");
		if ((StorageNew->mtpMsAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpMsAsaProfilePointerLen = 2;
		if ((StorageNew->mtpMsNetworkElementAliases = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpMsNetworkElementAliasesLen = strlen("");
		StorageNew->mtpMsRowStatus = 0;
		StorageNew->mtpMsRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpMsTable_data *mtpMsTable_duplicate(struct mtpMsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpMsTable_data *
mtpMsTable_duplicate(struct mtpMsTable_data *thedata)
{
	struct mtpMsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpMsTable_data);

	DEBUGMSGTL(("mtpMsTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpMsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpMsTable_destroy(struct mtpMsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpMsTable_destroy(struct mtpMsTable_data **thedata)
{
	struct mtpMsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpMsName);
		StorageDel->mtpMsNameLen = 0;
		SNMP_FREE(StorageDel->mtpMsAlarmStatus);
		StorageDel->mtpMsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->mtpMsManagedElementType);
		StorageDel->mtpMsManagedElementTypeLen = 0;
		SNMP_FREE(StorageDel->mtpMsModelCode);
		StorageDel->mtpMsModelCodeLen = 0;
		SNMP_FREE(StorageDel->mtpMsVendorName);
		StorageDel->mtpMsVendorNameLen = 0;
		SNMP_FREE(StorageDel->mtpMsUserLabel);
		StorageDel->mtpMsUserLabelLen = 0;
		SNMP_FREE(StorageDel->mtpMsVersion);
		StorageDel->mtpMsVersionLen = 0;
		SNMP_FREE(StorageDel->mtpMsAsaProfilePointer);
		StorageDel->mtpMsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpMsNetworkElementAliases);
		StorageDel->mtpMsNetworkElementAliasesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpMsTable_add(struct mtpMsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpMsTable table data set.
 *
 * Adds a table row structure to the mtpMsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpMsTable_add(struct mtpMsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	header_complex_add_data(&mtpMsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpMsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpMsTable_del(struct mtpMsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpMsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpMsTable_del(struct mtpMsTable_data *thedata)
{
	struct mtpMsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpMsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpMsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpMsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpMsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpMsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpMsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpMsTable_data *StorageTmp = mtpMsTable_create();

	DEBUGMSGTL(("mtpMsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpMsName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsName, &StorageTmp->mtpMsNameLen);
	if (StorageTmp->mtpMsName == NULL) {
		config_perror("invalid specification for mtpMsName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsAlarmStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpMsAlarmStatus, &StorageTmp->mtpMsAlarmStatusLen);
	if (StorageTmp->mtpMsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpMsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpMsManagedElementType);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsManagedElementType, &StorageTmp->mtpMsManagedElementTypeLen);
	if (StorageTmp->mtpMsManagedElementType == NULL) {
		config_perror("invalid specification for mtpMsManagedElementType");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsModelCode);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsModelCode, &StorageTmp->mtpMsModelCodeLen);
	if (StorageTmp->mtpMsModelCode == NULL) {
		config_perror("invalid specification for mtpMsModelCode");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsVendorName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVendorName, &StorageTmp->mtpMsVendorNameLen);
	if (StorageTmp->mtpMsVendorName == NULL) {
		config_perror("invalid specification for mtpMsVendorName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsUserLabel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsUserLabel, &StorageTmp->mtpMsUserLabelLen);
	if (StorageTmp->mtpMsUserLabel == NULL) {
		config_perror("invalid specification for mtpMsUserLabel");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsVersion);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVersion, &StorageTmp->mtpMsVersionLen);
	if (StorageTmp->mtpMsVersion == NULL) {
		config_perror("invalid specification for mtpMsVersion");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpMsAsaProfilePointer, &StorageTmp->mtpMsAsaProfilePointerLen);
	if (StorageTmp->mtpMsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpMsAsaProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsNetworkElementAliases);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsNetworkElementAliases, &StorageTmp->mtpMsNetworkElementAliasesLen);
	if (StorageTmp->mtpMsNetworkElementAliases == NULL) {
		config_perror("invalid specification for mtpMsNetworkElementAliases");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsRowStatus, &tmpsize);
	mtpMsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
}

/*
 * store_mtpMsTable(): store configuraiton file for mtpMsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpMsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpMsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMsTable", "storing data...  "));
	refresh_mtpMsTable(1);
	(void) tmpsize;
	for (hcindex = mtpMsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpMsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpMsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsName, &StorageTmp->mtpMsNameLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpMsAlarmStatus, &StorageTmp->mtpMsAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsManagedElementType, &StorageTmp->mtpMsManagedElementTypeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsModelCode, &StorageTmp->mtpMsModelCodeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVendorName, &StorageTmp->mtpMsVendorNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsUserLabel, &StorageTmp->mtpMsUserLabelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVersion, &StorageTmp->mtpMsVersionLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpMsAsaProfilePointer, &StorageTmp->mtpMsAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsNetworkElementAliases, &StorageTmp->mtpMsNetworkElementAliasesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSpProfileTable_data *mtpSpProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSpProfileTable table.
 *
 * Creates a new mtpSpProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSpProfileTable_data *
mtpSpProfileTable_create(void)
{
	struct mtpSpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);

	DEBUGMSGTL(("mtpSpProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpProfileTimerT1R = 80;
		StorageNew->mtpSpProfileTimerT2 = 140;
		StorageNew->mtpSpProfileTimerT4 = 80;
		StorageNew->mtpSpProfileTimerT5 = 80;
		StorageNew->mtpSpProfileTimerT7 = 150;
		StorageNew->mtpSpProfileTimerT11 = 6000;
		StorageNew->mtpSpProfileTimerT12 = 120;
		StorageNew->mtpSpProfileTimerT13 = 120;
		StorageNew->mtpSpProfileTimerT14 = 250;
		StorageNew->mtpSpProfileTimerT15 = 250;
		StorageNew->mtpSpProfileTimerT16 = 200;
		StorageNew->mtpSpProfileTimerT18I = 60000;
		StorageNew->mtpSpProfileTimerT19I = 6800;
		StorageNew->mtpSpProfileTimerT20I = 6000;
		StorageNew->mtpSpProfileTimerT21I = 6400;
		StorageNew->mtpSpProfileTimerT22I = 27000;
		StorageNew->mtpSpProfileTimerT23I = 27000;
		StorageNew->mtpSpProfileTimerT20A = 10000;
		StorageNew->mtpSpProfileTimerT21A = 10000;
		StorageNew->mtpSpProfileTimerT22A = 60000;
		StorageNew->mtpSpProfileTimerT23A = 60000;
		StorageNew->mtpSpProfileTimerT24A = 60000;
		StorageNew->mtpSpProfileTimerT26A = 1350;
		StorageNew->mtpSpProfileTimerT27A = 300;
		StorageNew->mtpSpProfileTimerT1T = 400;
		StorageNew->mtpSpProfileTimerT2T = 6000;
		if ((StorageNew->mtpSpProfileName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSpProfileNameLen = strlen("");
		StorageNew->mtpSpProfileCircularRteDetect = MTPSPPROFILECIRCULARRTEDETECT_NONE;
		StorageNew->mtpSpRsDefault = (uint8_t *) strdup("");
		StorageNew->mtpSpRsDefaultLen = strlen("");
		StorageNew->mtpSpLsDefault = (uint8_t *) strdup("");
		StorageNew->mtpSpLsDefaultLen = strlen("");
		StorageNew->mtpSpProfileRowStatus = 0;
		StorageNew->mtpSpProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSpProfileTable_data *mtpSpProfileTable_duplicate(struct mtpSpProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSpProfileTable_data *
mtpSpProfileTable_duplicate(struct mtpSpProfileTable_data *thedata)
{
	struct mtpSpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);

	DEBUGMSGTL(("mtpSpProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSpProfileTable_destroy(struct mtpSpProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSpProfileTable_destroy(struct mtpSpProfileTable_data **thedata)
{
	struct mtpSpProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSpProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSpProfileId);
		StorageDel->mtpSpProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSpProfileName);
		StorageDel->mtpSpProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpSpRsDefault);
		StorageDel->mtpSpRsDefaultLen = 0;
		SNMP_FREE(StorageDel->mtpSpLsDefault);
		StorageDel->mtpSpLsDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpProfileTable_add(struct mtpSpProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSpProfileTable table data set.
 *
 * Adds a table row structure to the mtpSpProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSpProfileTable_add(struct mtpSpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSpProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpProfileId, thedata->mtpSpProfileIdLen);
	header_complex_add_data(&mtpSpProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpProfileTable_del(struct mtpSpProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSpProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSpProfileTable_del(struct mtpSpProfileTable_data *thedata)
{
	struct mtpSpProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSpProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSpProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSpProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSpProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSpProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSpProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSpProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpProfileTable_data *StorageTmp = mtpSpProfileTable_create();

	DEBUGMSGTL(("mtpSpProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSpProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileId, &StorageTmp->mtpSpProfileIdLen);
	if (StorageTmp->mtpSpProfileId == NULL) {
		config_perror("invalid specification for mtpSpProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT1R, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT12, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT13, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT14, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT18I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT19I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT20I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT21I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT22I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT23I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT20A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT21A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT22A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT23A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT24A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT26A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT27A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT2T, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSpProfileName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
	if (StorageTmp->mtpSpProfileName == NULL) {
		config_perror("invalid specification for mtpSpProfileName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileCircularRteDetect, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSpRsDefault);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpRsDefault, &StorageTmp->mtpSpRsDefaultLen);
	if (StorageTmp->mtpSpRsDefault == NULL) {
		config_perror("invalid specification for mtpSpRsDefault");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpLsDefault);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpLsDefault, &StorageTmp->mtpSpLsDefaultLen);
	if (StorageTmp->mtpSpLsDefault == NULL) {
		config_perror("invalid specification for mtpSpLsDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileRowStatus, &tmpsize);
	mtpSpProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
}

/*
 * store_mtpSpProfileTable(): store configuraiton file for mtpSpProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpProfileTable", "storing data...  "));
	refresh_mtpSpProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpSpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSpProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileId, &StorageTmp->mtpSpProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT1R, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT11, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT12, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT13, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT14, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT15, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT16, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT18I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT19I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT20I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT21I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT22I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT23I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT20A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT21A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT22A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT23A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT24A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT26A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT27A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT1T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT2T, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileCircularRteDetect, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpRsDefault, &StorageTmp->mtpSpRsDefaultLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpLsDefault, &StorageTmp->mtpSpLsDefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSpTable_data *mtpSpTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSpTable table.
 *
 * Creates a new mtpSpTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSpTable_data *
mtpSpTable_create(void)
{
	struct mtpSpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpTable_data);

	DEBUGMSGTL(("mtpSpTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		if (memdup((u_char **) &StorageNew->mtpSpPointCode, (u_char *) "\x00\x00\x00\x00", 4) == SNMPERR_SUCCESS)
			StorageNew->mtpSpPointCodeLen = 4;
		StorageNew->mtpSpType = MTPSPTYPE_SEP;
		StorageNew->mtpSpOperationalState = MTPSPOPERATIONALSTATE_DISABLED;
		if (memdup((u_char **) &StorageNew->mtpSpProceduralStatus, (u_char *) "\x80", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpSpProceduralStatusLen = 1;
		if (memdup((u_char **) &StorageNew->mtpSpAvailabilityStatus, (u_char *) "\x00\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->mtpSpAvailabilityStatusLen = 2;
		StorageNew->mtpSpVersion = (uint8_t *) strdup("ITU-T Q.704 1996");
		StorageNew->mtpSpVersionLen = strlen("ITU-T Q.704 1996");
		StorageNew->mtpSpNetworkIndicator = MTPSPNETWORKINDICATOR_INTERNATIONALNETWORK1;
		if ((StorageNew->mtpSpName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSpNameLen = strlen("");
		StorageNew->mtpSpProfilePointer = (uint8_t *) strdup("");
		StorageNew->mtpSpProfilePointerLen = strlen("");
		if ((StorageNew->mtpSpNaPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSpNaPointerLen = 2;
		if (memdup((u_char **) &StorageNew->mtpSpOptions, (u_char *) "\x20", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpSpOptionsLen = 1;
		if (memdup((u_char **) &StorageNew->mtpSpUsers, (u_char *) "\x80\x14", 2) == SNMPERR_SUCCESS)
			StorageNew->mtpSpUsersLen = 2;
		if (memdup((u_char **) &StorageNew->mtpSpAlarmStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpSpAlarmStatusLen = 1;
		StorageNew->mtpSpRowStatus = 0;
		StorageNew->mtpSpRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSpTable_data *mtpSpTable_duplicate(struct mtpSpTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSpTable_data *
mtpSpTable_duplicate(struct mtpSpTable_data *thedata)
{
	struct mtpSpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpTable_data);

	DEBUGMSGTL(("mtpSpTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSpTable_destroy(struct mtpSpTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSpTable_destroy(struct mtpSpTable_data **thedata)
{
	struct mtpSpTable_data *StorageDel;

	DEBUGMSGTL(("mtpSpTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSpPointCode);
		StorageDel->mtpSpPointCodeLen = 0;
		SNMP_FREE(StorageDel->mtpSpProceduralStatus);
		StorageDel->mtpSpProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSpAvailabilityStatus);
		StorageDel->mtpSpAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSpVersion);
		StorageDel->mtpSpVersionLen = 0;
		SNMP_FREE(StorageDel->mtpSpName);
		StorageDel->mtpSpNameLen = 0;
		SNMP_FREE(StorageDel->mtpSpProfilePointer);
		StorageDel->mtpSpProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSpNaPointer);
		StorageDel->mtpSpNaPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSpOptions);
		StorageDel->mtpSpOptionsLen = 0;
		SNMP_FREE(StorageDel->mtpSpUsers);
		StorageDel->mtpSpUsersLen = 0;
		SNMP_FREE(StorageDel->mtpSpAlarmStatus);
		StorageDel->mtpSpAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpTable_add(struct mtpSpTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSpTable table data set.
 *
 * Adds a table row structure to the mtpSpTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSpTable_add(struct mtpSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	header_complex_add_data(&mtpSpTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpTable_del(struct mtpSpTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSpTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSpTable_del(struct mtpSpTable_data *thedata)
{
	struct mtpSpTable_data *StorageDel;

	DEBUGMSGTL(("mtpSpTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSpTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSpTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSpTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSpTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSpTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpTable_data *StorageTmp = mtpSpTable_create();

	DEBUGMSGTL(("mtpSpTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSpPointCode);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpPointCode, &StorageTmp->mtpSpPointCodeLen);
	if (StorageTmp->mtpSpPointCode == NULL) {
		config_perror("invalid specification for mtpSpPointCode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSpProceduralStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
	if (StorageTmp->mtpSpProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSpProceduralStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpAvailabilityStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
	if (StorageTmp->mtpSpAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSpAvailabilityStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpVersion);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpVersion, &StorageTmp->mtpSpVersionLen);
	if (StorageTmp->mtpSpVersion == NULL) {
		config_perror("invalid specification for mtpSpVersion");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpNetworkIndicator, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSpName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
	if (StorageTmp->mtpSpName == NULL) {
		config_perror("invalid specification for mtpSpName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpProfilePointer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfilePointer, &StorageTmp->mtpSpProfilePointerLen);
	if (StorageTmp->mtpSpProfilePointer == NULL) {
		config_perror("invalid specification for mtpSpProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpNaPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSpNaPointer, &StorageTmp->mtpSpNaPointerLen);
	if (StorageTmp->mtpSpNaPointer == NULL) {
		config_perror("invalid specification for mtpSpNaPointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpOptions);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpOptions, &StorageTmp->mtpSpOptionsLen);
	if (StorageTmp->mtpSpOptions == NULL) {
		config_perror("invalid specification for mtpSpOptions");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpUsers);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpUsers, &StorageTmp->mtpSpUsersLen);
	if (StorageTmp->mtpSpUsers == NULL) {
		config_perror("invalid specification for mtpSpUsers");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpAlarmStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpAlarmStatus, &StorageTmp->mtpSpAlarmStatusLen);
	if (StorageTmp->mtpSpAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSpAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpRowStatus, &tmpsize);
	mtpSpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
}

/*
 * store_mtpSpTable(): store configuraiton file for mtpSpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpTable", "storing data...  "));
	refresh_mtpSpTable(1);
	(void) tmpsize;
	for (hcindex = mtpSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSpTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpPointCode, &StorageTmp->mtpSpPointCodeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpVersion, &StorageTmp->mtpSpVersionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpNetworkIndicator, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfilePointer, &StorageTmp->mtpSpProfilePointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSpNaPointer, &StorageTmp->mtpSpNaPointerLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpOptions, &StorageTmp->mtpSpOptionsLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpUsers, &StorageTmp->mtpSpUsersLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpAlarmStatus, &StorageTmp->mtpSpAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpL3Table_data *mtpL3Table_create(void)
 * @brief create a fresh data structure representing a new row in the mtpL3Table table.
 *
 * Creates a new mtpL3Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpL3Table_data *
mtpL3Table_create(void)
{
	struct mtpL3Table_data *StorageNew = SNMP_MALLOC_STRUCT(mtpL3Table_data);

	DEBUGMSGTL(("mtpL3Table", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpL3AdministrativeState = MTPL3ADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpL3OperationalState = MTPL3OPERATIONALSTATE_DISABLED;
		StorageNew->mtpL3UsageState = MTPL3USAGESTATE_IDLE;
		if (memdup((u_char **) &StorageNew->mtpL3ProceduralStatus, (u_char *) "\x80", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpL3ProceduralStatusLen = 1;
		if ((StorageNew->mtpL3AsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpL3AsaProfilePointerLen = 2;
		StorageNew->mtpL3Name = (uint8_t *) strdup("");
		StorageNew->mtpL3NameLen = strlen("");
		StorageNew->mtpL3RowStatus = 0;
		StorageNew->mtpL3RowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpL3Table_data *mtpL3Table_duplicate(struct mtpL3Table_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpL3Table_data *
mtpL3Table_duplicate(struct mtpL3Table_data *thedata)
{
	struct mtpL3Table_data *StorageNew = SNMP_MALLOC_STRUCT(mtpL3Table_data);

	DEBUGMSGTL(("mtpL3Table", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpL3Table_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpL3Table_destroy(struct mtpL3Table_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpL3Table_destroy(struct mtpL3Table_data **thedata)
{
	struct mtpL3Table_data *StorageDel;

	DEBUGMSGTL(("mtpL3Table", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpL3ProceduralStatus);
		StorageDel->mtpL3ProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpL3AsaProfilePointer);
		StorageDel->mtpL3AsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpL3Name);
		StorageDel->mtpL3NameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpL3Table_add(struct mtpL3Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpL3Table table data set.
 *
 * Adds a table row structure to the mtpL3Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpL3Table_add(struct mtpL3Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpL3Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpL3Id */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpL3Id, sizeof(thedata->mtpL3Id));
	header_complex_add_data(&mtpL3TableStorage, vars, thedata);
	DEBUGMSGTL(("mtpL3Table", "registered an entry\n"));
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpL3Table_del(struct mtpL3Table_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpL3Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpL3Table_del(struct mtpL3Table_data *thedata)
{
	struct mtpL3Table_data *StorageDel;

	DEBUGMSGTL(("mtpL3Table", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpL3TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpL3TableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpL3Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpL3Table entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpL3Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpL3Table(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpL3Table_data *StorageTmp = mtpL3Table_create();

	DEBUGMSGTL(("mtpL3Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL3Id, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3AdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3OperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3UsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpL3ProceduralStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpL3ProceduralStatus, &StorageTmp->mtpL3ProceduralStatusLen);
	if (StorageTmp->mtpL3ProceduralStatus == NULL) {
		config_perror("invalid specification for mtpL3ProceduralStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpL3AsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpL3AsaProfilePointer, &StorageTmp->mtpL3AsaProfilePointerLen);
	if (StorageTmp->mtpL3AsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpL3AsaProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpL3Name);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Name, &StorageTmp->mtpL3NameLen);
	if (StorageTmp->mtpL3Name == NULL) {
		config_perror("invalid specification for mtpL3Name");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3RowStatus, &tmpsize);
	mtpL3Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
}

/*
 * store_mtpL3Table(): store configuraiton file for mtpL3Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpL3Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpL3Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpL3Table", "storing data...  "));
	refresh_mtpL3Table(1);
	(void) tmpsize;
	for (hcindex = mtpL3TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL3Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpL3Table ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL3Id, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3AdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3OperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3UsageState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpL3ProceduralStatus, &StorageTmp->mtpL3ProceduralStatusLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpL3AsaProfilePointer, &StorageTmp->mtpL3AsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Name, &StorageTmp->mtpL3NameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3RowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpGsTable_data *mtpGsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpGsTable table.
 *
 * Creates a new mtpGsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpGsTable_data *
mtpGsTable_create(void)
{
	struct mtpGsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsTable_data);

	DEBUGMSGTL(("mtpGsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpGsAdministrativeState = MTPGSADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpGsTreatmentOfOutsideRanges = MTPGSTREATMENTOFOUTSIDERANGES_NORMAL;
		StorageNew->mtpGsListMode = TV_TRUE;
		StorageNew->mtpGsScreeningByLinkSetOrByOpc = MTPGSSCREENINGBYLINKSETORBYOPC_BYOPC;
		StorageNew->mtpGsGetScreenedOpcsOrLinkSetsByDpc = 0;
		if ((StorageNew->mtpGsName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpGsNameLen = strlen("");
		StorageNew->mtpGsRowStatus = 0;
		StorageNew->mtpGsRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpGsTable_data *mtpGsTable_duplicate(struct mtpGsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpGsTable_data *
mtpGsTable_duplicate(struct mtpGsTable_data *thedata)
{
	struct mtpGsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsTable_data);

	DEBUGMSGTL(("mtpGsTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpGsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpGsTable_destroy(struct mtpGsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpGsTable_destroy(struct mtpGsTable_data **thedata)
{
	struct mtpGsTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsName);
		StorageDel->mtpGsNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsTable_add(struct mtpGsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpGsTable table data set.
 *
 * Adds a table row structure to the mtpGsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpGsTable_add(struct mtpGsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
	header_complex_add_data(&mtpGsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsTable_del(struct mtpGsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpGsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpGsTable_del(struct mtpGsTable_data *thedata)
{
	struct mtpGsTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpGsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpGsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpGsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpGsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpGsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpGsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsTable_data *StorageTmp = mtpGsTable_create();

	DEBUGMSGTL(("mtpGsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsListMode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpsize);
	SNMP_FREE(StorageTmp->mtpGsName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
	if (StorageTmp->mtpGsName == NULL) {
		config_perror("invalid specification for mtpGsName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsRowStatus, &tmpsize);
	mtpGsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
}

/*
 * store_mtpGsTable(): store configuraiton file for mtpGsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsTable", "storing data...  "));
	refresh_mtpGsTable(1);
	(void) tmpsize;
	for (hcindex = mtpGsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsListMode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpGsLineTable_data *mtpGsLineTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpGsLineTable table.
 *
 * Creates a new mtpGsLineTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpGsLineTable_data *
mtpGsLineTable_create(void)
{
	struct mtpGsLineTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineTable_data);

	DEBUGMSGTL(("mtpGsLineTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpGsId = 0;
		if ((StorageNew->mtpGsLineObject = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpGsLineObjectLen = 2;
		StorageNew->mtpGsLineContent = 0;
		StorageNew->mtpGsLineRowStatus = 0;
		StorageNew->mtpGsLineRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpGsLineTable_data *mtpGsLineTable_duplicate(struct mtpGsLineTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpGsLineTable_data *
mtpGsLineTable_duplicate(struct mtpGsLineTable_data *thedata)
{
	struct mtpGsLineTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineTable_data);

	DEBUGMSGTL(("mtpGsLineTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpGsLineTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpGsLineTable_destroy(struct mtpGsLineTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpGsLineTable_destroy(struct mtpGsLineTable_data **thedata)
{
	struct mtpGsLineTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsLineTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsLineObject);
		StorageDel->mtpGsLineObjectLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineTable_add(struct mtpGsLineTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpGsLineTable table data set.
 *
 * Adds a table row structure to the mtpGsLineTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpGsLineTable_add(struct mtpGsLineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsLineTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
	/* mtpGsLineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineId, sizeof(thedata->mtpGsLineId));
	header_complex_add_data(&mtpGsLineTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsLineTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineTable_del(struct mtpGsLineTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpGsLineTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpGsLineTable_del(struct mtpGsLineTable_data *thedata)
{
	struct mtpGsLineTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsLineTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpGsLineTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpGsLineTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpGsLineTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpGsLineTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpGsLineTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpGsLineTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsLineTable_data *StorageTmp = mtpGsLineTable_create();

	DEBUGMSGTL(("mtpGsLineTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpGsLineObject);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpGsLineObject, &StorageTmp->mtpGsLineObjectLen);
	if (StorageTmp->mtpGsLineObject == NULL) {
		config_perror("invalid specification for mtpGsLineObject");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineRowStatus, &tmpsize);
	mtpGsLineTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
}

/*
 * store_mtpGsLineTable(): store configuraiton file for mtpGsLineTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsLineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsLineTable", "storing data...  "));
	refresh_mtpGsLineTable(1);
	(void) tmpsize;
	for (hcindex = mtpGsLineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsLineTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpGsLineObject, &StorageTmp->mtpGsLineObjectLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContent, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpGsLineContentTable_data *mtpGsLineContentTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpGsLineContentTable table.
 *
 * Creates a new mtpGsLineContentTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpGsLineContentTable_data *
mtpGsLineContentTable_create(void)
{
	struct mtpGsLineContentTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data);

	DEBUGMSGTL(("mtpGsLineContentTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpGsId = 0;
		StorageNew->mtpGsLineId = 0;
		if (memdup((u_char **) &StorageNew->mtpGsLineContentDesignatedDPCFirst, (u_char *) "\x00\x00\x00\x00", 4) == SNMPERR_SUCCESS)
			StorageNew->mtpGsLineContentDesignatedDPCFirstLen = 4;
		if (memdup((u_char **) &StorageNew->mtpGsLineContentDesignatedDPCLast, (u_char *) "\x00\x00\x00\x00", 4) == SNMPERR_SUCCESS)
			StorageNew->mtpGsLineContentDesignatedDPCLastLen = 4;
		if (memdup((u_char **) &StorageNew->mtpGsLineContentSiMask, (u_char *) "\xFF\x1F", 2) == SNMPERR_SUCCESS)
			StorageNew->mtpGsLineContentSiMaskLen = 2;
		StorageNew->mtpGsLineContentMessageTreatment = MTPGSLINECONTENTMESSAGETREATMENT_NORMAL;
		if ((StorageNew->mtpGsLineContentComment = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpGsLineContentCommentLen = strlen("");
		StorageNew->mtpGsLineContentRowStatus = 0;
		StorageNew->mtpGsLineContentRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpGsLineContentTable_data *mtpGsLineContentTable_duplicate(struct mtpGsLineContentTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpGsLineContentTable_data *
mtpGsLineContentTable_duplicate(struct mtpGsLineContentTable_data *thedata)
{
	struct mtpGsLineContentTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data);

	DEBUGMSGTL(("mtpGsLineContentTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpGsLineContentTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpGsLineContentTable_destroy(struct mtpGsLineContentTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpGsLineContentTable_destroy(struct mtpGsLineContentTable_data **thedata)
{
	struct mtpGsLineContentTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsLineContentTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsLineContentDesignatedDPCFirst);
		StorageDel->mtpGsLineContentDesignatedDPCFirstLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentDesignatedDPCLast);
		StorageDel->mtpGsLineContentDesignatedDPCLastLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentSiMask);
		StorageDel->mtpGsLineContentSiMaskLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentComment);
		StorageDel->mtpGsLineContentCommentLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineContentTable_add(struct mtpGsLineContentTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpGsLineContentTable table data set.
 *
 * Adds a table row structure to the mtpGsLineContentTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpGsLineContentTable_add(struct mtpGsLineContentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsLineContentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
	/* mtpGsLineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineId, sizeof(thedata->mtpGsLineId));
	/* mtpGsLineContentId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineContentId, sizeof(thedata->mtpGsLineContentId));
	header_complex_add_data(&mtpGsLineContentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsLineContentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineContentTable_del(struct mtpGsLineContentTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpGsLineContentTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpGsLineContentTable_del(struct mtpGsLineContentTable_data *thedata)
{
	struct mtpGsLineContentTable_data *StorageDel;

	DEBUGMSGTL(("mtpGsLineContentTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpGsLineContentTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpGsLineContentTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpGsLineContentTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpGsLineContentTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpGsLineContentTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpGsLineContentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsLineContentTable_data *StorageTmp = mtpGsLineContentTable_create();

	DEBUGMSGTL(("mtpGsLineContentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContentId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpGsLineContentDesignatedDPCFirst);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &StorageTmp->mtpGsLineContentDesignatedDPCFirstLen);
	if (StorageTmp->mtpGsLineContentDesignatedDPCFirst == NULL) {
		config_perror("invalid specification for mtpGsLineContentDesignatedDPCFirst");
		return;
	}
	SNMP_FREE(StorageTmp->mtpGsLineContentDesignatedDPCLast);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &StorageTmp->mtpGsLineContentDesignatedDPCLastLen);
	if (StorageTmp->mtpGsLineContentDesignatedDPCLast == NULL) {
		config_perror("invalid specification for mtpGsLineContentDesignatedDPCLast");
		return;
	}
	SNMP_FREE(StorageTmp->mtpGsLineContentSiMask);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpGsLineContentSiMask, &StorageTmp->mtpGsLineContentSiMaskLen);
	if (StorageTmp->mtpGsLineContentSiMask == NULL) {
		config_perror("invalid specification for mtpGsLineContentSiMask");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpsize);
	SNMP_FREE(StorageTmp->mtpGsLineContentComment);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentComment, &StorageTmp->mtpGsLineContentCommentLen);
	if (StorageTmp->mtpGsLineContentComment == NULL) {
		config_perror("invalid specification for mtpGsLineContentComment");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentRowStatus, &tmpsize);
	mtpGsLineContentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
}

/*
 * store_mtpGsLineContentTable(): store configuraiton file for mtpGsLineContentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineContentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsLineContentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsLineContentTable", "storing data...  "));
	refresh_mtpGsLineContentTable(1);
	(void) tmpsize;
	for (hcindex = mtpGsLineContentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineContentTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsLineContentTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContentId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &StorageTmp->mtpGsLineContentDesignatedDPCFirstLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &StorageTmp->mtpGsLineContentDesignatedDPCLastLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpGsLineContentSiMask, &StorageTmp->mtpGsLineContentSiMaskLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentComment, &StorageTmp->mtpGsLineContentCommentLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRsProfileTable_data *mtpRsProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRsProfileTable table.
 *
 * Creates a new mtpRsProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRsProfileTable_data *
mtpRsProfileTable_create(void)
{
	struct mtpRsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data);

	DEBUGMSGTL(("mtpRsProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpRsProfileName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpRsProfileNameLen = strlen("");
		StorageNew->mtpRsProfileTimerT8 = 100;
		StorageNew->mtpRsProfileTimerT11 = 6000;
		StorageNew->mtpRsProfileTimerT15 = 250;
		StorageNew->mtpRsProfileTimerT16 = 175;
		StorageNew->mtpRsProfileTimerT18A = 1200;
		StorageNew->mtpRsProfileRtDefault = (uint8_t *) strdup("");
		StorageNew->mtpRsProfileRtDefaultLen = strlen("");
		StorageNew->mtpRsProfileRowStatus = 0;
		StorageNew->mtpRsProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpRsProfileTable_data *mtpRsProfileTable_duplicate(struct mtpRsProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRsProfileTable_data *
mtpRsProfileTable_duplicate(struct mtpRsProfileTable_data *thedata)
{
	struct mtpRsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data);

	DEBUGMSGTL(("mtpRsProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRsProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRsProfileTable_destroy(struct mtpRsProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRsProfileTable_destroy(struct mtpRsProfileTable_data **thedata)
{
	struct mtpRsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpRsProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRsProfileId);
		StorageDel->mtpRsProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfileName);
		StorageDel->mtpRsProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfileRtDefault);
		StorageDel->mtpRsProfileRtDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsProfileTable_add(struct mtpRsProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRsProfileTable table data set.
 *
 * Adds a table row structure to the mtpRsProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRsProfileTable_add(struct mtpRsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpRsProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRsProfileId, thedata->mtpRsProfileIdLen);
	header_complex_add_data(&mtpRsProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsProfileTable_del(struct mtpRsProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpRsProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRsProfileTable_del(struct mtpRsProfileTable_data *thedata)
{
	struct mtpRsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpRsProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRsProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRsProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRsProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRsProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRsProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRsProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsProfileTable_data *StorageTmp = mtpRsProfileTable_create();

	DEBUGMSGTL(("mtpRsProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpRsProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileId, &StorageTmp->mtpRsProfileIdLen);
	if (StorageTmp->mtpRsProfileId == NULL) {
		config_perror("invalid specification for mtpRsProfileId");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsProfileName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileName, &StorageTmp->mtpRsProfileNameLen);
	if (StorageTmp->mtpRsProfileName == NULL) {
		config_perror("invalid specification for mtpRsProfileName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT18A, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRsProfileRtDefault);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileRtDefault, &StorageTmp->mtpRsProfileRtDefaultLen);
	if (StorageTmp->mtpRsProfileRtDefault == NULL) {
		config_perror("invalid specification for mtpRsProfileRtDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileRowStatus, &tmpsize);
	mtpRsProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
}

/*
 * store_mtpRsProfileTable(): store configuraiton file for mtpRsProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsProfileTable", "storing data...  "));
	refresh_mtpRsProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpRsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRsProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileId, &StorageTmp->mtpRsProfileIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileName, &StorageTmp->mtpRsProfileNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT11, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT15, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT16, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT18A, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileRtDefault, &StorageTmp->mtpRsProfileRtDefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRsTable_data *mtpRsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRsTable table.
 *
 * Creates a new mtpRsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRsTable_data *
mtpRsTable_create(void)
{
	struct mtpRsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsTable_data);

	DEBUGMSGTL(("mtpRsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		if (memdup((u_char **) &StorageNew->mtpRsDest, (u_char *) "\x00\x00\x00\x00", 4) == SNMPERR_SUCCESS)
			StorageNew->mtpRsDestLen = 4;
		if (memdup((u_char **) &StorageNew->mtpRsOptions, (u_char *) "\x20", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpRsOptionsLen = 1;
		StorageNew->mtpRsAdministrativeState = MTPRSADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpRsOperationalState = MTPRSOPERATIONALSTATE_DISABLED;
		if ((StorageNew->mtpRsAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpRsAsaProfilePointerLen = 2;
		StorageNew->mtpRsCongestedState = MTPRSCONGESTEDSTATE_NOTCONGESTED;
		StorageNew->mtpRsCongestionLevel = MTPRSCONGESTIONLEVEL_NONE;
		if ((StorageNew->mtpRsLoadsharingInformation = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpRsLoadsharingInformationLen = strlen("");
		if ((StorageNew->mtpRsLoadsharingObject = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpRsLoadsharingObjectLen = 2;
		if ((StorageNew->mtpRsRemoteExchangeLabel = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpRsRemoteExchangeLabelLen = strlen("");
		if ((StorageNew->mtpRsName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpRsNameLen = strlen("");
		StorageNew->mtpRsProfile = (uint8_t *) strdup("");
		StorageNew->mtpRsProfileLen = strlen("");
		if (memdup((u_char **) &StorageNew->mtpRsAlarmStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpRsAlarmStatusLen = 1;
		StorageNew->mtpRsRowStatus = 0;
		StorageNew->mtpRsRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpRsTable_data *mtpRsTable_duplicate(struct mtpRsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRsTable_data *
mtpRsTable_duplicate(struct mtpRsTable_data *thedata)
{
	struct mtpRsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsTable_data);

	DEBUGMSGTL(("mtpRsTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRsTable_destroy(struct mtpRsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRsTable_destroy(struct mtpRsTable_data **thedata)
{
	struct mtpRsTable_data *StorageDel;

	DEBUGMSGTL(("mtpRsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRsDest);
		StorageDel->mtpRsDestLen = 0;
		SNMP_FREE(StorageDel->mtpRsOptions);
		StorageDel->mtpRsOptionsLen = 0;
		SNMP_FREE(StorageDel->mtpRsAsaProfilePointer);
		StorageDel->mtpRsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpRsLoadsharingInformation);
		StorageDel->mtpRsLoadsharingInformationLen = 0;
		SNMP_FREE(StorageDel->mtpRsLoadsharingObject);
		StorageDel->mtpRsLoadsharingObjectLen = 0;
		SNMP_FREE(StorageDel->mtpRsRemoteExchangeLabel);
		StorageDel->mtpRsRemoteExchangeLabelLen = 0;
		SNMP_FREE(StorageDel->mtpRsName);
		StorageDel->mtpRsNameLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfile);
		StorageDel->mtpRsProfileLen = 0;
		SNMP_FREE(StorageDel->mtpRsAlarmStatus);
		StorageDel->mtpRsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsTable_add(struct mtpRsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRsTable table data set.
 *
 * Adds a table row structure to the mtpRsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRsTable_add(struct mtpRsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	header_complex_add_data(&mtpRsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsTable_del(struct mtpRsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpRsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRsTable_del(struct mtpRsTable_data *thedata)
{
	struct mtpRsTable_data *StorageDel;

	DEBUGMSGTL(("mtpRsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsTable_data *StorageTmp = mtpRsTable_create();

	DEBUGMSGTL(("mtpRsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRsDest);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsDest, &StorageTmp->mtpRsDestLen);
	if (StorageTmp->mtpRsDest == NULL) {
		config_perror("invalid specification for mtpRsDest");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsOptions);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRsOptions, &StorageTmp->mtpRsOptionsLen);
	if (StorageTmp->mtpRsOptions == NULL) {
		config_perror("invalid specification for mtpRsOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRsAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsAsaProfilePointer, &StorageTmp->mtpRsAsaProfilePointerLen);
	if (StorageTmp->mtpRsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpRsAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestedState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestionLevel, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRsLoadsharingInformation);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
	if (StorageTmp->mtpRsLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingInformation");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsLoadsharingObject);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
	if (StorageTmp->mtpRsLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingObject");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsRemoteExchangeLabel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
	if (StorageTmp->mtpRsRemoteExchangeLabel == NULL) {
		config_perror("invalid specification for mtpRsRemoteExchangeLabel");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
	if (StorageTmp->mtpRsName == NULL) {
		config_perror("invalid specification for mtpRsName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsProfile);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfile, &StorageTmp->mtpRsProfileLen);
	if (StorageTmp->mtpRsProfile == NULL) {
		config_perror("invalid specification for mtpRsProfile");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsAlarmStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRsAlarmStatus, &StorageTmp->mtpRsAlarmStatusLen);
	if (StorageTmp->mtpRsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpRsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsRowStatus, &tmpsize);
	mtpRsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
}

/*
 * store_mtpRsTable(): store configuraiton file for mtpRsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsTable", "storing data...  "));
	refresh_mtpRsTable(1);
	(void) tmpsize;
	for (hcindex = mtpRsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsDest, &StorageTmp->mtpRsDestLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRsOptions, &StorageTmp->mtpRsOptionsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsAsaProfilePointer, &StorageTmp->mtpRsAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestedState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestionLevel, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfile, &StorageTmp->mtpRsProfileLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRsAlarmStatus, &StorageTmp->mtpRsAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRtProfileTable_data *mtpRtProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRtProfileTable table.
 *
 * Creates a new mtpRtProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRtProfileTable_data *
mtpRtProfileTable_create(void)
{
	struct mtpRtProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data);

	DEBUGMSGTL(("mtpRtProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpRtProfileTimerT6 = 80;
		StorageNew->mtpRtProfileTimerT10 = 4500;
		StorageNew->mtpRtProfileRowStatus = 0;
		StorageNew->mtpRtProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpRtProfileTable_data *mtpRtProfileTable_duplicate(struct mtpRtProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRtProfileTable_data *
mtpRtProfileTable_duplicate(struct mtpRtProfileTable_data *thedata)
{
	struct mtpRtProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data);

	DEBUGMSGTL(("mtpRtProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRtProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRtProfileTable_destroy(struct mtpRtProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRtProfileTable_destroy(struct mtpRtProfileTable_data **thedata)
{
	struct mtpRtProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtProfileId);
		StorageDel->mtpRtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtProfileTable_add(struct mtpRtProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRtProfileTable table data set.
 *
 * Adds a table row structure to the mtpRtProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRtProfileTable_add(struct mtpRtProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpRtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRtProfileId, thedata->mtpRtProfileIdLen);
	header_complex_add_data(&mtpRtProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtProfileTable_del(struct mtpRtProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpRtProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRtProfileTable_del(struct mtpRtProfileTable_data *thedata)
{
	struct mtpRtProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRtProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRtProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRtProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRtProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRtProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRtProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtProfileTable_data *StorageTmp = mtpRtProfileTable_create();

	DEBUGMSGTL(("mtpRtProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpRtProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtProfileId, &StorageTmp->mtpRtProfileIdLen);
	if (StorageTmp->mtpRtProfileId == NULL) {
		config_perror("invalid specification for mtpRtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT10, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileRowStatus, &tmpsize);
	mtpRtProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
}

/*
 * store_mtpRtProfileTable(): store configuraiton file for mtpRtProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtProfileTable", "storing data...  "));
	refresh_mtpRtProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpRtProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtProfileId, &StorageTmp->mtpRtProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT10, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRtTable_data *mtpRtTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRtTable table.
 *
 * Creates a new mtpRtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRtTable_data *
mtpRtTable_create(void)
{
	struct mtpRtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtTable_data);

	DEBUGMSGTL(("mtpRtTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpRsId = 0;
		if ((StorageNew->mtpRtLsPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpRtLsPointerLen = 2;
		StorageNew->mtpRtAdministrativeState = MTPRTADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpRtOperationalState = MTPRTOPERATIONALSTATE_DISABLED;
		if (memdup((u_char **) &StorageNew->mtpRtAvailabilityStatus, (u_char *) "\x00\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->mtpRtAvailabilityStatusLen = 2;
		StorageNew->mtpRtInClsLoadsharingAlgorithm = 16;
		StorageNew->mtpRtFixedPriority = 0;
		StorageNew->mtpRtFlexiblePriority = 0;
		StorageNew->mtpRtPriorityMode = 0;
		if ((StorageNew->mtpRtLoadsharingInformation = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpRtLoadsharingInformationLen = strlen("");
		if ((StorageNew->mtpRtLoadsharingObject = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpRtLoadsharingObjectLen = 2;
		if ((StorageNew->mtpRtName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpRtNameLen = strlen("");
		if ((StorageNew->mtpRtSlsList = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpRtSlsListLen = strlen("");
		StorageNew->mtpRtUsageState = MTPRTUSAGESTATE_IDLE;
		StorageNew->mtpRtRlSlot = 0;
		StorageNew->mtpRtProfile = (uint8_t *) strdup("");
		StorageNew->mtpRtProfileLen = strlen("");
		StorageNew->mtpRtRowStatus = 0;
		StorageNew->mtpRtRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpRtTable_data *mtpRtTable_duplicate(struct mtpRtTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRtTable_data *
mtpRtTable_duplicate(struct mtpRtTable_data *thedata)
{
	struct mtpRtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtTable_data);

	DEBUGMSGTL(("mtpRtTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRtTable_destroy(struct mtpRtTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRtTable_destroy(struct mtpRtTable_data **thedata)
{
	struct mtpRtTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtLsPointer);
		StorageDel->mtpRtLsPointerLen = 0;
		SNMP_FREE(StorageDel->mtpRtAvailabilityStatus);
		StorageDel->mtpRtAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpRtLoadsharingInformation);
		StorageDel->mtpRtLoadsharingInformationLen = 0;
		SNMP_FREE(StorageDel->mtpRtLoadsharingObject);
		StorageDel->mtpRtLoadsharingObjectLen = 0;
		SNMP_FREE(StorageDel->mtpRtName);
		StorageDel->mtpRtNameLen = 0;
		SNMP_FREE(StorageDel->mtpRtSlsList);
		StorageDel->mtpRtSlsListLen = 0;
		SNMP_FREE(StorageDel->mtpRtProfile);
		StorageDel->mtpRtProfileLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtTable_add(struct mtpRtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRtTable table data set.
 *
 * Adds a table row structure to the mtpRtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRtTable_add(struct mtpRtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtId, sizeof(thedata->mtpRtId));
	header_complex_add_data(&mtpRtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtTable_del(struct mtpRtTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpRtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRtTable_del(struct mtpRtTable_data *thedata)
{
	struct mtpRtTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRtTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRtTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtTable_data *StorageTmp = mtpRtTable_create();

	DEBUGMSGTL(("mtpRtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRtLsPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRtLsPointer, &StorageTmp->mtpRtLsPointerLen);
	if (StorageTmp->mtpRtLsPointer == NULL) {
		config_perror("invalid specification for mtpRtLsPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRtAvailabilityStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
	if (StorageTmp->mtpRtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpRtAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFixedPriority, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFlexiblePriority, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtPriorityMode, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRtLoadsharingInformation);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
	if (StorageTmp->mtpRtLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingInformation");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRtLoadsharingObject);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
	if (StorageTmp->mtpRtLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingObject");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRtName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
	if (StorageTmp->mtpRtName == NULL) {
		config_perror("invalid specification for mtpRtName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRtSlsList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
	if (StorageTmp->mtpRtSlsList == NULL) {
		config_perror("invalid specification for mtpRtSlsList");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtUsageState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtRlSlot, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRtProfile);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtProfile, &StorageTmp->mtpRtProfileLen);
	if (StorageTmp->mtpRtProfile == NULL) {
		config_perror("invalid specification for mtpRtProfile");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtRowStatus, &tmpsize);
	mtpRtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
}

/*
 * store_mtpRtTable(): store configuraiton file for mtpRtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtTable", "storing data...  "));
	refresh_mtpRtTable(1);
	(void) tmpsize;
	for (hcindex = mtpRtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRtLsPointer, &StorageTmp->mtpRtLsPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFixedPriority, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFlexiblePriority, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtPriorityMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtRlSlot, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtProfile, &StorageTmp->mtpRtProfileLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRtLsaTable_data *mtpRtLsaTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRtLsaTable table.
 *
 * Creates a new mtpRtLsaTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRtLsaTable_data *
mtpRtLsaTable_create(void)
{
	struct mtpRtLsaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtLsaTable_data);

	DEBUGMSGTL(("mtpRtLsaTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpRsId = 0;
		StorageNew->mtpRtId = 0;
		StorageNew->mtpRtLsaNormalSlCode = 0;
		if ((StorageNew->mtpRtLsaAlternativeSlCodeList = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpRtLsaAlternativeSlCodeListLen = strlen("");

	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpRtLsaTable_data *mtpRtLsaTable_duplicate(struct mtpRtLsaTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRtLsaTable_data *
mtpRtLsaTable_duplicate(struct mtpRtLsaTable_data *thedata)
{
	struct mtpRtLsaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtLsaTable_data);

	DEBUGMSGTL(("mtpRtLsaTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRtLsaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRtLsaTable_destroy(struct mtpRtLsaTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRtLsaTable_destroy(struct mtpRtLsaTable_data **thedata)
{
	struct mtpRtLsaTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtLsaTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtLsaAlternativeSlCodeList);
		StorageDel->mtpRtLsaAlternativeSlCodeListLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtLsaTable_add(struct mtpRtLsaTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRtLsaTable table data set.
 *
 * Adds a table row structure to the mtpRtLsaTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRtLsaTable_add(struct mtpRtLsaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtLsaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtId, sizeof(thedata->mtpRtId));
	/* mtpRtLsaSlsCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpRtLsaSlsCode, sizeof(thedata->mtpRtLsaSlsCode));
	header_complex_add_data(&mtpRtLsaTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtLsaTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtLsaTable_del(struct mtpRtLsaTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpRtLsaTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRtLsaTable_del(struct mtpRtLsaTable_data *thedata)
{
	struct mtpRtLsaTable_data *StorageDel;

	DEBUGMSGTL(("mtpRtLsaTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRtLsaTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRtLsaTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRtLsaTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRtLsaTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRtLsaTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRtLsaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtLsaTable_data *StorageTmp = mtpRtLsaTable_create();

	DEBUGMSGTL(("mtpRtLsaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtLsaSlsCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtLsaNormalSlCode, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRtLsaAlternativeSlCodeList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &StorageTmp->mtpRtLsaAlternativeSlCodeListLen);
	if (StorageTmp->mtpRtLsaAlternativeSlCodeList == NULL) {
		config_perror("invalid specification for mtpRtLsaAlternativeSlCodeList");
		return;
	}
	mtpRtLsaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
}

/*
 * store_mtpRtLsaTable(): store configuraiton file for mtpRtLsaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtLsaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtLsaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtLsaTable", "storing data...  "));
	refresh_mtpRtLsaTable(1);
	(void) tmpsize;
	for (hcindex = mtpRtLsaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtLsaTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtLsaTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtLsaSlsCode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtLsaNormalSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &StorageTmp->mtpRtLsaAlternativeSlCodeListLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpLsProfileTable_data *mtpLsProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpLsProfileTable table.
 *
 * Creates a new mtpLsProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpLsProfileTable_data *
mtpLsProfileTable_create(void)
{
	struct mtpLsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data);

	DEBUGMSGTL(("mtpLsProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpLsProfileTimerT6 = 80;
		StorageNew->mtpLsProfileTimerT8 = 100;
		StorageNew->mtpLsProfileTimerT10 = 4500;
		StorageNew->mtpLsProfileTimerT7 = 150;
		StorageNew->mtpLsProfileTimerT19I = 6800;
		StorageNew->mtpLsProfileTimerT21I = 0;
		StorageNew->mtpLsProfileTimerT25A = 3000;
		StorageNew->mtpLsProfileTimerT28A = 2000;
		StorageNew->mtpLsProfileTimerT29A = 6000;
		StorageNew->mtpLsProfileTimerT30A = 3000;
		StorageNew->mtpLsProfileParameterN = 50;
		StorageNew->mtpLsProfileParameterM = 3;
		if ((StorageNew->mtpLsProfileName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpLsProfileNameLen = strlen("");
		StorageNew->mtpLsProfileSlDefault = (uint8_t *) strdup("");
		StorageNew->mtpLsProfileSlDefaultLen = strlen("");
		StorageNew->mtpLsProfileRowStatus = 0;
		StorageNew->mtpLsProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpLsProfileTable_data *mtpLsProfileTable_duplicate(struct mtpLsProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpLsProfileTable_data *
mtpLsProfileTable_duplicate(struct mtpLsProfileTable_data *thedata)
{
	struct mtpLsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data);

	DEBUGMSGTL(("mtpLsProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpLsProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpLsProfileTable_destroy(struct mtpLsProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpLsProfileTable_destroy(struct mtpLsProfileTable_data **thedata)
{
	struct mtpLsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpLsProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpLsProfileId);
		StorageDel->mtpLsProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfileName);
		StorageDel->mtpLsProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfileSlDefault);
		StorageDel->mtpLsProfileSlDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsProfileTable_add(struct mtpLsProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpLsProfileTable table data set.
 *
 * Adds a table row structure to the mtpLsProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpLsProfileTable_add(struct mtpLsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpLsProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpLsProfileId, thedata->mtpLsProfileIdLen);
	header_complex_add_data(&mtpLsProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsProfileTable_del(struct mtpLsProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpLsProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpLsProfileTable_del(struct mtpLsProfileTable_data *thedata)
{
	struct mtpLsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpLsProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpLsProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpLsProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpLsProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpLsProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpLsProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpLsProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpLsProfileTable_data *StorageTmp = mtpLsProfileTable_create();

	DEBUGMSGTL(("mtpLsProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpLsProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileId, &StorageTmp->mtpLsProfileIdLen);
	if (StorageTmp->mtpLsProfileId == NULL) {
		config_perror("invalid specification for mtpLsProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT10, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT19I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT21I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT25A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT28A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT29A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT30A, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsProfileParameterN, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsProfileParameterM, &tmpsize);
	SNMP_FREE(StorageTmp->mtpLsProfileName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileName, &StorageTmp->mtpLsProfileNameLen);
	if (StorageTmp->mtpLsProfileName == NULL) {
		config_perror("invalid specification for mtpLsProfileName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpLsProfileSlDefault);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileSlDefault, &StorageTmp->mtpLsProfileSlDefaultLen);
	if (StorageTmp->mtpLsProfileSlDefault == NULL) {
		config_perror("invalid specification for mtpLsProfileSlDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileRowStatus, &tmpsize);
	mtpLsProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
}

/*
 * store_mtpLsProfileTable(): store configuraiton file for mtpLsProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpLsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsProfileTable", "storing data...  "));
	refresh_mtpLsProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpLsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpLsProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileId, &StorageTmp->mtpLsProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT10, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT19I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT21I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT25A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT28A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT29A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT30A, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsProfileParameterN, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsProfileParameterM, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileName, &StorageTmp->mtpLsProfileNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileSlDefault, &StorageTmp->mtpLsProfileSlDefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpLsTable_data *mtpLsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpLsTable table.
 *
 * Creates a new mtpLsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpLsTable_data *
mtpLsTable_create(void)
{
	struct mtpLsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsTable_data);

	DEBUGMSGTL(("mtpLsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		if (memdup((u_char **) &StorageNew->mtpLsAdjPc, (u_char *) "\x00\x00\x00\x00", 4) == SNMPERR_SUCCESS)
			StorageNew->mtpLsAdjPcLen = 4;
		if ((StorageNew->mtpLsRsId = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpLsRsIdLen = 2;
		StorageNew->mtpLsMaxCapacity = 0;
		StorageNew->mtpLsCurrentCapacity = 0;
		StorageNew->mtpLsCongestionControlMethod = MTPLSCONGESTIONCONTROLMETHOD_CCMQ704INTERNATIONAL;
		StorageNew->mtpLsUsageState = MTPLSUSAGESTATE_IDLE;
		StorageNew->mtpLsOperationalState = MTPLSOPERATIONALSTATE_DISABLED;
		if (memdup((u_char **) &StorageNew->mtpLsAvailabilityStatus, (u_char *) "\x00\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->mtpLsAvailabilityStatusLen = 2;
		StorageNew->mtpLsPeriodicLinkTestFlag = MTPLSPERIODICLINKTESTFLAG_ON;
		StorageNew->mtpLsPeriodicLinkTestFail = TV_FALSE;
		StorageNew->mtpLsAdministrativeState = MTPLSADMINISTRATIVESTATE_LOCKED;
		{
			static oid tmpoid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 3, 1, 4, 4, 1 };
			if ((StorageNew->mtpLsInLsLoadShareAlgorithm = snmp_duplicate_objid(tmpoid, 15)))
				StorageNew->mtpLsInLsLoadShareAlgorithmLen = 15;
		}
		if ((StorageNew->mtpLsProfilePointer = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpLsProfilePointerLen = strlen("");
		StorageNew->mtpLsNumberOfNormallyActiveSignLinks = 2;
		if ((StorageNew->mtpLsName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpLsNameLen = strlen("");
		if ((StorageNew->mtpLsAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpLsAsaProfilePointerLen = 2;
		if (memdup((u_char **) &StorageNew->mtpLsAlarmStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpLsAlarmStatusLen = 1;
		StorageNew->mtpLsRowStatus = 0;
		StorageNew->mtpLsRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpLsTable_data *mtpLsTable_duplicate(struct mtpLsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpLsTable_data *
mtpLsTable_duplicate(struct mtpLsTable_data *thedata)
{
	struct mtpLsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsTable_data);

	DEBUGMSGTL(("mtpLsTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpLsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpLsTable_destroy(struct mtpLsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpLsTable_destroy(struct mtpLsTable_data **thedata)
{
	struct mtpLsTable_data *StorageDel;

	DEBUGMSGTL(("mtpLsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpLsAdjPc);
		StorageDel->mtpLsAdjPcLen = 0;
		SNMP_FREE(StorageDel->mtpLsRsId);
		StorageDel->mtpLsRsIdLen = 0;
		SNMP_FREE(StorageDel->mtpLsAvailabilityStatus);
		StorageDel->mtpLsAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpLsInLsLoadShareAlgorithm);
		StorageDel->mtpLsInLsLoadShareAlgorithmLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfilePointer);
		StorageDel->mtpLsProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpLsName);
		StorageDel->mtpLsNameLen = 0;
		SNMP_FREE(StorageDel->mtpLsAsaProfilePointer);
		StorageDel->mtpLsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpLsAlarmStatus);
		StorageDel->mtpLsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsTable_add(struct mtpLsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpLsTable table data set.
 *
 * Adds a table row structure to the mtpLsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpLsTable_add(struct mtpLsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	header_complex_add_data(&mtpLsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsTable_del(struct mtpLsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpLsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpLsTable_del(struct mtpLsTable_data *thedata)
{
	struct mtpLsTable_data *StorageDel;

	DEBUGMSGTL(("mtpLsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpLsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpLsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpLsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpLsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpLsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpLsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpLsTable_data *StorageTmp = mtpLsTable_create();

	DEBUGMSGTL(("mtpLsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpLsAdjPc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
	if (StorageTmp->mtpLsAdjPc == NULL) {
		config_perror("invalid specification for mtpLsAdjPc");
		return;
	}
	SNMP_FREE(StorageTmp->mtpLsRsId);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsRsId, &StorageTmp->mtpLsRsIdLen);
	if (StorageTmp->mtpLsRsId == NULL) {
		config_perror("invalid specification for mtpLsRsId");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsMaxCapacity, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsCurrentCapacity, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsCongestionControlMethod, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpLsAvailabilityStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
	if (StorageTmp->mtpLsAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpLsAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFail, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsAdministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpLsInLsLoadShareAlgorithm);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
	if (StorageTmp->mtpLsInLsLoadShareAlgorithm == NULL) {
		config_perror("invalid specification for mtpLsInLsLoadShareAlgorithm");
		return;
	}
	SNMP_FREE(StorageTmp->mtpLsProfilePointer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfilePointer, &StorageTmp->mtpLsProfilePointerLen);
	if (StorageTmp->mtpLsProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks, &tmpsize);
	SNMP_FREE(StorageTmp->mtpLsName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
	if (StorageTmp->mtpLsName == NULL) {
		config_perror("invalid specification for mtpLsName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpLsAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsAsaProfilePointer, &StorageTmp->mtpLsAsaProfilePointerLen);
	if (StorageTmp->mtpLsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsAsaProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpLsAlarmStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLsAlarmStatus, &StorageTmp->mtpLsAlarmStatusLen);
	if (StorageTmp->mtpLsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpLsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsRowStatus, &tmpsize);
	mtpLsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
}

/*
 * store_mtpLsTable(): store configuraiton file for mtpLsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpLsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsTable", "storing data...  "));
	refresh_mtpLsTable(1);
	(void) tmpsize;
	for (hcindex = mtpLsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpLsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsRsId, &StorageTmp->mtpLsRsIdLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsMaxCapacity, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsCurrentCapacity, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsCongestionControlMethod, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFail, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfilePointer, &StorageTmp->mtpLsProfilePointerLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsAsaProfilePointer, &StorageTmp->mtpLsAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLsAlarmStatus, &StorageTmp->mtpLsAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlL3ProfileTable_data *mtpSlL3ProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlL3ProfileTable table.
 *
 * Creates a new mtpSlL3ProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlL3ProfileTable_data *
mtpSlL3ProfileTable_create(void)
{
	struct mtpSlL3ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL3ProfileTable_data);

	DEBUGMSGTL(("mtpSlL3ProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlL3ProfileTimerT1 = 80;
		StorageNew->mtpSlL3ProfileTimerT3 = 80;
		StorageNew->mtpSlL3ProfileTimerT17 = 120;
		StorageNew->mtpSlL3ProfileTimerT24I = 50;
		if ((StorageNew->mtpSlL3ProfileName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSlL3ProfileNameLen = strlen("");
		StorageNew->mtpSlL3ProfileTimerT2 = 140;
		StorageNew->mtpSlL3ProfileTimerT4 = 80;
		StorageNew->mtpSlL3ProfileTimerT5 = 80;
		StorageNew->mtpSlL3ProfileTimerT12 = 120;
		StorageNew->mtpSlL3ProfileTimerT13 = 120;
		StorageNew->mtpSlL3ProfileTimerT14 = 250;
		StorageNew->mtpSlL3ProfileTimerT19A = 54000;
		StorageNew->mtpSlL3ProfileTimerT20A = 10000;
		StorageNew->mtpSlL3ProfileTimerT21A = 10000;
		StorageNew->mtpSlL3ProfileTimerT22I = 27000;
		StorageNew->mtpSlL3ProfileTimerT23I = 27000;
		StorageNew->mtpSlL3ProfileTimerT31A = 6000;
		StorageNew->mtpSlL3ProfileTimerT32A = 6000;
		StorageNew->mtpSlL3ProfileTimerT33A = 36000;
		StorageNew->mtpSlL3ProfileTimerT34A = 6000;
		StorageNew->mtpSlL3ProfileTimerT1T = 400;
		StorageNew->mtpSlL3ProfileTimerT2T = 6000;
		StorageNew->mtpSlL3ProfileTimerT1S = 400;
		StorageNew->mtpSlL3ProfileL2Default = (uint8_t *) strdup("");
		StorageNew->mtpSlL3ProfileL2DefaultLen = strlen("");
		StorageNew->mtpSlL3ProfileRowStatus = 0;
		StorageNew->mtpSlL3ProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSlL3ProfileTable_data *mtpSlL3ProfileTable_duplicate(struct mtpSlL3ProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlL3ProfileTable_data *
mtpSlL3ProfileTable_duplicate(struct mtpSlL3ProfileTable_data *thedata)
{
	struct mtpSlL3ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL3ProfileTable_data);

	DEBUGMSGTL(("mtpSlL3ProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlL3ProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlL3ProfileTable_destroy(struct mtpSlL3ProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlL3ProfileTable_destroy(struct mtpSlL3ProfileTable_data **thedata)
{
	struct mtpSlL3ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlL3ProfileId);
		StorageDel->mtpSlL3ProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfileName);
		StorageDel->mtpSlL3ProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfileL2Default);
		StorageDel->mtpSlL3ProfileL2DefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL3ProfileTable_add(struct mtpSlL3ProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlL3ProfileTable table data set.
 *
 * Adds a table row structure to the mtpSlL3ProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlL3ProfileTable_add(struct mtpSlL3ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSlL3ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSlL3ProfileId, thedata->mtpSlL3ProfileIdLen);
	header_complex_add_data(&mtpSlL3ProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL3ProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL3ProfileTable_del(struct mtpSlL3ProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSlL3ProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlL3ProfileTable_del(struct mtpSlL3ProfileTable_data *thedata)
{
	struct mtpSlL3ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlL3ProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlL3ProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlL3ProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlL3ProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlL3ProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlL3ProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL3ProfileTable_data *StorageTmp = mtpSlL3ProfileTable_create();

	DEBUGMSGTL(("mtpSlL3ProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSlL3ProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileId, &StorageTmp->mtpSlL3ProfileIdLen);
	if (StorageTmp->mtpSlL3ProfileId == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT17, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT24I, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlL3ProfileName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileName, &StorageTmp->mtpSlL3ProfileNameLen);
	if (StorageTmp->mtpSlL3ProfileName == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT12, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT13, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT14, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT19A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT20A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT21A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT22I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT23I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT31A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT32A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT33A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT34A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT2T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1S, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlL3ProfileL2Default);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileL2Default, &StorageTmp->mtpSlL3ProfileL2DefaultLen);
	if (StorageTmp->mtpSlL3ProfileL2Default == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileL2Default");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileRowStatus, &tmpsize);
	mtpSlL3ProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
}

/*
 * store_mtpSlL3ProfileTable(): store configuraiton file for mtpSlL3ProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL3ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL3ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "storing data...  "));
	refresh_mtpSlL3ProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpSlL3ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL3ProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlL3ProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileId, &StorageTmp->mtpSlL3ProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT17, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT24I, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileName, &StorageTmp->mtpSlL3ProfileNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT12, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT13, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT14, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT19A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT20A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT21A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT22I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT23I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT31A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT32A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT33A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT34A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT2T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1S, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileL2Default, &StorageTmp->mtpSlL3ProfileL2DefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlL2ProfileTable_data *mtpSlL2ProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlL2ProfileTable table.
 *
 * Creates a new mtpSlL2ProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlL2ProfileTable_data *
mtpSlL2ProfileTable_create(void)
{
	struct mtpSlL2ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL2ProfileTable_data);

	DEBUGMSGTL(("mtpSlL2ProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlL2ProfileErrorCorrectionMethod = MTPSLL2PROFILEERRORCORRECTIONMETHOD_BASICRETR;
		{
			static oid tmpoid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 0, 1, 4, 1, 1, 0 };
			if ((StorageNew->mtpSlL2ProfileProtocolVariant = snmp_duplicate_objid(tmpoid, 15)))
				StorageNew->mtpSlL2ProfileProtocolVariantLen = 15;
		}
		StorageNew->mtpSlL2ProfileTimerT1 = 4500;
		StorageNew->mtpSlL2ProfileTimerT2 = 500;
		StorageNew->mtpSlL2ProfileTimerT2L = 2000;
		StorageNew->mtpSlL2ProfileTimerT2H = 10000;
		StorageNew->mtpSlL2ProfileTimerT3 = 100;
		StorageNew->mtpSlL2ProfileTimerT4N = 800;
		StorageNew->mtpSlL2ProfileTimerT4E = 50;
		StorageNew->mtpSlL2ProfileTimerT5 = 10;
		StorageNew->mtpSlL2ProfileTimerT6 = 4000;
		StorageNew->mtpSlL2ProfileTimerT7 = 1000;
		StorageNew->mtpSlL2ProfileTbOnset1 = 69632;
		StorageNew->mtpSlL2ProfileTbAbate1 = 34816;
		StorageNew->mtpSlL2ProfileNumberOfThresholdLevels = 1;
		StorageNew->mtpSlL2ProfileCongestionCounting = MTPSLL2PROFILECONGESTIONCOUNTING_OCTET;
		StorageNew->mtpSlL2ProfileCongestionReportingBaseObject = MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_ROUTESET;
		StorageNew->mtpSlL2ProfileLoopDelay = 0;
		if ((StorageNew->mtpSlL2ProfileName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSlL2ProfileNameLen = strlen("");
		StorageNew->mtpSlL2ProfileTbOnset2 = 174080;
		StorageNew->mtpSlL2ProfileTbAbate2 = 139264;
		StorageNew->mtpSlL2ProfileTbOnset3 = 278528;
		StorageNew->mtpSlL2ProfileTbAbate3 = 243712;
		StorageNew->mtpSlL2ProfileTbDiscard1 = 104448;
		StorageNew->mtpSlL2ProfileTbDiscard2 = 208896;
		StorageNew->mtpSlL2ProfileTbDiscard3 = 313344;
		StorageNew->mtpSlL2ProfileTimerTx = 100;
		StorageNew->mtpSlL2ProfileTimerTy = 200;
		StorageNew->mtpSlL2ProfileNumberOfCongestionStates = 3;
		StorageNew->mtpSlL2ProfileInitialLevelOfCongestion = 1;
		StorageNew->mtpSlL2ProfileMaxMSUsRetransN1 = 127;
		StorageNew->mtpSlL2ProfileMaxOctRetransN2 = 8192;
		StorageNew->mtpSlL2ProfileReceiveCongestionThresholdOnset = 6;
		StorageNew->mtpSlL2ProfileReceiveCongestionThresholdAbate = 3;
		StorageNew->mtpSlL2ProfileReceiveCongestionThresholdDiscard = 9;
		StorageNew->mtpSlL2ProfileM = 5;
		StorageNew->mtpSlL2ProfileRowStatus = 0;
		StorageNew->mtpSlL2ProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSlL2ProfileTable_data *mtpSlL2ProfileTable_duplicate(struct mtpSlL2ProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlL2ProfileTable_data *
mtpSlL2ProfileTable_duplicate(struct mtpSlL2ProfileTable_data *thedata)
{
	struct mtpSlL2ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL2ProfileTable_data);

	DEBUGMSGTL(("mtpSlL2ProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlL2ProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlL2ProfileTable_destroy(struct mtpSlL2ProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlL2ProfileTable_destroy(struct mtpSlL2ProfileTable_data **thedata)
{
	struct mtpSlL2ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlL2ProfileId);
		StorageDel->mtpSlL2ProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSlL2ProfileProtocolVariant);
		StorageDel->mtpSlL2ProfileProtocolVariantLen = 0;
		SNMP_FREE(StorageDel->mtpSlL2ProfileName);
		StorageDel->mtpSlL2ProfileNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL2ProfileTable_add(struct mtpSlL2ProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlL2ProfileTable table data set.
 *
 * Adds a table row structure to the mtpSlL2ProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlL2ProfileTable_add(struct mtpSlL2ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSlL2ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSlL2ProfileId, thedata->mtpSlL2ProfileIdLen);
	/* mtpSlL2ProfileTransmissionRate */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpSlL2ProfileTransmissionRate, sizeof(thedata->mtpSlL2ProfileTransmissionRate));
	header_complex_add_data(&mtpSlL2ProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL2ProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL2ProfileTable_del(struct mtpSlL2ProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSlL2ProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlL2ProfileTable_del(struct mtpSlL2ProfileTable_data *thedata)
{
	struct mtpSlL2ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlL2ProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlL2ProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlL2ProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlL2ProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlL2ProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlL2ProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL2ProfileTable_data *StorageTmp = mtpSlL2ProfileTable_create();

	DEBUGMSGTL(("mtpSlL2ProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSlL2ProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL2ProfileId, &StorageTmp->mtpSlL2ProfileIdLen);
	if (StorageTmp->mtpSlL2ProfileId == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTransmissionRate, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlL2ProfileProtocolVariant);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlL2ProfileProtocolVariant, &StorageTmp->mtpSlL2ProfileProtocolVariantLen);
	if (StorageTmp->mtpSlL2ProfileProtocolVariant == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileProtocolVariant");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2L, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2H, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT4N, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT4E, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileCongestionCounting, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileLoopDelay, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlL2ProfileName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL2ProfileName, &StorageTmp->mtpSlL2ProfileNameLen);
	if (StorageTmp->mtpSlL2ProfileName == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset3, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate3, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerTx, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerTy, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileMaxOctRetransN2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileM, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileRowStatus, &tmpsize);
	mtpSlL2ProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
}

/*
 * store_mtpSlL2ProfileTable(): store configuraiton file for mtpSlL2ProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL2ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL2ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "storing data...  "));
	refresh_mtpSlL2ProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpSlL2ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL2ProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlL2ProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL2ProfileId, &StorageTmp->mtpSlL2ProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlL2ProfileProtocolVariant, &StorageTmp->mtpSlL2ProfileProtocolVariantLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2L, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2H, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT4N, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT4E, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileCongestionCounting, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileLoopDelay, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL2ProfileName, &StorageTmp->mtpSlL2ProfileNameLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset3, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate3, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerTx, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerTy, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileMaxOctRetransN2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileM, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlTable_data *mtpSlTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlTable table.
 *
 * Creates a new mtpSlTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlTable_data *
mtpSlTable_create(void)
{
	struct mtpSlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlTable_data);

	DEBUGMSGTL(("mtpSlTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlSlCode = 0;
		if ((StorageNew->mtpSlSlsCodeCurrentList = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSlSlsCodeCurrentListLen = strlen("");
		StorageNew->mtpSlMaxCapacitySL = 8000;
		StorageNew->mtpSlCurrentCapacitySL = 8000;
		if (memdup((u_char **) &StorageNew->mtpSlLinkTpStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpSlLinkTpStatusLen = 1;
		StorageNew->mtpSlAdministrativeState = MTPSLADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpSlOperationalState = MTPSLOPERATIONALSTATE_DISABLED;
		StorageNew->mtpSlUsageState = MTPSLUSAGESTATE_IDLE;
		if (memdup((u_char **) &StorageNew->mtpSlProceduralStatus, (u_char *) "\x80", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpSlProceduralStatusLen = 1;
		StorageNew->mtpSlMtpL2ProtocolProfilePointer = (uint8_t *) strdup("");
		StorageNew->mtpSlMtpL2ProtocolProfilePointerLen = strlen("");
		if ((StorageNew->mtpSlSignTermPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSlSignTermPointerLen = 2;
		if ((StorageNew->mtpSlSignDataLinkTpPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSlSignDataLinkTpPointerLen = 2;
		StorageNew->mtpSlLocalInhibit = 0;
		StorageNew->mtpSlLocalUninhibit = 0;
		StorageNew->mtpSlReplaceSt = 0;
		if ((StorageNew->mtpSlAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSlAsaProfilePointerLen = 2;
		StorageNew->mtpSlCongestionLevel = MTPSLCONGESTIONLEVEL_NONE;
		StorageNew->mtpSlRelatedLinkGroupNumber = 0;
		StorageNew->mtpSlSdlList = 0;
		StorageNew->mtpSlTest = 0;
		if ((StorageNew->mtpSlName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSlNameLen = strlen("");
		StorageNew->mtpSlSdtList = 0;
		if (memdup((u_char **) &StorageNew->mtpSlSlsCodeNormalList, (u_char *) "\xFF\xFF", 2) == SNMPERR_SUCCESS)
			StorageNew->mtpSlSlsCodeNormalListLen = 2;
		StorageNew->mtpSlL3ProfilePointer = (uint8_t *) strdup("");
		StorageNew->mtpSlL3ProfilePointerLen = strlen("");
		if (memdup((u_char **) &StorageNew->mtpSlAlarmStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpSlAlarmStatusLen = 1;
		StorageNew->mtpSlRowStatus = 0;
		StorageNew->mtpSlRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSlTable_data *mtpSlTable_duplicate(struct mtpSlTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlTable_data *
mtpSlTable_duplicate(struct mtpSlTable_data *thedata)
{
	struct mtpSlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlTable_data);

	DEBUGMSGTL(("mtpSlTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlTable_destroy(struct mtpSlTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlTable_destroy(struct mtpSlTable_data **thedata)
{
	struct mtpSlTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSlsCodeCurrentList);
		StorageDel->mtpSlSlsCodeCurrentListLen = 0;
		SNMP_FREE(StorageDel->mtpSlLinkTpStatus);
		StorageDel->mtpSlLinkTpStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSlProceduralStatus);
		StorageDel->mtpSlProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSlMtpL2ProtocolProfilePointer);
		StorageDel->mtpSlMtpL2ProtocolProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlSignTermPointer);
		StorageDel->mtpSlSignTermPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlSignDataLinkTpPointer);
		StorageDel->mtpSlSignDataLinkTpPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlAsaProfilePointer);
		StorageDel->mtpSlAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlName);
		StorageDel->mtpSlNameLen = 0;
		SNMP_FREE(StorageDel->mtpSlSlsCodeNormalList);
		StorageDel->mtpSlSlsCodeNormalListLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfilePointer);
		StorageDel->mtpSlL3ProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlAlarmStatus);
		StorageDel->mtpSlAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlTable_add(struct mtpSlTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlTable table data set.
 *
 * Adds a table row structure to the mtpSlTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlTable_add(struct mtpSlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
	header_complex_add_data(&mtpSlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlTable_del(struct mtpSlTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSlTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlTable_del(struct mtpSlTable_data *thedata)
{
	struct mtpSlTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlTable_data *StorageTmp = mtpSlTable_create();

	DEBUGMSGTL(("mtpSlTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlSlsCodeCurrentList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
	if (StorageTmp->mtpSlSlsCodeCurrentList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeCurrentList");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlMaxCapacitySL, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCurrentCapacitySL, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlLinkTpStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlLinkTpStatus, &StorageTmp->mtpSlLinkTpStatusLen);
	if (StorageTmp->mtpSlLinkTpStatus == NULL) {
		config_perror("invalid specification for mtpSlLinkTpStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlProceduralStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
	if (StorageTmp->mtpSlProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSlProceduralStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSlMtpL2ProtocolProfilePointer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlMtpL2ProtocolProfilePointer, &StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen);
	if (StorageTmp->mtpSlMtpL2ProtocolProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlMtpL2ProtocolProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSlSignTermPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSignTermPointer, &StorageTmp->mtpSlSignTermPointerLen);
	if (StorageTmp->mtpSlSignTermPointer == NULL) {
		config_perror("invalid specification for mtpSlSignTermPointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSlSignDataLinkTpPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSignDataLinkTpPointer, &StorageTmp->mtpSlSignDataLinkTpPointerLen);
	if (StorageTmp->mtpSlSignDataLinkTpPointer == NULL) {
		config_perror("invalid specification for mtpSlSignDataLinkTpPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalInhibit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalUninhibit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlReplaceSt, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlAsaProfilePointer, &StorageTmp->mtpSlAsaProfilePointerLen);
	if (StorageTmp->mtpSlAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlCongestionLevel, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlList, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlTest, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
	if (StorageTmp->mtpSlName == NULL) {
		config_perror("invalid specification for mtpSlName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtList, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlSlsCodeNormalList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
	if (StorageTmp->mtpSlSlsCodeNormalList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeNormalList");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSlL3ProfilePointer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfilePointer, &StorageTmp->mtpSlL3ProfilePointerLen);
	if (StorageTmp->mtpSlL3ProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlL3ProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSlAlarmStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlAlarmStatus, &StorageTmp->mtpSlAlarmStatusLen);
	if (StorageTmp->mtpSlAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSlAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlRowStatus, &tmpsize);
	mtpSlTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
}

/*
 * store_mtpSlTable(): store configuraiton file for mtpSlTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlTable", "storing data...  "));
	refresh_mtpSlTable(1);
	(void) tmpsize;
	for (hcindex = mtpSlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlMaxCapacitySL, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCurrentCapacitySL, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlLinkTpStatus, &StorageTmp->mtpSlLinkTpStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlMtpL2ProtocolProfilePointer, &StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSignTermPointer, &StorageTmp->mtpSlSignTermPointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSignDataLinkTpPointer, &StorageTmp->mtpSlSignDataLinkTpPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalInhibit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalUninhibit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlReplaceSt, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlAsaProfilePointer, &StorageTmp->mtpSlAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlCongestionLevel, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlList, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlTest, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtList, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfilePointer, &StorageTmp->mtpSlL3ProfilePointerLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlAlarmStatus, &StorageTmp->mtpSlAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlSdlListTable_data *mtpSlSdlListTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlSdlListTable table.
 *
 * Creates a new mtpSlSdlListTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlSdlListTable_data *
mtpSlSdlListTable_create(void)
{
	struct mtpSlSdlListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);

	DEBUGMSGTL(("mtpSlSdlListTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlId = 0;
		if ((StorageNew->mtpSlSdlListPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSlSdlListPointerLen = 2;
		StorageNew->mtpSlSdlListRowStatus = 0;
		StorageNew->mtpSlSdlListRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSlSdlListTable_data *mtpSlSdlListTable_duplicate(struct mtpSlSdlListTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlSdlListTable_data *
mtpSlSdlListTable_duplicate(struct mtpSlSdlListTable_data *thedata)
{
	struct mtpSlSdlListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);

	DEBUGMSGTL(("mtpSlSdlListTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlSdlListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlSdlListTable_destroy(struct mtpSlSdlListTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlSdlListTable_destroy(struct mtpSlSdlListTable_data **thedata)
{
	struct mtpSlSdlListTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlSdlListTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSdlListPointer);
		StorageDel->mtpSlSdlListPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdlListTable_add(struct mtpSlSdlListTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlSdlListTable table data set.
 *
 * Adds a table row structure to the mtpSlSdlListTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlSdlListTable_add(struct mtpSlSdlListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdlListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
	/* mtpSlSdlListId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdlListId, sizeof(thedata->mtpSlSdlListId));
	header_complex_add_data(&mtpSlSdlListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdlListTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdlListTable_del(struct mtpSlSdlListTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSlSdlListTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlSdlListTable_del(struct mtpSlSdlListTable_data *thedata)
{
	struct mtpSlSdlListTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlSdlListTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlSdlListTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlSdlListTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlSdlListTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlSdlListTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlSdlListTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlSdlListTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlSdlListTable_data *StorageTmp = mtpSlSdlListTable_create();

	DEBUGMSGTL(("mtpSlSdlListTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlListId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlSdlListPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
	if (StorageTmp->mtpSlSdlListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdlListPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdlListRowStatus, &tmpsize);
	mtpSlSdlListTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
}

/*
 * store_mtpSlSdlListTable(): store configuraiton file for mtpSlSdlListTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdlListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlSdlListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdlListTable", "storing data...  "));
	refresh_mtpSlSdlListTable(1);
	(void) tmpsize;
	for (hcindex = mtpSlSdlListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdlListTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlSdlListTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlListId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdlListRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlSdtListTable_data *mtpSlSdtListTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlSdtListTable table.
 *
 * Creates a new mtpSlSdtListTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlSdtListTable_data *
mtpSlSdtListTable_create(void)
{
	struct mtpSlSdtListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);

	DEBUGMSGTL(("mtpSlSdtListTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlId = 0;
		if ((StorageNew->mtpSlSdtListPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSlSdtListPointerLen = 2;
		StorageNew->mtpSlSdtListRowStatus = 0;
		StorageNew->mtpSlSdtListRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSlSdtListTable_data *mtpSlSdtListTable_duplicate(struct mtpSlSdtListTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlSdtListTable_data *
mtpSlSdtListTable_duplicate(struct mtpSlSdtListTable_data *thedata)
{
	struct mtpSlSdtListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);

	DEBUGMSGTL(("mtpSlSdtListTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlSdtListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlSdtListTable_destroy(struct mtpSlSdtListTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlSdtListTable_destroy(struct mtpSlSdtListTable_data **thedata)
{
	struct mtpSlSdtListTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlSdtListTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSdtListPointer);
		StorageDel->mtpSlSdtListPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdtListTable_add(struct mtpSlSdtListTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlSdtListTable table data set.
 *
 * Adds a table row structure to the mtpSlSdtListTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlSdtListTable_add(struct mtpSlSdtListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdtListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
	/* mtpSlSdtListId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdtListId, sizeof(thedata->mtpSlSdtListId));
	header_complex_add_data(&mtpSlSdtListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdtListTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdtListTable_del(struct mtpSlSdtListTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSlSdtListTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlSdtListTable_del(struct mtpSlSdtListTable_data *thedata)
{
	struct mtpSlSdtListTable_data *StorageDel;

	DEBUGMSGTL(("mtpSlSdtListTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlSdtListTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlSdtListTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlSdtListTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlSdtListTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlSdtListTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlSdtListTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlSdtListTable_data *StorageTmp = mtpSlSdtListTable_create();

	DEBUGMSGTL(("mtpSlSdtListTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtListId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlSdtListPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
	if (StorageTmp->mtpSlSdtListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdtListPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdtListRowStatus, &tmpsize);
	mtpSlSdtListTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
}

/*
 * store_mtpSlSdtListTable(): store configuraiton file for mtpSlSdtListTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdtListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlSdtListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdtListTable", "storing data...  "));
	refresh_mtpSlSdtListTable(1);
	(void) tmpsize;
	for (hcindex = mtpSlSdtListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdtListTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlSdtListTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtListId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdtListRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpNbTable_data *mtpNbTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpNbTable table.
 *
 * Creates a new mtpNbTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpNbTable_data *
mtpNbTable_create(void)
{
	struct mtpNbTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNbTable_data);

	DEBUGMSGTL(("mtpNbTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpNbTransmissionRate = MTPNBTRANSMISSIONRATE_KBITS64;
		StorageNew->mtpNbTimerT8 = 100;
		StorageNew->mtpNbTin = 4;
		StorageNew->mtpNbTie = 1;
		StorageNew->mtpNbT = 64;
		StorageNew->mtpNbD = 256;
		StorageNew->mtpNbTe = 793544;
		StorageNew->mtpNbDe = 11328;
		StorageNew->mtpNbUe = 198384;
		StorageNew->mtpNbN = 16;
		StorageNew->mtpNbm = 272;
		StorageNew->mtpNbb = 8;
		StorageNew->mtpNbf = MTPNBF_ONE;
		StorageNew->mtpNbRowStatus = 0;
		StorageNew->mtpNbRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpNbTable_data *mtpNbTable_duplicate(struct mtpNbTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpNbTable_data *
mtpNbTable_duplicate(struct mtpNbTable_data *thedata)
{
	struct mtpNbTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNbTable_data);

	DEBUGMSGTL(("mtpNbTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpNbTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpNbTable_destroy(struct mtpNbTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpNbTable_destroy(struct mtpNbTable_data **thedata)
{
	struct mtpNbTable_data *StorageDel;

	DEBUGMSGTL(("mtpNbTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNbTable_add(struct mtpNbTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpNbTable table data set.
 *
 * Adds a table row structure to the mtpNbTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpNbTable_add(struct mtpNbTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNbTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
	header_complex_add_data(&mtpNbTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNbTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNbTable_del(struct mtpNbTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpNbTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpNbTable_del(struct mtpNbTable_data *thedata)
{
	struct mtpNbTable_data *StorageDel;

	DEBUGMSGTL(("mtpNbTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpNbTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpNbTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpNbTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpNbTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpNbTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpNbTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpNbTable_data *StorageTmp = mtpNbTable_create();

	DEBUGMSGTL(("mtpNbTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSdtProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbTransmissionRate, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTimerT8, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTie, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbT, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbD, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbDe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbUe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbN, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbm, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbb, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbf, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbRowStatus, &tmpsize);
	mtpNbTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
}

/*
 * store_mtpNbTable(): store configuraiton file for mtpNbTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpNbTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpNbTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNbTable", "storing data...  "));
	refresh_mtpNbTable(1);
	(void) tmpsize;
	for (hcindex = mtpNbTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNbTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpNbTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTin, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTie, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbT, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbD, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbDe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbUe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbN, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbm, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbb, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbf, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSaalTable_data *mtpSaalTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSaalTable table.
 *
 * Creates a new mtpSaalTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSaalTable_data *
mtpSaalTable_create(void)
{
	struct mtpSaalTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSaalTable_data);

	DEBUGMSGTL(("mtpSaalTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpSdtProfileId = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSdtProfileIdLen = strlen("");
		StorageNew->mtpSaalBufferRelease = TV_FALSE;
		StorageNew->mtpSaalMaxCc = 4;
		StorageNew->mtpSaalMaxNrp = 1;
		StorageNew->mtpSaalMaxInformationFieldLength = 4096;
		StorageNew->mtpSaalMaxLengthSscopUuField = 4;
		StorageNew->mtpSaalMaxPd = 500;
		StorageNew->mtpSaalMaxSscopCreditToPeer = 128;
		StorageNew->mtpSaalMaxStat = 67;
		StorageNew->mtpSaalN1 = 1000;
		StorageNew->mtpSaalNniLayerManagementProvingState = MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_NEUTRAL;
		StorageNew->mtpSaalNniLayerManagementTimerNoCredit = 200;
		StorageNew->mtpSaalNniLayerManagementTimerRepeatSrec = 0;
		StorageNew->mtpSaalNniTimerT1 = 500;
		StorageNew->mtpSaalNniTimerT2 = 3000;
		StorageNew->mtpSaalNniTimerT3 = 10;
		StorageNew->mtpSaalSscopTimerCc = 20;
		StorageNew->mtpSaalSscopTimerIdle = 10;
		StorageNew->mtpSaalSscopTimerKeepAlive = 10;
		StorageNew->mtpSaalSscopTimerNoResponse = 150;
		StorageNew->mtpSaalSscopTimerPoll = 10;
		StorageNew->mtpSaalTransmissionRateIntervalLower = 129;
		StorageNew->mtpSaalTransmissionRateIntervalUpper = 256;
		StorageNew->mtpSaalEgressTransmissionRateIntervalLower = 129;
		StorageNew->mtpSaalEgressTransmissionRateIntervalUpper = 256;
		StorageNew->mtpSaalPollAfterRetransmission = TV_TRUE;
		StorageNew->mtpSaalRowStatus = 0;
		StorageNew->mtpSaalRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSaalTable_data *mtpSaalTable_duplicate(struct mtpSaalTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSaalTable_data *
mtpSaalTable_duplicate(struct mtpSaalTable_data *thedata)
{
	struct mtpSaalTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSaalTable_data);

	DEBUGMSGTL(("mtpSaalTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSaalTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSaalTable_destroy(struct mtpSaalTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSaalTable_destroy(struct mtpSaalTable_data **thedata)
{
	struct mtpSaalTable_data *StorageDel;

	DEBUGMSGTL(("mtpSaalTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSaalTable_add(struct mtpSaalTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSaalTable table data set.
 *
 * Adds a table row structure to the mtpSaalTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSaalTable_add(struct mtpSaalTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSaalTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
	header_complex_add_data(&mtpSaalTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSaalTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSaalTable_del(struct mtpSaalTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSaalTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSaalTable_del(struct mtpSaalTable_data *thedata)
{
	struct mtpSaalTable_data *StorageDel;

	DEBUGMSGTL(("mtpSaalTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSaalTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSaalTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSaalTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSaalTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSaalTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSaalTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSaalTable_data *StorageTmp = mtpSaalTable_create();

	DEBUGMSGTL(("mtpSaalTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSdtProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalBufferRelease, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxCc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxNrp, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxPd, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxStat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerCc, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerIdle, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerPoll, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalRowStatus, &tmpsize);
	mtpSaalTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
}

/*
 * store_mtpSaalTable(): store configuraiton file for mtpSaalTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSaalTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSaalTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSaalTable", "storing data...  "));
	refresh_mtpSaalTable(1);
	(void) tmpsize;
	for (hcindex = mtpSaalTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSaalTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSaalTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalBufferRelease, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxCc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxNrp, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxPd, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxStat, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalN1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerCc, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerIdle, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerPoll, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpM2paTable_data *mtpM2paTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpM2paTable table.
 *
 * Creates a new mtpM2paTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpM2paTable_data *
mtpM2paTable_create(void)
{
	struct mtpM2paTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2paTable_data);

	DEBUGMSGTL(("mtpM2paTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpSdtProfileId = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSdtProfileIdLen = strlen("");
		StorageNew->mtpM2paN1 = 1000;
		StorageNew->mtpM2paProving = TV_TRUE;
		StorageNew->mtpM2paManagementProvingState = MTPM2PAMANAGEMENTPROVINGSTATE_NEUTRAL;
		StorageNew->mtpM2paProvingAttempts = 4;
		StorageNew->mtpM2paSctpNoDelay = TV_TRUE;
		StorageNew->mtpM2paSctpMaxseg = 65536;
		StorageNew->mtpM2paSctpHeartbeatItvl = 60000;
		StorageNew->mtpM2paSctpHeartbeat = TV_TRUE;
		StorageNew->mtpM2paSctpRtoInitial = 3000;
		StorageNew->mtpM2paSctpRtoMin = 1000;
		StorageNew->mtpM2paSctpRtoMax = 60000;
		StorageNew->mtpM2paSctpPathMaxRetrans = 5;
		StorageNew->mtpM2paSctpCookieLife = 60000;
		StorageNew->mtpM2paSctpCookieInc = 1000;
		StorageNew->mtpM2paSctpMaxInitRetries = 8;
		StorageNew->mtpM2paSctpMaxBurst = 4;
		StorageNew->mtpM2paSctpAssocMaxRetrans = 10;
		StorageNew->mtpM2paSctpSackDelay = 200;
		StorageNew->mtpM2paSctpLifetime = 0;
		StorageNew->mtpM2paLoopDelayLower = 0;
		StorageNew->mtpM2paLoopDelayUpper = 600;
		StorageNew->mtpM2paTransmissionRateIntervalLower = 1544000;
		StorageNew->mtpM2paTransmissionRateIntervalUpper = 155000000;
		StorageNew->mtpM2paRowStatus = 0;
		StorageNew->mtpM2paRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpM2paTable_data *mtpM2paTable_duplicate(struct mtpM2paTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpM2paTable_data *
mtpM2paTable_duplicate(struct mtpM2paTable_data *thedata)
{
	struct mtpM2paTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2paTable_data);

	DEBUGMSGTL(("mtpM2paTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpM2paTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpM2paTable_destroy(struct mtpM2paTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpM2paTable_destroy(struct mtpM2paTable_data **thedata)
{
	struct mtpM2paTable_data *StorageDel;

	DEBUGMSGTL(("mtpM2paTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2paTable_add(struct mtpM2paTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpM2paTable table data set.
 *
 * Adds a table row structure to the mtpM2paTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpM2paTable_add(struct mtpM2paTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpM2paTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
	header_complex_add_data(&mtpM2paTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpM2paTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2paTable_del(struct mtpM2paTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpM2paTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpM2paTable_del(struct mtpM2paTable_data *thedata)
{
	struct mtpM2paTable_data *StorageDel;

	DEBUGMSGTL(("mtpM2paTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpM2paTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpM2paTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpM2paTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpM2paTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpM2paTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpM2paTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM2paTable_data *StorageTmp = mtpM2paTable_create();

	DEBUGMSGTL(("mtpM2paTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSdtProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paProving, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paManagementProvingState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paProvingAttempts, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpLifetime, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayUpper, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paRowStatus, &tmpsize);
	mtpM2paTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
}

/*
 * store_mtpM2paTable(): store configuraiton file for mtpM2paTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM2paTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM2paTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpM2paTable", "storing data...  "));
	refresh_mtpM2paTable(1);
	(void) tmpsize;
	for (hcindex = mtpM2paTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM2paTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM2paTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paN1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paProving, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paManagementProvingState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paProvingAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpNoDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxseg, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpHeartbeat, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoInitial, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMin, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMax, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieLife, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieInc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxBurst, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpSackDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayUpper, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSdtTable_data *mtpSdtTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSdtTable table.
 *
 * Creates a new mtpSdtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSdtTable_data *
mtpSdtTable_create(void)
{
	struct mtpSdtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdtTable_data);

	DEBUGMSGTL(("mtpSdtTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSdtType = 0;
		StorageNew->mtpSdtAdministrativeState = MTPSDTADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpSdtOperationalState = MTPSDTOPERATIONALSTATE_DISABLED;
		StorageNew->mtpSdtUsageState = MTPSDTUSAGESTATE_IDLE;
		if (memdup((u_char **) &StorageNew->mtpSdtProceduralStatus, (u_char *) "\x80", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpSdtProceduralStatusLen = 1;
		if (memdup((u_char **) &StorageNew->mtpSdtAvailabilityStatus, (u_char *) "\x00\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->mtpSdtAvailabilityStatusLen = 2;
		if ((StorageNew->mtpSdtEquipmentPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSdtEquipmentPointerLen = 2;
		if ((StorageNew->mtpSdtName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSdtNameLen = strlen("");
		StorageNew->mtpSdtStandbyStatus = 0;
		StorageNew->mtpSdtPrimaryId = 0;
		/* StorageNew->mtpSdtProfilePointer = NULL; *//* DEFVAL '' */
		/* StorageNew->mtpSdtProfilePointer = 0; *//* DEFVAL '' */
		StorageNew->mtpSdtRowStatus = 0;
		StorageNew->mtpSdtRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSdtTable_data *mtpSdtTable_duplicate(struct mtpSdtTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSdtTable_data *
mtpSdtTable_duplicate(struct mtpSdtTable_data *thedata)
{
	struct mtpSdtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdtTable_data);

	DEBUGMSGTL(("mtpSdtTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSdtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSdtTable_destroy(struct mtpSdtTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSdtTable_destroy(struct mtpSdtTable_data **thedata)
{
	struct mtpSdtTable_data *StorageDel;

	DEBUGMSGTL(("mtpSdtTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProceduralStatus);
		StorageDel->mtpSdtProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSdtAvailabilityStatus);
		StorageDel->mtpSdtAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSdtEquipmentPointer);
		StorageDel->mtpSdtEquipmentPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdtName);
		StorageDel->mtpSdtNameLen = 0;
		SNMP_FREE(StorageDel->mtpSdtProfilePointer);
		StorageDel->mtpSdtProfilePointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdtTable_add(struct mtpSdtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSdtTable table data set.
 *
 * Adds a table row structure to the mtpSdtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSdtTable_add(struct mtpSdtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSdtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSdtId, sizeof(thedata->mtpSdtId));
	header_complex_add_data(&mtpSdtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdtTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdtTable_del(struct mtpSdtTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSdtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSdtTable_del(struct mtpSdtTable_data *thedata)
{
	struct mtpSdtTable_data *StorageDel;

	DEBUGMSGTL(("mtpSdtTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSdtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSdtTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSdtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSdtTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSdtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSdtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSdtTable_data *StorageTmp = mtpSdtTable_create();

	DEBUGMSGTL(("mtpSdtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdtProceduralStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtProceduralStatus, &StorageTmp->mtpSdtProceduralStatusLen);
	if (StorageTmp->mtpSdtProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSdtProceduralStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdtAvailabilityStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtAvailabilityStatus, &StorageTmp->mtpSdtAvailabilityStatusLen);
	if (StorageTmp->mtpSdtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSdtAvailabilityStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdtEquipmentPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
	if (StorageTmp->mtpSdtEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdtEquipmentPointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdtName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
	if (StorageTmp->mtpSdtName == NULL) {
		config_perror("invalid specification for mtpSdtName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtStandbyStatus, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtPrimaryId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdtProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtProfilePointer, &StorageTmp->mtpSdtProfilePointerLen);
	if (StorageTmp->mtpSdtProfilePointer == NULL) {
		config_perror("invalid specification for mtpSdtProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtRowStatus, &tmpsize);
	mtpSdtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
}

/*
 * store_mtpSdtTable(): store configuraiton file for mtpSdtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSdtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdtTable", "storing data...  "));
	refresh_mtpSdtTable(1);
	(void) tmpsize;
	for (hcindex = mtpSdtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSdtTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtProceduralStatus, &StorageTmp->mtpSdtProceduralStatusLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtAvailabilityStatus, &StorageTmp->mtpSdtAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtStandbyStatus, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtPrimaryId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtProfilePointer, &StorageTmp->mtpSdtProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSdlTable_data *mtpSdlTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSdlTable table.
 *
 * Creates a new mtpSdlTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSdlTable_data *
mtpSdlTable_create(void)
{
	struct mtpSdlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdlTable_data);

	DEBUGMSGTL(("mtpSdlTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpSdlType = 0;
		if (memdup((u_char **) &StorageNew->mtpSdlAdjPc, (u_char *) "\x00\x00\x00\x00", 4) == SNMPERR_SUCCESS)
			StorageNew->mtpSdlAdjPcLen = 4;
		StorageNew->mtpSdlLoopDelay = 0;
		StorageNew->mtpSdlOperationalState = MTPSDLOPERATIONALSTATE_DISABLED;
		if ((StorageNew->mtpSdlEquipmentPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSdlEquipmentPointerLen = 2;
		StorageNew->mtpSdlCIC = 0;
		StorageNew->mtpSdlTransmissionRate = MTPSDLTRANSMISSIONRATE_KBITS64;
		/* StorageNew->mtpSdlStmChannel = (uint8_t *) strdup(19); *//* DEFVAL 19 */
		/* StorageNew->mtpSdlStmChannelLen = strlen(19); *//* DEFVAL 19 */
		if ((StorageNew->mtpSdlVcTTpPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSdlVcTTpPointerLen = 2;
		if ((StorageNew->mtpSdlSctpPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpSdlSctpPointerLen = 2;
		if ((StorageNew->mtpSdlName = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSdlNameLen = strlen("");
		StorageNew->mtpSdlRowStatus = 0;
		StorageNew->mtpSdlRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSdlTable_data *mtpSdlTable_duplicate(struct mtpSdlTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSdlTable_data *
mtpSdlTable_duplicate(struct mtpSdlTable_data *thedata)
{
	struct mtpSdlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdlTable_data);

	DEBUGMSGTL(("mtpSdlTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSdlTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSdlTable_destroy(struct mtpSdlTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSdlTable_destroy(struct mtpSdlTable_data **thedata)
{
	struct mtpSdlTable_data *StorageDel;

	DEBUGMSGTL(("mtpSdlTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdlId);
		StorageDel->mtpSdlIdLen = 0;
		SNMP_FREE(StorageDel->mtpSdlAdjPc);
		StorageDel->mtpSdlAdjPcLen = 0;
		SNMP_FREE(StorageDel->mtpSdlEquipmentPointer);
		StorageDel->mtpSdlEquipmentPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdlStmChannel);
		StorageDel->mtpSdlStmChannelLen = 0;
		SNMP_FREE(StorageDel->mtpSdlVcTTpPointer);
		StorageDel->mtpSdlVcTTpPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdlSctpPointer);
		StorageDel->mtpSdlSctpPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdlName);
		StorageDel->mtpSdlNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdlTable_add(struct mtpSdlTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSdlTable table data set.
 *
 * Adds a table row structure to the mtpSdlTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSdlTable_add(struct mtpSdlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSdlId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdlId, thedata->mtpSdlIdLen);
	header_complex_add_data(&mtpSdlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdlTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdlTable_del(struct mtpSdlTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSdlTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSdlTable_del(struct mtpSdlTable_data *thedata)
{
	struct mtpSdlTable_data *StorageDel;

	DEBUGMSGTL(("mtpSdlTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSdlTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSdlTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSdlTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSdlTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSdlTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSdlTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSdlTable_data *StorageTmp = mtpSdlTable_create();

	DEBUGMSGTL(("mtpSdlTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdlId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlId, &StorageTmp->mtpSdlIdLen);
	if (StorageTmp->mtpSdlId == NULL) {
		config_perror("invalid specification for mtpSdlId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlType, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdlAdjPc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
	if (StorageTmp->mtpSdlAdjPc == NULL) {
		config_perror("invalid specification for mtpSdlAdjPc");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlLoopDelay, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdlEquipmentPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
	if (StorageTmp->mtpSdlEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdlEquipmentPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlCIC, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlTransmissionRate, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdlStmChannel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlStmChannel, &StorageTmp->mtpSdlStmChannelLen);
	if (StorageTmp->mtpSdlStmChannel == NULL) {
		config_perror("invalid specification for mtpSdlStmChannel");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdlVcTTpPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
	if (StorageTmp->mtpSdlVcTTpPointer == NULL) {
		config_perror("invalid specification for mtpSdlVcTTpPointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdlSctpPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlSctpPointer, &StorageTmp->mtpSdlSctpPointerLen);
	if (StorageTmp->mtpSdlSctpPointer == NULL) {
		config_perror("invalid specification for mtpSdlSctpPointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdlName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
	if (StorageTmp->mtpSdlName == NULL) {
		config_perror("invalid specification for mtpSdlName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlRowStatus, &tmpsize);
	mtpSdlTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
}

/*
 * store_mtpSdlTable(): store configuraiton file for mtpSdlTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSdlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdlTable", "storing data...  "));
	refresh_mtpSdlTable(1);
	(void) tmpsize;
	for (hcindex = mtpSdlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdlTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSdlTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlId, &StorageTmp->mtpSdlIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlLoopDelay, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlCIC, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlStmChannel, &StorageTmp->mtpSdlStmChannelLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlSctpPointer, &StorageTmp->mtpSdlSctpPointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSctpProfileTable_data *mtpSctpProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSctpProfileTable table.
 *
 * Creates a new mtpSctpProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSctpProfileTable_data *
mtpSctpProfileTable_create(void)
{
	struct mtpSctpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpProfileTable_data);

	DEBUGMSGTL(("mtpSctpProfileTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpProfileNoDelay = TV_TRUE;
		StorageNew->mtpSctpProfileMaxseg = 65536;
		StorageNew->mtpSctpProfileHeartbeatItvl = 60000;
		StorageNew->mtpSctpProfileHeartbeat = TV_TRUE;
		StorageNew->mtpSctpProfileRtoInitial = 3000;
		StorageNew->mtpSctpProfileRtoMin = 1000;
		StorageNew->mtpSctpProfileRtoMax = 60000;
		StorageNew->mtpSctpProfilePathMaxRetrans = 5;
		StorageNew->mtpSctpProfileCookieLife = 60000;
		StorageNew->mtpSctpProfileCookieInc = 1000;
		StorageNew->mtpSctpProfileMaxInitRetries = 8;
		StorageNew->mtpSctpProfileMaxBurst = 4;
		StorageNew->mtpSctpProfileAssocMaxRetrans = 10;
		StorageNew->mtpSctpProfileSackDelay = 200;
		StorageNew->mtpSctpProfileLifetime = 0;
		StorageNew->mtpSctpProfileMinOstreams = 2;
		StorageNew->mtpSctpProfileMaxIstreams = 4096;
		StorageNew->mtpSctpProfileRowStatus = 0;
		StorageNew->mtpSctpProfileRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSctpProfileTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSctpProfileTable_data *mtpSctpProfileTable_duplicate(struct mtpSctpProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSctpProfileTable_data *
mtpSctpProfileTable_duplicate(struct mtpSctpProfileTable_data *thedata)
{
	struct mtpSctpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpProfileTable_data);

	DEBUGMSGTL(("mtpSctpProfileTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSctpProfileTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSctpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSctpProfileTable_destroy(struct mtpSctpProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSctpProfileTable_destroy(struct mtpSctpProfileTable_data **thedata)
{
	struct mtpSctpProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSctpProfileTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSctpProfileId);
		StorageDel->mtpSctpProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSctpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpProfileTable_add(struct mtpSctpProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSctpProfileTable table data set.
 *
 * Adds a table row structure to the mtpSctpProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSctpProfileTable_add(struct mtpSctpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSctpProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSctpProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSctpProfileId, thedata->mtpSctpProfileIdLen);
	header_complex_add_data(&mtpSctpProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSctpProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSctpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpProfileTable_del(struct mtpSctpProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSctpProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSctpProfileTable_del(struct mtpSctpProfileTable_data *thedata)
{
	struct mtpSctpProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpSctpProfileTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSctpProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSctpProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSctpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSctpProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSctpProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSctpProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSctpProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSctpProfileTable_data *StorageTmp = mtpSctpProfileTable_create();

	DEBUGMSGTL(("mtpSctpProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSctpProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSctpProfileId, &StorageTmp->mtpSctpProfileIdLen);
	if (StorageTmp->mtpSctpProfileId == NULL) {
		config_perror("invalid specification for mtpSctpProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpProfileNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpProfileHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfilePathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpProfileMinOstreams, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpProfileMaxIstreams, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpProfileRowStatus, &tmpsize);
	mtpSctpProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSctpProfileTable", "done.\n"));
}

/*
 * store_mtpSctpProfileTable(): store configuraiton file for mtpSctpProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSctpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSctpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSctpProfileTable", "storing data...  "));
	refresh_mtpSctpProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpSctpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSctpProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSctpProfileTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSctpProfileId, &StorageTmp->mtpSctpProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpProfileNoDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileMaxseg, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileHeartbeatItvl, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpProfileHeartbeat, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileRtoInitial, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileRtoMin, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileRtoMax, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfilePathMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileCookieLife, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileCookieInc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileMaxInitRetries, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileMaxBurst, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileAssocMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileSackDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpProfileMinOstreams, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpProfileMaxIstreams, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSctpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSctpTable_data *mtpSctpTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSctpTable table.
 *
 * Creates a new mtpSctpTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSctpTable_data *
mtpSctpTable_create(void)
{
	struct mtpSctpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpTable_data);

	DEBUGMSGTL(("mtpSctpTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpAdministrativeState = MTPSCTPADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpSctpOperationalState = MTPSCTPOPERATIONALSTATE_DISABLED;
		StorageNew->mtpSctpUsageState = MTPSCTPUSAGESTATE_IDLE;
		if (memdup((u_char **) &StorageNew->mtpSctpProceduralStatus, (u_char *) "\x80", 1) == SNMPERR_SUCCESS)
			StorageNew->mtpSctpProceduralStatusLen = 1;
		StorageNew->mtpSctpLocalPort = 0;
		StorageNew->mtpSctpRemotePort = 0;
		StorageNew->mtpSctpProfile = (uint8_t *) strdup("");
		StorageNew->mtpSctpProfileLen = strlen("");
		StorageNew->mtpSctpProtocolPayloadId = 0;
		StorageNew->mtpSctpRowStatus = 0;
		StorageNew->mtpSctpRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSctpTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSctpTable_data *mtpSctpTable_duplicate(struct mtpSctpTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSctpTable_data *
mtpSctpTable_duplicate(struct mtpSctpTable_data *thedata)
{
	struct mtpSctpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpTable_data);

	DEBUGMSGTL(("mtpSctpTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSctpTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSctpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSctpTable_destroy(struct mtpSctpTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSctpTable_destroy(struct mtpSctpTable_data **thedata)
{
	struct mtpSctpTable_data *StorageDel;

	DEBUGMSGTL(("mtpSctpTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSctpProceduralStatus);
		StorageDel->mtpSctpProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSctpProfile);
		StorageDel->mtpSctpProfileLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSctpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpTable_add(struct mtpSctpTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSctpTable table data set.
 *
 * Adds a table row structure to the mtpSctpTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSctpTable_add(struct mtpSctpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSctpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSctpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
	header_complex_add_data(&mtpSctpTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSctpTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSctpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpTable_del(struct mtpSctpTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSctpTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSctpTable_del(struct mtpSctpTable_data *thedata)
{
	struct mtpSctpTable_data *StorageDel;

	DEBUGMSGTL(("mtpSctpTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSctpTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSctpTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSctpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSctpTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSctpTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSctpTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSctpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSctpTable_data *StorageTmp = mtpSctpTable_create();

	DEBUGMSGTL(("mtpSctpTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSctpProceduralStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSctpProceduralStatus, &StorageTmp->mtpSctpProceduralStatusLen);
	if (StorageTmp->mtpSctpProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSctpProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpLocalPort, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpRemotePort, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSctpProfile);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSctpProfile, &StorageTmp->mtpSctpProfileLen);
	if (StorageTmp->mtpSctpProfile == NULL) {
		config_perror("invalid specification for mtpSctpProfile");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProtocolPayloadId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpRowStatus, &tmpsize);
	mtpSctpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSctpTable", "done.\n"));
}

/*
 * store_mtpSctpTable(): store configuraiton file for mtpSctpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSctpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSctpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSctpTable", "storing data...  "));
	refresh_mtpSctpTable(1);
	(void) tmpsize;
	for (hcindex = mtpSctpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSctpTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSctpTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSctpProceduralStatus, &StorageTmp->mtpSctpProceduralStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpLocalPort, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpRemotePort, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSctpProfile, &StorageTmp->mtpSctpProfileLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProtocolPayloadId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSctpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSctpLocalTable_data *mtpSctpLocalTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSctpLocalTable table.
 *
 * Creates a new mtpSctpLocalTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSctpLocalTable_data *
mtpSctpLocalTable_create(void)
{
	struct mtpSctpLocalTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpLocalTable_data);

	DEBUGMSGTL(("mtpSctpLocalTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpSctpLocalAddress = (u_char *) "\x00\x00\x00\x00";
		StorageNew->mtpSctpLocalAddressLen = 4;
		StorageNew->mtpSctpLocalRowStatus = 0;
		StorageNew->mtpSctpLocalRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSctpLocalTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSctpLocalTable_data *mtpSctpLocalTable_duplicate(struct mtpSctpLocalTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSctpLocalTable_data *
mtpSctpLocalTable_duplicate(struct mtpSctpLocalTable_data *thedata)
{
	struct mtpSctpLocalTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpLocalTable_data);

	DEBUGMSGTL(("mtpSctpLocalTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSctpLocalTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSctpLocalTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSctpLocalTable_destroy(struct mtpSctpLocalTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSctpLocalTable_destroy(struct mtpSctpLocalTable_data **thedata)
{
	struct mtpSctpLocalTable_data *StorageDel;

	DEBUGMSGTL(("mtpSctpLocalTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSctpLocalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpLocalTable_add(struct mtpSctpLocalTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSctpLocalTable table data set.
 *
 * Adds a table row structure to the mtpSctpLocalTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSctpLocalTable_add(struct mtpSctpLocalTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSctpLocalTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSctpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
	/* mtpSctpLocalId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpLocalId, sizeof(thedata->mtpSctpLocalId));
	header_complex_add_data(&mtpSctpLocalTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSctpLocalTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSctpLocalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpLocalTable_del(struct mtpSctpLocalTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSctpLocalTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSctpLocalTable_del(struct mtpSctpLocalTable_data *thedata)
{
	struct mtpSctpLocalTable_data *StorageDel;

	DEBUGMSGTL(("mtpSctpLocalTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSctpLocalTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSctpLocalTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSctpLocalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSctpLocalTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSctpLocalTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSctpLocalTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSctpLocalTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSctpLocalTable_data *StorageTmp = mtpSctpLocalTable_create();

	DEBUGMSGTL(("mtpSctpLocalTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpLocalId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSctpLocalAddress);
	line = read_config_read_data(ASN_IPADDRESS, line, &StorageTmp->mtpSctpLocalAddress, &StorageTmp->mtpSctpLocalAddressLen);
	if (StorageTmp->mtpSctpLocalAddress == NULL) {
		config_perror("invalid specification for mtpSctpLocalAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpLocalRowStatus, &tmpsize);
	mtpSctpLocalTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSctpLocalTable", "done.\n"));
}

/*
 * store_mtpSctpLocalTable(): store configuraiton file for mtpSctpLocalTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSctpLocalTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSctpLocalTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSctpLocalTable", "storing data...  "));
	refresh_mtpSctpLocalTable(1);
	(void) tmpsize;
	for (hcindex = mtpSctpLocalTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSctpLocalTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSctpLocalTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpLocalId, &tmpsize);
			cptr = read_config_store_data(ASN_IPADDRESS, cptr, &StorageTmp->mtpSctpLocalAddress, &StorageTmp->mtpSctpLocalAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpLocalRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSctpLocalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSctpRemoteTable_data *mtpSctpRemoteTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSctpRemoteTable table.
 *
 * Creates a new mtpSctpRemoteTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSctpRemoteTable_data *
mtpSctpRemoteTable_create(void)
{
	struct mtpSctpRemoteTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpRemoteTable_data);

	DEBUGMSGTL(("mtpSctpRemoteTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpSctpRemoteAddress = (u_char *) "\x00\x00\x00\x00";
		StorageNew->mtpSctpRemoteAddressLen = 4;
		StorageNew->mtpSctpRemoteRowStatus = 0;
		StorageNew->mtpSctpRemoteRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpSctpRemoteTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpSctpRemoteTable_data *mtpSctpRemoteTable_duplicate(struct mtpSctpRemoteTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSctpRemoteTable_data *
mtpSctpRemoteTable_duplicate(struct mtpSctpRemoteTable_data *thedata)
{
	struct mtpSctpRemoteTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpRemoteTable_data);

	DEBUGMSGTL(("mtpSctpRemoteTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpSctpRemoteTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSctpRemoteTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSctpRemoteTable_destroy(struct mtpSctpRemoteTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSctpRemoteTable_destroy(struct mtpSctpRemoteTable_data **thedata)
{
	struct mtpSctpRemoteTable_data *StorageDel;

	DEBUGMSGTL(("mtpSctpRemoteTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpSctpRemoteTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpRemoteTable_add(struct mtpSctpRemoteTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSctpRemoteTable table data set.
 *
 * Adds a table row structure to the mtpSctpRemoteTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSctpRemoteTable_add(struct mtpSctpRemoteTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSctpRemoteTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSctpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
	/* mtpSctpRemoteId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpRemoteId, sizeof(thedata->mtpSctpRemoteId));
	header_complex_add_data(&mtpSctpRemoteTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSctpRemoteTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSctpRemoteTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpRemoteTable_del(struct mtpSctpRemoteTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSctpRemoteTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSctpRemoteTable_del(struct mtpSctpRemoteTable_data *thedata)
{
	struct mtpSctpRemoteTable_data *StorageDel;

	DEBUGMSGTL(("mtpSctpRemoteTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSctpRemoteTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSctpRemoteTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpSctpRemoteTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSctpRemoteTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSctpRemoteTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSctpRemoteTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSctpRemoteTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSctpRemoteTable_data *StorageTmp = mtpSctpRemoteTable_create();

	DEBUGMSGTL(("mtpSctpRemoteTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpRemoteId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSctpRemoteAddress);
	line = read_config_read_data(ASN_IPADDRESS, line, &StorageTmp->mtpSctpRemoteAddress, &StorageTmp->mtpSctpRemoteAddressLen);
	if (StorageTmp->mtpSctpRemoteAddress == NULL) {
		config_perror("invalid specification for mtpSctpRemoteAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpRemoteRowStatus, &tmpsize);
	mtpSctpRemoteTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSctpRemoteTable", "done.\n"));
}

/*
 * store_mtpSctpRemoteTable(): store configuraiton file for mtpSctpRemoteTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSctpRemoteTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSctpRemoteTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSctpRemoteTable", "storing data...  "));
	refresh_mtpSctpRemoteTable(1);
	(void) tmpsize;
	for (hcindex = mtpSctpRemoteTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSctpRemoteTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSctpRemoteTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpRemoteId, &tmpsize);
			cptr = read_config_store_data(ASN_IPADDRESS, cptr, &StorageTmp->mtpSctpRemoteAddress, &StorageTmp->mtpSctpRemoteAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpRemoteRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpSctpRemoteTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpM2uaAspTable_data *mtpM2uaAspTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpM2uaAspTable table.
 *
 * Creates a new mtpM2uaAspTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpM2uaAspTable_data *
mtpM2uaAspTable_create(void)
{
	struct mtpM2uaAspTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2uaAspTable_data);

	DEBUGMSGTL(("mtpM2uaAspTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpM2uaAspState = MTPM2UAASPSTATE_DOWN;
		StorageNew->mtpM2uaAspId = 0;
		if (memdup((u_char **) &StorageNew->mtpM2uaAspCapabilities, (u_char *) "\x00\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->mtpM2uaAspCapabilitiesLen = 2;
		{
			static oid tmpoid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 10, 2, 1 };
			if ((StorageNew->mtpM2uaAspSgVersion = snmp_duplicate_objid(tmpoid, 11)))
				StorageNew->mtpM2uaAspSgVersionLen = 11;
		}
		if (memdup((u_char **) &StorageNew->mtpM2uaAspSgOptions, (u_char *) "\x00\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->mtpM2uaAspSgOptionsLen = 2;
		StorageNew->mtpM2uaAspSgRegistrationPolicy = 0;
		StorageNew->mtpM2uaAspSgAspIdPolicy = MTPM2UAASPSGASPIDPOLICY_UNKNOWN;
		StorageNew->mtpM2uaAspAssociationPolicy = MTPM2UAASPASSOCIATIONPOLICY_UNKNOWN;
		StorageNew->mtpM2uaAspProtocolPayloadId = 0;
		StorageNew->mtpM2uaAspRowStatus = 0;
		StorageNew->mtpM2uaAspRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpM2uaAspTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpM2uaAspTable_data *mtpM2uaAspTable_duplicate(struct mtpM2uaAspTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpM2uaAspTable_data *
mtpM2uaAspTable_duplicate(struct mtpM2uaAspTable_data *thedata)
{
	struct mtpM2uaAspTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2uaAspTable_data);

	DEBUGMSGTL(("mtpM2uaAspTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpM2uaAspTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpM2uaAspTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpM2uaAspTable_destroy(struct mtpM2uaAspTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpM2uaAspTable_destroy(struct mtpM2uaAspTable_data **thedata)
{
	struct mtpM2uaAspTable_data *StorageDel;

	DEBUGMSGTL(("mtpM2uaAspTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpM2uaAspCapabilities);
		StorageDel->mtpM2uaAspCapabilitiesLen = 0;
		SNMP_FREE(StorageDel->mtpM2uaAspSgVersion);
		StorageDel->mtpM2uaAspSgVersionLen = 0;
		SNMP_FREE(StorageDel->mtpM2uaAspSgOptions);
		StorageDel->mtpM2uaAspSgOptionsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpM2uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2uaAspTable_add(struct mtpM2uaAspTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpM2uaAspTable table data set.
 *
 * Adds a table row structure to the mtpM2uaAspTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpM2uaAspTable_add(struct mtpM2uaAspTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpM2uaAspTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSctpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
	header_complex_add_data(&mtpM2uaAspTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpM2uaAspTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpM2uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2uaAspTable_del(struct mtpM2uaAspTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpM2uaAspTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpM2uaAspTable_del(struct mtpM2uaAspTable_data *thedata)
{
	struct mtpM2uaAspTable_data *StorageDel;

	DEBUGMSGTL(("mtpM2uaAspTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpM2uaAspTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpM2uaAspTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpM2uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpM2uaAspTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpM2uaAspTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpM2uaAspTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpM2uaAspTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM2uaAspTable_data *StorageTmp = mtpM2uaAspTable_create();

	DEBUGMSGTL(("mtpM2uaAspTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2uaAspId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpM2uaAspCapabilities);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpM2uaAspCapabilities, &StorageTmp->mtpM2uaAspCapabilitiesLen);
	if (StorageTmp->mtpM2uaAspCapabilities == NULL) {
		config_perror("invalid specification for mtpM2uaAspCapabilities");
		return;
	}
	SNMP_FREE(StorageTmp->mtpM2uaAspSgVersion);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpM2uaAspSgVersion, &StorageTmp->mtpM2uaAspSgVersionLen);
	if (StorageTmp->mtpM2uaAspSgVersion == NULL) {
		config_perror("invalid specification for mtpM2uaAspSgVersion");
		return;
	}
	SNMP_FREE(StorageTmp->mtpM2uaAspSgOptions);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpM2uaAspSgOptions, &StorageTmp->mtpM2uaAspSgOptionsLen);
	if (StorageTmp->mtpM2uaAspSgOptions == NULL) {
		config_perror("invalid specification for mtpM2uaAspSgOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspSgRegistrationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspSgAspIdPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspAssociationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspProtocolPayloadId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspRowStatus, &tmpsize);
	mtpM2uaAspTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpM2uaAspTable", "done.\n"));
}

/*
 * store_mtpM2uaAspTable(): store configuraiton file for mtpM2uaAspTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM2uaAspTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM2uaAspTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpM2uaAspTable", "storing data...  "));
	refresh_mtpM2uaAspTable(1);
	(void) tmpsize;
	for (hcindex = mtpM2uaAspTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM2uaAspTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM2uaAspTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2uaAspId, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpM2uaAspCapabilities, &StorageTmp->mtpM2uaAspCapabilitiesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpM2uaAspSgVersion, &StorageTmp->mtpM2uaAspSgVersionLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpM2uaAspSgOptions, &StorageTmp->mtpM2uaAspSgOptionsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspSgRegistrationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspSgAspIdPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspAssociationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspProtocolPayloadId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpM2uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpM2uaAsTable_data *mtpM2uaAsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpM2uaAsTable table.
 *
 * Creates a new mtpM2uaAsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpM2uaAsTable_data *
mtpM2uaAsTable_create(void)
{
	struct mtpM2uaAsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2uaAsTable_data);

	DEBUGMSGTL(("mtpM2uaAsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpM3uaAsId = 0;
		StorageNew->mtpM2uaAsId = 0;
		StorageNew->mtpM2uaAsState = MTPM2UAASSTATE_DOWN;
		StorageNew->mtpM2uaAsInterfaceIdentifier = 0;
		if ((StorageNew->mtpM2uaInterfaceIdentifierText = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpM2uaInterfaceIdentifierTextLen = strlen("");
		StorageNew->mtpM2uaAsSDTI = 0;
		/* StorageNew->mtpM2uaAsTrafficMode = NULL; *//* DEFVAL OPENSS7-SIGTRAN-TC : activeStandby */
		/* StorageNew->mtpM2uaAsTrafficMode = 0; *//* DEFVAL OPENSS7-SIGTRAN-TC : activeStandby */
		StorageNew->mtpM2uaAsRowStatus = 0;
		StorageNew->mtpM2uaAsRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpM2uaAsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpM2uaAsTable_data *mtpM2uaAsTable_duplicate(struct mtpM2uaAsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpM2uaAsTable_data *
mtpM2uaAsTable_duplicate(struct mtpM2uaAsTable_data *thedata)
{
	struct mtpM2uaAsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2uaAsTable_data);

	DEBUGMSGTL(("mtpM2uaAsTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpM2uaAsTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpM2uaAsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpM2uaAsTable_destroy(struct mtpM2uaAsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpM2uaAsTable_destroy(struct mtpM2uaAsTable_data **thedata)
{
	struct mtpM2uaAsTable_data *StorageDel;

	DEBUGMSGTL(("mtpM2uaAsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpM2uaInterfaceIdentifierText);
		StorageDel->mtpM2uaInterfaceIdentifierTextLen = 0;
		SNMP_FREE(StorageDel->mtpM2uaAsTrafficMode);
		StorageDel->mtpM2uaAsTrafficModeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpM2uaAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2uaAsTable_add(struct mtpM2uaAsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpM2uaAsTable table data set.
 *
 * Adds a table row structure to the mtpM2uaAsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpM2uaAsTable_add(struct mtpM2uaAsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpM2uaAsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSctpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
	/* mtpM3uaAsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpM3uaAsId, sizeof(thedata->mtpM3uaAsId));
	header_complex_add_data(&mtpM2uaAsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpM2uaAsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpM2uaAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2uaAsTable_del(struct mtpM2uaAsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpM2uaAsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpM2uaAsTable_del(struct mtpM2uaAsTable_data *thedata)
{
	struct mtpM2uaAsTable_data *StorageDel;

	DEBUGMSGTL(("mtpM2uaAsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpM2uaAsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpM2uaAsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpM2uaAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpM2uaAsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpM2uaAsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpM2uaAsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpM2uaAsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM2uaAsTable_data *StorageTmp = mtpM2uaAsTable_create();

	DEBUGMSGTL(("mtpM2uaAsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM3uaAsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2uaAsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAsState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAsInterfaceIdentifier, &tmpsize);
	SNMP_FREE(StorageTmp->mtpM2uaInterfaceIdentifierText);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpM2uaInterfaceIdentifierText, &StorageTmp->mtpM2uaInterfaceIdentifierTextLen);
	if (StorageTmp->mtpM2uaInterfaceIdentifierText == NULL) {
		config_perror("invalid specification for mtpM2uaInterfaceIdentifierText");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAsSDTI, &tmpsize);
	SNMP_FREE(StorageTmp->mtpM2uaAsTrafficMode);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpM2uaAsTrafficMode, &StorageTmp->mtpM2uaAsTrafficModeLen);
	if (StorageTmp->mtpM2uaAsTrafficMode == NULL) {
		config_perror("invalid specification for mtpM2uaAsTrafficMode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAsRowStatus, &tmpsize);
	mtpM2uaAsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpM2uaAsTable", "done.\n"));
}

/*
 * store_mtpM2uaAsTable(): store configuraiton file for mtpM2uaAsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM2uaAsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM2uaAsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpM2uaAsTable", "storing data...  "));
	refresh_mtpM2uaAsTable(1);
	(void) tmpsize;
	for (hcindex = mtpM2uaAsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM2uaAsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM2uaAsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM3uaAsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2uaAsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAsState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAsInterfaceIdentifier, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpM2uaInterfaceIdentifierText, &StorageTmp->mtpM2uaInterfaceIdentifierTextLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAsSDTI, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpM2uaAsTrafficMode, &StorageTmp->mtpM2uaAsTrafficModeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpM2uaAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpM3uaAspTable_data *mtpM3uaAspTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpM3uaAspTable table.
 *
 * Creates a new mtpM3uaAspTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpM3uaAspTable_data *
mtpM3uaAspTable_create(void)
{
	struct mtpM3uaAspTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM3uaAspTable_data);

	DEBUGMSGTL(("mtpM3uaAspTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpM3uaAspState = 0;
		StorageNew->mtpM3uaAsType = MTPM3UAASTYPE_IPSP;
		StorageNew->mtpM3uaAspId = 0;
		if (memdup((u_char **) &StorageNew->mtpM3uaAspCapabilities, (u_char *) "\x00\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->mtpM3uaAspCapabilitiesLen = 2;
		{
			static oid tmpoid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 10, 2, 1 };
			if ((StorageNew->mtpM3uaAspSgVersion = snmp_duplicate_objid(tmpoid, 11)))
				StorageNew->mtpM3uaAspSgVersionLen = 11;
		}
		if (memdup((u_char **) &StorageNew->mtpM3uaAspSgOptions, (u_char *) "\x00\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->mtpM3uaAspSgOptionsLen = 2;
		StorageNew->mtpM3uaAspSgRegistrationPolicy = 0;
		StorageNew->mtpM3uaAspSgAspIdPolicy = MTPM3UAASPSGASPIDPOLICY_UNKNOWN;
		StorageNew->mtpM3uaAspAssociationPolicy = MTPM3UAASPASSOCIATIONPOLICY_UNKNOWN;
		StorageNew->mtpM3uaAspProtocolPayloadId = 0;
		StorageNew->mtpM3uaAspRowStatus = 0;
		StorageNew->mtpM3uaAspRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpM3uaAspTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpM3uaAspTable_data *mtpM3uaAspTable_duplicate(struct mtpM3uaAspTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpM3uaAspTable_data *
mtpM3uaAspTable_duplicate(struct mtpM3uaAspTable_data *thedata)
{
	struct mtpM3uaAspTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM3uaAspTable_data);

	DEBUGMSGTL(("mtpM3uaAspTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpM3uaAspTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpM3uaAspTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpM3uaAspTable_destroy(struct mtpM3uaAspTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpM3uaAspTable_destroy(struct mtpM3uaAspTable_data **thedata)
{
	struct mtpM3uaAspTable_data *StorageDel;

	DEBUGMSGTL(("mtpM3uaAspTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpM3uaAspCapabilities);
		StorageDel->mtpM3uaAspCapabilitiesLen = 0;
		SNMP_FREE(StorageDel->mtpM3uaAspSgVersion);
		StorageDel->mtpM3uaAspSgVersionLen = 0;
		SNMP_FREE(StorageDel->mtpM3uaAspSgOptions);
		StorageDel->mtpM3uaAspSgOptionsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpM3uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM3uaAspTable_add(struct mtpM3uaAspTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpM3uaAspTable table data set.
 *
 * Adds a table row structure to the mtpM3uaAspTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpM3uaAspTable_add(struct mtpM3uaAspTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpM3uaAspTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSctpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
	header_complex_add_data(&mtpM3uaAspTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpM3uaAspTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpM3uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM3uaAspTable_del(struct mtpM3uaAspTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpM3uaAspTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpM3uaAspTable_del(struct mtpM3uaAspTable_data *thedata)
{
	struct mtpM3uaAspTable_data *StorageDel;

	DEBUGMSGTL(("mtpM3uaAspTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpM3uaAspTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpM3uaAspTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpM3uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpM3uaAspTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpM3uaAspTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpM3uaAspTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpM3uaAspTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM3uaAspTable_data *StorageTmp = mtpM3uaAspTable_create();

	DEBUGMSGTL(("mtpM3uaAspTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAsType, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM3uaAspId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpM3uaAspCapabilities);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpM3uaAspCapabilities, &StorageTmp->mtpM3uaAspCapabilitiesLen);
	if (StorageTmp->mtpM3uaAspCapabilities == NULL) {
		config_perror("invalid specification for mtpM3uaAspCapabilities");
		return;
	}
	SNMP_FREE(StorageTmp->mtpM3uaAspSgVersion);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpM3uaAspSgVersion, &StorageTmp->mtpM3uaAspSgVersionLen);
	if (StorageTmp->mtpM3uaAspSgVersion == NULL) {
		config_perror("invalid specification for mtpM3uaAspSgVersion");
		return;
	}
	SNMP_FREE(StorageTmp->mtpM3uaAspSgOptions);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpM3uaAspSgOptions, &StorageTmp->mtpM3uaAspSgOptionsLen);
	if (StorageTmp->mtpM3uaAspSgOptions == NULL) {
		config_perror("invalid specification for mtpM3uaAspSgOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspSgRegistrationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspSgAspIdPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspAssociationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspProtocolPayloadId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspRowStatus, &tmpsize);
	mtpM3uaAspTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpM3uaAspTable", "done.\n"));
}

/*
 * store_mtpM3uaAspTable(): store configuraiton file for mtpM3uaAspTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM3uaAspTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM3uaAspTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpM3uaAspTable", "storing data...  "));
	refresh_mtpM3uaAspTable(1);
	(void) tmpsize;
	for (hcindex = mtpM3uaAspTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM3uaAspTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM3uaAspTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAsType, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM3uaAspId, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpM3uaAspCapabilities, &StorageTmp->mtpM3uaAspCapabilitiesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpM3uaAspSgVersion, &StorageTmp->mtpM3uaAspSgVersionLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpM3uaAspSgOptions, &StorageTmp->mtpM3uaAspSgOptionsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspSgRegistrationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspSgAspIdPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspAssociationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspProtocolPayloadId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpM3uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpM3uaAsTable_data *mtpM3uaAsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpM3uaAsTable table.
 *
 * Creates a new mtpM3uaAsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpM3uaAsTable_data *
mtpM3uaAsTable_create(void)
{
	struct mtpM3uaAsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM3uaAsTable_data);

	DEBUGMSGTL(("mtpM3uaAsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpM3uaAsState = MTPM3UAASSTATE_DOWN;
		StorageNew->mtpM3uaAsRoutingContext = 0;
		StorageNew->mtpM3uaAsNetworkAppearance = 0;
		if ((StorageNew->mtpM3uaAsNetworkPointCode = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpM3uaAsNetworkPointCodeLen = strlen("");
		if ((StorageNew->mtpM3uaAsTrafficMode = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpM3uaAsTrafficModeLen = 2;
		StorageNew->mtpM3uaAsRowStatus = 0;
		StorageNew->mtpM3uaAsRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpM3uaAsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpM3uaAsTable_data *mtpM3uaAsTable_duplicate(struct mtpM3uaAsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpM3uaAsTable_data *
mtpM3uaAsTable_duplicate(struct mtpM3uaAsTable_data *thedata)
{
	struct mtpM3uaAsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM3uaAsTable_data);

	DEBUGMSGTL(("mtpM3uaAsTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpM3uaAsTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpM3uaAsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpM3uaAsTable_destroy(struct mtpM3uaAsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpM3uaAsTable_destroy(struct mtpM3uaAsTable_data **thedata)
{
	struct mtpM3uaAsTable_data *StorageDel;

	DEBUGMSGTL(("mtpM3uaAsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpM3uaAsNetworkPointCode);
		StorageDel->mtpM3uaAsNetworkPointCodeLen = 0;
		SNMP_FREE(StorageDel->mtpM3uaAsTrafficMode);
		StorageDel->mtpM3uaAsTrafficModeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpM3uaAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM3uaAsTable_add(struct mtpM3uaAsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpM3uaAsTable table data set.
 *
 * Adds a table row structure to the mtpM3uaAsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpM3uaAsTable_add(struct mtpM3uaAsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpM3uaAsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* mtpSctpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
	/* mtpM3uaAsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpM3uaAsId, sizeof(thedata->mtpM3uaAsId));
	header_complex_add_data(&mtpM3uaAsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpM3uaAsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpM3uaAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM3uaAsTable_del(struct mtpM3uaAsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpM3uaAsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpM3uaAsTable_del(struct mtpM3uaAsTable_data *thedata)
{
	struct mtpM3uaAsTable_data *StorageDel;

	DEBUGMSGTL(("mtpM3uaAsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpM3uaAsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpM3uaAsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpM3uaAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpM3uaAsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpM3uaAsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpM3uaAsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpM3uaAsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM3uaAsTable_data *StorageTmp = mtpM3uaAsTable_create();

	DEBUGMSGTL(("mtpM3uaAsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM3uaAsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAsState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM3uaAsRoutingContext, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM3uaAsNetworkAppearance, &tmpsize);
	SNMP_FREE(StorageTmp->mtpM3uaAsNetworkPointCode);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpM3uaAsNetworkPointCode, &StorageTmp->mtpM3uaAsNetworkPointCodeLen);
	if (StorageTmp->mtpM3uaAsNetworkPointCode == NULL) {
		config_perror("invalid specification for mtpM3uaAsNetworkPointCode");
		return;
	}
	SNMP_FREE(StorageTmp->mtpM3uaAsTrafficMode);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpM3uaAsTrafficMode, &StorageTmp->mtpM3uaAsTrafficModeLen);
	if (StorageTmp->mtpM3uaAsTrafficMode == NULL) {
		config_perror("invalid specification for mtpM3uaAsTrafficMode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAsRowStatus, &tmpsize);
	mtpM3uaAsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpM3uaAsTable", "done.\n"));
}

/*
 * store_mtpM3uaAsTable(): store configuraiton file for mtpM3uaAsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM3uaAsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM3uaAsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpM3uaAsTable", "storing data...  "));
	refresh_mtpM3uaAsTable(1);
	(void) tmpsize;
	for (hcindex = mtpM3uaAsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM3uaAsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM3uaAsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM3uaAsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAsState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM3uaAsRoutingContext, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM3uaAsNetworkAppearance, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpM3uaAsNetworkPointCode, &StorageTmp->mtpM3uaAsNetworkPointCodeLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpM3uaAsTrafficMode, &StorageTmp->mtpM3uaAsTrafficModeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpM3uaAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_mtpSapTable_row(struct mtpSapTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSapTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSapTable_row(struct mtpSapTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSapTable_request == sa_request))
		return;
	StorageTmp->mtpSapTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSapTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSapTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSapTable(int force)
{
	if (!force && mtpSapTable_refresh == 0)
		return;
	mtpSapTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSapTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSapTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSapTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSapTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSapTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSapTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSAP2ADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSap2Address);
		rval = (u_char *) &StorageTmp->mtpSap2Address;
		break;
	case (u_char) MTPSAPUSERPART:	/* Create */
		*write_method = write_mtpSapUserPart;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSapUserPart);
		rval = (u_char *) &StorageTmp->mtpSapUserPart;
		break;
	case (u_char) MTPSAPUSERPARTSTATUS:	/* Create */
		*write_method = write_mtpSapUserPartStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSapUserPartStatus);
		rval = (u_char *) &StorageTmp->mtpSapUserPartStatus;
		break;
	case (u_char) MTPSAPUSERENTITYNAMES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSapUserEntityNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSapUserEntityNames;
		break;
	case (u_char) MTPSAPPROVIDERENTITYNAMES:	/* Create */
		*write_method = write_mtpSapProviderEntityNames;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSapProviderEntityNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSapProviderEntityNames;
		break;
	case (u_char) MTPSAPUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSapUsageState);
		rval = (u_char *) &StorageTmp->mtpSapUsageState;
		break;
	case (u_char) MTPSAPASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpSapAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSapAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSapAsaProfilePointer;
		break;
	case (u_char) MTPSAPNAME:	/* Create */
		*write_method = write_mtpSapName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSapNameLen;
		rval = (u_char *) StorageTmp->mtpSapName;
		break;
	case (u_char) MTPSAPLONGMESSAGESUPPORTED:	/* Create */
		*write_method = write_mtpSapLongMessageSupported;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSapLongMessageSupported);
		rval = (u_char *) &StorageTmp->mtpSapLongMessageSupported;
		break;
	case (u_char) MTPSAPROWSTATUS:	/* Create */
		*write_method = write_mtpSapRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSapRowStatus);
		rval = (u_char *) &StorageTmp->mtpSapRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpNaTable_row(struct mtpNaTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpNaTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpNaTable_row(struct mtpNaTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpNaTable_request == sa_request))
		return;
	StorageTmp->mtpNaTable_request = sa_request;
}

/**
 * @fn void refresh_mtpNaTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpNaTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpNaTable(int force)
{
	if (!force && mtpNaTable_refresh == 0)
		return;
	mtpNaTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpNaTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpNaTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpNaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpNaTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpNaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpNaTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpNaTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpNaTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPNAPROTOCOLVARIANT:	/* Create */
		*write_method = write_mtpNaProtocolVariant;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpNaProtocolVariantLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpNaProtocolVariant;
		break;
	case (u_char) MTPNAPROTOCOLYEAR:	/* Create */
		*write_method = write_mtpNaProtocolYear;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNaProtocolYear);
		rval = (u_char *) &StorageTmp->mtpNaProtocolYear;
		break;
	case (u_char) MTPNAPROTOCOLOPTIONS:	/* Create */
		*write_method = write_mtpNaProtocolOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpNaProtocolOptionsLen;
		rval = (u_char *) StorageTmp->mtpNaProtocolOptions;
		break;
	case (u_char) MTPNANETWORKINDICATOR:	/* Create */
		*write_method = write_mtpNaNetworkIndicator;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNaNetworkIndicator);
		rval = (u_char *) &StorageTmp->mtpNaNetworkIndicator;
		break;
	case (u_char) MTPNAPOINTCODEFORMAT:	/* Create */
		*write_method = write_mtpNaPointCodeFormat;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpNaPointCodeFormatLen;
		rval = (u_char *) StorageTmp->mtpNaPointCodeFormat;
		break;
	case (u_char) MTPNASLSLENGTH:	/* Create */
		*write_method = write_mtpNaSlsLength;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNaSlsLength);
		rval = (u_char *) &StorageTmp->mtpNaSlsLength;
		break;
	case (u_char) MTPNASPDEFAULT:	/* Create */
		*write_method = write_mtpNaSpDefault;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpNaSpDefaultLen;
		rval = (u_char *) StorageTmp->mtpNaSpDefault;
		break;
	case (u_char) MTPNANAME:	/* Create */
		*write_method = write_mtpNaName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpNaNameLen;
		rval = (u_char *) StorageTmp->mtpNaName;
		break;
	case (u_char) MTPNAROWSTATUS:	/* Create */
		*write_method = write_mtpNaRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNaRowStatus);
		rval = (u_char *) &StorageTmp->mtpNaRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpMsTable_row(struct mtpMsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpMsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpMsTable_row(struct mtpMsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpMsTable_request == sa_request))
		return;
	StorageTmp->mtpMsTable_request = sa_request;
}

/**
 * @fn void refresh_mtpMsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpMsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpMsTable(int force)
{
	if (!force && mtpMsTable_refresh == 0)
		return;
	mtpMsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpMsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpMsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpMsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpMsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpMsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpMsTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpMsTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPMSNAME:	/* Create */
		*write_method = write_mtpMsName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsNameLen;
		rval = (u_char *) StorageTmp->mtpMsName;
		break;
	case (u_char) MTPMSALARMSTATUS:	/* Create */
		*write_method = write_mtpMsAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsAlarmStatusLen;
		rval = (u_char *) StorageTmp->mtpMsAlarmStatus;
		break;
	case (u_char) MTPMSOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpMsOperationalState);
		rval = (u_char *) &StorageTmp->mtpMsOperationalState;
		break;
	case (u_char) MTPMSUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpMsUsageState);
		rval = (u_char *) &StorageTmp->mtpMsUsageState;
		break;
	case (u_char) MTPMSMANAGEDELEMENTTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsManagedElementTypeLen;
		rval = (u_char *) StorageTmp->mtpMsManagedElementType;
		break;
	case (u_char) MTPMSMODELCODE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsModelCodeLen;
		rval = (u_char *) StorageTmp->mtpMsModelCode;
		break;
	case (u_char) MTPMSVENDORNAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsVendorNameLen;
		rval = (u_char *) StorageTmp->mtpMsVendorName;
		break;
	case (u_char) MTPMSUSERLABEL:	/* Create */
		*write_method = write_mtpMsUserLabel;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsUserLabelLen;
		rval = (u_char *) StorageTmp->mtpMsUserLabel;
		break;
	case (u_char) MTPMSVERSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsVersionLen;
		rval = (u_char *) StorageTmp->mtpMsVersion;
		break;
	case (u_char) MTPMSASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpMsAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpMsAsaProfilePointer;
		break;
	case (u_char) MTPMSNETWORKELEMENTALIASES:	/* Create */
		*write_method = write_mtpMsNetworkElementAliases;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsNetworkElementAliasesLen;
		rval = (u_char *) StorageTmp->mtpMsNetworkElementAliases;
		break;
	case (u_char) MTPMSROWSTATUS:	/* Create */
		*write_method = write_mtpMsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpMsRowStatus);
		rval = (u_char *) &StorageTmp->mtpMsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSpProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSpProfileTable_request == sa_request))
		return;
	StorageTmp->mtpSpProfileTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSpProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSpProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSpProfileTable(int force)
{
	if (!force && mtpSpProfileTable_refresh == 0)
		return;
	mtpSpProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSpProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSpProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSpProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSpProfileTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSpProfileTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSPPROFILETIMERT1R:	/* Create */
		*write_method = write_mtpSpProfileTimerT1R;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT1R);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT1R;
		break;
	case (u_char) MTPSPPROFILETIMERT2:	/* Create */
		*write_method = write_mtpSpProfileTimerT2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT2);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT2;
		break;
	case (u_char) MTPSPPROFILETIMERT4:	/* Create */
		*write_method = write_mtpSpProfileTimerT4;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT4);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT4;
		break;
	case (u_char) MTPSPPROFILETIMERT5:	/* Create */
		*write_method = write_mtpSpProfileTimerT5;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT5);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT5;
		break;
	case (u_char) MTPSPPROFILETIMERT7:	/* Create */
		*write_method = write_mtpSpProfileTimerT7;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT7);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT7;
		break;
	case (u_char) MTPSPPROFILETIMERT11:	/* Create */
		*write_method = write_mtpSpProfileTimerT11;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT11);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT11;
		break;
	case (u_char) MTPSPPROFILETIMERT12:	/* Create */
		*write_method = write_mtpSpProfileTimerT12;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT12);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT12;
		break;
	case (u_char) MTPSPPROFILETIMERT13:	/* Create */
		*write_method = write_mtpSpProfileTimerT13;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT13);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT13;
		break;
	case (u_char) MTPSPPROFILETIMERT14:	/* Create */
		*write_method = write_mtpSpProfileTimerT14;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT14);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT14;
		break;
	case (u_char) MTPSPPROFILETIMERT15:	/* Create */
		*write_method = write_mtpSpProfileTimerT15;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT15);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT15;
		break;
	case (u_char) MTPSPPROFILETIMERT16:	/* Create */
		*write_method = write_mtpSpProfileTimerT16;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT16);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT16;
		break;
	case (u_char) MTPSPPROFILETIMERT18I:	/* Create */
		*write_method = write_mtpSpProfileTimerT18I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT18I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT18I;
		break;
	case (u_char) MTPSPPROFILETIMERT19I:	/* Create */
		*write_method = write_mtpSpProfileTimerT19I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT19I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT19I;
		break;
	case (u_char) MTPSPPROFILETIMERT20I:	/* Create */
		*write_method = write_mtpSpProfileTimerT20I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT20I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT20I;
		break;
	case (u_char) MTPSPPROFILETIMERT21I:	/* Create */
		*write_method = write_mtpSpProfileTimerT21I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT21I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT21I;
		break;
	case (u_char) MTPSPPROFILETIMERT22I:	/* Create */
		*write_method = write_mtpSpProfileTimerT22I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT22I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT22I;
		break;
	case (u_char) MTPSPPROFILETIMERT23I:	/* Create */
		*write_method = write_mtpSpProfileTimerT23I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT23I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT23I;
		break;
	case (u_char) MTPSPPROFILETIMERT20A:	/* Create */
		*write_method = write_mtpSpProfileTimerT20A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT20A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT20A;
		break;
	case (u_char) MTPSPPROFILETIMERT21A:	/* Create */
		*write_method = write_mtpSpProfileTimerT21A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT21A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT21A;
		break;
	case (u_char) MTPSPPROFILETIMERT22A:	/* Create */
		*write_method = write_mtpSpProfileTimerT22A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT22A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT22A;
		break;
	case (u_char) MTPSPPROFILETIMERT23A:	/* Create */
		*write_method = write_mtpSpProfileTimerT23A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT23A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT23A;
		break;
	case (u_char) MTPSPPROFILETIMERT24A:	/* Create */
		*write_method = write_mtpSpProfileTimerT24A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT24A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT24A;
		break;
	case (u_char) MTPSPPROFILETIMERT26A:	/* Create */
		*write_method = write_mtpSpProfileTimerT26A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT26A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT26A;
		break;
	case (u_char) MTPSPPROFILETIMERT27A:	/* Create */
		*write_method = write_mtpSpProfileTimerT27A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT27A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT27A;
		break;
	case (u_char) MTPSPPROFILETIMERT1T:	/* Create */
		*write_method = write_mtpSpProfileTimerT1T;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT1T);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT1T;
		break;
	case (u_char) MTPSPPROFILETIMERT2T:	/* Create */
		*write_method = write_mtpSpProfileTimerT2T;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT2T);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT2T;
		break;
	case (u_char) MTPSPPROFILENAME:	/* Create */
		*write_method = write_mtpSpProfileName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpProfileNameLen;
		rval = (u_char *) StorageTmp->mtpSpProfileName;
		break;
	case (u_char) MTPSPPROFILECIRCULARRTEDETECT:	/* Create */
		*write_method = write_mtpSpProfileCircularRteDetect;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileCircularRteDetect);
		rval = (u_char *) &StorageTmp->mtpSpProfileCircularRteDetect;
		break;
	case (u_char) MTPSPPROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpSpProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpSpProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSpTable_row(struct mtpSpTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSpTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSpTable_row(struct mtpSpTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSpTable_request == sa_request))
		return;
	StorageTmp->mtpSpTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSpTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSpTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSpTable(int force)
{
	if (!force && mtpSpTable_refresh == 0)
		return;
	mtpSpTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSpTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSpTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSpTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSpTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSpTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSPPOINTCODE:	/* Create */
		*write_method = write_mtpSpPointCode;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpPointCodeLen;
		rval = (u_char *) StorageTmp->mtpSpPointCode;
		break;
	case (u_char) MTPSPTYPE:	/* Create */
		*write_method = write_mtpSpType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpType);
		rval = (u_char *) &StorageTmp->mtpSpType;
		break;
	case (u_char) MTPSPOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpOperationalState);
		rval = (u_char *) &StorageTmp->mtpSpOperationalState;
		break;
	case (u_char) MTPSPPROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpProceduralStatusLen;
		rval = (u_char *) StorageTmp->mtpSpProceduralStatus;
		break;
	case (u_char) MTPSPAVAILABILITYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpAvailabilityStatusLen;
		rval = (u_char *) StorageTmp->mtpSpAvailabilityStatus;
		break;
	case (u_char) MTPSPVERSION:	/* Create */
		*write_method = write_mtpSpVersion;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpVersionLen;
		rval = (u_char *) StorageTmp->mtpSpVersion;
		break;
	case (u_char) MTPSPNETWORKINDICATOR:	/* Create */
		*write_method = write_mtpSpNetworkIndicator;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpNetworkIndicator);
		rval = (u_char *) &StorageTmp->mtpSpNetworkIndicator;
		break;
	case (u_char) MTPSPNAME:	/* Create */
		*write_method = write_mtpSpName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpNameLen;
		rval = (u_char *) StorageTmp->mtpSpName;
		break;
	case (u_char) MTPSPPROFILEPOINTER:	/* Create */
		*write_method = write_mtpSpProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpProfilePointerLen;
		rval = (u_char *) StorageTmp->mtpSpProfilePointer;
		break;
	case (u_char) MTPSPNAPOINTER:	/* Create */
		*write_method = write_mtpSpNaPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpNaPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSpNaPointer;
		break;
	case (u_char) MTPSPOPTIONS:	/* Create */
		*write_method = write_mtpSpOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpOptionsLen;
		rval = (u_char *) StorageTmp->mtpSpOptions;
		break;
	case (u_char) MTPSPUSERS:	/* Create */
		*write_method = write_mtpSpUsers;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpUsersLen;
		rval = (u_char *) StorageTmp->mtpSpUsers;
		break;
	case (u_char) MTPSPALARMSTATUS:	/* Create */
		*write_method = write_mtpSpAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpAlarmStatusLen;
		rval = (u_char *) StorageTmp->mtpSpAlarmStatus;
		break;
	case (u_char) MTPSPROWSTATUS:	/* Create */
		*write_method = write_mtpSpRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpRowStatus);
		rval = (u_char *) &StorageTmp->mtpSpRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpL3Table_row(struct mtpL3Table_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpL3Table row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpL3Table_row(struct mtpL3Table_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpL3Table_request == sa_request))
		return;
	StorageTmp->mtpL3Table_request = sa_request;
}

/**
 * @fn void refresh_mtpL3Table(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpL3Table.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpL3Table(int force)
{
	if (!force && mtpL3Table_refresh == 0)
		return;
	mtpL3Table_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpL3Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpL3Table.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpL3Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpL3Table_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpL3Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpL3Table(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpL3TableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpL3Table_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPL3ADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpL3AdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpL3AdministrativeState);
		rval = (u_char *) &StorageTmp->mtpL3AdministrativeState;
		break;
	case (u_char) MTPL3OPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpL3OperationalState);
		rval = (u_char *) &StorageTmp->mtpL3OperationalState;
		break;
	case (u_char) MTPL3USAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpL3UsageState);
		rval = (u_char *) &StorageTmp->mtpL3UsageState;
		break;
	case (u_char) MTPL3PROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpL3ProceduralStatusLen;
		rval = (u_char *) StorageTmp->mtpL3ProceduralStatus;
		break;
	case (u_char) MTPL3ASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpL3AsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpL3AsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpL3AsaProfilePointer;
		break;
	case (u_char) MTPL3NAME:	/* Create */
		*write_method = write_mtpL3Name;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpL3NameLen;
		rval = (u_char *) StorageTmp->mtpL3Name;
		break;
	case (u_char) MTPL3ROWSTATUS:	/* Create */
		*write_method = write_mtpL3RowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpL3RowStatus);
		rval = (u_char *) &StorageTmp->mtpL3RowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpGsTable_row(struct mtpGsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpGsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpGsTable_row(struct mtpGsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpGsTable_request == sa_request))
		return;
	StorageTmp->mtpGsTable_request = sa_request;
}

/**
 * @fn void refresh_mtpGsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpGsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsTable(int force)
{
	if (!force && mtpGsTable_refresh == 0)
		return;
	mtpGsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpGsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpGsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpGsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpGsTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpGsTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPGSADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpGsAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpGsAdministrativeState;
		break;
	case (u_char) MTPGSTREATMENTOFOUTSIDERANGES:	/* Create */
		*write_method = write_mtpGsTreatmentOfOutsideRanges;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsTreatmentOfOutsideRanges);
		rval = (u_char *) &StorageTmp->mtpGsTreatmentOfOutsideRanges;
		break;
	case (u_char) MTPGSLISTMODE:	/* Create */
		*write_method = write_mtpGsListMode;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsListMode);
		rval = (u_char *) &StorageTmp->mtpGsListMode;
		break;
	case (u_char) MTPGSSCREENINGBYLINKSETORBYOPC:	/* Create */
		*write_method = write_mtpGsScreeningByLinkSetOrByOpc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsScreeningByLinkSetOrByOpc);
		rval = (u_char *) &StorageTmp->mtpGsScreeningByLinkSetOrByOpc;
		break;
	case (u_char) MTPGSGETSCREENEDOPCSORLINKSETSBYDPC:	/* Create */
		*write_method = write_mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc);
		rval = (u_char *) &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		break;
	case (u_char) MTPGSNAME:	/* Create */
		*write_method = write_mtpGsName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsNameLen;
		rval = (u_char *) StorageTmp->mtpGsName;
		break;
	case (u_char) MTPGSROWSTATUS:	/* Create */
		*write_method = write_mtpGsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsRowStatus);
		rval = (u_char *) &StorageTmp->mtpGsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpGsLineTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpGsLineTable_request == sa_request))
		return;
	StorageTmp->mtpGsLineTable_request = sa_request;
}

/**
 * @fn void refresh_mtpGsLineTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpGsLineTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsLineTable(int force)
{
	if (!force && mtpGsLineTable_refresh == 0)
		return;
	mtpGsLineTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpGsLineTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpGsLineTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsLineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsLineTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsLineTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpGsLineTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpGsLineTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpGsLineTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPGSLINEOBJECT:	/* Create */
		*write_method = write_mtpGsLineObject;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsLineObjectLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpGsLineObject;
		break;
	case (u_char) MTPGSLINECONTENT:	/* Create */
		*write_method = write_mtpGsLineContent;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsLineContent);
		rval = (u_char *) &StorageTmp->mtpGsLineContent;
		break;
	case (u_char) MTPGSLINEROWSTATUS:	/* Create */
		*write_method = write_mtpGsLineRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsLineRowStatus);
		rval = (u_char *) &StorageTmp->mtpGsLineRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpGsLineContentTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpGsLineContentTable_request == sa_request))
		return;
	StorageTmp->mtpGsLineContentTable_request = sa_request;
}

/**
 * @fn void refresh_mtpGsLineContentTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpGsLineContentTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsLineContentTable(int force)
{
	if (!force && mtpGsLineContentTable_refresh == 0)
		return;
	mtpGsLineContentTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpGsLineContentTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpGsLineContentTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsLineContentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsLineContentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpGsLineContentTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpGsLineContentTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpGsLineContentTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPGSLINECONTENTDESIGNATEDDPCFIRST:	/* Create */
		*write_method = write_mtpGsLineContentDesignatedDPCFirst;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsLineContentDesignatedDPCFirstLen;
		rval = (u_char *) StorageTmp->mtpGsLineContentDesignatedDPCFirst;
		break;
	case (u_char) MTPGSLINECONTENTDESIGNATEDDPCLAST:	/* Create */
		*write_method = write_mtpGsLineContentDesignatedDPCLast;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsLineContentDesignatedDPCLastLen;
		rval = (u_char *) StorageTmp->mtpGsLineContentDesignatedDPCLast;
		break;
	case (u_char) MTPGSLINECONTENTSIMASK:	/* Create */
		*write_method = write_mtpGsLineContentSiMask;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsLineContentSiMaskLen;
		rval = (u_char *) StorageTmp->mtpGsLineContentSiMask;
		break;
	case (u_char) MTPGSLINECONTENTMESSAGETREATMENT:	/* Create */
		*write_method = write_mtpGsLineContentMessageTreatment;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsLineContentMessageTreatment);
		rval = (u_char *) &StorageTmp->mtpGsLineContentMessageTreatment;
		break;
	case (u_char) MTPGSLINECONTENTCOMMENT:	/* Create */
		*write_method = write_mtpGsLineContentComment;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsLineContentCommentLen;
		rval = (u_char *) StorageTmp->mtpGsLineContentComment;
		break;
	case (u_char) MTPGSLINECONTENTROWSTATUS:	/* Create */
		*write_method = write_mtpGsLineContentRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsLineContentRowStatus);
		rval = (u_char *) &StorageTmp->mtpGsLineContentRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpRsProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpRsProfileTable_request == sa_request))
		return;
	StorageTmp->mtpRsProfileTable_request = sa_request;
}

/**
 * @fn void refresh_mtpRsProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpRsProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRsProfileTable(int force)
{
	if (!force && mtpRsProfileTable_refresh == 0)
		return;
	mtpRsProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpRsProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRsProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRsProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpRsProfileTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpRsProfileTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPRSPROFILENAME:	/* Create */
		*write_method = write_mtpRsProfileName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsProfileNameLen;
		rval = (u_char *) StorageTmp->mtpRsProfileName;
		break;
	case (u_char) MTPRSPROFILETIMERT8:	/* Create */
		*write_method = write_mtpRsProfileTimerT8;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT8);
		rval = (u_char *) &StorageTmp->mtpRsProfileTimerT8;
		break;
	case (u_char) MTPRSPROFILETIMERT11:	/* Create */
		*write_method = write_mtpRsProfileTimerT11;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT11);
		rval = (u_char *) &StorageTmp->mtpRsProfileTimerT11;
		break;
	case (u_char) MTPRSPROFILETIMERT15:	/* Create */
		*write_method = write_mtpRsProfileTimerT15;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT15);
		rval = (u_char *) &StorageTmp->mtpRsProfileTimerT15;
		break;
	case (u_char) MTPRSPROFILETIMERT16:	/* Create */
		*write_method = write_mtpRsProfileTimerT16;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT16);
		rval = (u_char *) &StorageTmp->mtpRsProfileTimerT16;
		break;
	case (u_char) MTPRSPROFILETIMERT18A:	/* Create */
		*write_method = write_mtpRsProfileTimerT18A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT18A);
		rval = (u_char *) &StorageTmp->mtpRsProfileTimerT18A;
		break;
	case (u_char) MTPRSPROFILERTDEFAULT:	/* Create */
		*write_method = write_mtpRsProfileRtDefault;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsProfileRtDefaultLen;
		rval = (u_char *) StorageTmp->mtpRsProfileRtDefault;
		break;
	case (u_char) MTPRSPROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpRsProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpRsProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpRsTable_row(struct mtpRsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpRsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRsTable_row(struct mtpRsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpRsTable_request == sa_request))
		return;
	StorageTmp->mtpRsTable_request = sa_request;
}

/**
 * @fn void refresh_mtpRsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpRsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRsTable(int force)
{
	if (!force && mtpRsTable_refresh == 0)
		return;
	mtpRsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpRsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpRsTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpRsTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPRSDEST:	/* Create */
		*write_method = write_mtpRsDest;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsDestLen;
		rval = (u_char *) StorageTmp->mtpRsDest;
		break;
	case (u_char) MTPRSOPTIONS:	/* Create */
		*write_method = write_mtpRsOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsOptionsLen;
		rval = (u_char *) StorageTmp->mtpRsOptions;
		break;
	case (u_char) MTPRSADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpRsAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpRsAdministrativeState;
		break;
	case (u_char) MTPRSOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsOperationalState);
		rval = (u_char *) &StorageTmp->mtpRsOperationalState;
		break;
	case (u_char) MTPRSASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpRsAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpRsAsaProfilePointer;
		break;
	case (u_char) MTPRSCONGESTEDSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsCongestedState);
		rval = (u_char *) &StorageTmp->mtpRsCongestedState;
		break;
	case (u_char) MTPRSCONGESTIONLEVEL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsCongestionLevel);
		rval = (u_char *) &StorageTmp->mtpRsCongestionLevel;
		break;
	case (u_char) MTPRSLOADSHARINGINFORMATION:	/* Create */
		*write_method = write_mtpRsLoadsharingInformation;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsLoadsharingInformationLen;
		rval = (u_char *) StorageTmp->mtpRsLoadsharingInformation;
		break;
	case (u_char) MTPRSLOADSHARINGOBJECT:	/* Create */
		*write_method = write_mtpRsLoadsharingObject;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsLoadsharingObjectLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpRsLoadsharingObject;
		break;
	case (u_char) MTPRSREMOTEEXCHANGELABEL:	/* Create */
		*write_method = write_mtpRsRemoteExchangeLabel;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsRemoteExchangeLabelLen;
		rval = (u_char *) StorageTmp->mtpRsRemoteExchangeLabel;
		break;
	case (u_char) MTPRSNAME:	/* Create */
		*write_method = write_mtpRsName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsNameLen;
		rval = (u_char *) StorageTmp->mtpRsName;
		break;
	case (u_char) MTPRSPROFILE:	/* Create */
		*write_method = write_mtpRsProfile;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsProfileLen;
		rval = (u_char *) StorageTmp->mtpRsProfile;
		break;
	case (u_char) MTPRSALARMSTATUS:	/* Create */
		*write_method = write_mtpRsAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsAlarmStatusLen;
		rval = (u_char *) StorageTmp->mtpRsAlarmStatus;
		break;
	case (u_char) MTPRSROWSTATUS:	/* Create */
		*write_method = write_mtpRsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsRowStatus);
		rval = (u_char *) &StorageTmp->mtpRsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpRtProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpRtProfileTable_request == sa_request))
		return;
	StorageTmp->mtpRtProfileTable_request = sa_request;
}

/**
 * @fn void refresh_mtpRtProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpRtProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtProfileTable(int force)
{
	if (!force && mtpRtProfileTable_refresh == 0)
		return;
	mtpRtProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpRtProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRtProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRtProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpRtProfileTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpRtProfileTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPRTPROFILETIMERT6:	/* Create */
		*write_method = write_mtpRtProfileTimerT6;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT6);
		rval = (u_char *) &StorageTmp->mtpRtProfileTimerT6;
		break;
	case (u_char) MTPRTPROFILETIMERT10:	/* Create */
		*write_method = write_mtpRtProfileTimerT10;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT10);
		rval = (u_char *) &StorageTmp->mtpRtProfileTimerT10;
		break;
	case (u_char) MTPRTPROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpRtProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpRtProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpRtTable_row(struct mtpRtTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpRtTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRtTable_row(struct mtpRtTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpRtTable_request == sa_request))
		return;
	StorageTmp->mtpRtTable_request = sa_request;
}

/**
 * @fn void refresh_mtpRtTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpRtTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtTable(int force)
{
	if (!force && mtpRtTable_refresh == 0)
		return;
	mtpRtTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpRtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRtTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRtTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpRtTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpRtTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPRTLSPOINTER:	/* Create */
		*write_method = write_mtpRtLsPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtLsPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpRtLsPointer;
		break;
	case (u_char) MTPRTADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpRtAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpRtAdministrativeState;
		break;
	case (u_char) MTPRTOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtOperationalState);
		rval = (u_char *) &StorageTmp->mtpRtOperationalState;
		break;
	case (u_char) MTPRTAVAILABILITYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtAvailabilityStatusLen;
		rval = (u_char *) StorageTmp->mtpRtAvailabilityStatus;
		break;
	case (u_char) MTPRTINCLSLOADSHARINGALGORITHM:	/* Create */
		*write_method = write_mtpRtInClsLoadsharingAlgorithm;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtInClsLoadsharingAlgorithm);
		rval = (u_char *) &StorageTmp->mtpRtInClsLoadsharingAlgorithm;
		break;
	case (u_char) MTPRTFIXEDPRIORITY:	/* Create */
		*write_method = write_mtpRtFixedPriority;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtFixedPriority);
		rval = (u_char *) &StorageTmp->mtpRtFixedPriority;
		break;
	case (u_char) MTPRTFLEXIBLEPRIORITY:	/* Create */
		*write_method = write_mtpRtFlexiblePriority;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtFlexiblePriority);
		rval = (u_char *) &StorageTmp->mtpRtFlexiblePriority;
		break;
	case (u_char) MTPRTPRIORITYMODE:	/* Create */
		*write_method = write_mtpRtPriorityMode;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtPriorityMode);
		rval = (u_char *) &StorageTmp->mtpRtPriorityMode;
		break;
	case (u_char) MTPRTLOADSHARINGINFORMATION:	/* Create */
		*write_method = write_mtpRtLoadsharingInformation;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtLoadsharingInformationLen;
		rval = (u_char *) StorageTmp->mtpRtLoadsharingInformation;
		break;
	case (u_char) MTPRTLOADSHARINGOBJECT:	/* Create */
		*write_method = write_mtpRtLoadsharingObject;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtLoadsharingObjectLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpRtLoadsharingObject;
		break;
	case (u_char) MTPRTNAME:	/* Create */
		*write_method = write_mtpRtName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtNameLen;
		rval = (u_char *) StorageTmp->mtpRtName;
		break;
	case (u_char) MTPRTSLSLIST:	/* Create */
		*write_method = write_mtpRtSlsList;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtSlsListLen;
		rval = (u_char *) StorageTmp->mtpRtSlsList;
		break;
	case (u_char) MTPRTUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtUsageState);
		rval = (u_char *) &StorageTmp->mtpRtUsageState;
		break;
	case (u_char) MTPRTRLSLOT:	/* Create */
		*write_method = write_mtpRtRlSlot;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtRlSlot);
		rval = (u_char *) &StorageTmp->mtpRtRlSlot;
		break;
	case (u_char) MTPRTPROFILE:	/* Create */
		*write_method = write_mtpRtProfile;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtProfileLen;
		rval = (u_char *) StorageTmp->mtpRtProfile;
		break;
	case (u_char) MTPRTROWSTATUS:	/* Create */
		*write_method = write_mtpRtRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtRowStatus);
		rval = (u_char *) &StorageTmp->mtpRtRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpRtLsaTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpRtLsaTable_request == sa_request))
		return;
	StorageTmp->mtpRtLsaTable_request = sa_request;
}

/**
 * @fn void refresh_mtpRtLsaTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpRtLsaTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtLsaTable(int force)
{
	if (!force && mtpRtLsaTable_refresh == 0)
		return;
	mtpRtLsaTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpRtLsaTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRtLsaTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtLsaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtLsaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRtLsaTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpRtLsaTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpRtLsaTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPRTLSANORMALSLCODE:	/* ReadWrite */
		*write_method = write_mtpRtLsaNormalSlCode;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtLsaNormalSlCode);
		rval = (u_char *) &StorageTmp->mtpRtLsaNormalSlCode;
		break;
	case (u_char) MTPRTLSAALTERNATIVESLCODELIST:	/* ReadWrite */
		*write_method = write_mtpRtLsaAlternativeSlCodeList;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
		rval = (u_char *) StorageTmp->mtpRtLsaAlternativeSlCodeList;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpLsProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpLsProfileTable_request == sa_request))
		return;
	StorageTmp->mtpLsProfileTable_request = sa_request;
}

/**
 * @fn void refresh_mtpLsProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpLsProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpLsProfileTable(int force)
{
	if (!force && mtpLsProfileTable_refresh == 0)
		return;
	mtpLsProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpLsProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpLsProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpLsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpLsProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpLsProfileTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpLsProfileTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPLSPROFILETIMERT6:	/* Create */
		*write_method = write_mtpLsProfileTimerT6;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT6);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT6;
		break;
	case (u_char) MTPLSPROFILETIMERT8:	/* Create */
		*write_method = write_mtpLsProfileTimerT8;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT8);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT8;
		break;
	case (u_char) MTPLSPROFILETIMERT10:	/* Create */
		*write_method = write_mtpLsProfileTimerT10;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT10);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT10;
		break;
	case (u_char) MTPLSPROFILETIMERT7:	/* Create */
		*write_method = write_mtpLsProfileTimerT7;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT7);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT7;
		break;
	case (u_char) MTPLSPROFILETIMERT19I:	/* Create */
		*write_method = write_mtpLsProfileTimerT19I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT19I);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT19I;
		break;
	case (u_char) MTPLSPROFILETIMERT21I:	/* Create */
		*write_method = write_mtpLsProfileTimerT21I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT21I);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT21I;
		break;
	case (u_char) MTPLSPROFILETIMERT25A:	/* Create */
		*write_method = write_mtpLsProfileTimerT25A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT25A);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT25A;
		break;
	case (u_char) MTPLSPROFILETIMERT28A:	/* Create */
		*write_method = write_mtpLsProfileTimerT28A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT28A);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT28A;
		break;
	case (u_char) MTPLSPROFILETIMERT29A:	/* Create */
		*write_method = write_mtpLsProfileTimerT29A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT29A);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT29A;
		break;
	case (u_char) MTPLSPROFILETIMERT30A:	/* Create */
		*write_method = write_mtpLsProfileTimerT30A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT30A);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT30A;
		break;
	case (u_char) MTPLSPROFILEPARAMETERN:	/* Create */
		*write_method = write_mtpLsProfileParameterN;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileParameterN);
		rval = (u_char *) &StorageTmp->mtpLsProfileParameterN;
		break;
	case (u_char) MTPLSPROFILEPARAMETERM:	/* Create */
		*write_method = write_mtpLsProfileParameterM;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileParameterM);
		rval = (u_char *) &StorageTmp->mtpLsProfileParameterM;
		break;
	case (u_char) MTPLSPROFILENAME:	/* Create */
		*write_method = write_mtpLsProfileName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsProfileNameLen;
		rval = (u_char *) StorageTmp->mtpLsProfileName;
		break;
	case (u_char) MTPLSPROFILESLDEFAULT:	/* Create */
		*write_method = write_mtpLsProfileSlDefault;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsProfileSlDefaultLen;
		rval = (u_char *) StorageTmp->mtpLsProfileSlDefault;
		break;
	case (u_char) MTPLSPROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpLsProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpLsProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpLsTable_row(struct mtpLsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpLsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpLsTable_row(struct mtpLsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpLsTable_request == sa_request))
		return;
	StorageTmp->mtpLsTable_request = sa_request;
}

/**
 * @fn void refresh_mtpLsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpLsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpLsTable(int force)
{
	if (!force && mtpLsTable_refresh == 0)
		return;
	mtpLsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpLsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpLsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpLsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpLsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpLsTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpLsTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPLSADJPC:	/* Create */
		*write_method = write_mtpLsAdjPc;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsAdjPcLen;
		rval = (u_char *) StorageTmp->mtpLsAdjPc;
		break;
	case (u_char) MTPLSRSID:	/* Create */
		*write_method = write_mtpLsRsId;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsRsIdLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpLsRsId;
		break;
	case (u_char) MTPLSMAXCAPACITY:	/* Create */
		*write_method = write_mtpLsMaxCapacity;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsMaxCapacity);
		rval = (u_char *) &StorageTmp->mtpLsMaxCapacity;
		break;
	case (u_char) MTPLSCURRENTCAPACITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsCurrentCapacity);
		rval = (u_char *) &StorageTmp->mtpLsCurrentCapacity;
		break;
	case (u_char) MTPLSCONGESTIONCONTROLMETHOD:	/* Create */
		*write_method = write_mtpLsCongestionControlMethod;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsCongestionControlMethod);
		rval = (u_char *) &StorageTmp->mtpLsCongestionControlMethod;
		break;
	case (u_char) MTPLSUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsUsageState);
		rval = (u_char *) &StorageTmp->mtpLsUsageState;
		break;
	case (u_char) MTPLSOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsOperationalState);
		rval = (u_char *) &StorageTmp->mtpLsOperationalState;
		break;
	case (u_char) MTPLSAVAILABILITYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsAvailabilityStatusLen;
		rval = (u_char *) StorageTmp->mtpLsAvailabilityStatus;
		break;
	case (u_char) MTPLSPERIODICLINKTESTFLAG:	/* Create */
		*write_method = write_mtpLsPeriodicLinkTestFlag;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFlag);
		rval = (u_char *) &StorageTmp->mtpLsPeriodicLinkTestFlag;
		break;
	case (u_char) MTPLSPERIODICLINKTESTFAIL:	/* Create */
		*write_method = write_mtpLsPeriodicLinkTestFail;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFail);
		rval = (u_char *) &StorageTmp->mtpLsPeriodicLinkTestFail;
		break;
	case (u_char) MTPLSADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpLsAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpLsAdministrativeState;
		break;
	case (u_char) MTPLSINLSLOADSHAREALGORITHM:	/* Create */
		*write_method = write_mtpLsInLsLoadShareAlgorithm;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsInLsLoadShareAlgorithmLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpLsInLsLoadShareAlgorithm;
		break;
	case (u_char) MTPLSPROFILEPOINTER:	/* Create */
		*write_method = write_mtpLsProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsProfilePointerLen;
		rval = (u_char *) StorageTmp->mtpLsProfilePointer;
		break;
	case (u_char) MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS:	/* Create */
		*write_method = write_mtpLsNumberOfNormallyActiveSignLinks;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsNumberOfNormallyActiveSignLinks);
		rval = (u_char *) &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks;
		break;
	case (u_char) MTPLSNAME:	/* Create */
		*write_method = write_mtpLsName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsNameLen;
		rval = (u_char *) StorageTmp->mtpLsName;
		break;
	case (u_char) MTPLSASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpLsAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpLsAsaProfilePointer;
		break;
	case (u_char) MTPLSALARMSTATUS:	/* Create */
		*write_method = write_mtpLsAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsAlarmStatusLen;
		rval = (u_char *) StorageTmp->mtpLsAlarmStatus;
		break;
	case (u_char) MTPLSROWSTATUS:	/* Create */
		*write_method = write_mtpLsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsRowStatus);
		rval = (u_char *) &StorageTmp->mtpLsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSlL3ProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSlL3ProfileTable_request == sa_request))
		return;
	StorageTmp->mtpSlL3ProfileTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSlL3ProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSlL3ProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlL3ProfileTable(int force)
{
	if (!force && mtpSlL3ProfileTable_refresh == 0)
		return;
	mtpSlL3ProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSlL3ProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlL3ProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlL3ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlL3ProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlL3ProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSlL3ProfileTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSLL3PROFILETIMERT1:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1;
		break;
	case (u_char) MTPSLL3PROFILETIMERT3:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT3);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT3;
		break;
	case (u_char) MTPSLL3PROFILETIMERT17:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT17;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT17);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT17;
		break;
	case (u_char) MTPSLL3PROFILETIMERT24I:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT24I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT24I);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT24I;
		break;
	case (u_char) MTPSLL3PROFILENAME:	/* Create */
		*write_method = write_mtpSlL3ProfileName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlL3ProfileNameLen;
		rval = (u_char *) StorageTmp->mtpSlL3ProfileName;
		break;
	case (u_char) MTPSLL3PROFILETIMERT2:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT2);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT2;
		break;
	case (u_char) MTPSLL3PROFILETIMERT4:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT4;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT4);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT4;
		break;
	case (u_char) MTPSLL3PROFILETIMERT5:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT5;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT5);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT5;
		break;
	case (u_char) MTPSLL3PROFILETIMERT12:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT12;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT12);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT12;
		break;
	case (u_char) MTPSLL3PROFILETIMERT13:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT13;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT13);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT13;
		break;
	case (u_char) MTPSLL3PROFILETIMERT14:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT14;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT14);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT14;
		break;
	case (u_char) MTPSLL3PROFILETIMERT19A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT19A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT19A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT19A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT20A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT20A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT20A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT20A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT21A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT21A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT21A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT21A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT22I:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT22I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT22I);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT22I;
		break;
	case (u_char) MTPSLL3PROFILETIMERT23I:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT23I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT23I);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT23I;
		break;
	case (u_char) MTPSLL3PROFILETIMERT31A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT31A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT31A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT31A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT32A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT32A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT32A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT32A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT33A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT33A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT33A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT33A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT34A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT34A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT34A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT34A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT1T:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT1T;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1T);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1T;
		break;
	case (u_char) MTPSLL3PROFILETIMERT2T:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT2T;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT2T);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT2T;
		break;
	case (u_char) MTPSLL3PROFILETIMERT1S:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT1S;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1S);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1S;
		break;
	case (u_char) MTPSLL3PROFILEL2DEFAULT:	/* Create */
		*write_method = write_mtpSlL3ProfileL2Default;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlL3ProfileL2DefaultLen;
		rval = (u_char *) StorageTmp->mtpSlL3ProfileL2Default;
		break;
	case (u_char) MTPSLL3PROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpSlL3ProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSlL2ProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSlL2ProfileTable_request == sa_request))
		return;
	StorageTmp->mtpSlL2ProfileTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSlL2ProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSlL2ProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlL2ProfileTable(int force)
{
	if (!force && mtpSlL2ProfileTable_refresh == 0)
		return;
	mtpSlL2ProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSlL2ProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlL2ProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlL2ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlL2ProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlL2ProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSlL2ProfileTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSLL2PROFILEERRORCORRECTIONMETHOD:	/* Create */
		*write_method = write_mtpSlL2ProfileErrorCorrectionMethod;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileErrorCorrectionMethod);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod;
		break;
	case (u_char) MTPSLL2PROFILEPROTOCOLVARIANT:	/* Create */
		*write_method = write_mtpSlL2ProfileProtocolVariant;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlL2ProfileProtocolVariantLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlL2ProfileProtocolVariant;
		break;
	case (u_char) MTPSLL2PROFILETIMERT1:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT1);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT1;
		break;
	case (u_char) MTPSLL2PROFILETIMERT2:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2;
		break;
	case (u_char) MTPSLL2PROFILETIMERT2L:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT2L;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2L);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2L;
		break;
	case (u_char) MTPSLL2PROFILETIMERT2H:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT2H;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2H);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2H;
		break;
	case (u_char) MTPSLL2PROFILETIMERT3:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT3);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT3;
		break;
	case (u_char) MTPSLL2PROFILETIMERT4N:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT4N;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT4N);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT4N;
		break;
	case (u_char) MTPSLL2PROFILETIMERT4E:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT4E;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT4E);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT4E;
		break;
	case (u_char) MTPSLL2PROFILETIMERT5:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT5;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT5);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT5;
		break;
	case (u_char) MTPSLL2PROFILETIMERT6:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT6;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT6);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT6;
		break;
	case (u_char) MTPSLL2PROFILETIMERT7:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT7;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT7);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT7;
		break;
	case (u_char) MTPSLL2PROFILETBONSET1:	/* Create */
		*write_method = write_mtpSlL2ProfileTbOnset1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset1);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset1;
		break;
	case (u_char) MTPSLL2PROFILETBABATE1:	/* Create */
		*write_method = write_mtpSlL2ProfileTbAbate1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate1);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate1;
		break;
	case (u_char) MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS:	/* Create */
		*write_method = write_mtpSlL2ProfileNumberOfThresholdLevels;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels;
		break;
	case (u_char) MTPSLL2PROFILECONGESTIONCOUNTING:	/* Create */
		*write_method = write_mtpSlL2ProfileCongestionCounting;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileCongestionCounting);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileCongestionCounting;
		break;
	case (u_char) MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT:	/* Create */
		*write_method = write_mtpSlL2ProfileCongestionReportingBaseObject;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject;
		break;
	case (u_char) MTPSLL2PROFILELOOPDELAY:	/* Create */
		*write_method = write_mtpSlL2ProfileLoopDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileLoopDelay);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileLoopDelay;
		break;
	case (u_char) MTPSLL2PROFILENAME:	/* Create */
		*write_method = write_mtpSlL2ProfileName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlL2ProfileNameLen;
		rval = (u_char *) StorageTmp->mtpSlL2ProfileName;
		break;
	case (u_char) MTPSLL2PROFILETBONSET2:	/* Create */
		*write_method = write_mtpSlL2ProfileTbOnset2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset2);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset2;
		break;
	case (u_char) MTPSLL2PROFILETBABATE2:	/* Create */
		*write_method = write_mtpSlL2ProfileTbAbate2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate2);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate2;
		break;
	case (u_char) MTPSLL2PROFILETBONSET3:	/* Create */
		*write_method = write_mtpSlL2ProfileTbOnset3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset3);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset3;
		break;
	case (u_char) MTPSLL2PROFILETBABATE3:	/* Create */
		*write_method = write_mtpSlL2ProfileTbAbate3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate3);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate3;
		break;
	case (u_char) MTPSLL2PROFILETBDISCARD1:	/* Create */
		*write_method = write_mtpSlL2ProfileTbDiscard1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard1);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard1;
		break;
	case (u_char) MTPSLL2PROFILETBDISCARD2:	/* Create */
		*write_method = write_mtpSlL2ProfileTbDiscard2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard2);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard2;
		break;
	case (u_char) MTPSLL2PROFILETBDISCARD3:	/* Create */
		*write_method = write_mtpSlL2ProfileTbDiscard3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard3);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard3;
		break;
	case (u_char) MTPSLL2PROFILETIMERTX:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerTx;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerTx);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerTx;
		break;
	case (u_char) MTPSLL2PROFILETIMERTY:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerTy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerTy);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerTy;
		break;
	case (u_char) MTPSLL2PROFILENUMBEROFCONGESTIONSTATES:	/* Create */
		*write_method = write_mtpSlL2ProfileNumberOfCongestionStates;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileNumberOfCongestionStates);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates;
		break;
	case (u_char) MTPSLL2PROFILEINITIALLEVELOFCONGESTION:	/* Create */
		*write_method = write_mtpSlL2ProfileInitialLevelOfCongestion;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion;
		break;
	case (u_char) MTPSLL2PROFILEMAXMSUSRETRANSN1:	/* Create */
		*write_method = write_mtpSlL2ProfileMaxMSUsRetransN1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1;
		break;
	case (u_char) MTPSLL2PROFILEMAXOCTRETRANSN2:	/* Create */
		*write_method = write_mtpSlL2ProfileMaxOctRetransN2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileMaxOctRetransN2);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileMaxOctRetransN2;
		break;
	case (u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET:	/* Create */
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdOnset;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset;
		break;
	case (u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE:	/* Create */
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdAbate;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate;
		break;
	case (u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD:	/* Create */
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		break;
	case (u_char) MTPSLL2PROFILEM:	/* Create */
		*write_method = write_mtpSlL2ProfileM;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileM);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileM;
		break;
	case (u_char) MTPSLL2PROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpSlL2ProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSlTable_row(struct mtpSlTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSlTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlTable_row(struct mtpSlTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSlTable_request == sa_request))
		return;
	StorageTmp->mtpSlTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSlTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSlTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlTable(int force)
{
	if (!force && mtpSlTable_refresh == 0)
		return;
	mtpSlTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSlTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSlTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSlTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSLSLSCODECURRENTLIST:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSlsCodeCurrentListLen;
		rval = (u_char *) StorageTmp->mtpSlSlsCodeCurrentList;
		break;
	case (u_char) MTPSLMAXCAPACITYSL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlMaxCapacitySL);
		rval = (u_char *) &StorageTmp->mtpSlMaxCapacitySL;
		break;
	case (u_char) MTPSLCURRENTCAPACITYSL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlCurrentCapacitySL);
		rval = (u_char *) &StorageTmp->mtpSlCurrentCapacitySL;
		break;
	case (u_char) MTPSLLINKTPSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlLinkTpStatusLen;
		rval = (u_char *) StorageTmp->mtpSlLinkTpStatus;
		break;
	case (u_char) MTPSLADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpSlAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpSlAdministrativeState;
		break;
	case (u_char) MTPSLOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlOperationalState);
		rval = (u_char *) &StorageTmp->mtpSlOperationalState;
		break;
	case (u_char) MTPSLUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlUsageState);
		rval = (u_char *) &StorageTmp->mtpSlUsageState;
		break;
	case (u_char) MTPSLPROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlProceduralStatusLen;
		rval = (u_char *) StorageTmp->mtpSlProceduralStatus;
		break;
	case (u_char) MTPSLMTPL2PROTOCOLPROFILEPOINTER:	/* Create */
		*write_method = write_mtpSlMtpL2ProtocolProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen;
		rval = (u_char *) StorageTmp->mtpSlMtpL2ProtocolProfilePointer;
		break;
	case (u_char) MTPSLSIGNTERMPOINTER:	/* Create */
		*write_method = write_mtpSlSignTermPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSignTermPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlSignTermPointer;
		break;
	case (u_char) MTPSLSIGNDATALINKTPPOINTER:	/* Create */
		*write_method = write_mtpSlSignDataLinkTpPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSignDataLinkTpPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlSignDataLinkTpPointer;
		break;
	case (u_char) MTPSLLOCALINHIBIT:	/* Create */
		*write_method = write_mtpSlLocalInhibit;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlLocalInhibit);
		rval = (u_char *) &StorageTmp->mtpSlLocalInhibit;
		break;
	case (u_char) MTPSLLOCALUNINHIBIT:	/* Create */
		*write_method = write_mtpSlLocalUninhibit;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlLocalUninhibit);
		rval = (u_char *) &StorageTmp->mtpSlLocalUninhibit;
		break;
	case (u_char) MTPSLREPLACEST:	/* Create */
		*write_method = write_mtpSlReplaceSt;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlReplaceSt);
		rval = (u_char *) &StorageTmp->mtpSlReplaceSt;
		break;
	case (u_char) MTPSLASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpSlAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlAsaProfilePointer;
		break;
	case (u_char) MTPSLCONGESTIONLEVEL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlCongestionLevel);
		rval = (u_char *) &StorageTmp->mtpSlCongestionLevel;
		break;
	case (u_char) MTPSLRELATEDLINKGROUPNUMBER:	/* Create */
		*write_method = write_mtpSlRelatedLinkGroupNumber;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlRelatedLinkGroupNumber);
		rval = (u_char *) &StorageTmp->mtpSlRelatedLinkGroupNumber;
		break;
	case (u_char) MTPSLSDLLIST:	/* Create */
		*write_method = write_mtpSlSdlList;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlSdlList);
		rval = (u_char *) &StorageTmp->mtpSlSdlList;
		break;
	case (u_char) MTPSLTEST:	/* Create */
		*write_method = write_mtpSlTest;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlTest);
		rval = (u_char *) &StorageTmp->mtpSlTest;
		break;
	case (u_char) MTPSLNAME:	/* Create */
		*write_method = write_mtpSlName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlNameLen;
		rval = (u_char *) StorageTmp->mtpSlName;
		break;
	case (u_char) MTPSLSDTLIST:	/* Create */
		*write_method = write_mtpSlSdtList;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlSdtList);
		rval = (u_char *) &StorageTmp->mtpSlSdtList;
		break;
	case (u_char) MTPSLSLSCODENORMALLIST:	/* Create */
		*write_method = write_mtpSlSlsCodeNormalList;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSlsCodeNormalListLen;
		rval = (u_char *) StorageTmp->mtpSlSlsCodeNormalList;
		break;
	case (u_char) MTPSLL3PROFILEPOINTER:	/* Create */
		*write_method = write_mtpSlL3ProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlL3ProfilePointerLen;
		rval = (u_char *) StorageTmp->mtpSlL3ProfilePointer;
		break;
	case (u_char) MTPSLALARMSTATUS:	/* Create */
		*write_method = write_mtpSlAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlAlarmStatusLen;
		rval = (u_char *) StorageTmp->mtpSlAlarmStatus;
		break;
	case (u_char) MTPSLROWSTATUS:	/* Create */
		*write_method = write_mtpSlRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlRowStatus);
		rval = (u_char *) &StorageTmp->mtpSlRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSlSdlListTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSlSdlListTable_request == sa_request))
		return;
	StorageTmp->mtpSlSdlListTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSlSdlListTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSlSdlListTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlSdlListTable(int force)
{
	if (!force && mtpSlSdlListTable_refresh == 0)
		return;
	mtpSlSdlListTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSlSdlListTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlSdlListTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlSdlListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlSdlListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlSdlListTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSlSdlListTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSlSdlListTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSLSDLLISTPOINTER:	/* Create */
		*write_method = write_mtpSlSdlListPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSdlListPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlSdlListPointer;
		break;
	case (u_char) MTPSLSDLLISTROWSTATUS:	/* Create */
		*write_method = write_mtpSlSdlListRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlSdlListRowStatus);
		rval = (u_char *) &StorageTmp->mtpSlSdlListRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSlSdtListTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSlSdtListTable_request == sa_request))
		return;
	StorageTmp->mtpSlSdtListTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSlSdtListTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSlSdtListTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlSdtListTable(int force)
{
	if (!force && mtpSlSdtListTable_refresh == 0)
		return;
	mtpSlSdtListTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSlSdtListTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlSdtListTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlSdtListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlSdtListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlSdtListTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSlSdtListTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSlSdtListTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSLSDTLISTPOINTER:	/* Create */
		*write_method = write_mtpSlSdtListPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSdtListPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlSdtListPointer;
		break;
	case (u_char) MTPSLSDTLISTROWSTATUS:	/* Create */
		*write_method = write_mtpSlSdtListRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlSdtListRowStatus);
		rval = (u_char *) &StorageTmp->mtpSlSdtListRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpNbTable_row(struct mtpNbTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpNbTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpNbTable_row(struct mtpNbTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpNbTable_request == sa_request))
		return;
	StorageTmp->mtpNbTable_request = sa_request;
}

/**
 * @fn void refresh_mtpNbTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpNbTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpNbTable(int force)
{
	if (!force && mtpNbTable_refresh == 0)
		return;
	mtpNbTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpNbTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpNbTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpNbTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpNbTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpNbTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpNbTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpNbTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpNbTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPNBTRANSMISSIONRATE:	/* Create */
		*write_method = write_mtpNbTransmissionRate;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbTransmissionRate);
		rval = (u_char *) &StorageTmp->mtpNbTransmissionRate;
		break;
	case (u_char) MTPNBTIMERT8:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbTimerT8);
		rval = (u_char *) &StorageTmp->mtpNbTimerT8;
		break;
	case (u_char) MTPNBTIN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbTin);
		rval = (u_char *) &StorageTmp->mtpNbTin;
		break;
	case (u_char) MTPNBTIE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbTie);
		rval = (u_char *) &StorageTmp->mtpNbTie;
		break;
	case (u_char) MTPNBT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbT);
		rval = (u_char *) &StorageTmp->mtpNbT;
		break;
	case (u_char) MTPNBD:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbD);
		rval = (u_char *) &StorageTmp->mtpNbD;
		break;
	case (u_char) MTPNBTE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbTe);
		rval = (u_char *) &StorageTmp->mtpNbTe;
		break;
	case (u_char) MTPNBDE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbDe);
		rval = (u_char *) &StorageTmp->mtpNbDe;
		break;
	case (u_char) MTPNBUE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbUe);
		rval = (u_char *) &StorageTmp->mtpNbUe;
		break;
	case (u_char) MTPNBN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbN);
		rval = (u_char *) &StorageTmp->mtpNbN;
		break;
	case (u_char) MTPNBM:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbm);
		rval = (u_char *) &StorageTmp->mtpNbm;
		break;
	case (u_char) MTPNBB:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbb);
		rval = (u_char *) &StorageTmp->mtpNbb;
		break;
	case (u_char) MTPNBF:	/* Create */
		*write_method = write_mtpNbf;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbf);
		rval = (u_char *) &StorageTmp->mtpNbf;
		break;
	case (u_char) MTPNBROWSTATUS:	/* Create */
		*write_method = write_mtpNbRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbRowStatus);
		rval = (u_char *) &StorageTmp->mtpNbRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSaalTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSaalTable_request == sa_request))
		return;
	StorageTmp->mtpSaalTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSaalTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSaalTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSaalTable(int force)
{
	if (!force && mtpSaalTable_refresh == 0)
		return;
	mtpSaalTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSaalTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSaalTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSaalTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSaalTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSaalTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSaalTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSaalTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSaalTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSAALBUFFERRELEASE:	/* Create */
		*write_method = write_mtpSaalBufferRelease;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalBufferRelease);
		rval = (u_char *) &StorageTmp->mtpSaalBufferRelease;
		break;
	case (u_char) MTPSAALMAXCC:	/* Create */
		*write_method = write_mtpSaalMaxCc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxCc);
		rval = (u_char *) &StorageTmp->mtpSaalMaxCc;
		break;
	case (u_char) MTPSAALMAXNRP:	/* Create */
		*write_method = write_mtpSaalMaxNrp;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxNrp);
		rval = (u_char *) &StorageTmp->mtpSaalMaxNrp;
		break;
	case (u_char) MTPSAALMAXINFORMATIONFIELDLENGTH:	/* Create */
		*write_method = write_mtpSaalMaxInformationFieldLength;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxInformationFieldLength);
		rval = (u_char *) &StorageTmp->mtpSaalMaxInformationFieldLength;
		break;
	case (u_char) MTPSAALMAXLENGTHSSCOPUUFIELD:	/* Create */
		*write_method = write_mtpSaalMaxLengthSscopUuField;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxLengthSscopUuField);
		rval = (u_char *) &StorageTmp->mtpSaalMaxLengthSscopUuField;
		break;
	case (u_char) MTPSAALMAXPD:	/* Create */
		*write_method = write_mtpSaalMaxPd;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxPd);
		rval = (u_char *) &StorageTmp->mtpSaalMaxPd;
		break;
	case (u_char) MTPSAALMAXSSCOPCREDITTOPEER:	/* Create */
		*write_method = write_mtpSaalMaxSscopCreditToPeer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxSscopCreditToPeer);
		rval = (u_char *) &StorageTmp->mtpSaalMaxSscopCreditToPeer;
		break;
	case (u_char) MTPSAALMAXSTAT:	/* Create */
		*write_method = write_mtpSaalMaxStat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxStat);
		rval = (u_char *) &StorageTmp->mtpSaalMaxStat;
		break;
	case (u_char) MTPSAALN1:	/* Create */
		*write_method = write_mtpSaalN1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalN1);
		rval = (u_char *) &StorageTmp->mtpSaalN1;
		break;
	case (u_char) MTPSAALNNILAYERMANAGEMENTPROVINGSTATE:	/* Create */
		*write_method = write_mtpSaalNniLayerManagementProvingState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementProvingState);
		rval = (u_char *) &StorageTmp->mtpSaalNniLayerManagementProvingState;
		break;
	case (u_char) MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT:	/* Create */
		*write_method = write_mtpSaalNniLayerManagementTimerNoCredit;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerNoCredit);
		rval = (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;
		break;
	case (u_char) MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC:	/* Create */
		*write_method = write_mtpSaalNniLayerManagementTimerRepeatSrec;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec);
		rval = (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;
		break;
	case (u_char) MTPSAALNNITIMERT1:	/* Create */
		*write_method = write_mtpSaalNniTimerT1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT1);
		rval = (u_char *) &StorageTmp->mtpSaalNniTimerT1;
		break;
	case (u_char) MTPSAALNNITIMERT2:	/* Create */
		*write_method = write_mtpSaalNniTimerT2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT2);
		rval = (u_char *) &StorageTmp->mtpSaalNniTimerT2;
		break;
	case (u_char) MTPSAALNNITIMERT3:	/* Create */
		*write_method = write_mtpSaalNniTimerT3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT3);
		rval = (u_char *) &StorageTmp->mtpSaalNniTimerT3;
		break;
	case (u_char) MTPSAALSSCOPTIMERCC:	/* Create */
		*write_method = write_mtpSaalSscopTimerCc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerCc);
		rval = (u_char *) &StorageTmp->mtpSaalSscopTimerCc;
		break;
	case (u_char) MTPSAALSSCOPTIMERIDLE:	/* Create */
		*write_method = write_mtpSaalSscopTimerIdle;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerIdle);
		rval = (u_char *) &StorageTmp->mtpSaalSscopTimerIdle;
		break;
	case (u_char) MTPSAALSSCOPTIMERKEEPALIVE:	/* Create */
		*write_method = write_mtpSaalSscopTimerKeepAlive;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerKeepAlive);
		rval = (u_char *) &StorageTmp->mtpSaalSscopTimerKeepAlive;
		break;
	case (u_char) MTPSAALSSCOPTIMERNORESPONSE:	/* Create */
		*write_method = write_mtpSaalSscopTimerNoResponse;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerNoResponse);
		rval = (u_char *) &StorageTmp->mtpSaalSscopTimerNoResponse;
		break;
	case (u_char) MTPSAALSSCOPTIMERPOLL:	/* Create */
		*write_method = write_mtpSaalSscopTimerPoll;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerPoll);
		rval = (u_char *) &StorageTmp->mtpSaalSscopTimerPoll;
		break;
	case (u_char) MTPSAALTRANSMISSIONRATEINTERVALLOWER:	/* Create */
		*write_method = write_mtpSaalTransmissionRateIntervalLower;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalLower);
		rval = (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalLower;
		break;
	case (u_char) MTPSAALTRANSMISSIONRATEINTERVALUPPER:	/* Create */
		*write_method = write_mtpSaalTransmissionRateIntervalUpper;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalUpper);
		rval = (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalUpper;
		break;
	case (u_char) MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER:	/* Create */
		*write_method = write_mtpSaalEgressTransmissionRateIntervalLower;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalLower);
		rval = (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;
		break;
	case (u_char) MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER:	/* Create */
		*write_method = write_mtpSaalEgressTransmissionRateIntervalUpper;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper);
		rval = (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;
		break;
	case (u_char) MTPSAALPOLLAFTERRETRANSMISSION:	/* Create */
		*write_method = write_mtpSaalPollAfterRetransmission;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalPollAfterRetransmission);
		rval = (u_char *) &StorageTmp->mtpSaalPollAfterRetransmission;
		break;
	case (u_char) MTPSAALROWSTATUS:	/* Create */
		*write_method = write_mtpSaalRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalRowStatus);
		rval = (u_char *) &StorageTmp->mtpSaalRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpM2paTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpM2paTable_request == sa_request))
		return;
	StorageTmp->mtpM2paTable_request = sa_request;
}

/**
 * @fn void refresh_mtpM2paTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpM2paTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM2paTable(int force)
{
	if (!force && mtpM2paTable_refresh == 0)
		return;
	mtpM2paTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpM2paTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpM2paTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM2paTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM2paTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpM2paTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpM2paTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpM2paTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpM2paTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPM2PAN1:	/* Create */
		*write_method = write_mtpM2paN1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paN1);
		rval = (u_char *) &StorageTmp->mtpM2paN1;
		break;
	case (u_char) MTPM2PAPROVING:	/* Create */
		*write_method = write_mtpM2paProving;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paProving);
		rval = (u_char *) &StorageTmp->mtpM2paProving;
		break;
	case (u_char) MTPM2PAMANAGEMENTPROVINGSTATE:	/* Create */
		*write_method = write_mtpM2paManagementProvingState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paManagementProvingState);
		rval = (u_char *) &StorageTmp->mtpM2paManagementProvingState;
		break;
	case (u_char) MTPM2PAPROVINGATTEMPTS:	/* Create */
		*write_method = write_mtpM2paProvingAttempts;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paProvingAttempts);
		rval = (u_char *) &StorageTmp->mtpM2paProvingAttempts;
		break;
	case (u_char) MTPM2PASCTPNODELAY:	/* Create */
		*write_method = write_mtpM2paSctpNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpNoDelay);
		rval = (u_char *) &StorageTmp->mtpM2paSctpNoDelay;
		break;
	case (u_char) MTPM2PASCTPMAXSEG:	/* Create */
		*write_method = write_mtpM2paSctpMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxseg);
		rval = (u_char *) &StorageTmp->mtpM2paSctpMaxseg;
		break;
	case (u_char) MTPM2PASCTPHEARTBEATITVL:	/* Create */
		*write_method = write_mtpM2paSctpHeartbeatItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeatItvl);
		rval = (u_char *) &StorageTmp->mtpM2paSctpHeartbeatItvl;
		break;
	case (u_char) MTPM2PASCTPHEARTBEAT:	/* Create */
		*write_method = write_mtpM2paSctpHeartbeat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeat);
		rval = (u_char *) &StorageTmp->mtpM2paSctpHeartbeat;
		break;
	case (u_char) MTPM2PASCTPRTOINITIAL:	/* Create */
		*write_method = write_mtpM2paSctpRtoInitial;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoInitial);
		rval = (u_char *) &StorageTmp->mtpM2paSctpRtoInitial;
		break;
	case (u_char) MTPM2PASCTPRTOMIN:	/* Create */
		*write_method = write_mtpM2paSctpRtoMin;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMin);
		rval = (u_char *) &StorageTmp->mtpM2paSctpRtoMin;
		break;
	case (u_char) MTPM2PASCTPRTOMAX:	/* Create */
		*write_method = write_mtpM2paSctpRtoMax;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMax);
		rval = (u_char *) &StorageTmp->mtpM2paSctpRtoMax;
		break;
	case (u_char) MTPM2PASCTPPATHMAXRETRANS:	/* Create */
		*write_method = write_mtpM2paSctpPathMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpPathMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpM2paSctpPathMaxRetrans;
		break;
	case (u_char) MTPM2PASCTPCOOKIELIFE:	/* Create */
		*write_method = write_mtpM2paSctpCookieLife;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieLife);
		rval = (u_char *) &StorageTmp->mtpM2paSctpCookieLife;
		break;
	case (u_char) MTPM2PASCTPCOOKIEINC:	/* Create */
		*write_method = write_mtpM2paSctpCookieInc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieInc);
		rval = (u_char *) &StorageTmp->mtpM2paSctpCookieInc;
		break;
	case (u_char) MTPM2PASCTPMAXINITRETRIES:	/* Create */
		*write_method = write_mtpM2paSctpMaxInitRetries;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxInitRetries);
		rval = (u_char *) &StorageTmp->mtpM2paSctpMaxInitRetries;
		break;
	case (u_char) MTPM2PASCTPMAXBURST:	/* Create */
		*write_method = write_mtpM2paSctpMaxBurst;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxBurst);
		rval = (u_char *) &StorageTmp->mtpM2paSctpMaxBurst;
		break;
	case (u_char) MTPM2PASCTPASSOCMAXRETRANS:	/* Create */
		*write_method = write_mtpM2paSctpAssocMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpAssocMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpM2paSctpAssocMaxRetrans;
		break;
	case (u_char) MTPM2PASCTPSACKDELAY:	/* Create */
		*write_method = write_mtpM2paSctpSackDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpSackDelay);
		rval = (u_char *) &StorageTmp->mtpM2paSctpSackDelay;
		break;
	case (u_char) MTPM2PASCTPLIFETIME:	/* Create */
		*write_method = write_mtpM2paSctpLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpLifetime);
		rval = (u_char *) &StorageTmp->mtpM2paSctpLifetime;
		break;
	case (u_char) MTPM2PALOOPDELAYLOWER:	/* Create */
		*write_method = write_mtpM2paLoopDelayLower;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayLower);
		rval = (u_char *) &StorageTmp->mtpM2paLoopDelayLower;
		break;
	case (u_char) MTPM2PALOOPDELAYUPPER:	/* Create */
		*write_method = write_mtpM2paLoopDelayUpper;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayUpper);
		rval = (u_char *) &StorageTmp->mtpM2paLoopDelayUpper;
		break;
	case (u_char) MTPM2PATRANSMISSIONRATEINTERVALLOWER:	/* Create */
		*write_method = write_mtpM2paTransmissionRateIntervalLower;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalLower);
		rval = (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalLower;
		break;
	case (u_char) MTPM2PATRANSMISSIONRATEINTERVALUPPER:	/* Create */
		*write_method = write_mtpM2paTransmissionRateIntervalUpper;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalUpper);
		rval = (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalUpper;
		break;
	case (u_char) MTPM2PAROWSTATUS:	/* Create */
		*write_method = write_mtpM2paRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paRowStatus);
		rval = (u_char *) &StorageTmp->mtpM2paRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSdtTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSdtTable_request == sa_request))
		return;
	StorageTmp->mtpSdtTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSdtTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSdtTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSdtTable(int force)
{
	if (!force && mtpSdtTable_refresh == 0)
		return;
	mtpSdtTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSdtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSdtTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSdtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdtTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSdtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSdtTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSdtTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSdtTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSDTADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpSdtAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpSdtAdministrativeState;
		break;
	case (u_char) MTPSDTOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtOperationalState);
		rval = (u_char *) &StorageTmp->mtpSdtOperationalState;
		break;
	case (u_char) MTPSDTUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtUsageState);
		rval = (u_char *) &StorageTmp->mtpSdtUsageState;
		break;
	case (u_char) MTPSDTPROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdtProceduralStatusLen;
		rval = (u_char *) StorageTmp->mtpSdtProceduralStatus;
		break;
	case (u_char) MTPSDTAVAILABILITYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdtAvailabilityStatusLen;
		rval = (u_char *) StorageTmp->mtpSdtAvailabilityStatus;
		break;
	case (u_char) MTPSDTEQUIPMENTPOINTER:	/* Create */
		*write_method = write_mtpSdtEquipmentPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdtEquipmentPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSdtEquipmentPointer;
		break;
	case (u_char) MTPSDTNAME:	/* Create */
		*write_method = write_mtpSdtName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdtNameLen;
		rval = (u_char *) StorageTmp->mtpSdtName;
		break;
	case (u_char) MTPSDTSTANDBYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtStandbyStatus);
		rval = (u_char *) &StorageTmp->mtpSdtStandbyStatus;
		break;
	case (u_char) MTPSDTPRIMARYID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtPrimaryId);
		rval = (u_char *) &StorageTmp->mtpSdtPrimaryId;
		break;
	case (u_char) MTPSDTPROFILEPOINTER:	/* Create */
		*write_method = write_mtpSdtProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdtProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSdtProfilePointer;
		break;
	case (u_char) MTPSDTROWSTATUS:	/* Create */
		*write_method = write_mtpSdtRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtRowStatus);
		rval = (u_char *) &StorageTmp->mtpSdtRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSdlTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSdlTable_request == sa_request))
		return;
	StorageTmp->mtpSdlTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSdlTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSdlTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSdlTable(int force)
{
	if (!force && mtpSdlTable_refresh == 0)
		return;
	mtpSdlTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSdlTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSdlTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSdlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdlTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSdlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSdlTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSdlTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSdlTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSDLTYPE:	/* Create */
		*write_method = write_mtpSdlType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlType);
		rval = (u_char *) &StorageTmp->mtpSdlType;
		break;
	case (u_char) MTPSDLADJPC:	/* Create */
		*write_method = write_mtpSdlAdjPc;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlAdjPcLen;
		rval = (u_char *) StorageTmp->mtpSdlAdjPc;
		break;
	case (u_char) MTPSDLLOOPDELAY:	/* Create */
		*write_method = write_mtpSdlLoopDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlLoopDelay);
		rval = (u_char *) &StorageTmp->mtpSdlLoopDelay;
		break;
	case (u_char) MTPSDLOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlOperationalState);
		rval = (u_char *) &StorageTmp->mtpSdlOperationalState;
		break;
	case (u_char) MTPSDLEQUIPMENTPOINTER:	/* Create */
		*write_method = write_mtpSdlEquipmentPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlEquipmentPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSdlEquipmentPointer;
		break;
	case (u_char) MTPSDLCIC:	/* Create */
		*write_method = write_mtpSdlCIC;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlCIC);
		rval = (u_char *) &StorageTmp->mtpSdlCIC;
		break;
	case (u_char) MTPSDLTRANSMISSIONRATE:	/* Create */
		*write_method = write_mtpSdlTransmissionRate;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlTransmissionRate);
		rval = (u_char *) &StorageTmp->mtpSdlTransmissionRate;
		break;
	case (u_char) MTPSDLSTMCHANNEL:	/* Create */
		*write_method = write_mtpSdlStmChannel;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlStmChannelLen;
		rval = (u_char *) StorageTmp->mtpSdlStmChannel;
		break;
	case (u_char) MTPSDLVCTTPPOINTER:	/* Create */
		*write_method = write_mtpSdlVcTTpPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlVcTTpPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSdlVcTTpPointer;
		break;
	case (u_char) MTPSDLSCTPPOINTER:	/* Create */
		*write_method = write_mtpSdlSctpPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlSctpPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSdlSctpPointer;
		break;
	case (u_char) MTPSDLNAME:	/* Create */
		*write_method = write_mtpSdlName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlNameLen;
		rval = (u_char *) StorageTmp->mtpSdlName;
		break;
	case (u_char) MTPSDLROWSTATUS:	/* Create */
		*write_method = write_mtpSdlRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlRowStatus);
		rval = (u_char *) &StorageTmp->mtpSdlRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSctpProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSctpProfileTable_request == sa_request))
		return;
	StorageTmp->mtpSctpProfileTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSctpProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSctpProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSctpProfileTable(int force)
{
	if (!force && mtpSctpProfileTable_refresh == 0)
		return;
	mtpSctpProfileTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSctpProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSctpProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSctpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSctpProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSctpProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSctpProfileTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSctpProfileTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSCTPPROFILENODELAY:	/* Create */
		*write_method = write_mtpSctpProfileNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileNoDelay);
		rval = (u_char *) &StorageTmp->mtpSctpProfileNoDelay;
		break;
	case (u_char) MTPSCTPPROFILEMAXSEG:	/* Create */
		*write_method = write_mtpSctpProfileMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileMaxseg);
		rval = (u_char *) &StorageTmp->mtpSctpProfileMaxseg;
		break;
	case (u_char) MTPSCTPPROFILEHEARTBEATITVL:	/* Create */
		*write_method = write_mtpSctpProfileHeartbeatItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileHeartbeatItvl);
		rval = (u_char *) &StorageTmp->mtpSctpProfileHeartbeatItvl;
		break;
	case (u_char) MTPSCTPPROFILEHEARTBEAT:	/* Create */
		*write_method = write_mtpSctpProfileHeartbeat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileHeartbeat);
		rval = (u_char *) &StorageTmp->mtpSctpProfileHeartbeat;
		break;
	case (u_char) MTPSCTPPROFILERTOINITIAL:	/* Create */
		*write_method = write_mtpSctpProfileRtoInitial;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileRtoInitial);
		rval = (u_char *) &StorageTmp->mtpSctpProfileRtoInitial;
		break;
	case (u_char) MTPSCTPPROFILERTOMIN:	/* Create */
		*write_method = write_mtpSctpProfileRtoMin;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileRtoMin);
		rval = (u_char *) &StorageTmp->mtpSctpProfileRtoMin;
		break;
	case (u_char) MTPSCTPPROFILERTOMAX:	/* Create */
		*write_method = write_mtpSctpProfileRtoMax;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileRtoMax);
		rval = (u_char *) &StorageTmp->mtpSctpProfileRtoMax;
		break;
	case (u_char) MTPSCTPPROFILEPATHMAXRETRANS:	/* Create */
		*write_method = write_mtpSctpProfilePathMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfilePathMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpSctpProfilePathMaxRetrans;
		break;
	case (u_char) MTPSCTPPROFILECOOKIELIFE:	/* Create */
		*write_method = write_mtpSctpProfileCookieLife;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileCookieLife);
		rval = (u_char *) &StorageTmp->mtpSctpProfileCookieLife;
		break;
	case (u_char) MTPSCTPPROFILECOOKIEINC:	/* Create */
		*write_method = write_mtpSctpProfileCookieInc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileCookieInc);
		rval = (u_char *) &StorageTmp->mtpSctpProfileCookieInc;
		break;
	case (u_char) MTPSCTPPROFILEMAXINITRETRIES:	/* Create */
		*write_method = write_mtpSctpProfileMaxInitRetries;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileMaxInitRetries);
		rval = (u_char *) &StorageTmp->mtpSctpProfileMaxInitRetries;
		break;
	case (u_char) MTPSCTPPROFILEMAXBURST:	/* Create */
		*write_method = write_mtpSctpProfileMaxBurst;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileMaxBurst);
		rval = (u_char *) &StorageTmp->mtpSctpProfileMaxBurst;
		break;
	case (u_char) MTPSCTPPROFILEASSOCMAXRETRANS:	/* Create */
		*write_method = write_mtpSctpProfileAssocMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileAssocMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpSctpProfileAssocMaxRetrans;
		break;
	case (u_char) MTPSCTPPROFILESACKDELAY:	/* Create */
		*write_method = write_mtpSctpProfileSackDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileSackDelay);
		rval = (u_char *) &StorageTmp->mtpSctpProfileSackDelay;
		break;
	case (u_char) MTPSCTPPROFILELIFETIME:	/* Create */
		*write_method = write_mtpSctpProfileLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileLifetime);
		rval = (u_char *) &StorageTmp->mtpSctpProfileLifetime;
		break;
	case (u_char) MTPSCTPPROFILEMINOSTREAMS:	/* Create */
		*write_method = write_mtpSctpProfileMinOstreams;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileMinOstreams);
		rval = (u_char *) &StorageTmp->mtpSctpProfileMinOstreams;
		break;
	case (u_char) MTPSCTPPROFILEMAXISTREAMS:	/* Create */
		*write_method = write_mtpSctpProfileMaxIstreams;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileMaxIstreams);
		rval = (u_char *) &StorageTmp->mtpSctpProfileMaxIstreams;
		break;
	case (u_char) MTPSCTPPROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpSctpProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpSctpProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSctpTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSctpTable_request == sa_request))
		return;
	StorageTmp->mtpSctpTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSctpTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSctpTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSctpTable(int force)
{
	if (!force && mtpSctpTable_refresh == 0)
		return;
	mtpSctpTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSctpTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSctpTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSctpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSctpTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSctpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSctpTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSctpTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSctpTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSCTPADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpSctpAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpSctpAdministrativeState;
		break;
	case (u_char) MTPSCTPOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpOperationalState);
		rval = (u_char *) &StorageTmp->mtpSctpOperationalState;
		break;
	case (u_char) MTPSCTPUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpUsageState);
		rval = (u_char *) &StorageTmp->mtpSctpUsageState;
		break;
	case (u_char) MTPSCTPPROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSctpProceduralStatusLen;
		rval = (u_char *) StorageTmp->mtpSctpProceduralStatus;
		break;
	case (u_char) MTPSCTPLOCALPORT:	/* Create */
		*write_method = write_mtpSctpLocalPort;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpLocalPort);
		rval = (u_char *) &StorageTmp->mtpSctpLocalPort;
		break;
	case (u_char) MTPSCTPREMOTEPORT:	/* Create */
		*write_method = write_mtpSctpRemotePort;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpRemotePort);
		rval = (u_char *) &StorageTmp->mtpSctpRemotePort;
		break;
	case (u_char) MTPSCTPPROFILE:	/* Create */
		*write_method = write_mtpSctpProfile;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSctpProfileLen;
		rval = (u_char *) StorageTmp->mtpSctpProfile;
		break;
	case (u_char) MTPSCTPPROTOCOLPAYLOADID:	/* Create */
		*write_method = write_mtpSctpProtocolPayloadId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProtocolPayloadId);
		rval = (u_char *) &StorageTmp->mtpSctpProtocolPayloadId;
		break;
	case (u_char) MTPSCTPROWSTATUS:	/* Create */
		*write_method = write_mtpSctpRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpRowStatus);
		rval = (u_char *) &StorageTmp->mtpSctpRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSctpLocalTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSctpLocalTable_request == sa_request))
		return;
	StorageTmp->mtpSctpLocalTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSctpLocalTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSctpLocalTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSctpLocalTable(int force)
{
	if (!force && mtpSctpLocalTable_refresh == 0)
		return;
	mtpSctpLocalTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSctpLocalTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSctpLocalTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSctpLocalTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSctpLocalTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSctpLocalTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSctpLocalTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSctpLocalTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSctpLocalTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSCTPLOCALADDRESS:	/* Create */
		*write_method = write_mtpSctpLocalAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSctpLocalAddressLen;
		rval = (u_char *) StorageTmp->mtpSctpLocalAddress;
		break;
	case (u_char) MTPSCTPLOCALROWSTATUS:	/* Create */
		*write_method = write_mtpSctpLocalRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpLocalRowStatus);
		rval = (u_char *) &StorageTmp->mtpSctpLocalRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSctpRemoteTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSctpRemoteTable_request == sa_request))
		return;
	StorageTmp->mtpSctpRemoteTable_request = sa_request;
}

/**
 * @fn void refresh_mtpSctpRemoteTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSctpRemoteTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSctpRemoteTable(int force)
{
	if (!force && mtpSctpRemoteTable_refresh == 0)
		return;
	mtpSctpRemoteTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpSctpRemoteTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSctpRemoteTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSctpRemoteTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSctpRemoteTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSctpRemoteTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSctpRemoteTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpSctpRemoteTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpSctpRemoteTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSCTPREMOTEADDRESS:	/* Create */
		*write_method = write_mtpSctpRemoteAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSctpRemoteAddressLen;
		rval = (u_char *) StorageTmp->mtpSctpRemoteAddress;
		break;
	case (u_char) MTPSCTPREMOTEROWSTATUS:	/* Create */
		*write_method = write_mtpSctpRemoteRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpRemoteRowStatus);
		rval = (u_char *) &StorageTmp->mtpSctpRemoteRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpM2uaAspTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpM2uaAspTable_request == sa_request))
		return;
	StorageTmp->mtpM2uaAspTable_request = sa_request;
}

/**
 * @fn void refresh_mtpM2uaAspTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpM2uaAspTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM2uaAspTable(int force)
{
	if (!force && mtpM2uaAspTable_refresh == 0)
		return;
	mtpM2uaAspTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpM2uaAspTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpM2uaAspTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM2uaAspTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpM2uaAspTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpM2uaAspTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpM2uaAspTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpM2uaAspTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPM2UAASPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspState);
		rval = (u_char *) &StorageTmp->mtpM2uaAspState;
		break;
	case (u_char) MTPM2UAASPID:	/* Create */
		*write_method = write_mtpM2uaAspId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspId);
		rval = (u_char *) &StorageTmp->mtpM2uaAspId;
		break;
	case (u_char) MTPM2UAASPCAPABILITIES:	/* Create */
		*write_method = write_mtpM2uaAspCapabilities;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM2uaAspCapabilitiesLen;
		rval = (u_char *) StorageTmp->mtpM2uaAspCapabilities;
		break;
	case (u_char) MTPM2UAASPSGVERSION:	/* Create */
		*write_method = write_mtpM2uaAspSgVersion;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM2uaAspSgVersionLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpM2uaAspSgVersion;
		break;
	case (u_char) MTPM2UAASPSGOPTIONS:	/* Create */
		*write_method = write_mtpM2uaAspSgOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM2uaAspSgOptionsLen;
		rval = (u_char *) StorageTmp->mtpM2uaAspSgOptions;
		break;
	case (u_char) MTPM2UAASPSGREGISTRATIONPOLICY:	/* Create */
		*write_method = write_mtpM2uaAspSgRegistrationPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspSgRegistrationPolicy);
		rval = (u_char *) &StorageTmp->mtpM2uaAspSgRegistrationPolicy;
		break;
	case (u_char) MTPM2UAASPSGASPIDPOLICY:	/* Create */
		*write_method = write_mtpM2uaAspSgAspIdPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspSgAspIdPolicy);
		rval = (u_char *) &StorageTmp->mtpM2uaAspSgAspIdPolicy;
		break;
	case (u_char) MTPM2UAASPASSOCIATIONPOLICY:	/* Create */
		*write_method = write_mtpM2uaAspAssociationPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspAssociationPolicy);
		rval = (u_char *) &StorageTmp->mtpM2uaAspAssociationPolicy;
		break;
	case (u_char) MTPM2UAASPPROTOCOLPAYLOADID:	/* Create */
		*write_method = write_mtpM2uaAspProtocolPayloadId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspProtocolPayloadId);
		rval = (u_char *) &StorageTmp->mtpM2uaAspProtocolPayloadId;
		break;
	case (u_char) MTPM2UAASPROWSTATUS:	/* Create */
		*write_method = write_mtpM2uaAspRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspRowStatus);
		rval = (u_char *) &StorageTmp->mtpM2uaAspRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpM2uaAsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpM2uaAsTable_request == sa_request))
		return;
	StorageTmp->mtpM2uaAsTable_request = sa_request;
}

/**
 * @fn void refresh_mtpM2uaAsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpM2uaAsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM2uaAsTable(int force)
{
	if (!force && mtpM2uaAsTable_refresh == 0)
		return;
	mtpM2uaAsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpM2uaAsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpM2uaAsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM2uaAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM2uaAsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpM2uaAsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpM2uaAsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpM2uaAsTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpM2uaAsTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPM2UAASSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAsState);
		rval = (u_char *) &StorageTmp->mtpM2uaAsState;
		break;
	case (u_char) MTPM2UAASINTERFACEIDENTIFIER:	/* Create */
		*write_method = write_mtpM2uaAsInterfaceIdentifier;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAsInterfaceIdentifier);
		rval = (u_char *) &StorageTmp->mtpM2uaAsInterfaceIdentifier;
		break;
	case (u_char) MTPM2UAINTERFACEIDENTIFIERTEXT:	/* Create */
		*write_method = write_mtpM2uaInterfaceIdentifierText;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM2uaInterfaceIdentifierTextLen;
		rval = (u_char *) StorageTmp->mtpM2uaInterfaceIdentifierText;
		break;
	case (u_char) MTPM2UAASSDTI:	/* Create */
		*write_method = write_mtpM2uaAsSDTI;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAsSDTI);
		rval = (u_char *) &StorageTmp->mtpM2uaAsSDTI;
		break;
	case (u_char) MTPM2UAASTRAFFICMODE:	/* Create */
		*write_method = write_mtpM2uaAsTrafficMode;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM2uaAsTrafficModeLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpM2uaAsTrafficMode;
		break;
	case (u_char) MTPM2UAASROWSTATUS:	/* Create */
		*write_method = write_mtpM2uaAsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAsRowStatus);
		rval = (u_char *) &StorageTmp->mtpM2uaAsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpM3uaAspTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpM3uaAspTable_request == sa_request))
		return;
	StorageTmp->mtpM3uaAspTable_request = sa_request;
}

/**
 * @fn void refresh_mtpM3uaAspTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpM3uaAspTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM3uaAspTable(int force)
{
	if (!force && mtpM3uaAspTable_refresh == 0)
		return;
	mtpM3uaAspTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpM3uaAspTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpM3uaAspTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM3uaAspTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpM3uaAspTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpM3uaAspTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpM3uaAspTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpM3uaAspTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPM3UAASPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspState);
		rval = (u_char *) &StorageTmp->mtpM3uaAspState;
		break;
	case (u_char) MTPM3UAASTYPE:	/* Create */
		*write_method = write_mtpM3uaAsType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAsType);
		rval = (u_char *) &StorageTmp->mtpM3uaAsType;
		break;
	case (u_char) MTPM3UAASPID:	/* Create */
		*write_method = write_mtpM3uaAspId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspId);
		rval = (u_char *) &StorageTmp->mtpM3uaAspId;
		break;
	case (u_char) MTPM3UAASPCAPABILITIES:	/* Create */
		*write_method = write_mtpM3uaAspCapabilities;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM3uaAspCapabilitiesLen;
		rval = (u_char *) StorageTmp->mtpM3uaAspCapabilities;
		break;
	case (u_char) MTPM3UAASPSGVERSION:	/* Create */
		*write_method = write_mtpM3uaAspSgVersion;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM3uaAspSgVersionLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpM3uaAspSgVersion;
		break;
	case (u_char) MTPM3UAASPSGOPTIONS:	/* Create */
		*write_method = write_mtpM3uaAspSgOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM3uaAspSgOptionsLen;
		rval = (u_char *) StorageTmp->mtpM3uaAspSgOptions;
		break;
	case (u_char) MTPM3UAASPSGREGISTRATIONPOLICY:	/* Create */
		*write_method = write_mtpM3uaAspSgRegistrationPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspSgRegistrationPolicy);
		rval = (u_char *) &StorageTmp->mtpM3uaAspSgRegistrationPolicy;
		break;
	case (u_char) MTPM3UAASPSGASPIDPOLICY:	/* Create */
		*write_method = write_mtpM3uaAspSgAspIdPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspSgAspIdPolicy);
		rval = (u_char *) &StorageTmp->mtpM3uaAspSgAspIdPolicy;
		break;
	case (u_char) MTPM3UAASPASSOCIATIONPOLICY:	/* Create */
		*write_method = write_mtpM3uaAspAssociationPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspAssociationPolicy);
		rval = (u_char *) &StorageTmp->mtpM3uaAspAssociationPolicy;
		break;
	case (u_char) MTPM3UAASPPROTOCOLPAYLOADID:	/* Create */
		*write_method = write_mtpM3uaAspProtocolPayloadId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspProtocolPayloadId);
		rval = (u_char *) &StorageTmp->mtpM3uaAspProtocolPayloadId;
		break;
	case (u_char) MTPM3UAASPROWSTATUS:	/* Create */
		*write_method = write_mtpM3uaAspRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspRowStatus);
		rval = (u_char *) &StorageTmp->mtpM3uaAspRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpM3uaAsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpM3uaAsTable_request == sa_request))
		return;
	StorageTmp->mtpM3uaAsTable_request = sa_request;
}

/**
 * @fn void refresh_mtpM3uaAsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpM3uaAsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM3uaAsTable(int force)
{
	if (!force && mtpM3uaAsTable_refresh == 0)
		return;
	mtpM3uaAsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_mtpM3uaAsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpM3uaAsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM3uaAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM3uaAsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpM3uaAsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpM3uaAsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(mtpM3uaAsTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_mtpM3uaAsTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPM3UAASSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAsState);
		rval = (u_char *) &StorageTmp->mtpM3uaAsState;
		break;
	case (u_char) MTPM3UAASROUTINGCONTEXT:	/* Create */
		*write_method = write_mtpM3uaAsRoutingContext;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAsRoutingContext);
		rval = (u_char *) &StorageTmp->mtpM3uaAsRoutingContext;
		break;
	case (u_char) MTPM3UAASNETWORKAPPEARANCE:	/* Create */
		*write_method = write_mtpM3uaAsNetworkAppearance;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAsNetworkAppearance);
		rval = (u_char *) &StorageTmp->mtpM3uaAsNetworkAppearance;
		break;
	case (u_char) MTPM3UAASNETWORKPOINTCODE:	/* Create */
		*write_method = write_mtpM3uaAsNetworkPointCode;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM3uaAsNetworkPointCodeLen;
		rval = (u_char *) StorageTmp->mtpM3uaAsNetworkPointCode;
		break;
	case (u_char) MTPM3UAASTRAFFICMODE:	/* Create */
		*write_method = write_mtpM3uaAsTrafficMode;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM3uaAsTrafficModeLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpM3uaAsTrafficMode;
		break;
	case (u_char) MTPM3UAASROWSTATUS:	/* Create */
		*write_method = write_mtpM3uaAsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAsRowStatus);
		rval = (u_char *) &StorageTmp->mtpM3uaAsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_mtpSapUserPart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapUserPart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSapUserPart entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAPUSERPART_SNMM:
		case MTPSAPUSERPART_SNTM:
		case MTPSAPUSERPART_SNSM:
		case MTPSAPUSERPART_SCCP:
		case MTPSAPUSERPART_TUP:
		case MTPSAPUSERPART_ISUP:
		case MTPSAPUSERPART_DUP1:
		case MTPSAPUSERPART_DUP2:
		case MTPSAPUSERPART_MTUP:
		case MTPSAPUSERPART_BISUP:
		case MTPSAPUSERPART_SIUP:
		case MTPSAPUSERPART_SPNEUP:
		case MTPSAPUSERPART_STC:
		case MTPSAPUSERPART_USER13:
		case MTPSAPUSERPART_USER14:
		case MTPSAPUSERPART_USER15:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapUserPart for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpSapUserPart;
		StorageTmp->mtpSapUserPart = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapUserPart = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapUserPartStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapUserPartStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSapUserPartStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAPUSERPARTSTATUS_UNKNOWN:
		case MTPSAPUSERPARTSTATUS_INACCESSIBLE:
		case MTPSAPUSERPARTSTATUS_UNEQUIPPED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapUserPartStatus for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSapUserPartStatus;
		StorageTmp->mtpSapUserPartStatus = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapUserPartStatus = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapProviderEntityNames entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapProviderEntityNames for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSapProviderEntityNames;
		old_length = StorageTmp->mtpSapProviderEntityNamesLen;
		StorageTmp->mtpSapProviderEntityNames = objid;
		StorageTmp->mtpSapProviderEntityNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapProviderEntityNames = old_value;
		StorageTmp->mtpSapProviderEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapAsaProfilePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSapAsaProfilePointer;
		old_length = StorageTmp->mtpSapAsaProfilePointerLen;
		StorageTmp->mtpSapAsaProfilePointer = objid;
		StorageTmp->mtpSapAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapAsaProfilePointer = old_value;
		StorageTmp->mtpSapAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSapName;
		old_length = StorageTmp->mtpSapNameLen;
		StorageTmp->mtpSapName = string;
		StorageTmp->mtpSapNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapName = old_value;
		StorageTmp->mtpSapNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapLongMessageSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapLongMessageSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSapLongMessageSupported entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapLongMessageSupported for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSapLongMessageSupported;
		StorageTmp->mtpSapLongMessageSupported = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapLongMessageSupported = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolVariant entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 14..15 */
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid) || ((14 * sizeof(oid) > var_val_len || var_val_len > 15 * sizeof(oid)))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { OPENSS7-SS7-MIB : ss7ProtocolItut 0 } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaProtocolVariant for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaProtocolVariant;
		old_length = StorageTmp->mtpNaProtocolVariantLen;
		StorageTmp->mtpNaProtocolVariant = objid;
		StorageTmp->mtpNaProtocolVariantLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolVariant = old_value;
		StorageTmp->mtpNaProtocolVariantLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaProtocolYear(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaProtocolYear(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolYear entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value yCurrent */
		switch (set_value) {
		case MTPNAPROTOCOLYEAR_YCURRENT:
		case MTPNAPROTOCOLYEAR_Y1980:
		case MTPNAPROTOCOLYEAR_Y1984:
		case MTPNAPROTOCOLYEAR_Y1988:
		case MTPNAPROTOCOLYEAR_Y1992:
		case MTPNAPROTOCOLYEAR_Y1996:
		case MTPNAPROTOCOLYEAR_Y2000:
		case MTPNAPROTOCOLYEAR_Y2004:
		case MTPNAPROTOCOLYEAR_Y2008:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaProtocolYear for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaProtocolYear;
		StorageTmp->mtpNaProtocolYear = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolYear = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaProtocolOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaProtocolOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolOptions entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 4) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { mtpfCongInt , mtpfLinkOsc , mtpfGws , mtpfEGws , mtpfBGws , mtpfLinkStAlloc } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaProtocolOptions for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaProtocolOptions;
		old_length = StorageTmp->mtpNaProtocolOptionsLen;
		StorageTmp->mtpNaProtocolOptions = string;
		StorageTmp->mtpNaProtocolOptionsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolOptions = old_value;
		StorageTmp->mtpNaProtocolOptionsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNaNetworkIndicator entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internationalNetwork1 */
		switch (set_value) {
		case MTPNANETWORKINDICATOR_INTERNATIONALNETWORK1:
		case MTPNANETWORKINDICATOR_INTERNATIONALNETWORK2:
		case MTPNANETWORKINDICATOR_NATIONALNETWORK1:
		case MTPNANETWORKINDICATOR_NATIONALNETWORK2:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaNetworkIndicator for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaNetworkIndicator;
		StorageTmp->mtpNaNetworkIndicator = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaNetworkIndicator = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaPointCodeFormat entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 3..3 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 3)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '030803'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaPointCodeFormat for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaPointCodeFormat;
		old_length = StorageTmp->mtpNaPointCodeFormatLen;
		StorageTmp->mtpNaPointCodeFormat = string;
		StorageTmp->mtpNaPointCodeFormatLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaPointCodeFormat = old_value;
		StorageTmp->mtpNaPointCodeFormatLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaSlsLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaSlsLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNaSlsLength entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value sls4bits */
		switch (set_value) {
		case MTPNASLSLENGTH_SLS4BITS:
		case MTPNASLSLENGTH_SLS5BITS:
		case MTPNASLSLENGTH_SLS8BITS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaSlsLength for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaSlsLength;
		StorageTmp->mtpNaSlsLength = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaSlsLength = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaSpDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaSpDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaSpDefault entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaSpDefault for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpNaSpDefault;
		old_length = StorageTmp->mtpNaSpDefaultLen;
		StorageTmp->mtpNaSpDefault = string;
		StorageTmp->mtpNaSpDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaSpDefault = old_value;
		StorageTmp->mtpNaSpDefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpNaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpNaName;
		old_length = StorageTmp->mtpNaNameLen;
		StorageTmp->mtpNaName = string;
		StorageTmp->mtpNaNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaName = old_value;
		StorageTmp->mtpNaNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpMsName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpMsName;
		old_length = StorageTmp->mtpMsNameLen;
		StorageTmp->mtpMsName = string;
		StorageTmp->mtpMsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsName = old_value;
		StorageTmp->mtpMsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsAlarmStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpMsAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsAlarmStatus;
		old_length = StorageTmp->mtpMsAlarmStatusLen;
		StorageTmp->mtpMsAlarmStatus = string;
		StorageTmp->mtpMsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsAlarmStatus = old_value;
		StorageTmp->mtpMsAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsUserLabel entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpMsUserLabel for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsUserLabel;
		old_length = StorageTmp->mtpMsUserLabelLen;
		StorageTmp->mtpMsUserLabel = string;
		StorageTmp->mtpMsUserLabelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsUserLabel = old_value;
		StorageTmp->mtpMsUserLabelLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsAsaProfilePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpMsAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsAsaProfilePointer;
		old_length = StorageTmp->mtpMsAsaProfilePointerLen;
		StorageTmp->mtpMsAsaProfilePointer = objid;
		StorageTmp->mtpMsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsAsaProfilePointer = old_value;
		StorageTmp->mtpMsAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpMsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsNetworkElementAliases entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpMsNetworkElementAliases for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpMsNetworkElementAliases;
		old_length = StorageTmp->mtpMsNetworkElementAliasesLen;
		StorageTmp->mtpMsNetworkElementAliases = string;
		StorageTmp->mtpMsNetworkElementAliasesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMsNetworkElementAliases = old_value;
		StorageTmp->mtpMsNetworkElementAliasesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT1R(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT1R(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT1R entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT1R for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT1R;
		StorageTmp->mtpSpProfileTimerT1R = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT1R = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT2 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 140 */
		/* Note: ranges 70..200 */
		if ((70 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT2 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT2;
		StorageTmp->mtpSpProfileTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT4 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT4 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT4;
		StorageTmp->mtpSpProfileTimerT4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT5 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT5 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT5;
		StorageTmp->mtpSpProfileTimerT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT7 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 150 */
		/* Note: ranges 100..200 */
		if ((100 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT7 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT7;
		StorageTmp->mtpSpProfileTimerT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT11 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 3000..9000 */
		if ((3000 > set_value || set_value > 9000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT11 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT11;
		StorageTmp->mtpSpProfileTimerT11 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT11 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT12 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 120 */
		/* Note: ranges 80..150 */
		if ((80 > set_value || set_value > 150)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT12 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT12;
		StorageTmp->mtpSpProfileTimerT12 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT12 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT13 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 120 */
		/* Note: ranges 80..150 */
		if ((80 > set_value || set_value > 150)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT13 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT13;
		StorageTmp->mtpSpProfileTimerT13 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT13 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT14 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 250 */
		/* Note: ranges 200..300 */
		if ((200 > set_value || set_value > 300)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT14 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT14;
		StorageTmp->mtpSpProfileTimerT14 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT14 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT15 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 250 */
		/* Note: ranges 200..300 */
		if ((200 > set_value || set_value > 300)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT15 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT15;
		StorageTmp->mtpSpProfileTimerT15 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT15 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT16 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 140..200 */
		if ((140 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT16 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT16;
		StorageTmp->mtpSpProfileTimerT16 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT16 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT18I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT18I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT18I entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT18I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT18I;
		StorageTmp->mtpSpProfileTimerT18I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT18I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT19I entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6800 */
		/* Note: ranges 6700..6900 */
		if ((6700 > set_value || set_value > 6900)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT19I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT19I;
		StorageTmp->mtpSpProfileTimerT19I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT19I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT20I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT20I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT20I entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 5900..6100 */
		if ((5900 > set_value || set_value > 6100)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT20I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT20I;
		StorageTmp->mtpSpProfileTimerT20I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT20I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT21I entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6400 */
		/* Note: ranges 6300..6500 */
		if ((6300 > set_value || set_value > 6500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT21I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT21I;
		StorageTmp->mtpSpProfileTimerT21I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT21I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT22I entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT22I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT22I;
		StorageTmp->mtpSpProfileTimerT22I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT22I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT23I entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT23I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT23I;
		StorageTmp->mtpSpProfileTimerT23I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT23I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT20A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT20A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT20A;
		StorageTmp->mtpSpProfileTimerT20A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT20A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT21A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT21A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT21A;
		StorageTmp->mtpSpProfileTimerT21A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT21A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT22A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT22A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT22A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT22A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT22A;
		StorageTmp->mtpSpProfileTimerT22A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT22A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT23A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT23A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT23A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT23A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT23A;
		StorageTmp->mtpSpProfileTimerT23A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT23A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT24A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT24A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT24A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT24A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT24A;
		StorageTmp->mtpSpProfileTimerT24A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT24A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT26A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT26A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT26A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1350 */
		/* Note: ranges 1200..1500 */
		if ((1200 > set_value || set_value > 1500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT26A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT26A;
		StorageTmp->mtpSpProfileTimerT26A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT26A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT27A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT27A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT27A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 300 */
		/* Note: ranges 200..500 */
		if ((200 > set_value || set_value > 500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT27A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT27A;
		StorageTmp->mtpSpProfileTimerT27A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT27A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT1T entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 400 */
		/* Note: ranges 400..1200 */
		if ((400 > set_value || set_value > 1200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT1T for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT1T;
		StorageTmp->mtpSpProfileTimerT1T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT1T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT2T entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 3000..9000 */
		if ((3000 > set_value || set_value > 9000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT2T for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileTimerT2T;
		StorageTmp->mtpSpProfileTimerT2T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT2T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileName;
		old_length = StorageTmp->mtpSpProfileNameLen;
		StorageTmp->mtpSpProfileName = string;
		StorageTmp->mtpSpProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileName = old_value;
		StorageTmp->mtpSpProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileCircularRteDetect(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileCircularRteDetect(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileCircularRteDetect entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileCircularRteDetect: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileCircularRteDetect not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileCircularRteDetect: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value none */
		switch (set_value) {
		case MTPSPPROFILECIRCULARRTEDETECT_NONE:
		case MTPSPPROFILECIRCULARRTEDETECT_CONGESTEDLINKOFLINKSET:
		case MTPSPPROFILECIRCULARRTEDETECT_CONGESTEDLINKOFNONCLINKSET:
		case MTPSPPROFILECIRCULARRTEDETECT_NEWROUTEFORROUTESET:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileCircularRteDetect: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileCircularRteDetect for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfileCircularRteDetect;
		StorageTmp->mtpSpProfileCircularRteDetect = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileCircularRteDetect = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpPointCode entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '00000000'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpPointCode for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpPointCode;
		old_length = StorageTmp->mtpSpPointCodeLen;
		StorageTmp->mtpSpPointCode = string;
		StorageTmp->mtpSpPointCodeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpPointCode = old_value;
		StorageTmp->mtpSpPointCodeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpType entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value sep */
		switch (set_value) {
		case MTPSPTYPE_SEP:
		case MTPSPTYPE_STEP:
		case MTPSPTYPE_STP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpType for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSpType;
		StorageTmp->mtpSpType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpVersion entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 'ITU-T Q.704 1996' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpVersion for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSpVersion;
		old_length = StorageTmp->mtpSpVersionLen;
		StorageTmp->mtpSpVersion = string;
		StorageTmp->mtpSpVersionLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpVersion = old_value;
		StorageTmp->mtpSpVersionLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSpNetworkIndicator entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internationalNetwork1 */
		switch (set_value) {
		case MTPSPNETWORKINDICATOR_INTERNATIONALNETWORK1:
		case MTPSPNETWORKINDICATOR_INTERNATIONALNETWORK2:
		case MTPSPNETWORKINDICATOR_NATIONALNETWORK1:
		case MTPSPNETWORKINDICATOR_NATIONALNETWORK2:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpNetworkIndicator for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpNetworkIndicator;
		StorageTmp->mtpSpNetworkIndicator = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpNetworkIndicator = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSpName;
		old_length = StorageTmp->mtpSpNameLen;
		StorageTmp->mtpSpName = string;
		StorageTmp->mtpSpNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpName = old_value;
		StorageTmp->mtpSpNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfilePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpProfilePointer;
		old_length = StorageTmp->mtpSpProfilePointerLen;
		StorageTmp->mtpSpProfilePointer = string;
		StorageTmp->mtpSpProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfilePointer = old_value;
		StorageTmp->mtpSpProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpNaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpNaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpNaPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpNaPointer for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpNaPointer;
		old_length = StorageTmp->mtpSpNaPointerLen;
		StorageTmp->mtpSpNaPointer = objid;
		StorageTmp->mtpSpNaPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpNaPointer = old_value;
		StorageTmp->mtpSpNaPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpOptions entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpOptions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { spfSecurity } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpOptions for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSpOptions;
		old_length = StorageTmp->mtpSpOptionsLen;
		StorageTmp->mtpSpOptions = string;
		StorageTmp->mtpSpOptionsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpOptions = old_value;
		StorageTmp->mtpSpOptionsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpUsers(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpUsers(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpUsers entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { sccp , isup , mtup } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpUsers for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSpUsers;
		old_length = StorageTmp->mtpSpUsersLen;
		StorageTmp->mtpSpUsers = string;
		StorageTmp->mtpSpUsersLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpUsers = old_value;
		StorageTmp->mtpSpUsersLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpAlarmStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSpAlarmStatus;
		old_length = StorageTmp->mtpSpAlarmStatusLen;
		StorageTmp->mtpSpAlarmStatus = string;
		StorageTmp->mtpSpAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpAlarmStatus = old_value;
		StorageTmp->mtpSpAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpL3AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpL3Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpL3AdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpL3RowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPL3ADMINISTRATIVESTATE_LOCKED:
		case MTPL3ADMINISTRATIVESTATE_UNLOCKED:
		case MTPL3ADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpL3AdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpL3AdministrativeState;
		StorageTmp->mtpL3AdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL3AdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3AsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpL3AsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpL3Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpL3AsaProfilePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpL3RowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpL3AsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpL3AsaProfilePointer;
		old_length = StorageTmp->mtpL3AsaProfilePointerLen;
		StorageTmp->mtpL3AsaProfilePointer = objid;
		StorageTmp->mtpL3AsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL3AsaProfilePointer = old_value;
		StorageTmp->mtpL3AsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpL3Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpL3Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpL3Name entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpL3RowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpL3Name for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpL3Name;
		old_length = StorageTmp->mtpL3NameLen;
		StorageTmp->mtpL3Name = string;
		StorageTmp->mtpL3NameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL3Name = old_value;
		StorageTmp->mtpL3NameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPGSADMINISTRATIVESTATE_LOCKED:
		case MTPGSADMINISTRATIVESTATE_UNLOCKED:
		case MTPGSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsAdministrativeState;
		StorageTmp->mtpGsAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsTreatmentOfOutsideRanges(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsTreatmentOfOutsideRanges(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsTreatmentOfOutsideRanges entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value normal */
		switch (set_value) {
		case MTPGSTREATMENTOFOUTSIDERANGES_NORMAL:
		case MTPGSTREATMENTOFOUTSIDERANGES_DISCARD:
		case MTPGSTREATMENTOFOUTSIDERANGES_PROHIBIT:
		case MTPGSTREATMENTOFOUTSIDERANGES_UNEQUIPPED:
		case MTPGSTREATMENTOFOUTSIDERANGES_INACCESSIBLE:
		case MTPGSTREATMENTOFOUTSIDERANGES_CONGEST:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsTreatmentOfOutsideRanges for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsTreatmentOfOutsideRanges;
		StorageTmp->mtpGsTreatmentOfOutsideRanges = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsTreatmentOfOutsideRanges = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsListMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsListMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsListMode entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsListMode for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsListMode;
		StorageTmp->mtpGsListMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsListMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsScreeningByLinkSetOrByOpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsScreeningByLinkSetOrByOpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsScreeningByLinkSetOrByOpc entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value byOpc */
		switch (set_value) {
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYOPC:
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYINCOMINGLINKSET:
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYOUTGOINGLINKSET:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsScreeningByLinkSetOrByOpc for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsScreeningByLinkSetOrByOpc;
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsGetScreenedOpcsOrLinkSetsByDpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsGetScreenedOpcsOrLinkSetsByDpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsGetScreenedOpcsOrLinkSetsByDpc entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SUCCESS:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_UNSUCCESSFUL:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_NOTPERFORMED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_LINKALREADYINHIBITED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_LINKNOTINHIBITED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_WRONGCLASSREFERENCED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SIGNTERMNONEXISTING:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SIGNTERMALREADYREFERENCED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpGsName;
		old_length = StorageTmp->mtpGsNameLen;
		StorageTmp->mtpGsName = string;
		StorageTmp->mtpGsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsName = old_value;
		StorageTmp->mtpGsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpGsLineTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineObject entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineObject for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineObject;
		old_length = StorageTmp->mtpGsLineObjectLen;
		StorageTmp->mtpGsLineObject = objid;
		StorageTmp->mtpGsLineObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineObject = old_value;
		StorageTmp->mtpGsLineObjectLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpGsLineTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContent entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContent for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContent;
		StorageTmp->mtpGsLineContent = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContent = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentDesignatedDPCFirst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentDesignatedDPCFirst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentDesignatedDPCFirst entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '00000000'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContentDesignatedDPCFirst for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContentDesignatedDPCFirst;
		old_length = StorageTmp->mtpGsLineContentDesignatedDPCFirstLen;
		StorageTmp->mtpGsLineContentDesignatedDPCFirst = string;
		StorageTmp->mtpGsLineContentDesignatedDPCFirstLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentDesignatedDPCFirst = old_value;
		StorageTmp->mtpGsLineContentDesignatedDPCFirstLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentDesignatedDPCLast(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentDesignatedDPCLast(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentDesignatedDPCLast entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '00000000'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContentDesignatedDPCLast for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContentDesignatedDPCLast;
		old_length = StorageTmp->mtpGsLineContentDesignatedDPCLastLen;
		StorageTmp->mtpGsLineContentDesignatedDPCLast = string;
		StorageTmp->mtpGsLineContentDesignatedDPCLastLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentDesignatedDPCLast = old_value;
		StorageTmp->mtpGsLineContentDesignatedDPCLastLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentSiMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentSiMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentSiMask entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8191 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContentSiMask for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContentSiMask;
		old_length = StorageTmp->mtpGsLineContentSiMaskLen;
		StorageTmp->mtpGsLineContentSiMask = string;
		StorageTmp->mtpGsLineContentSiMaskLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentSiMask = old_value;
		StorageTmp->mtpGsLineContentSiMaskLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentMessageTreatment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentMessageTreatment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentMessageTreatment entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value normal */
		switch (set_value) {
		case MTPGSLINECONTENTMESSAGETREATMENT_NORMAL:
		case MTPGSLINECONTENTMESSAGETREATMENT_DISCARD:
		case MTPGSLINECONTENTMESSAGETREATMENT_PROHIBIT:
		case MTPGSLINECONTENTMESSAGETREATMENT_UNEQUIPPED:
		case MTPGSLINECONTENTMESSAGETREATMENT_INACCESSIBLE:
		case MTPGSLINECONTENTMESSAGETREATMENT_CONGEST:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContentMessageTreatment for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContentMessageTreatment;
		StorageTmp->mtpGsLineContentMessageTreatment = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentMessageTreatment = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentComment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentComment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentComment entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContentComment for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpGsLineContentComment;
		old_length = StorageTmp->mtpGsLineContentCommentLen;
		StorageTmp->mtpGsLineContentComment = string;
		StorageTmp->mtpGsLineContentCommentLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentComment = old_value;
		StorageTmp->mtpGsLineContentCommentLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileName;
		old_length = StorageTmp->mtpRsProfileNameLen;
		StorageTmp->mtpRsProfileName = string;
		StorageTmp->mtpRsProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileName = old_value;
		StorageTmp->mtpRsProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT8 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 80..120 */
		if ((80 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileTimerT8 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT8;
		StorageTmp->mtpRsProfileTimerT8 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT8 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT11 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 3000..9000 */
		if ((3000 > set_value || set_value > 9000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileTimerT11 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT11;
		StorageTmp->mtpRsProfileTimerT11 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT11 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT15 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 250 */
		/* Note: ranges 200..300 */
		if ((200 > set_value || set_value > 300)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileTimerT15 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT15;
		StorageTmp->mtpRsProfileTimerT15 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT15 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT16 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 175 */
		/* Note: ranges 140..200 */
		if ((140 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileTimerT16 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT16;
		StorageTmp->mtpRsProfileTimerT16 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT16 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT18A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT18A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT18A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1200 */
		/* Note: ranges 200..2000 */
		if ((200 > set_value || set_value > 2000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileTimerT18A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileTimerT18A;
		StorageTmp->mtpRsProfileTimerT18A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT18A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileRtDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileRtDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileRtDefault entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileRtDefault for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfileRtDefault;
		old_length = StorageTmp->mtpRsProfileRtDefaultLen;
		StorageTmp->mtpRsProfileRtDefault = string;
		StorageTmp->mtpRsProfileRtDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileRtDefault = old_value;
		StorageTmp->mtpRsProfileRtDefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsDest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsDest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsDest entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '00000000'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsDest for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpRsDest;
		old_length = StorageTmp->mtpRsDestLen;
		StorageTmp->mtpRsDest = string;
		StorageTmp->mtpRsDestLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsDest = old_value;
		StorageTmp->mtpRsDestLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsOptions entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsOptions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { rsfSecurity } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsOptions for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpRsOptions;
		old_length = StorageTmp->mtpRsOptionsLen;
		StorageTmp->mtpRsOptions = string;
		StorageTmp->mtpRsOptionsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsOptions = old_value;
		StorageTmp->mtpRsOptionsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPRSADMINISTRATIVESTATE_LOCKED:
		case MTPRSADMINISTRATIVESTATE_UNLOCKED:
		case MTPRSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsAdministrativeState;
		StorageTmp->mtpRsAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAsaProfilePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsAsaProfilePointer;
		old_length = StorageTmp->mtpRsAsaProfilePointerLen;
		StorageTmp->mtpRsAsaProfilePointer = objid;
		StorageTmp->mtpRsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAsaProfilePointer = old_value;
		StorageTmp->mtpRsAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsLoadsharingInformation entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsLoadsharingInformation for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsLoadsharingInformation;
		old_length = StorageTmp->mtpRsLoadsharingInformationLen;
		StorageTmp->mtpRsLoadsharingInformation = string;
		StorageTmp->mtpRsLoadsharingInformationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsLoadsharingInformation = old_value;
		StorageTmp->mtpRsLoadsharingInformationLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsLoadsharingObject entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsLoadsharingObject for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsLoadsharingObject;
		old_length = StorageTmp->mtpRsLoadsharingObjectLen;
		StorageTmp->mtpRsLoadsharingObject = objid;
		StorageTmp->mtpRsLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsLoadsharingObject = old_value;
		StorageTmp->mtpRsLoadsharingObjectLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsRemoteExchangeLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsRemoteExchangeLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsRemoteExchangeLabel entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsRemoteExchangeLabel for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsRemoteExchangeLabel;
		old_length = StorageTmp->mtpRsRemoteExchangeLabelLen;
		StorageTmp->mtpRsRemoteExchangeLabel = string;
		StorageTmp->mtpRsRemoteExchangeLabelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsRemoteExchangeLabel = old_value;
		StorageTmp->mtpRsRemoteExchangeLabelLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpRsName;
		old_length = StorageTmp->mtpRsNameLen;
		StorageTmp->mtpRsName = string;
		StorageTmp->mtpRsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsName = old_value;
		StorageTmp->mtpRsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfile entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfile for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpRsProfile;
		old_length = StorageTmp->mtpRsProfileLen;
		StorageTmp->mtpRsProfile = string;
		StorageTmp->mtpRsProfileLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfile = old_value;
		StorageTmp->mtpRsProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAlarmStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRsAlarmStatus;
		old_length = StorageTmp->mtpRsAlarmStatusLen;
		StorageTmp->mtpRsAlarmStatus = string;
		StorageTmp->mtpRsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAlarmStatus = old_value;
		StorageTmp->mtpRsAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfileTimerT6 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtProfileTimerT6 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtProfileTimerT6;
		StorageTmp->mtpRtProfileTimerT6 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfileTimerT6 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfileTimerT10 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4500 */
		/* Note: ranges 3000..6000 */
		if ((3000 > set_value || set_value > 6000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtProfileTimerT10 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtProfileTimerT10;
		StorageTmp->mtpRtProfileTimerT10 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfileTimerT10 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLsPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLsPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtLsPointer for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtLsPointer;
		old_length = StorageTmp->mtpRtLsPointerLen;
		StorageTmp->mtpRtLsPointer = objid;
		StorageTmp->mtpRtLsPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLsPointer = old_value;
		StorageTmp->mtpRtLsPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPRTADMINISTRATIVESTATE_LOCKED:
		case MTPRTADMINISTRATIVESTATE_UNLOCKED:
		case MTPRTADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtAdministrativeState;
		StorageTmp->mtpRtAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtInClsLoadsharingAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtInClsLoadsharingAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtInClsLoadsharingAlgorithm entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 16 */
		/* Note: ranges 0..0 16..16 32..32 256..256 */
		if (set_value != 0 && set_value != 16 && set_value != 32 && set_value != 256) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtInClsLoadsharingAlgorithm for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtInClsLoadsharingAlgorithm;
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtFixedPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtFixedPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtFixedPriority entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtFixedPriority for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtFixedPriority;
		StorageTmp->mtpRtFixedPriority = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFixedPriority = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtFlexiblePriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtFlexiblePriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtFlexiblePriority entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtFlexiblePriority for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtFlexiblePriority;
		StorageTmp->mtpRtFlexiblePriority = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFlexiblePriority = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtPriorityMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtPriorityMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtPriorityMode entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPRTPRIORITYMODE_INSERT:
		case MTPRTPRIORITYMODE_EQUAL:
		case MTPRTPRIORITYMODE_EXCHANGESINGLE:
		case MTPRTPRIORITYMODE_EXCHANGEGROUP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtPriorityMode for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtPriorityMode;
		StorageTmp->mtpRtPriorityMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtPriorityMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLoadsharingInformation entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtLoadsharingInformation for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtLoadsharingInformation;
		old_length = StorageTmp->mtpRtLoadsharingInformationLen;
		StorageTmp->mtpRtLoadsharingInformation = string;
		StorageTmp->mtpRtLoadsharingInformationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLoadsharingInformation = old_value;
		StorageTmp->mtpRtLoadsharingInformationLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLoadsharingObject entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtLoadsharingObject for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtLoadsharingObject;
		old_length = StorageTmp->mtpRtLoadsharingObjectLen;
		StorageTmp->mtpRtLoadsharingObject = objid;
		StorageTmp->mtpRtLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLoadsharingObject = old_value;
		StorageTmp->mtpRtLoadsharingObjectLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpRtName;
		old_length = StorageTmp->mtpRtNameLen;
		StorageTmp->mtpRtName = string;
		StorageTmp->mtpRtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtName = old_value;
		StorageTmp->mtpRtNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtSlsList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtSlsList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtSlsList entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..0 2..2 4..4 32..32 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 0 && var_val_len != 2 && var_val_len != 4 && var_val_len != 32)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtSlsList for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpRtSlsList;
		old_length = StorageTmp->mtpRtSlsListLen;
		StorageTmp->mtpRtSlsList = string;
		StorageTmp->mtpRtSlsListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtSlsList = old_value;
		StorageTmp->mtpRtSlsListLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtRlSlot(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtRlSlot(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtRlSlot entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..3 */
		if ((0 > set_value || set_value > 3)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtRlSlot for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpRtRlSlot;
		StorageTmp->mtpRtRlSlot = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtRlSlot = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfile entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtProfile for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpRtProfile;
		old_length = StorageTmp->mtpRtProfileLen;
		StorageTmp->mtpRtProfile = string;
		StorageTmp->mtpRtProfileLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfile = old_value;
		StorageTmp->mtpRtProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLsaNormalSlCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLsaNormalSlCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsaNormalSlCode entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..15 */
		if ((0 > set_value || set_value > 15)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtLsaNormalSlCode for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtLsaNormalSlCode;
		StorageTmp->mtpRtLsaNormalSlCode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLsaNormalSlCode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLsaAlternativeSlCodeList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLsaAlternativeSlCodeList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsaAlternativeSlCodeList entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaAlternativeSlCodeList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..15 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 15))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaAlternativeSlCodeList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtLsaAlternativeSlCodeList for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpRtLsaAlternativeSlCodeList;
		old_length = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
		StorageTmp->mtpRtLsaAlternativeSlCodeList = string;
		StorageTmp->mtpRtLsaAlternativeSlCodeListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLsaAlternativeSlCodeList = old_value;
		StorageTmp->mtpRtLsaAlternativeSlCodeListLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT6 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT6 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT6;
		StorageTmp->mtpLsProfileTimerT6 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT6 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT8 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 80..120 */
		if ((80 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT8 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT8;
		StorageTmp->mtpLsProfileTimerT8 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT8 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT10 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4500 */
		/* Note: ranges 3000..6000 */
		if ((3000 > set_value || set_value > 6000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT10 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT10;
		StorageTmp->mtpLsProfileTimerT10 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT10 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT7 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 150 */
		/* Note: ranges 100..200 */
		if ((100 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT7 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT7;
		StorageTmp->mtpLsProfileTimerT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT19I entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6800 */
		/* Note: ranges 6700..6900 */
		if ((6700 > set_value || set_value > 6900)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT19I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT19I;
		StorageTmp->mtpLsProfileTimerT19I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT19I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT21I entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT21I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT21I;
		StorageTmp->mtpLsProfileTimerT21I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT21I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT25A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT25A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT25A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* Note: ranges 3000..3500 */
		if ((3000 > set_value || set_value > 3500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT25A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT25A;
		StorageTmp->mtpLsProfileTimerT25A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT25A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT28A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT28A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT28A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2000 */
		/* Note: ranges 300..3500 */
		if ((300 > set_value || set_value > 3500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT28A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT28A;
		StorageTmp->mtpLsProfileTimerT28A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT28A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT29A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT29A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT29A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 6000..6500 */
		if ((6000 > set_value || set_value > 6500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT29A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT29A;
		StorageTmp->mtpLsProfileTimerT29A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT29A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT30A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT30A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT30A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* Note: ranges 3000..3500 */
		if ((3000 > set_value || set_value > 3500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT30A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileTimerT30A;
		StorageTmp->mtpLsProfileTimerT30A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT30A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileParameterN(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileParameterN(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileParameterN entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterN: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterN not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterN: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 50 */
		/* Note: ranges 50..200 */
		if ((50 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterN: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileParameterN for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileParameterN;
		StorageTmp->mtpLsProfileParameterN = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileParameterN = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileParameterM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileParameterM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileParameterM entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterM: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterM not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3 */
		/* Note: ranges 3..10 */
		if ((3 > set_value || set_value > 10)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterM: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileParameterM for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileParameterM;
		StorageTmp->mtpLsProfileParameterM = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileParameterM = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileName;
		old_length = StorageTmp->mtpLsProfileNameLen;
		StorageTmp->mtpLsProfileName = string;
		StorageTmp->mtpLsProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileName = old_value;
		StorageTmp->mtpLsProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileSlDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileSlDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileSlDefault entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileSlDefault for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfileSlDefault;
		old_length = StorageTmp->mtpLsProfileSlDefaultLen;
		StorageTmp->mtpLsProfileSlDefault = string;
		StorageTmp->mtpLsProfileSlDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileSlDefault = old_value;
		StorageTmp->mtpLsProfileSlDefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAdjPc entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '00000000'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsAdjPc for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpLsAdjPc;
		old_length = StorageTmp->mtpLsAdjPcLen;
		StorageTmp->mtpLsAdjPc = string;
		StorageTmp->mtpLsAdjPcLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAdjPc = old_value;
		StorageTmp->mtpLsAdjPcLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsRsId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsRsId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsRsId entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsRsId for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpLsRsId;
		old_length = StorageTmp->mtpLsRsIdLen;
		StorageTmp->mtpLsRsId = objid;
		StorageTmp->mtpLsRsIdLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsRsId = old_value;
		StorageTmp->mtpLsRsIdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsMaxCapacity entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..128000 */
		if ((0 > set_value || set_value > 128000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsMaxCapacity for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsMaxCapacity;
		StorageTmp->mtpLsMaxCapacity = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsMaxCapacity = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsCongestionControlMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsCongestionControlMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsCongestionControlMethod entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value ccmQ704International */
		switch (set_value) {
		case MTPLSCONGESTIONCONTROLMETHOD_UNKNOWN:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704INTERNATIONAL:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALWITHPRIO:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALNOPRIOBUFFERMECHANISM:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALNOPRIOTIMERMECHANISM:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsCongestionControlMethod for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsCongestionControlMethod;
		StorageTmp->mtpLsCongestionControlMethod = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCongestionControlMethod = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsPeriodicLinkTestFlag(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsPeriodicLinkTestFlag(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsPeriodicLinkTestFlag entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value on */
		switch (set_value) {
		case MTPLSPERIODICLINKTESTFLAG_ON:
		case MTPLSPERIODICLINKTESTFLAG_OFF:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsPeriodicLinkTestFlag for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsPeriodicLinkTestFlag;
		StorageTmp->mtpLsPeriodicLinkTestFlag = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsPeriodicLinkTestFlag = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsPeriodicLinkTestFail(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsPeriodicLinkTestFail(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsPeriodicLinkTestFail entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsPeriodicLinkTestFail for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsPeriodicLinkTestFail;
		StorageTmp->mtpLsPeriodicLinkTestFail = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsPeriodicLinkTestFail = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPLSADMINISTRATIVESTATE_LOCKED:
		case MTPLSADMINISTRATIVESTATE_UNLOCKED:
		case MTPLSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsAdministrativeState;
		StorageTmp->mtpLsAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsInLsLoadShareAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsInLsLoadShareAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsInLsLoadShareAlgorithm entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { defaultInLsLoadShareAlgorithm } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsInLsLoadShareAlgorithm for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsInLsLoadShareAlgorithm;
		old_length = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
		StorageTmp->mtpLsInLsLoadShareAlgorithm = objid;
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsInLsLoadShareAlgorithm = old_value;
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfilePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsProfilePointer;
		old_length = StorageTmp->mtpLsProfilePointerLen;
		StorageTmp->mtpLsProfilePointer = string;
		StorageTmp->mtpLsProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfilePointer = old_value;
		StorageTmp->mtpLsProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsNumberOfNormallyActiveSignLinks(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsNumberOfNormallyActiveSignLinks(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpLsNumberOfNormallyActiveSignLinks entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		/* Note: ranges 0..32 */
		if ((0 > set_value || set_value > 32)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsNumberOfNormallyActiveSignLinks for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsNumberOfNormallyActiveSignLinks;
		StorageTmp->mtpLsNumberOfNormallyActiveSignLinks = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsNumberOfNormallyActiveSignLinks = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpLsName;
		old_length = StorageTmp->mtpLsNameLen;
		StorageTmp->mtpLsName = string;
		StorageTmp->mtpLsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsName = old_value;
		StorageTmp->mtpLsNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAsaProfilePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsAsaProfilePointer;
		old_length = StorageTmp->mtpLsAsaProfilePointerLen;
		StorageTmp->mtpLsAsaProfilePointer = objid;
		StorageTmp->mtpLsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAsaProfilePointer = old_value;
		StorageTmp->mtpLsAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpLsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAlarmStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpLsAlarmStatus;
		old_length = StorageTmp->mtpLsAlarmStatusLen;
		StorageTmp->mtpLsAlarmStatus = string;
		StorageTmp->mtpLsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAlarmStatus = old_value;
		StorageTmp->mtpLsAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT1 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT1;
		StorageTmp->mtpSlL3ProfileTimerT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT3 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT3 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT3;
		StorageTmp->mtpSlL3ProfileTimerT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT17 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 120 */
		/* Note: ranges 80..150 */
		if ((80 > set_value || set_value > 150)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT17 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT17;
		StorageTmp->mtpSlL3ProfileTimerT17 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT17 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT24I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT24I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT24I entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 50 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT24I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT24I;
		StorageTmp->mtpSlL3ProfileTimerT24I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT24I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileName;
		old_length = StorageTmp->mtpSlL3ProfileNameLen;
		StorageTmp->mtpSlL3ProfileName = string;
		StorageTmp->mtpSlL3ProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileName = old_value;
		StorageTmp->mtpSlL3ProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT2 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 140 */
		/* Note: ranges 70..200 */
		if ((70 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT2 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT2;
		StorageTmp->mtpSlL3ProfileTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT4 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT4 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT4;
		StorageTmp->mtpSlL3ProfileTimerT4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT5 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT5 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT5;
		StorageTmp->mtpSlL3ProfileTimerT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT12 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 120 */
		/* Note: ranges 80..150 */
		if ((80 > set_value || set_value > 150)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT12 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT12;
		StorageTmp->mtpSlL3ProfileTimerT12 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT12 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT13 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 120 */
		/* Note: ranges 80..150 */
		if ((80 > set_value || set_value > 150)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT13 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT13;
		StorageTmp->mtpSlL3ProfileTimerT13 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT13 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT14 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 250 */
		/* Note: ranges 200..300 */
		if ((200 > set_value || set_value > 300)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT14 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT14;
		StorageTmp->mtpSlL3ProfileTimerT14 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT14 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT19A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 54000 */
		/* Note: ranges 48000..60000 */
		if ((48000 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT19A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT19A;
		StorageTmp->mtpSlL3ProfileTimerT19A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT19A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT20A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT20A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT20A;
		StorageTmp->mtpSlL3ProfileTimerT20A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT20A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT21A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT21A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT21A;
		StorageTmp->mtpSlL3ProfileTimerT21A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT21A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT22I entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT22I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT22I;
		StorageTmp->mtpSlL3ProfileTimerT22I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT22I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT23I entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT23I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT23I;
		StorageTmp->mtpSlL3ProfileTimerT23I = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT23I = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT31A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 1000..12000 */
		if ((1000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT31A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT31A;
		StorageTmp->mtpSlL3ProfileTimerT31A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT31A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT32A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT32A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT32A;
		StorageTmp->mtpSlL3ProfileTimerT32A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT32A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT33A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 36000 */
		/* Note: ranges 6000..60000 */
		if ((6000 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT33A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT33A;
		StorageTmp->mtpSlL3ProfileTimerT33A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT33A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT34A entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT34A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT34A;
		StorageTmp->mtpSlL3ProfileTimerT34A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT34A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1T entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 400 */
		/* Note: ranges 400..1200 */
		if ((400 > set_value || set_value > 1200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT1T for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT1T;
		StorageTmp->mtpSlL3ProfileTimerT1T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT2T entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 3000..9000 */
		if ((3000 > set_value || set_value > 9000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT2T for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT2T;
		StorageTmp->mtpSlL3ProfileTimerT2T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT2T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1S entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 400 */
		/* Note: ranges 400..1200 */
		if ((400 > set_value || set_value > 1200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT1S for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileTimerT1S;
		StorageTmp->mtpSlL3ProfileTimerT1S = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1S = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileL2Default(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileL2Default(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileL2Default entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileL2Default for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfileL2Default;
		old_length = StorageTmp->mtpSlL3ProfileL2DefaultLen;
		StorageTmp->mtpSlL3ProfileL2Default = string;
		StorageTmp->mtpSlL3ProfileL2DefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileL2Default = old_value;
		StorageTmp->mtpSlL3ProfileL2DefaultLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileErrorCorrectionMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileErrorCorrectionMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileErrorCorrectionMethod entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value basicRetr */
		switch (set_value) {
		case MTPSLL2PROFILEERRORCORRECTIONMETHOD_BASICRETR:
		case MTPSLL2PROFILEERRORCORRECTIONMETHOD_PREVCYCLRETR:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileErrorCorrectionMethod for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileErrorCorrectionMethod;
		StorageTmp->mtpSlL2ProfileErrorCorrectionMethod = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileErrorCorrectionMethod = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileProtocolVariant entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileProtocolVariant: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileProtocolVariant not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 14..15 */
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid) || ((14 * sizeof(oid) > var_val_len || var_val_len > 15 * sizeof(oid)))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileProtocolVariant: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { OPENSS7-SS7-MIB : ss7ProtocolItut 0 } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileProtocolVariant for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileProtocolVariant;
		old_length = StorageTmp->mtpSlL2ProfileProtocolVariantLen;
		StorageTmp->mtpSlL2ProfileProtocolVariant = objid;
		StorageTmp->mtpSlL2ProfileProtocolVariantLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileProtocolVariant = old_value;
		StorageTmp->mtpSlL2ProfileProtocolVariantLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT1 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4500 */
		/* Note: ranges 1290..60000 */
		if ((1290 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT1 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT1;
		StorageTmp->mtpSlL2ProfileTimerT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		/* Note: ranges 500..15000 */
		if ((500 > set_value || set_value > 15000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT2 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT2;
		StorageTmp->mtpSlL2ProfileTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT2L(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT2L(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2L entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2000 */
		/* Note: ranges 500..5000 */
		if ((500 > set_value || set_value > 5000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT2L for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT2L;
		StorageTmp->mtpSlL2ProfileTimerT2L = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2L = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT2H(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT2H(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2H entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 7000..15000 */
		if ((7000 > set_value || set_value > 15000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT2H for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT2H;
		StorageTmp->mtpSlL2ProfileTimerT2H = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2H = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT3 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 100..1400 */
		if ((100 > set_value || set_value > 1400)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT3 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT3;
		StorageTmp->mtpSlL2ProfileTimerT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT4N(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT4N(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT4N entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 800 */
		/* Note: ranges 230..12000 */
		if ((230 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT4N for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT4N;
		StorageTmp->mtpSlL2ProfileTimerT4N = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT4N = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT4E(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT4E(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT4E entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 50 */
		/* Note: ranges 40..800 */
		if ((40 > set_value || set_value > 800)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT4E for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT4E;
		StorageTmp->mtpSlL2ProfileTimerT4E = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT4E = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT5 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 8..12 */
		if ((8 > set_value || set_value > 12)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT5 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT5;
		StorageTmp->mtpSlL2ProfileTimerT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT6 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4000 */
		/* Note: ranges 300..1200 */
		if ((300 > set_value || set_value > 1200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT6 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT6;
		StorageTmp->mtpSlL2ProfileTimerT6 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT6 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT7 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* Note: ranges 50..600 */
		if ((50 > set_value || set_value > 600)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT7 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerT7;
		StorageTmp->mtpSlL2ProfileTimerT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbOnset1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbOnset1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset1 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 69632 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbOnset1 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbOnset1;
		StorageTmp->mtpSlL2ProfileTbOnset1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbAbate1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbAbate1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate1 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 34816 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbAbate1 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbAbate1;
		StorageTmp->mtpSlL2ProfileTbAbate1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileNumberOfThresholdLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileNumberOfThresholdLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileNumberOfThresholdLevels entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels;
		StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileCongestionCounting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileCongestionCounting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileCongestionCounting entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value octet */
		switch (set_value) {
		case MTPSLL2PROFILECONGESTIONCOUNTING_OCTET:
		case MTPSLL2PROFILECONGESTIONCOUNTING_MESSAGE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileCongestionCounting for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileCongestionCounting;
		StorageTmp->mtpSlL2ProfileCongestionCounting = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileCongestionCounting = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileCongestionReportingBaseObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileCongestionReportingBaseObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileCongestionReportingBaseObject entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value routeSet */
		switch (set_value) {
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_ROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_LINKSETOFCONGESTEDROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_LINKOFCONGESTEDROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_CONGESTEDLINKOFCONGESTEDROUTE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject;
		StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileLoopDelay entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileLoopDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileLoopDelay;
		StorageTmp->mtpSlL2ProfileLoopDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileLoopDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileName;
		old_length = StorageTmp->mtpSlL2ProfileNameLen;
		StorageTmp->mtpSlL2ProfileName = string;
		StorageTmp->mtpSlL2ProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileName = old_value;
		StorageTmp->mtpSlL2ProfileNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbOnset2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbOnset2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset2 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 174080 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbOnset2 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbOnset2;
		StorageTmp->mtpSlL2ProfileTbOnset2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbAbate2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbAbate2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate2 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 139264 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbAbate2 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbAbate2;
		StorageTmp->mtpSlL2ProfileTbAbate2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbOnset3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbOnset3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset3 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 278528 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbOnset3 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbOnset3;
		StorageTmp->mtpSlL2ProfileTbOnset3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbAbate3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbAbate3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate3 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 243712 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbAbate3 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbAbate3;
		StorageTmp->mtpSlL2ProfileTbAbate3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbDiscard1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbDiscard1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard1 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 104448 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbDiscard1 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbDiscard1;
		StorageTmp->mtpSlL2ProfileTbDiscard1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbDiscard2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbDiscard2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard2 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 208896 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbDiscard2 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbDiscard2;
		StorageTmp->mtpSlL2ProfileTbDiscard2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbDiscard3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbDiscard3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard3 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 313344 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbDiscard3 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTbDiscard3;
		StorageTmp->mtpSlL2ProfileTbDiscard3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerTx(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerTx(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerTx entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerTx for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerTx;
		StorageTmp->mtpSlL2ProfileTimerTx = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerTx = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerTy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerTy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerTy entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerTy for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileTimerTy;
		StorageTmp->mtpSlL2ProfileTimerTy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerTy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileNumberOfCongestionStates(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileNumberOfCongestionStates(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileNumberOfCongestionStates entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileNumberOfCongestionStates for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileNumberOfCongestionStates;
		StorageTmp->mtpSlL2ProfileNumberOfCongestionStates = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileNumberOfCongestionStates = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileInitialLevelOfCongestion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileInitialLevelOfCongestion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileInitialLevelOfCongestion entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion;
		StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileMaxMSUsRetransN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileMaxMSUsRetransN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileMaxMSUsRetransN1 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 127 */
		/* Note: ranges 0..16777215 */
		if ((0 > set_value || set_value > 16777215)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1;
		StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileMaxOctRetransN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileMaxOctRetransN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileMaxOctRetransN2 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8192 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileMaxOctRetransN2 for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileMaxOctRetransN2;
		StorageTmp->mtpSlL2ProfileMaxOctRetransN2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileMaxOctRetransN2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileReceiveCongestionThresholdOnset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileReceiveCongestionThresholdOnset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdOnset entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset for you to use, and you have just been asked to do something with it.
				   Note that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileReceiveCongestionThresholdAbate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileReceiveCongestionThresholdAbate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdAbate entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate for you to use, and you have just been asked to do something with it.
				   Note that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileReceiveCongestionThresholdDiscard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileReceiveCongestionThresholdDiscard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdDiscard entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 9 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard for you to use, and you have just been asked to do something with it.
				   Note that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileM entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileM for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL2ProfileM;
		StorageTmp->mtpSlL2ProfileM = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileM = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPSLADMINISTRATIVESTATE_LOCKED:
		case MTPSLADMINISTRATIVESTATE_UNLOCKED:
		case MTPSLADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlAdministrativeState;
		StorageTmp->mtpSlAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlMtpL2ProtocolProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlMtpL2ProtocolProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlMtpL2ProtocolProfilePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlMtpL2ProtocolProfilePointer for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlMtpL2ProtocolProfilePointer;
		old_length = StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen;
		StorageTmp->mtpSlMtpL2ProtocolProfilePointer = string;
		StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlMtpL2ProtocolProfilePointer = old_value;
		StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSignTermPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSignTermPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSignTermPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSignTermPointer for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSignTermPointer;
		old_length = StorageTmp->mtpSlSignTermPointerLen;
		StorageTmp->mtpSlSignTermPointer = objid;
		StorageTmp->mtpSlSignTermPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSignTermPointer = old_value;
		StorageTmp->mtpSlSignTermPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSignDataLinkTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSignDataLinkTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSignDataLinkTpPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSignDataLinkTpPointer for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSignDataLinkTpPointer;
		old_length = StorageTmp->mtpSlSignDataLinkTpPointerLen;
		StorageTmp->mtpSlSignDataLinkTpPointer = objid;
		StorageTmp->mtpSlSignDataLinkTpPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSignDataLinkTpPointer = old_value;
		StorageTmp->mtpSlSignDataLinkTpPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlLocalInhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlLocalInhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlLocalInhibit entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLLOCALINHIBIT_SUCCESS:
		case MTPSLLOCALINHIBIT_UNSUCCESSFUL:
		case MTPSLLOCALINHIBIT_NOTPERFORMED:
		case MTPSLLOCALINHIBIT_LINKALREADYINHIBITED:
		case MTPSLLOCALINHIBIT_LINKNOTINHIBITED:
		case MTPSLLOCALINHIBIT_WRONGCLASSREFERENCED:
		case MTPSLLOCALINHIBIT_SIGNTERMNONEXISTING:
		case MTPSLLOCALINHIBIT_SIGNTERMALREADYREFERENCED:
		case MTPSLLOCALINHIBIT_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlLocalInhibit for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlLocalInhibit;
		StorageTmp->mtpSlLocalInhibit = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalInhibit = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlLocalUninhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlLocalUninhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlLocalUninhibit entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLLOCALUNINHIBIT_SUCCESS:
		case MTPSLLOCALUNINHIBIT_UNSUCCESSFUL:
		case MTPSLLOCALUNINHIBIT_NOTPERFORMED:
		case MTPSLLOCALUNINHIBIT_LINKALREADYINHIBITED:
		case MTPSLLOCALUNINHIBIT_LINKNOTINHIBITED:
		case MTPSLLOCALUNINHIBIT_WRONGCLASSREFERENCED:
		case MTPSLLOCALUNINHIBIT_SIGNTERMNONEXISTING:
		case MTPSLLOCALUNINHIBIT_SIGNTERMALREADYREFERENCED:
		case MTPSLLOCALUNINHIBIT_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlLocalUninhibit for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlLocalUninhibit;
		StorageTmp->mtpSlLocalUninhibit = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalUninhibit = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlReplaceSt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlReplaceSt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlReplaceSt entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLREPLACEST_SUCCESS:
		case MTPSLREPLACEST_UNSUCCESSFUL:
		case MTPSLREPLACEST_NOTPERFORMED:
		case MTPSLREPLACEST_LINKALREADYINHIBITED:
		case MTPSLREPLACEST_LINKNOTINHIBITED:
		case MTPSLREPLACEST_WRONGCLASSREFERENCED:
		case MTPSLREPLACEST_SIGNTERMNONEXISTING:
		case MTPSLREPLACEST_SIGNTERMALREADYREFERENCED:
		case MTPSLREPLACEST_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlReplaceSt for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlReplaceSt;
		StorageTmp->mtpSlReplaceSt = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlReplaceSt = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAsaProfilePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlAsaProfilePointer;
		old_length = StorageTmp->mtpSlAsaProfilePointerLen;
		StorageTmp->mtpSlAsaProfilePointer = objid;
		StorageTmp->mtpSlAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAsaProfilePointer = old_value;
		StorageTmp->mtpSlAsaProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlRelatedLinkGroupNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlRelatedLinkGroupNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlRelatedLinkGroupNumber entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..15 */
		if ((0 > set_value || set_value > 15)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlRelatedLinkGroupNumber for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlRelatedLinkGroupNumber;
		StorageTmp->mtpSlRelatedLinkGroupNumber = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlRelatedLinkGroupNumber = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdlList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdlList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdlList entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSdlList for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSdlList;
		StorageTmp->mtpSlSdlList = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdlList = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlTest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlTest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlTest entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLTEST_SUCCESS:
		case MTPSLTEST_UNSUCCESSFUL:
		case MTPSLTEST_NOTPERFORMED:
		case MTPSLTEST_LINKALREADYINHIBITED:
		case MTPSLTEST_LINKNOTINHIBITED:
		case MTPSLTEST_WRONGCLASSREFERENCED:
		case MTPSLTEST_SIGNTERMNONEXISTING:
		case MTPSLTEST_SIGNTERMALREADYREFERENCED:
		case MTPSLTEST_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlTest for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSlTest;
		StorageTmp->mtpSlTest = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlTest = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSlName;
		old_length = StorageTmp->mtpSlNameLen;
		StorageTmp->mtpSlName = string;
		StorageTmp->mtpSlNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlName = old_value;
		StorageTmp->mtpSlNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdtList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdtList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdtList entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSdtList for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSdtList;
		StorageTmp->mtpSlSdtList = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdtList = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSlsCodeNormalList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSlsCodeNormalList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSlsCodeNormalList entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..0 2..2 4..4 32..32 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 0 && var_val_len != 2 && var_val_len != 4 && var_val_len != 32)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 'FFFF'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSlsCodeNormalList for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSlsCodeNormalList;
		old_length = StorageTmp->mtpSlSlsCodeNormalListLen;
		StorageTmp->mtpSlSlsCodeNormalList = string;
		StorageTmp->mtpSlSlsCodeNormalListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSlsCodeNormalList = old_value;
		StorageTmp->mtpSlSlsCodeNormalListLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfilePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlL3ProfilePointer;
		old_length = StorageTmp->mtpSlL3ProfilePointerLen;
		StorageTmp->mtpSlL3ProfilePointer = string;
		StorageTmp->mtpSlL3ProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfilePointer = old_value;
		StorageTmp->mtpSlL3ProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAlarmStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlAlarmStatus;
		old_length = StorageTmp->mtpSlAlarmStatusLen;
		StorageTmp->mtpSlAlarmStatus = string;
		StorageTmp->mtpSlAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAlarmStatus = old_value;
		StorageTmp->mtpSlAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdlListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdlListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdlListPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlSdlListRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSdlListPointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSdlListPointer;
		old_length = StorageTmp->mtpSlSdlListPointerLen;
		StorageTmp->mtpSlSdlListPointer = objid;
		StorageTmp->mtpSlSdlListPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdlListPointer = old_value;
		StorageTmp->mtpSlSdlListPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdtListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdtListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdtListPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlSdtListRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSdtListPointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSlSdtListPointer;
		old_length = StorageTmp->mtpSlSdtListPointerLen;
		StorageTmp->mtpSlSdtListPointer = objid;
		StorageTmp->mtpSlSdtListPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdtListPointer = old_value;
		StorageTmp->mtpSlSdtListPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTransmissionRate entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value kbits64 */
		switch (set_value) {
		case MTPNBTRANSMISSIONRATE_KBITS4POINT8:
		case MTPNBTRANSMISSIONRATE_KBITS56:
		case MTPNBTRANSMISSIONRATE_KBITS64:
		case MTPNBTRANSMISSIONRATE_KBITS1544:
		case MTPNBTRANSMISSIONRATE_KBITS2048:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNbTransmissionRate for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpNbTransmissionRate;
		StorageTmp->mtpNbTransmissionRate = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTransmissionRate = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbf(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbf(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpNbTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpNbf entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value one */
		switch (set_value) {
		case MTPNBF_ONE:
		case MTPNBF_SHARED:
		case MTPNBF_TWO:
		case MTPNBF_THREE:
		case MTPNBF_FOUR:
		case MTPNBF_FIVE:
		case MTPNBF_SIX:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNbf for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpNbf;
		StorageTmp->mtpNbf = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbf = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalBufferRelease(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalBufferRelease(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalBufferRelease entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalBufferRelease for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalBufferRelease;
		StorageTmp->mtpSaalBufferRelease = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalBufferRelease = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxCc entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxCc for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxCc;
		StorageTmp->mtpSaalMaxCc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxCc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxNrp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxNrp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxNrp entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxNrp for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxNrp;
		StorageTmp->mtpSaalMaxNrp = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxNrp = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxInformationFieldLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxInformationFieldLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxInformationFieldLength entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4096 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxInformationFieldLength for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxInformationFieldLength;
		StorageTmp->mtpSaalMaxInformationFieldLength = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxInformationFieldLength = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxLengthSscopUuField(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxLengthSscopUuField(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxLengthSscopUuField entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxLengthSscopUuField for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxLengthSscopUuField;
		StorageTmp->mtpSaalMaxLengthSscopUuField = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxLengthSscopUuField = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxPd(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxPd(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxPd entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxPd for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxPd;
		StorageTmp->mtpSaalMaxPd = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxPd = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxSscopCreditToPeer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxSscopCreditToPeer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxSscopCreditToPeer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 128 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxSscopCreditToPeer for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxSscopCreditToPeer;
		StorageTmp->mtpSaalMaxSscopCreditToPeer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxSscopCreditToPeer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxStat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxStat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxStat entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 67 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxStat for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalMaxStat;
		StorageTmp->mtpSaalMaxStat = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxStat = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalN1 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalN1 for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalN1;
		StorageTmp->mtpSaalN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniLayerManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniLayerManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementProvingState entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value neutral */
		switch (set_value) {
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_NORMAL:
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_EMERGENCY:
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_NEUTRAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniLayerManagementProvingState for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniLayerManagementProvingState;
		StorageTmp->mtpSaalNniLayerManagementProvingState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementProvingState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniLayerManagementTimerNoCredit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniLayerManagementTimerNoCredit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementTimerNoCredit entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniLayerManagementTimerNoCredit for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniLayerManagementTimerRepeatSrec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniLayerManagementTimerRepeatSrec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementTimerRepeatSrec entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT1 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniTimerT1 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniTimerT1;
		StorageTmp->mtpSaalNniTimerT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT2 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniTimerT2 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniTimerT2;
		StorageTmp->mtpSaalNniTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT3 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniTimerT3 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalNniTimerT3;
		StorageTmp->mtpSaalNniTimerT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerCc entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalSscopTimerCc for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerCc;
		StorageTmp->mtpSaalSscopTimerCc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerCc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerIdle entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalSscopTimerIdle for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerIdle;
		StorageTmp->mtpSaalSscopTimerIdle = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerIdle = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerKeepAlive entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalSscopTimerKeepAlive for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerKeepAlive;
		StorageTmp->mtpSaalSscopTimerKeepAlive = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerKeepAlive = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerNoResponse(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerNoResponse(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerNoResponse entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 150 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalSscopTimerNoResponse for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerNoResponse;
		StorageTmp->mtpSaalSscopTimerNoResponse = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerNoResponse = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerPoll(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerPoll(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerPoll entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalSscopTimerPoll for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalSscopTimerPoll;
		StorageTmp->mtpSaalSscopTimerPoll = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerPoll = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalTransmissionRateIntervalLower entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 129 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalTransmissionRateIntervalLower for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalTransmissionRateIntervalLower;
		StorageTmp->mtpSaalTransmissionRateIntervalLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalTransmissionRateIntervalUpper entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalTransmissionRateIntervalUpper for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalEgressTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalEgressTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalEgressTransmissionRateIntervalLower entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 129 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalEgressTransmissionRateIntervalLower for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalEgressTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalEgressTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalEgressTransmissionRateIntervalUpper entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalPollAfterRetransmission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalPollAfterRetransmission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSaalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalPollAfterRetransmission entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalPollAfterRetransmission for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSaalPollAfterRetransmission;
		StorageTmp->mtpSaalPollAfterRetransmission = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalPollAfterRetransmission = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paN1 entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paN1 for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paN1;
		StorageTmp->mtpM2paN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paProving(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paProving(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paProving entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paProving for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paProving;
		StorageTmp->mtpM2paProving = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProving = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paManagementProvingState entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value neutral */
		switch (set_value) {
		case MTPM2PAMANAGEMENTPROVINGSTATE_NORMAL:
		case MTPM2PAMANAGEMENTPROVINGSTATE_EMERGENCY:
		case MTPM2PAMANAGEMENTPROVINGSTATE_NEUTRAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paManagementProvingState for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paManagementProvingState;
		StorageTmp->mtpM2paManagementProvingState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paManagementProvingState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paProvingAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paProvingAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paProvingAttempts entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paProvingAttempts for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paProvingAttempts;
		StorageTmp->mtpM2paProvingAttempts = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProvingAttempts = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpNoDelay entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpNoDelay for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpNoDelay;
		StorageTmp->mtpM2paSctpNoDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpNoDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxseg entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		if ((1 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpMaxseg for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpMaxseg;
		StorageTmp->mtpM2paSctpMaxseg = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxseg = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpHeartbeatItvl entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpHeartbeatItvl for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpHeartbeatItvl;
		StorageTmp->mtpM2paSctpHeartbeatItvl = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeatItvl = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpHeartbeat entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpHeartbeat for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpHeartbeat;
		StorageTmp->mtpM2paSctpHeartbeat = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeat = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoInitial entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpRtoInitial for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpRtoInitial;
		StorageTmp->mtpM2paSctpRtoInitial = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoInitial = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoMin entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpRtoMin for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpRtoMin;
		StorageTmp->mtpM2paSctpRtoMin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoMax entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpRtoMax for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpRtoMax;
		StorageTmp->mtpM2paSctpRtoMax = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMax = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpPathMaxRetrans entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpPathMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpPathMaxRetrans;
		StorageTmp->mtpM2paSctpPathMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpPathMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpCookieLife entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpCookieLife for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpCookieLife;
		StorageTmp->mtpM2paSctpCookieLife = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieLife = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpCookieInc entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpCookieInc for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpCookieInc;
		StorageTmp->mtpM2paSctpCookieInc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieInc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxInitRetries entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpMaxInitRetries for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpMaxInitRetries;
		StorageTmp->mtpM2paSctpMaxInitRetries = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxInitRetries = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxBurst entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpMaxBurst for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpMaxBurst;
		StorageTmp->mtpM2paSctpMaxBurst = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxBurst = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpAssocMaxRetrans entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpAssocMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpAssocMaxRetrans;
		StorageTmp->mtpM2paSctpAssocMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpAssocMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpSackDelay entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..500 */
		if ((0 > set_value || set_value > 500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpSackDelay for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpSackDelay;
		StorageTmp->mtpM2paSctpSackDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpSackDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpLifetime entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpLifetime for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paSctpLifetime;
		StorageTmp->mtpM2paSctpLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paLoopDelayLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paLoopDelayLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paLoopDelayLower entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paLoopDelayLower for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paLoopDelayLower;
		StorageTmp->mtpM2paLoopDelayLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paLoopDelayUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paLoopDelayUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paLoopDelayUpper entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 600 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paLoopDelayUpper for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paLoopDelayUpper;
		StorageTmp->mtpM2paLoopDelayUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paTransmissionRateIntervalLower entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1544000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paTransmissionRateIntervalLower for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paTransmissionRateIntervalLower;
		StorageTmp->mtpM2paTransmissionRateIntervalLower = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalLower = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2paTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paTransmissionRateIntervalUpper entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 155000000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paTransmissionRateIntervalUpper for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2paTransmissionRateIntervalUpper;
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPSDTADMINISTRATIVESTATE_LOCKED:
		case MTPSDTADMINISTRATIVESTATE_UNLOCKED:
		case MTPSDTADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdtAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdtAdministrativeState;
		StorageTmp->mtpSdtAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtEquipmentPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdtEquipmentPointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdtEquipmentPointer;
		old_length = StorageTmp->mtpSdtEquipmentPointerLen;
		StorageTmp->mtpSdtEquipmentPointer = objid;
		StorageTmp->mtpSdtEquipmentPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtEquipmentPointer = old_value;
		StorageTmp->mtpSdtEquipmentPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdtName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSdtName;
		old_length = StorageTmp->mtpSdtNameLen;
		StorageTmp->mtpSdtName = string;
		StorageTmp->mtpSdtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtName = old_value;
		StorageTmp->mtpSdtNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtProfilePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdtProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdtProfilePointer;
		old_length = StorageTmp->mtpSdtProfilePointerLen;
		StorageTmp->mtpSdtProfilePointer = objid;
		StorageTmp->mtpSdtProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtProfilePointer = old_value;
		StorageTmp->mtpSdtProfilePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlType entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSDLTYPE_NARROWBAND:
		case MTPSDLTYPE_BROADBAND:
		case MTPSDLTYPE_M2PA:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlType for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlType;
		StorageTmp->mtpSdlType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlAdjPc entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '00000000'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlAdjPc for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlAdjPc;
		old_length = StorageTmp->mtpSdlAdjPcLen;
		StorageTmp->mtpSdlAdjPc = string;
		StorageTmp->mtpSdlAdjPcLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlAdjPc = old_value;
		StorageTmp->mtpSdlAdjPcLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlLoopDelay entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlLoopDelay for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlLoopDelay;
		StorageTmp->mtpSdlLoopDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlLoopDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlEquipmentPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlEquipmentPointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlEquipmentPointer;
		old_length = StorageTmp->mtpSdlEquipmentPointerLen;
		StorageTmp->mtpSdlEquipmentPointer = objid;
		StorageTmp->mtpSdlEquipmentPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlEquipmentPointer = old_value;
		StorageTmp->mtpSdlEquipmentPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlCIC entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..16383 */
		if ((0 > set_value || set_value > 16383)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlCIC for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlCIC;
		StorageTmp->mtpSdlCIC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlCIC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlTransmissionRate entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value kbits64 */
		switch (set_value) {
		case MTPSDLTRANSMISSIONRATE_KBITS4POINT8:
		case MTPSDLTRANSMISSIONRATE_KBITS56:
		case MTPSDLTRANSMISSIONRATE_KBITS64:
		case MTPSDLTRANSMISSIONRATE_KBITS1544:
		case MTPSDLTRANSMISSIONRATE_KBITS2048:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlTransmissionRate for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlTransmissionRate;
		StorageTmp->mtpSdlTransmissionRate = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlTransmissionRate = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlStmChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlStmChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlStmChannel entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 19 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlStmChannel for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlStmChannel;
		old_length = StorageTmp->mtpSdlStmChannelLen;
		StorageTmp->mtpSdlStmChannel = string;
		StorageTmp->mtpSdlStmChannelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlStmChannel = old_value;
		StorageTmp->mtpSdlStmChannelLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlVcTTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlVcTTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlVcTTpPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlVcTTpPointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlVcTTpPointer;
		old_length = StorageTmp->mtpSdlVcTTpPointerLen;
		StorageTmp->mtpSdlVcTTpPointer = objid;
		StorageTmp->mtpSdlVcTTpPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlVcTTpPointer = old_value;
		StorageTmp->mtpSdlVcTTpPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlSctpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlSctpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlSctpPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlSctpPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlSctpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlSctpPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { zeroDotZero } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlSctpPointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlSctpPointer;
		old_length = StorageTmp->mtpSdlSctpPointerLen;
		StorageTmp->mtpSdlSctpPointer = objid;
		StorageTmp->mtpSdlSctpPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlSctpPointer = old_value;
		StorageTmp->mtpSdlSctpPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSdlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlName entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpSdlName;
		old_length = StorageTmp->mtpSdlNameLen;
		StorageTmp->mtpSdlName = string;
		StorageTmp->mtpSdlNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlName = old_value;
		StorageTmp->mtpSdlNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileNoDelay entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileNoDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileNoDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileNoDelay;
		StorageTmp->mtpSctpProfileNoDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileNoDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileMaxseg entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxseg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		if ((1 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileMaxseg for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileMaxseg;
		StorageTmp->mtpSctpProfileMaxseg = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileMaxseg = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileHeartbeatItvl entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeatItvl: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileHeartbeatItvl for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileHeartbeatItvl;
		StorageTmp->mtpSctpProfileHeartbeatItvl = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileHeartbeatItvl = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileHeartbeat entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileHeartbeat for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileHeartbeat;
		StorageTmp->mtpSctpProfileHeartbeat = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileHeartbeat = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileRtoInitial entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoInitial: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileRtoInitial for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileRtoInitial;
		StorageTmp->mtpSctpProfileRtoInitial = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileRtoInitial = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileRtoMin entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMin: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileRtoMin for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileRtoMin;
		StorageTmp->mtpSctpProfileRtoMin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileRtoMin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileRtoMax entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMax: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileRtoMax for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileRtoMax;
		StorageTmp->mtpSctpProfileRtoMax = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileRtoMax = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfilePathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfilePathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfilePathMaxRetrans entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfilePathMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfilePathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfilePathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfilePathMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfilePathMaxRetrans;
		StorageTmp->mtpSctpProfilePathMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfilePathMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileCookieLife entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieLife: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileCookieLife for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileCookieLife;
		StorageTmp->mtpSctpProfileCookieLife = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileCookieLife = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileCookieInc entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieInc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileCookieInc for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileCookieInc;
		StorageTmp->mtpSctpProfileCookieInc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileCookieInc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileMaxInitRetries entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxInitRetries: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileMaxInitRetries for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileMaxInitRetries;
		StorageTmp->mtpSctpProfileMaxInitRetries = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileMaxInitRetries = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileMaxBurst entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxBurst: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileMaxBurst for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileMaxBurst;
		StorageTmp->mtpSctpProfileMaxBurst = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileMaxBurst = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileAssocMaxRetrans entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileAssocMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileAssocMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileAssocMaxRetrans;
		StorageTmp->mtpSctpProfileAssocMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileAssocMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileSackDelay entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileSackDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..500 */
		if ((0 > set_value || set_value > 500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileSackDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileSackDelay;
		StorageTmp->mtpSctpProfileSackDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileSackDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileLifetime entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileLifetime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileLifetime for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileLifetime;
		StorageTmp->mtpSctpProfileLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileMinOstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileMinOstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileMinOstreams entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMinOstreams: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMinOstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMinOstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		/* Note: ranges 2..65535 */
		if ((2 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMinOstreams: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileMinOstreams for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileMinOstreams;
		StorageTmp->mtpSctpProfileMinOstreams = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileMinOstreams = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileMaxIstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileMaxIstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileMaxIstreams entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxIstreams: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxIstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxIstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4096 */
		/* Note: ranges 2..65535 */
		if ((2 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxIstreams: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileMaxIstreams for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfileMaxIstreams;
		StorageTmp->mtpSctpProfileMaxIstreams = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfileMaxIstreams = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSctpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPSCTPADMINISTRATIVESTATE_LOCKED:
		case MTPSCTPADMINISTRATIVESTATE_UNLOCKED:
		case MTPSCTPADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpAdministrativeState;
		StorageTmp->mtpSctpAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpLocalPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpLocalPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSctpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpLocalPort entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalPort: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..65535 */
		if ((0 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalPort: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpLocalPort for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpLocalPort;
		StorageTmp->mtpSctpLocalPort = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpLocalPort = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpRemotePort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpRemotePort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpSctpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpRemotePort entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemotePort: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemotePort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemotePort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..65535 */
		if ((1 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemotePort: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpRemotePort for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpRemotePort;
		StorageTmp->mtpSctpRemotePort = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpRemotePort = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSctpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfile entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '' */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfile for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProfile;
		old_length = StorageTmp->mtpSctpProfileLen;
		StorageTmp->mtpSctpProfile = string;
		StorageTmp->mtpSctpProfileLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProfile = old_value;
		StorageTmp->mtpSctpProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpSctpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProtocolPayloadId entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProtocolPayloadId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProtocolPayloadId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProtocolPayloadId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProtocolPayloadId for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpProtocolPayloadId;
		StorageTmp->mtpSctpProtocolPayloadId = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpProtocolPayloadId = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpLocalAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpLocalAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSctpLocalTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpLocalAddress entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpLocalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpLocalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_IPADDRESS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalAddress not ASN_IPADDRESS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpLocalAddress for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpLocalAddress;
		old_length = StorageTmp->mtpSctpLocalAddressLen;
		StorageTmp->mtpSctpLocalAddress = string;
		StorageTmp->mtpSctpLocalAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpLocalAddress = old_value;
		StorageTmp->mtpSctpLocalAddressLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpRemoteAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpRemoteAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpSctpRemoteTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpRemoteAddress entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpRemoteTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRemoteRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemoteAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_IPADDRESS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemoteAddress not ASN_IPADDRESS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemoteAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpRemoteAddress for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpSctpRemoteAddress;
		old_length = StorageTmp->mtpSctpRemoteAddressLen;
		StorageTmp->mtpSctpRemoteAddress = string;
		StorageTmp->mtpSctpRemoteAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSctpRemoteAddress = old_value;
		StorageTmp->mtpSctpRemoteAddressLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM2uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspId entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspId for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaAspId;
		StorageTmp->mtpM2uaAspId = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaAspId = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpM2uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspCapabilities entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspCapabilities: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspCapabilities not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspCapabilities: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspCapabilities for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaAspCapabilities;
		old_length = StorageTmp->mtpM2uaAspCapabilitiesLen;
		StorageTmp->mtpM2uaAspCapabilities = string;
		StorageTmp->mtpM2uaAspCapabilitiesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaAspCapabilities = old_value;
		StorageTmp->mtpM2uaAspCapabilitiesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspSgVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspSgVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpM2uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspSgVersion entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgVersion not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { OPENSS7-SIGTRAN-TC : interoperableVersion } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspSgVersion for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaAspSgVersion;
		old_length = StorageTmp->mtpM2uaAspSgVersionLen;
		StorageTmp->mtpM2uaAspSgVersion = objid;
		StorageTmp->mtpM2uaAspSgVersionLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaAspSgVersion = old_value;
		StorageTmp->mtpM2uaAspSgVersionLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspSgOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspSgOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpM2uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspSgOptions entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgOptions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspSgOptions for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaAspSgOptions;
		old_length = StorageTmp->mtpM2uaAspSgOptionsLen;
		StorageTmp->mtpM2uaAspSgOptions = string;
		StorageTmp->mtpM2uaAspSgOptionsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaAspSgOptions = old_value;
		StorageTmp->mtpM2uaAspSgOptionsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspSgRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspSgRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspSgRegistrationPolicy entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgRegistrationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgRegistrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPM2UAASPSGREGISTRATIONPOLICY_UNKNOWN:
		case MTPM2UAASPSGREGISTRATIONPOLICY_FORBIDDEN:
		case MTPM2UAASPSGREGISTRATIONPOLICY_PERMITTED:
		case MTPM2UAASPSGREGISTRATIONPOLICY_REQUIRED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgRegistrationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspSgRegistrationPolicy for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaAspSgRegistrationPolicy;
		StorageTmp->mtpM2uaAspSgRegistrationPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaAspSgRegistrationPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspSgAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspSgAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspSgAspIdPolicy entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgAspIdPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgAspIdPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unknown */
		switch (set_value) {
		case MTPM2UAASPSGASPIDPOLICY_UNKNOWN:
		case MTPM2UAASPSGASPIDPOLICY_PERMITTED:
		case MTPM2UAASPSGASPIDPOLICY_REQUIRED:
		case MTPM2UAASPSGASPIDPOLICY_FORBIDDEN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgAspIdPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspSgAspIdPolicy for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaAspSgAspIdPolicy;
		StorageTmp->mtpM2uaAspSgAspIdPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaAspSgAspIdPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspAssociationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspAssociationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspAssociationPolicy entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspAssociationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspAssociationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspAssociationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unknown */
		switch (set_value) {
		case MTPM2UAASPASSOCIATIONPOLICY_UNKNOWN:
		case MTPM2UAASPASSOCIATIONPOLICY_ALWAYS:
		case MTPM2UAASPASSOCIATIONPOLICY_ONDEMAND:
		case MTPM2UAASPASSOCIATIONPOLICY_OTHER:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspAssociationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspAssociationPolicy for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaAspAssociationPolicy;
		StorageTmp->mtpM2uaAspAssociationPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaAspAssociationPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspProtocolPayloadId entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspProtocolPayloadId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspProtocolPayloadId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspProtocolPayloadId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspProtocolPayloadId for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaAspProtocolPayloadId;
		StorageTmp->mtpM2uaAspProtocolPayloadId = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaAspProtocolPayloadId = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAsInterfaceIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAsInterfaceIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2uaAsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAsInterfaceIdentifier entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsInterfaceIdentifier: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsInterfaceIdentifier not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsInterfaceIdentifier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..2147483647 */
		if ((1 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsInterfaceIdentifier: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAsInterfaceIdentifier for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaAsInterfaceIdentifier;
		StorageTmp->mtpM2uaAsInterfaceIdentifier = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaAsInterfaceIdentifier = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaInterfaceIdentifierText(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaInterfaceIdentifierText(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpM2uaAsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaInterfaceIdentifierText entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaInterfaceIdentifierText: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaInterfaceIdentifierText not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaInterfaceIdentifierText: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaInterfaceIdentifierText for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaInterfaceIdentifierText;
		old_length = StorageTmp->mtpM2uaInterfaceIdentifierTextLen;
		StorageTmp->mtpM2uaInterfaceIdentifierText = string;
		StorageTmp->mtpM2uaInterfaceIdentifierTextLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaInterfaceIdentifierText = old_value;
		StorageTmp->mtpM2uaInterfaceIdentifierTextLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAsSDTI(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAsSDTI(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM2uaAsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAsSDTI entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsSDTI: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsSDTI not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsSDTI: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAsSDTI for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaAsSDTI;
		StorageTmp->mtpM2uaAsSDTI = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaAsSDTI = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAsTrafficMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAsTrafficMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpM2uaAsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAsTrafficMode entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsTrafficMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsTrafficMode not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsTrafficMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value OPENSS7-SIGTRAN-TC : activeStandby */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAsTrafficMode for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM2uaAsTrafficMode;
		old_length = StorageTmp->mtpM2uaAsTrafficModeLen;
		StorageTmp->mtpM2uaAsTrafficMode = objid;
		StorageTmp->mtpM2uaAsTrafficModeLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2uaAsTrafficMode = old_value;
		StorageTmp->mtpM2uaAsTrafficModeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAsType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAsType entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value ipsp */
		switch (set_value) {
		case MTPM3UAASTYPE_ASP:
		case MTPM3UAASTYPE_IPSP:
		case MTPM3UAASTYPE_SGP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAsType for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAsType;
		StorageTmp->mtpM3uaAsType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAsType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspId entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspId for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAspId;
		StorageTmp->mtpM3uaAspId = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAspId = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspCapabilities entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspCapabilities: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspCapabilities not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspCapabilities: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspCapabilities for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAspCapabilities;
		old_length = StorageTmp->mtpM3uaAspCapabilitiesLen;
		StorageTmp->mtpM3uaAspCapabilities = string;
		StorageTmp->mtpM3uaAspCapabilitiesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAspCapabilities = old_value;
		StorageTmp->mtpM3uaAspCapabilitiesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspSgVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspSgVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspSgVersion entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgVersion not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value { OPENSS7-SIGTRAN-TC : interoperableVersion } */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspSgVersion for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAspSgVersion;
		old_length = StorageTmp->mtpM3uaAspSgVersionLen;
		StorageTmp->mtpM3uaAspSgVersion = objid;
		StorageTmp->mtpM3uaAspSgVersionLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAspSgVersion = old_value;
		StorageTmp->mtpM3uaAspSgVersionLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspSgOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspSgOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspSgOptions entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgOptions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspSgOptions for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAspSgOptions;
		old_length = StorageTmp->mtpM3uaAspSgOptionsLen;
		StorageTmp->mtpM3uaAspSgOptions = string;
		StorageTmp->mtpM3uaAspSgOptionsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAspSgOptions = old_value;
		StorageTmp->mtpM3uaAspSgOptionsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspSgRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspSgRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspSgRegistrationPolicy entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgRegistrationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgRegistrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPM3UAASPSGREGISTRATIONPOLICY_UNKNOWN:
		case MTPM3UAASPSGREGISTRATIONPOLICY_FORBIDDEN:
		case MTPM3UAASPSGREGISTRATIONPOLICY_PERMITTED:
		case MTPM3UAASPSGREGISTRATIONPOLICY_REQUIRED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgRegistrationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspSgRegistrationPolicy for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAspSgRegistrationPolicy;
		StorageTmp->mtpM3uaAspSgRegistrationPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAspSgRegistrationPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspSgAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspSgAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspSgAspIdPolicy entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgAspIdPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgAspIdPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unknown */
		switch (set_value) {
		case MTPM3UAASPSGASPIDPOLICY_UNKNOWN:
		case MTPM3UAASPSGASPIDPOLICY_PERMITTED:
		case MTPM3UAASPSGASPIDPOLICY_REQUIRED:
		case MTPM3UAASPSGASPIDPOLICY_FORBIDDEN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgAspIdPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspSgAspIdPolicy for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAspSgAspIdPolicy;
		StorageTmp->mtpM3uaAspSgAspIdPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAspSgAspIdPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspAssociationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspAssociationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspAssociationPolicy entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspAssociationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspAssociationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspAssociationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unknown */
		switch (set_value) {
		case MTPM3UAASPASSOCIATIONPOLICY_UNKNOWN:
		case MTPM3UAASPASSOCIATIONPOLICY_ALWAYS:
		case MTPM3UAASPASSOCIATIONPOLICY_ONDEMAND:
		case MTPM3UAASPASSOCIATIONPOLICY_OTHER:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspAssociationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspAssociationPolicy for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAspAssociationPolicy;
		StorageTmp->mtpM3uaAspAssociationPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAspAssociationPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspProtocolPayloadId entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspProtocolPayloadId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspProtocolPayloadId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspProtocolPayloadId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspProtocolPayloadId for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAspProtocolPayloadId;
		StorageTmp->mtpM3uaAspProtocolPayloadId = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAspProtocolPayloadId = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsRoutingContext(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAsRoutingContext(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM3uaAsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAsRoutingContext entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsRoutingContext: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsRoutingContext not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsRoutingContext: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAsRoutingContext for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAsRoutingContext;
		StorageTmp->mtpM3uaAsRoutingContext = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAsRoutingContext = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsNetworkAppearance(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAsNetworkAppearance(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpM3uaAsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAsNetworkAppearance entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkAppearance: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkAppearance not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkAppearance: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAsNetworkAppearance for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAsNetworkAppearance;
		StorageTmp->mtpM3uaAsNetworkAppearance = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAsNetworkAppearance = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsNetworkPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAsNetworkPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct mtpM3uaAsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAsNetworkPointCode entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkPointCode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkPointCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAsNetworkPointCode for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAsNetworkPointCode;
		old_length = StorageTmp->mtpM3uaAsNetworkPointCodeLen;
		StorageTmp->mtpM3uaAsNetworkPointCode = string;
		StorageTmp->mtpM3uaAsNetworkPointCodeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAsNetworkPointCode = old_value;
		StorageTmp->mtpM3uaAsNetworkPointCodeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsTrafficMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAsTrafficMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpM3uaAsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 17;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAsTrafficMode entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsTrafficMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsTrafficMode not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsTrafficMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAsTrafficMode for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->mtpM3uaAsTrafficMode;
		old_length = StorageTmp->mtpM3uaAsTrafficModeLen;
		StorageTmp->mtpM3uaAsTrafficMode = objid;
		StorageTmp->mtpM3uaAsTrafficModeLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM3uaAsTrafficMode = old_value;
		StorageTmp->mtpM3uaAsTrafficModeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpNoDelay;
		StorageTmp->mtpDefaultSctpNoDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpNoDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		if ((1 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpMaxseg;
		StorageTmp->mtpDefaultSctpMaxseg = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpMaxseg = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpHeartbeatItvl;
		StorageTmp->mtpDefaultSctpHeartbeatItvl = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpHeartbeatItvl = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpHeartbeat;
		StorageTmp->mtpDefaultSctpHeartbeat = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpHeartbeat = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpRtoInitial;
		StorageTmp->mtpDefaultSctpRtoInitial = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpRtoInitial = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpRtoMin;
		StorageTmp->mtpDefaultSctpRtoMin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpRtoMin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpRtoMax;
		StorageTmp->mtpDefaultSctpRtoMax = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpRtoMax = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpPathMaxRetrans;
		StorageTmp->mtpDefaultSctpPathMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpPathMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpCookieLife;
		StorageTmp->mtpDefaultSctpCookieLife = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpCookieLife = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpCookieInc;
		StorageTmp->mtpDefaultSctpCookieInc = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpCookieInc = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpMaxInitRetries;
		StorageTmp->mtpDefaultSctpMaxInitRetries = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpMaxInitRetries = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpMaxBurst;
		StorageTmp->mtpDefaultSctpMaxBurst = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpMaxBurst = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpAssocMaxRetrans;
		StorageTmp->mtpDefaultSctpAssocMaxRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpAssocMaxRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..50 */
		if ((0 > set_value || set_value > 50)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpSackDelay;
		StorageTmp->mtpDefaultSctpSackDelay = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpSackDelay = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpDefaultSctpLifetime;
		StorageTmp->mtpDefaultSctpLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpDefaultSctpLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int mtpSapTable_consistent(struct mtpSapTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSapTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSapTable_consistent(struct mtpSapTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpNaTable_consistent(struct mtpNaTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpNaTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpNaTable_consistent(struct mtpNaTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpMsTable_consistent(struct mtpMsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpMsTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpMsTable_consistent(struct mtpMsTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSpProfileTable_consistent(struct mtpSpProfileTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSpProfileTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSpProfileTable_consistent(struct mtpSpProfileTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSpTable_consistent(struct mtpSpTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSpTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSpTable_consistent(struct mtpSpTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpL3Table_consistent(struct mtpL3Table_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpL3Table table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpL3Table_consistent(struct mtpL3Table_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpGsTable_consistent(struct mtpGsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpGsTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpGsTable_consistent(struct mtpGsTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpGsLineTable_consistent(struct mtpGsLineTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpGsLineTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpGsLineTable_consistent(struct mtpGsLineTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpGsLineContentTable_consistent(struct mtpGsLineContentTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpGsLineContentTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpGsLineContentTable_consistent(struct mtpGsLineContentTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpRsProfileTable_consistent(struct mtpRsProfileTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpRsProfileTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpRsProfileTable_consistent(struct mtpRsProfileTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpRsTable_consistent(struct mtpRsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpRsTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpRsTable_consistent(struct mtpRsTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpRtProfileTable_consistent(struct mtpRtProfileTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpRtProfileTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpRtProfileTable_consistent(struct mtpRtProfileTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpRtTable_consistent(struct mtpRtTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpRtTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpRtTable_consistent(struct mtpRtTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpRtLsaTable_consistent(struct mtpRtLsaTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpRtLsaTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpRtLsaTable_consistent(struct mtpRtLsaTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpLsProfileTable_consistent(struct mtpLsProfileTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpLsProfileTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpLsProfileTable_consistent(struct mtpLsProfileTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpLsTable_consistent(struct mtpLsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpLsTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpLsTable_consistent(struct mtpLsTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSlL3ProfileTable_consistent(struct mtpSlL3ProfileTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSlL3ProfileTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSlL3ProfileTable_consistent(struct mtpSlL3ProfileTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSlL2ProfileTable_consistent(struct mtpSlL2ProfileTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSlL2ProfileTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSlL2ProfileTable_consistent(struct mtpSlL2ProfileTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSlTable_consistent(struct mtpSlTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSlTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSlTable_consistent(struct mtpSlTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSlSdlListTable_consistent(struct mtpSlSdlListTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSlSdlListTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSlSdlListTable_consistent(struct mtpSlSdlListTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSlSdtListTable_consistent(struct mtpSlSdtListTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSlSdtListTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSlSdtListTable_consistent(struct mtpSlSdtListTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpNbTable_consistent(struct mtpNbTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpNbTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpNbTable_consistent(struct mtpNbTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSaalTable_consistent(struct mtpSaalTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSaalTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSaalTable_consistent(struct mtpSaalTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpM2paTable_consistent(struct mtpM2paTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpM2paTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpM2paTable_consistent(struct mtpM2paTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSdtTable_consistent(struct mtpSdtTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSdtTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSdtTable_consistent(struct mtpSdtTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSdlTable_consistent(struct mtpSdlTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSdlTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSdlTable_consistent(struct mtpSdlTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSctpProfileTable_consistent(struct mtpSctpProfileTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSctpProfileTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSctpProfileTable_consistent(struct mtpSctpProfileTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSctpTable_consistent(struct mtpSctpTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSctpTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSctpTable_consistent(struct mtpSctpTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSctpLocalTable_consistent(struct mtpSctpLocalTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSctpLocalTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSctpLocalTable_consistent(struct mtpSctpLocalTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpSctpRemoteTable_consistent(struct mtpSctpRemoteTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpSctpRemoteTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpSctpRemoteTable_consistent(struct mtpSctpRemoteTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpM2uaAspTable_consistent(struct mtpM2uaAspTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpM2uaAspTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpM2uaAspTable_consistent(struct mtpM2uaAspTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpM2uaAsTable_consistent(struct mtpM2uaAsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpM2uaAsTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpM2uaAsTable_consistent(struct mtpM2uaAsTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpM3uaAspTable_consistent(struct mtpM3uaAspTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpM3uaAspTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpM3uaAspTable_consistent(struct mtpM3uaAspTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int mtpM3uaAsTable_consistent(struct mtpM3uaAsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpM3uaAsTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
mtpM3uaAsTable_consistent(struct mtpM3uaAsTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int write_mtpSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL;
	static struct mtpSapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSapRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSapTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSapTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSapId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSapTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSapId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSapTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSapTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSapTable_del(StorageNew);
			mtpSapTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSapTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSapRowStatus;
			StorageTmp->mtpSapRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSapTable_consistent(StorageTmp)) {
					StorageTmp->mtpSapRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSapRowStatus;
			StorageTmp->mtpSapRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSapRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSapTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSapRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSapTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSapRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSapTable_destroy(&StorageDel);
			/* mtpSapTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpNaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL;
	static struct mtpNaTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpNaRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpNaTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpNaTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpNaId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpNaTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpNaId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpNaTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpNaTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpNaTable_del(StorageNew);
			mtpNaTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpNaTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpNaRowStatus;
			StorageTmp->mtpNaRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpNaTable_consistent(StorageTmp)) {
					StorageTmp->mtpNaRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpNaRowStatus;
			StorageTmp->mtpNaRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpNaRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpNaTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpNaRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpNaTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpNaRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpNaTable_destroy(&StorageDel);
			/* mtpNaTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpMsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMsTable_data *StorageTmp = NULL;
	static struct mtpMsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpMsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpMsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpMsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpMsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpMsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpMsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpMsTable_del(StorageNew);
			mtpMsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpMsTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpMsRowStatus;
			StorageTmp->mtpMsRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpMsTable_consistent(StorageTmp)) {
					StorageTmp->mtpMsRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpMsRowStatus;
			StorageTmp->mtpMsRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpMsRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpMsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpMsRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpMsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpMsRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpMsTable_destroy(&StorageDel);
			/* mtpMsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static struct mtpSpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSpProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSpProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSpProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSpProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->mtpSpProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSpProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSpProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSpProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSpProfileTable_del(StorageNew);
			mtpSpProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSpProfileTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSpProfileRowStatus;
			StorageTmp->mtpSpProfileRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSpProfileTable_consistent(StorageTmp)) {
					StorageTmp->mtpSpProfileRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSpProfileRowStatus;
			StorageTmp->mtpSpProfileRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSpProfileRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSpProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSpProfileRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSpProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSpProfileRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSpProfileTable_destroy(&StorageDel);
			/* mtpSpProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL;
	static struct mtpSpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSpTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSpTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSpTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSpTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSpTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSpTable_del(StorageNew);
			mtpSpTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSpTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSpRowStatus;
			StorageTmp->mtpSpRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSpTable_consistent(StorageTmp)) {
					StorageTmp->mtpSpRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSpRowStatus;
			StorageTmp->mtpSpRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSpRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSpTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSpRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSpTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSpRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSpTable_destroy(&StorageDel);
			/* mtpSpTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpL3RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpL3Table_data *StorageTmp = NULL;
	static struct mtpL3Table_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3RowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3RowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpL3RowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpL3Table_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpL3Table_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpL3Id */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpL3Table_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpL3Id = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpL3TableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpL3Table_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpL3Table_del(StorageNew);
			mtpL3Table_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpL3Table_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpL3RowStatus;
			StorageTmp->mtpL3RowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpL3Table_consistent(StorageTmp)) {
					StorageTmp->mtpL3RowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpL3RowStatus;
			StorageTmp->mtpL3RowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpL3RowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpL3Table_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpL3RowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpL3Table_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpL3RowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpL3Table_destroy(&StorageDel);
			/* mtpL3Table_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpGsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL;
	static struct mtpGsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpGsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpGsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpGsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpGsTable_del(StorageNew);
			mtpGsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpGsTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpGsRowStatus;
			StorageTmp->mtpGsRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpGsTable_consistent(StorageTmp)) {
					StorageTmp->mtpGsRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpGsRowStatus;
			StorageTmp->mtpGsRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpGsRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpGsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpGsRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpGsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpGsRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpGsTable_destroy(&StorageDel);
			/* mtpGsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpGsLineRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineTable_data *StorageTmp = NULL;
	static struct mtpGsLineTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsLineRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsLineTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsLineTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsLineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpGsLineTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpGsLineTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpGsLineTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpGsLineTable_del(StorageNew);
			mtpGsLineTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpGsLineTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpGsLineRowStatus;
			StorageTmp->mtpGsLineRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpGsLineTable_consistent(StorageTmp)) {
					StorageTmp->mtpGsLineRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpGsLineRowStatus;
			StorageTmp->mtpGsLineRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpGsLineRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpGsLineTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpGsLineRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpGsLineTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpGsLineRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpGsLineTable_destroy(&StorageDel);
			/* mtpGsLineTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpGsLineContentRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static struct mtpGsLineContentTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsLineContentRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsLineContentTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsLineContentTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsLineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsLineContentId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpGsLineContentTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineContentId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpGsLineContentTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpGsLineContentTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpGsLineContentTable_del(StorageNew);
			mtpGsLineContentTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpGsLineContentTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpGsLineContentRowStatus;
			StorageTmp->mtpGsLineContentRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpGsLineContentTable_consistent(StorageTmp)) {
					StorageTmp->mtpGsLineContentRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpGsLineContentRowStatus;
			StorageTmp->mtpGsLineContentRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpGsLineContentRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpGsLineContentTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpGsLineContentRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpGsLineContentTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpGsLineContentRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpGsLineContentTable_destroy(&StorageDel);
			/* mtpGsLineContentTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static struct mtpRsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRsProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRsProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRsProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpRsProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpRsProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->mtpRsProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpRsProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpRsProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRsProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRsProfileTable_del(StorageNew);
			mtpRsProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRsProfileTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpRsProfileRowStatus;
			StorageTmp->mtpRsProfileRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpRsProfileTable_consistent(StorageTmp)) {
					StorageTmp->mtpRsProfileRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRsProfileRowStatus;
			StorageTmp->mtpRsProfileRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRsProfileRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpRsProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpRsProfileRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpRsProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpRsProfileRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRsProfileTable_destroy(&StorageDel);
			/* mtpRsProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL;
	static struct mtpRsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpRsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpRsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpRsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRsTable_del(StorageNew);
			mtpRsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRsTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpRsRowStatus;
			StorageTmp->mtpRsRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpRsTable_consistent(StorageTmp)) {
					StorageTmp->mtpRsRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRsRowStatus;
			StorageTmp->mtpRsRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRsRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpRsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpRsRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpRsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpRsRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRsTable_destroy(&StorageDel);
			/* mtpRsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRtProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	static struct mtpRtProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRtProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRtProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRtProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpRtProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpRtProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->mtpRtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpRtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpRtProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRtProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRtProfileTable_del(StorageNew);
			mtpRtProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRtProfileTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpRtProfileRowStatus;
			StorageTmp->mtpRtProfileRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpRtProfileTable_consistent(StorageTmp)) {
					StorageTmp->mtpRtProfileRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRtProfileRowStatus;
			StorageTmp->mtpRtProfileRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRtProfileRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpRtProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpRtProfileRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpRtProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpRtProfileRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRtProfileTable_destroy(&StorageDel);
			/* mtpRtProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL;
	static struct mtpRtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRtRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpRsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpRtId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpRtTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRtId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpRtTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpRtTable_del(StorageNew);
			mtpRtTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpRtTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpRtRowStatus;
			StorageTmp->mtpRtRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpRtTable_consistent(StorageTmp)) {
					StorageTmp->mtpRtRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpRtRowStatus;
			StorageTmp->mtpRtRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpRtRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpRtTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpRtRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpRtTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpRtRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpRtTable_destroy(&StorageDel);
			/* mtpRtTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpLsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static struct mtpLsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpLsProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpLsProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpLsProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpLsProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpLsProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->mtpLsProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpLsProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpLsProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpLsProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpLsProfileTable_del(StorageNew);
			mtpLsProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpLsProfileTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpLsProfileRowStatus;
			StorageTmp->mtpLsProfileRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpLsProfileTable_consistent(StorageTmp)) {
					StorageTmp->mtpLsProfileRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpLsProfileRowStatus;
			StorageTmp->mtpLsProfileRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpLsProfileRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpLsProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpLsProfileRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpLsProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpLsProfileRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpLsProfileTable_destroy(&StorageDel);
			/* mtpLsProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpLsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL;
	static struct mtpLsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpLsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpLsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpLsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpLsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpLsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpLsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpLsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpLsTable_del(StorageNew);
			mtpLsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpLsTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpLsRowStatus;
			StorageTmp->mtpLsRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpLsTable_consistent(StorageTmp)) {
					StorageTmp->mtpLsRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpLsRowStatus;
			StorageTmp->mtpLsRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpLsRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpLsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpLsRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpLsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpLsRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpLsTable_destroy(&StorageDel);
			/* mtpLsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlL3ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static struct mtpSlL3ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlL3ProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlL3ProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlL3ProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSlL3ProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSlL3ProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->mtpSlL3ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSlL3ProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSlL3ProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlL3ProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlL3ProfileTable_del(StorageNew);
			mtpSlL3ProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlL3ProfileTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSlL3ProfileRowStatus;
			StorageTmp->mtpSlL3ProfileRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSlL3ProfileTable_consistent(StorageTmp)) {
					StorageTmp->mtpSlL3ProfileRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlL3ProfileRowStatus;
			StorageTmp->mtpSlL3ProfileRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlL3ProfileRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSlL3ProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSlL3ProfileRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSlL3ProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSlL3ProfileRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlL3ProfileTable_destroy(&StorageDel);
			/* mtpSlL3ProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlL2ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static struct mtpSlL2ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlL2ProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlL2ProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlL2ProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSlL2ProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlL2ProfileTransmissionRate */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSlL2ProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->mtpSlL2ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSlL2ProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			StorageNew->mtpSlL2ProfileTransmissionRate = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSlL2ProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlL2ProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlL2ProfileTable_del(StorageNew);
			mtpSlL2ProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlL2ProfileTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSlL2ProfileRowStatus;
			StorageTmp->mtpSlL2ProfileRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSlL2ProfileTable_consistent(StorageTmp)) {
					StorageTmp->mtpSlL2ProfileRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlL2ProfileRowStatus;
			StorageTmp->mtpSlL2ProfileRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlL2ProfileRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSlL2ProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSlL2ProfileRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSlL2ProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSlL2ProfileRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlL2ProfileTable_destroy(&StorageDel);
			/* mtpSlL2ProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL;
	static struct mtpSlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpLsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSlTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSlTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlTable_del(StorageNew);
			mtpSlTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSlRowStatus;
			StorageTmp->mtpSlRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSlTable_consistent(StorageTmp)) {
					StorageTmp->mtpSlRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlRowStatus;
			StorageTmp->mtpSlRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSlTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSlRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSlTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSlRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlTable_destroy(&StorageDel);
			/* mtpSlTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdlListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlSdlListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	static struct mtpSlSdlListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlSdlListRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlSdlListTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlSdlListTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpLsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlSdlListId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSlSdlListTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdlListId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSlSdlListTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlSdlListTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlSdlListTable_del(StorageNew);
			mtpSlSdlListTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlSdlListTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSlSdlListRowStatus;
			StorageTmp->mtpSlSdlListRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSlSdlListTable_consistent(StorageTmp)) {
					StorageTmp->mtpSlSdlListRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdlListRowStatus;
			StorageTmp->mtpSlSdlListRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlSdlListRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSlSdlListTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSlSdlListRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSlSdlListTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSlSdlListRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlSdlListTable_destroy(&StorageDel);
			/* mtpSlSdlListTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdtListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlSdtListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	static struct mtpSlSdtListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlSdtListRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlSdtListTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlSdtListTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpLsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlSdtListId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSlSdtListTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdtListId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSlSdtListTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlSdtListTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSlSdtListTable_del(StorageNew);
			mtpSlSdtListTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSlSdtListTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSlSdtListRowStatus;
			StorageTmp->mtpSlSdtListRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSlSdtListTable_consistent(StorageTmp)) {
					StorageTmp->mtpSlSdtListRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdtListRowStatus;
			StorageTmp->mtpSlSdtListRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSlSdtListRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSlSdtListTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSlSdtListRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSlSdtListTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSlSdtListRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSlSdtListTable_destroy(&StorageDel);
			/* mtpSlSdtListTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpNbRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNbTable_data *StorageTmp = NULL;
	static struct mtpNbTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpNbRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpNbTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpNbTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpNbTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpNbTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpNbTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpNbTable_del(StorageNew);
			mtpNbTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpNbTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpNbRowStatus;
			StorageTmp->mtpNbRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpNbTable_consistent(StorageTmp)) {
					StorageTmp->mtpNbRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpNbRowStatus;
			StorageTmp->mtpNbRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpNbRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpNbTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpNbRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpNbTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpNbRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpNbTable_destroy(&StorageDel);
			/* mtpNbTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSaalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL;
	static struct mtpSaalTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSaalRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSaalTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSaalTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSaalTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSaalTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSaalTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSaalTable_del(StorageNew);
			mtpSaalTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSaalTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSaalRowStatus;
			StorageTmp->mtpSaalRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSaalTable_consistent(StorageTmp)) {
					StorageTmp->mtpSaalRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSaalRowStatus;
			StorageTmp->mtpSaalRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSaalRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSaalTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSaalRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSaalTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSaalRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSaalTable_destroy(&StorageDel);
			/* mtpSaalTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpM2paRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL;
	static struct mtpM2paTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM2paRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM2paTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM2paTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpM2paTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpM2paTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpM2paTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpM2paTable_del(StorageNew);
			mtpM2paTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpM2paTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpM2paRowStatus;
			StorageTmp->mtpM2paRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpM2paTable_consistent(StorageTmp)) {
					StorageTmp->mtpM2paRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpM2paRowStatus;
			StorageTmp->mtpM2paRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpM2paRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpM2paTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpM2paRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpM2paTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpM2paRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpM2paTable_destroy(&StorageDel);
			/* mtpM2paTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSdtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdtTable_data *StorageTmp = NULL;
	static struct mtpSdtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSdtRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSdtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSdtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSdtId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSdtTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSdtId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSdtTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSdtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSdtTable_del(StorageNew);
			mtpSdtTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSdtTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSdtRowStatus;
			StorageTmp->mtpSdtRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSdtTable_consistent(StorageTmp)) {
					StorageTmp->mtpSdtRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSdtRowStatus;
			StorageTmp->mtpSdtRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSdtRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSdtTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSdtRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSdtTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSdtRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSdtTable_destroy(&StorageDel);
			/* mtpSdtTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSdlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL;
	static struct mtpSdlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSdlRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSdlTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSdlTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSdlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSdlTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpSdlId, vp->val.string, vp->val_len);
			StorageNew->mtpSdlIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSdlTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSdlTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSdlTable_del(StorageNew);
			mtpSdlTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSdlTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSdlRowStatus;
			StorageTmp->mtpSdlRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSdlTable_consistent(StorageTmp)) {
					StorageTmp->mtpSdlRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSdlRowStatus;
			StorageTmp->mtpSdlRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSdlRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSdlTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSdlRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSdlTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSdlRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSdlTable_destroy(&StorageDel);
			/* mtpSdlTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSctpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	static struct mtpSctpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSctpProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSctpProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSctpProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSctpProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSctpProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->mtpSctpProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSctpProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSctpProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSctpProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSctpProfileTable_del(StorageNew);
			mtpSctpProfileTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSctpProfileTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSctpProfileRowStatus;
			StorageTmp->mtpSctpProfileRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSctpProfileTable_consistent(StorageTmp)) {
					StorageTmp->mtpSctpProfileRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSctpProfileRowStatus;
			StorageTmp->mtpSctpProfileRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSctpProfileRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSctpProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSctpProfileRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSctpProfileTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSctpProfileRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSctpProfileTable_destroy(&StorageDel);
			/* mtpSctpProfileTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSctpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpTable_data *StorageTmp = NULL;
	static struct mtpSctpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSctpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSctpTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSctpTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSctpTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpSctpId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSctpTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSctpTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSctpTable_del(StorageNew);
			mtpSctpTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSctpTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSctpRowStatus;
			StorageTmp->mtpSctpRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSctpTable_consistent(StorageTmp)) {
					StorageTmp->mtpSctpRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSctpRowStatus;
			StorageTmp->mtpSctpRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSctpRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSctpTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSctpRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSctpTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSctpRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSctpTable_destroy(&StorageDel);
			/* mtpSctpTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpLocalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSctpLocalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpLocalTable_data *StorageTmp = NULL;
	static struct mtpSctpLocalTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSctpLocalTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSctpLocalRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSctpLocalTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSctpLocalTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSctpLocalId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSctpLocalTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpSctpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSctpLocalId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSctpLocalTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSctpLocalTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSctpLocalTable_del(StorageNew);
			mtpSctpLocalTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSctpLocalTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSctpLocalRowStatus;
			StorageTmp->mtpSctpLocalRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSctpLocalTable_consistent(StorageTmp)) {
					StorageTmp->mtpSctpLocalRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSctpLocalRowStatus;
			StorageTmp->mtpSctpLocalRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSctpLocalRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSctpLocalTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSctpLocalRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSctpLocalTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSctpLocalRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSctpLocalTable_destroy(&StorageDel);
			/* mtpSctpLocalTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpRemoteRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSctpRemoteRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpRemoteTable_data *StorageTmp = NULL;
	static struct mtpSctpRemoteTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpSctpRemoteTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemoteRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemoteRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSctpRemoteRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSctpRemoteTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSctpRemoteTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSctpRemoteId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpSctpRemoteTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpSctpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSctpRemoteId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSctpRemoteTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSctpRemoteTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpSctpRemoteTable_del(StorageNew);
			mtpSctpRemoteTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpSctpRemoteTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpSctpRemoteRowStatus;
			StorageTmp->mtpSctpRemoteRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpSctpRemoteTable_consistent(StorageTmp)) {
					StorageTmp->mtpSctpRemoteRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpSctpRemoteRowStatus;
			StorageTmp->mtpSctpRemoteRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpSctpRemoteRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSctpRemoteTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpSctpRemoteRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpSctpRemoteTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpSctpRemoteRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpSctpRemoteTable_destroy(&StorageDel);
			/* mtpSctpRemoteTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpM2uaAspRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL;
	static struct mtpM2uaAspTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM2uaAspRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM2uaAspTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM2uaAspTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpM2uaAspTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpSctpId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpM2uaAspTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpM2uaAspTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpM2uaAspTable_del(StorageNew);
			mtpM2uaAspTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpM2uaAspTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpM2uaAspRowStatus;
			StorageTmp->mtpM2uaAspRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpM2uaAspTable_consistent(StorageTmp)) {
					StorageTmp->mtpM2uaAspRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpM2uaAspRowStatus;
			StorageTmp->mtpM2uaAspRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpM2uaAspRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpM2uaAspTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpM2uaAspRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpM2uaAspTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpM2uaAspRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpM2uaAspTable_destroy(&StorageDel);
			/* mtpM2uaAspTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpM2uaAsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAsTable_data *StorageTmp = NULL;
	static struct mtpM2uaAsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpM2uaAsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM2uaAsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM2uaAsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM2uaAsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpM3uaAsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpM2uaAsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpSctpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpM3uaAsId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpM2uaAsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpM2uaAsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpM2uaAsTable_del(StorageNew);
			mtpM2uaAsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpM2uaAsTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpM2uaAsRowStatus;
			StorageTmp->mtpM2uaAsRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpM2uaAsTable_consistent(StorageTmp)) {
					StorageTmp->mtpM2uaAsRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpM2uaAsRowStatus;
			StorageTmp->mtpM2uaAsRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpM2uaAsRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpM2uaAsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpM2uaAsRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpM2uaAsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpM2uaAsRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpM2uaAsTable_destroy(&StorageDel);
			/* mtpM2uaAsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpM3uaAspRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	static struct mtpM3uaAspTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM3uaAspRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM3uaAspTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM3uaAspTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpM3uaAspTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpSctpId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpM3uaAspTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpM3uaAspTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpM3uaAspTable_del(StorageNew);
			mtpM3uaAspTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpM3uaAspTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpM3uaAspRowStatus;
			StorageTmp->mtpM3uaAspRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpM3uaAspTable_consistent(StorageTmp)) {
					StorageTmp->mtpM3uaAspRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpM3uaAspRowStatus;
			StorageTmp->mtpM3uaAspRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpM3uaAspRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpM3uaAspTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpM3uaAspRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpM3uaAspTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpM3uaAspRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpM3uaAspTable_destroy(&StorageDel);
			/* mtpM3uaAspTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpM3uaAsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAsTable_data *StorageTmp = NULL;
	static struct mtpM3uaAsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 17;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mtpM3uaAsTableStorage, NULL, &name[17], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM3uaAsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM3uaAsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM3uaAsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpM3uaAsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[17]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = mtpM3uaAsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpSctpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpM3uaAsId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpM3uaAsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpM3uaAsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpM3uaAsTable_del(StorageNew);
			mtpM3uaAsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpM3uaAsTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->mtpM3uaAsRowStatus;
			StorageTmp->mtpM3uaAsRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!mtpM3uaAsTable_consistent(StorageTmp)) {
					StorageTmp->mtpM3uaAsRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpM3uaAsRowStatus;
			StorageTmp->mtpM3uaAsRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpM3uaAsRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpM3uaAsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->mtpM3uaAsRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (mtpM3uaAsTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->mtpM3uaAsRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpM3uaAsTable_destroy(&StorageDel);
			/* mtpM3uaAsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

void
send_mtpRestarting_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = mtpRestarting_oid;
	trap.val_len = sizeof(mtpRestarting_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_ss7OnOccEvent_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = ss7OnOccEvent_oid;
	trap.val_len = sizeof(ss7OnOccEvent_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_sdlEventLostSync_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdlEventLostSync_oid;
	trap.val_len = sizeof(sdlEventLostSync_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_sdlEventSuError_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdlEventSuError_oid;
	trap.val_len = sizeof(sdlEventSuError_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_sdlEventTxFail_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdlEventTxFail_oid;
	trap.val_len = sizeof(sdlEventTxFail_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_sdlEventRxFail_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdlEventRxFail_oid;
	trap.val_len = sizeof(sdlEventRxFail_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_sdtEventLostSync_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdtEventLostSync_oid;
	trap.val_len = sizeof(sdtEventLostSync_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_sdtEventSuError_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdtEventSuError_oid;
	trap.val_len = sizeof(sdtEventSuError_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_sdtEventTxFail_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdtEventTxFail_oid;
	trap.val_len = sizeof(sdtEventTxFail_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_sdtEventRxFail_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdtEventRxFail_oid;
	trap.val_len = sizeof(sdtEventRxFail_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_sdtEventCarrier_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdtEventCarrier_oid;
	trap.val_len = sizeof(sdtEventCarrier_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventFailureAllReasons_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventFailureAllReasons_oid;
	trap.val_len = sizeof(slEventFailureAllReasons_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventFailureAbnormalBsnrFibr_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventFailureAbnormalBsnrFibr_oid;
	trap.val_len = sizeof(slEventFailureAbnormalBsnrFibr_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventFailureExcessiveDelayOfAck_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventFailureExcessiveDelayOfAck_oid;
	trap.val_len = sizeof(slEventFailureExcessiveDelayOfAck_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventFailureExcessiveErrorRate_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventFailureExcessiveErrorRate_oid;
	trap.val_len = sizeof(slEventFailureExcessiveErrorRate_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventFailureExcessiveDurationCongestion_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventFailureExcessiveDurationCongestion_oid;
	trap.val_len = sizeof(slEventFailureExcessiveDurationCongestion_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventLocalAutomaticChangeover_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventLocalAutomaticChangeover_oid;
	trap.val_len = sizeof(slEventLocalAutomaticChangeover_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventLocalAutomaticChangeback_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventLocalAutomaticChangeback_oid;
	trap.val_len = sizeof(slEventLocalAutomaticChangeback_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventRestoration_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventRestoration_oid;
	trap.val_len = sizeof(slEventRestoration_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventRpoStartEvent_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventRpoStartEvent_oid;
	trap.val_len = sizeof(slEventRpoStartEvent_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventRpoStopEvent_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventRpoStopEvent_oid;
	trap.val_len = sizeof(slEventRpoStopEvent_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventLocalInhibitionStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventLocalInhibitionStart_oid;
	trap.val_len = sizeof(slEventLocalInhibitionStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventLocalInhibitionStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventLocalInhibitionStop_oid;
	trap.val_len = sizeof(slEventLocalInhibitionStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventRemoteInhibitionStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventRemoteInhibitionStart_oid;
	trap.val_len = sizeof(slEventRemoteInhibitionStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventRemoteInhibitionStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventRemoteInhibitionStop_oid;
	trap.val_len = sizeof(slEventRemoteInhibitionStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventCongestionStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventCongestionStart_oid;
	trap.val_len = sizeof(slEventCongestionStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventCongestionStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventCongestionStop_oid;
	trap.val_len = sizeof(slEventCongestionStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_slEventCongestionLoss_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventCongestionLoss_oid;
	trap.val_len = sizeof(slEventCongestionLoss_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_lkEventFailureStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lkEventFailureStart_oid;
	trap.val_len = sizeof(lkEventFailureStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_lkEventFailureStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lkEventFailureStop_oid;
	trap.val_len = sizeof(lkEventFailureStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_lkEventSendTFP_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lkEventSendTFP_oid;
	trap.val_len = sizeof(lkEventSendTFP_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_lkEventSendTFA_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lkEventSendTFA_oid;
	trap.val_len = sizeof(lkEventSendTFA_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_rsEventUnavailableStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventUnavailableStart_oid;
	trap.val_len = sizeof(rsEventUnavailableStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_rsEventUnavailableStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventUnavailableStop_oid;
	trap.val_len = sizeof(rsEventUnavailableStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_rsEventAdjSpLinkSetChange_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventAdjSpLinkSetChange_oid;
	trap.val_len = sizeof(rsEventAdjSpLinkSetChange_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_rsEventAdjSPInaccessibleStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventAdjSPInaccessibleStart_oid;
	trap.val_len = sizeof(rsEventAdjSPInaccessibleStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_rsEventAdjSpInaccessibleStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventAdjSpInaccessibleStop_oid;
	trap.val_len = sizeof(rsEventAdjSpInaccessibleStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_rsEventRecvTFC_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventRecvTFC_oid;
	trap.val_len = sizeof(rsEventRecvTFC_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_spEventMsuDiscard_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = spEventMsuDiscard_oid;
	trap.val_len = sizeof(spEventMsuDiscard_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_spEventUpuSent_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = spEventUpuSent_oid;
	trap.val_len = sizeof(spEventUpuSent_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

void
send_spEventUpuRecv_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = spEventUpuRecv_oid;
	trap.val_len = sizeof(spEventUpuRecv_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

#if defined MODULE
#if defined MASTER
/**
 * @fn void mtpMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
mtpMIB_loop_handler(int sig)
{
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	/* close files after each request */
	if (sa_fclose) {
		if (sa_fd != 0) {
			close(sa_fd);
			sa_fd = 0;
		}
		if (my_fd != 0) {
			close(my_fd);
			my_fd = 0;
		}
	}
	/* prepare for next request */
	sa_request++;
	if (mtpMIBold_signal_handler != NULL)
		(*mtpMIBold_signal_handler) (sig);
}
#endif				/* defined MASTER */
/**
 * @fn void mtpMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
mtpMIB_fd_handler(int fd, void *dummy)
{
	/* XXX: place actions to handle sa_readfd here... */
	return;
}
#endif				/* defined MOUDLE */
#if defined MASTER
const char sa_program[] = "mtpmib";
int sa_fclose = 1;			/* default close files between requests */
int sa_fd = 0;				/* file descriptor for MIB use */
int sa_readfd = 0;			/* file descriptor for autonomnous events */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
#endif				/* defined MASTER */
#if defined MASTER
#if !defined MODULE
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
int sa_nomead = 1;			/* default daemon mode */
int sa_output = 1;			/* default normal output */
int sa_agentx = 1;			/* default agentx mode */
int sa_alarms = 1;			/* default application alarms */
int sa_logaddr = 0;			/* log addresses */
int sa_logfillog = 0;			/* log to sa_logfile */
int sa_logstderr = 0;			/* log to standard error */
int sa_logstdout = 0;			/* log to standard output */
int sa_logsyslog = 0;			/* log to system logs */
int sa_logcallog = 0;			/* log to callback logs */
int sa_appendlog = 0;			/* append to log file without truncating */
char sa_logfile[256] = "/var/log/mtpmib.log";
char sa_pidfile[256] = "/var/run/mtpmib.pid";
char sa_sysctlf[256] = "/etc/mtpmib.conf";
int allow_severity = LOG_ERR;
int deny_severity = LOG_ERR;

/* file stream for log file */
FILE *stdlog = NULL;
static void
sa_version(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
%2$s\n\
Copyright (c) 2008-2009  Monavacon Limited.  All Rights Reserved.\n\
Distributed under Affero GPL Version 3, included here by reference.\n\
See `%1$s --copying' for copying permissions.\n\
", argv[0], ident);
}
static void
sa_usage(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stderr, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-H|--help-directives}\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
", argv[0]);
}
static void
sa_help(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
Arguments:\n\
    None.\n\
Options:\n\
    -a, --log-addresses\n\
        log addresses of connecting management stations.\n\
    -A, --append\n\
        append to logfiles without truncating.\n\
    -c, --config-file CONFIGFILE\n\
        use configuration file CONFIGFILE.\n\
    -C, --config-only\n\
        only load configuration given by -c option.\n\
    -d, --dump\n\
        dump sent and received PDUs.\n\
    -D, --debug [LEVEL]\n\
        set debugging verbosity to LEVEL.\n\
    -D, --debug-tokens [TOKEN[,TOKEN]*]\n\
        debug specified TOKEN's.\n\
    -f, --dont-fork\n\
        run in the foreground.\n\
    -g, --gid, --groupid GID\n\
        become group GID after listening.\n\
    -h, --help, -?, --?\n\
        print usage information and exit.\n\
    -H, --help-directives\n\
        print config directives and exit.\n\
    -I, --initialize [-]MODULE[,MODULE]*\n\
        initialize (or not, '-') these MODULE's.\n\
    -k, --keep-open\n\
        keep system files open between requests.\n\
    -l, --log-file [LOGFILE]\n\
        log to log file name LOGFILE.  [default: /var/log/mtpmib.log]\n\
    -L, --log-stderr\n\
        log to controlling terminal standard error.\n\
    -m, --mibs [+]MIB[,MIB]*\n\
        load these (additional '+') MIBs.\n\
    -M, --master\n\
        run as SNMP master instead of AgentX sub-agent.\n\
    -M, --mibdirs [+]MIBDIR[:MIBDIR]*\n\
        search these (additional, '+') colon separated directories for MIBs.\n\
    -n, --nodaemon\n\
        run in the foreground.\n\
    -n, --name NAME\n\
        use NAME for configuration file base.  [default: mtpmib]\n\
    -p, --port PORTNUM\n\
        listen on port number PORTNUM.  [default: 161]\n\
    -p, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/mtpmib.pid]\n\
    -P, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/mtpmib.pid]\n\
    -q, --quiet\n\
        suppress normal output.\n\
    -q, --quick\n\
        abbreviate output for machine readability.\n\
    -r, --noroot\n\
        do not require root privilege.\n\
    -s, --log-syslog\n\
        log to system logs.\n\
    -S, --sysctl-file FILENAME\n\
        write sysctl config file FILENAME.  [default: /etc/streams.conf]\n\
    -t, --agent-alarms\n\
        agent blocks {SIGALARM}.\n\
    -T, --transport [TRANSPORT]\n\
        default transport TRANSPORT.  [default: udp]\n\
    -u, --uid, --userid UID\n\
        become user UID after listening.\n\
    -U, --dont-remove-pidfile\n\
        do not remove PIDFILE when shutting down.\n\
    -v, --version\n\
        print version information and exit.\n\
    -V, --verbose [LEVEL]\n\
        be verbose to LEVEL.  [default: 1]\n\
    -x, --agentx-socket [SOCKET]\n\
        master AgentX on SOCKET.  [default: /var/agentx/master]\n\
    -X, --agentx\n\
        run as AgentX sub-agent instead of master (the default).\n\
    -y, --copying\n\
        print copying information and exit.\n\
", argv[0]);
}
static void
sa_copying(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
--------------------------------------------------------------------------------\n\
%1$s\n\
--------------------------------------------------------------------------------\n\
Copyright (c) 2008-2009  Monavacon Limited <http://www.monavacon.com>\n\
Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com>\n\
Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>\n\
\n\
All Rights Reserved.\n\
--------------------------------------------------------------------------------\n\
This program is free software; you can  redistribute  it and/or modify  it under\n\
the terms of the GNU Affero General Public License as published by the Free\n\
Software Foundation; Version 3 of the License.\n\
\n\
This program is distributed in the hope that it will  be useful, but WITHOUT ANY\n\
WARRANTY; without even  the implied warranty of MERCHANTABILITY or FITNESS FOR A\n\
PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.\n\
\n\
You should have received a copy of the GNU  Affero  General Public License along\n\
with this program.   If not, see <http://www.gnu.org/licenses/>, or write to the\n\
Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
--------------------------------------------------------------------------------\n\
U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf\n\
of the U.S. Government (\"Government\"), the following provisions apply to you. If\n\
the Software is supplied by the  Department of Defense (\"DoD\"), it is classified\n\
as \"Commercial  Computer  Software\"  under  paragraph  252.227-7014  of the  DoD\n\
Supplement  to the  Federal Acquisition Regulations  (\"DFARS\") (or any successor\n\
regulations) and the  Government  is acquiring  only the  license rights granted\n\
herein (the license rights customarily provided to non-Government users). If the\n\
Software is supplied to any unit or agency of the Government  other than DoD, it\n\
is  classified as  \"Restricted Computer Software\" and the Government's rights in\n\
the Software  are defined  in  paragraph 52.227-19  of the  Federal  Acquisition\n\
Regulations (\"FAR\")  (or any successor regulations) or, in the cases of NASA, in\n\
paragraph  18.52.227-86 of  the  NASA  Supplement  to the FAR (or any  successor\n\
regulations).\n\
--------------------------------------------------------------------------------\n\
Commercial  licensing  and  support of this  software is  available from OpenSS7\n\
Corporation at a fee.  See http://www.openss7.com/\n\
--------------------------------------------------------------------------------\n\
", ident);
}

void
sa_help_directives(int argc, char *argv[])
{
	ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
	init_agent("mtpMIB");
	// init_mib_modules();
	init_mib();
	init_snmp("mtpMIB");
	snmp_log(MY_FACILITY(LOG_INFO), "Configuration directives understood:\n");
	/* Unfortunately, read_config_print_usage() uses snmp_log(), meaning that it can only be writen to standard error and not standard output. */
	read_config_print_usage("    ");
}
static int
sa_sig_register(int signum, RETSIGTYPE(*handler) (int))
{
	sigset_t mask;
	struct sigaction act;

	act.sa_handler = handler ? handler : SIG_DFL;
	act.sa_flags = handler ? SA_RESTART : 0;
	sigemptyset(&act.sa_mask);
	if (sigaction(signum, &act, NULL))
		return (-1);
	sigemptyset(&mask);
	sigaddset(&mask, signum);
	sigprocmask(handler ? SIG_UNBLOCK : SIG_BLOCK, &mask, NULL);
	return (0);
}
static int sa_alm_signal = 0;
static int sa_pol_signal = 0;
static int sa_hup_signal = 0;
static int sa_int_signal = 0;
static int sa_trm_signal = 0;
static int sa_alm_handle = 0;
void
sa_alm_callback(uint req, void *arg)
{
	if (req == sa_alm_handle)
		sa_alm_handle = 0;
	sa_alm_signal = 1;
	return;
}

static RETSIGTYPE
sa_alm_handler(int signum)
{
	sa_alm_signal = 1;
	return (RETSIGTYPE) (0);
}
static void
sa_snmp_alm_handler(uint reg, void *clientarg)
{
	sa_alm_signal = 1;
	return;
}
static int
sa_alm_catch(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, &sa_alm_handler);
	return (-1);
}
static int
sa_alm_block(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, NULL);
	if (sa_alm_handle) {
		uint handle = sa_alm_handle;

		sa_alm_handle = 0;
		snmp_alarm_unregister(handle);
	}
	return (0);
}
static int
sa_alm_action(void)
{
	sa_alm_signal = 0;
	return (0);
}

static RETSIGTYPE
sa_pol_handler(int signum)
{
	sa_pol_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_pol_catch(void)
{
	return sa_sig_register(SIGPOLL, &sa_pol_handler);
}
static int
sa_pol_block(void)
{
	return sa_sig_register(SIGPOLL, NULL);
}

/*
 * Both the sc(4) module and sad(4) driver issue an M_PCSIG message with
 * SIGPOLL to the stream head whenever the STREAMS configuration or autopush
 * configuration changes, indicating to the agent which has the sc(4) or
 * sad(4) Stream open that it is necessary to reread information from the
 * kernel.  This fact is merely recorded, as this information is not read each
 * time that a configuration change occurs, but only after a request from some
 * portion of that information occurs. This condition is also set when the
 * sc(4) and sad(4) Streams are first opened. The SIGPOLL will also deliver in
 * siginfo the file descriptor issuing the signal, so we could distiguish
 * between sc(4) and sad(4) signals, but since one can be pushed over the
 * other, there is little point in distinguishing.
 *
 * sc(4) or sad(4) also should be modified to provide the general streams
 * statistics supported here; even though they are available through the /proc
 * filesystem on Linux Fast-STREAMS.
 */
static int
sa_pol_action(void)
{
	sa_pol_signal = 0;
	snmp_log(MY_FACILITY(LOG_INFO), "%s: Caught SIGPOLL, will re-read data structures", sa_program);
	sa_changed = 1;
	return (0);
}

static RETSIGTYPE
sa_hup_handler(int signum)
{
	sa_hup_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_hup_catch(void)
{
	if (sa_agentx)
		return sa_sig_register(SIGHUP, &sa_hup_handler);
	return (-1);
}
static int
sa_hup_block(void)
{
	return sa_sig_register(SIGHUP, NULL);
}
static int
sa_hup_action(void)
{
	/* There are several times that we might be sent a SIGHUP.  We might be sent a SIGHUP by logrotate asking us to close and reopen our log files. */
	sa_hup_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "Caught SIGHUP, reopening files.");
	if (sa_output > 1)
		snmp_log(MY_FACILITY(LOG_NOTICE), "Reopening output file %s", sa_logfile);
	if (sa_logfillog != 0) {
		fflush(stdlog);
		fclose(stdlog);
		snmp_disable_filelog();
		if ((stdlog = freopen(sa_logfile, sa_appendlog ? "a" : "w", stdlog)) == NULL) {
			/* I hope we have another log sink. */
			snmp_log(MY_FACILITY(LOG_ERR), "%s", strerror(errno));
			snmp_log(MY_FACILITY(LOG_ERR), "Could not reopen log file %s", sa_logfile);
		}
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	return (0);
}

static RETSIGTYPE
sa_int_handler(int signum)
{
	sa_int_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_int_catch(void)
{
	return sa_sig_register(SIGINT, &sa_int_handler);
}
static int
sa_int_block(void)
{
	return sa_sig_register(SIGINT, NULL);
}
static void sa_exit(int retval);
static int
sa_int_action(void)
{
	sa_int_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGINT, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}

static RETSIGTYPE
sa_trm_handler(int signum)
{
	sa_trm_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_trm_catch(void)
{
	return sa_sig_register(SIGTERM, &sa_trm_handler);
}
static int
sa_trm_block(void)
{
	return sa_sig_register(SIGTERM, NULL);
}
static void sa_exit(int retval);
static int
sa_trm_action(void)
{
	sa_trm_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGTERM, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}
static void
sa_sig_catch(void)
{
	sa_alm_catch();
	sa_pol_catch();
	sa_hup_catch();
	sa_int_catch();
	sa_trm_catch();
}
static void
sa_sig_block(void)
{
	sa_alm_block();
	sa_pol_block();
	sa_hup_block();
	sa_int_block();
	sa_trm_block();
}

int
sa_start_timer(long duration)
{
	if (sa_alarms) {
		struct itimerval setting = {
			{0, 0},
			{duration / 1000, (duration % 1000) * 1000}
		};
		if (sa_alm_catch())
			return (-1);
		if (setitimer(ITIMER_REAL, &setting, NULL))
			return (-1);
		sa_alm_signal = 0;
		return (0);
	} else {
#if defined NETSNMP_DS_APPLICATION_ID
		struct timeval setting = {
			duration / 1000, (duration % 1000) * 1000
		};
		sa_alm_handle = snmp_alarm_register_hr(setting, 0, sa_snmp_alm_handler, NULL);
#else
		sa_alm_handle = snmp_alarm_register((duration + 999) / 1000, 0, sa_snmp_alm_handler, NULL);
#endif
		return (sa_alm_handle ? 0 : -1);
	}
}
static void
sa_exit(int retval)
{
	if (retval)
		snmp_log(MY_FACILITY(LOG_ERR), "%s: Exiting %d", sa_program, retval);
	else
		snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Exiting %d", sa_program, retval);
	fflush(stdout);
	fflush(stderr);
	sa_sig_block();
	closelog();
	exit(retval);
}
static void
sa_init_logging(int argc, char *argv[])
{
	static char progname[256];

	/* The purpose of this function is to bring logging up before forking (and while still in the foreground) so that we can use the snmp_log() function before and during forking if necessary.
	   Note that the default configuration for snmp_log() is to send all logs to standard error. */
	strncpy(progname, basename(argv[0]), sizeof(progname));
	snmp_disable_log();
	if (sa_logfillog) {
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	if (sa_logstderr | sa_logstdout) {
#if defined LOG_PERROR
		/* Note that when we have Linux LOG_PERROR, and logs go both to syslog and stderr, it is better to use the LOG_PERROR than to use snmp_log()'s print to stderr, as the former is better 
		   formated. */
		if (!sa_logsyslog)
			snmp_enable_stderrlog();
#else				/* defined LOG_PERROR */
		snmp_enable_stderrlog();
#endif				/* defined LOG_PERROR */
	}
	if (sa_logsyslog) {
#if !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT
		snmp_enable_syslog();
#else				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		snmp_enable_syslog_ident("mtpMIB", LOG_DAEMON);
#endif				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		/* Note that the way that snmp sets up the logger is not really the way we want it, so close the log and reopen it the way we want. */
		closelog();
#if defined LOG_PERROR
		openlog("mtpMIB", LOG_PID | LOG_CONS | LOG_NDELAY | (sa_logstderr ? LOG_PERROR : 0), MY_FACILITY(0));
#else				/* defined LOG_PERROR */
		openlog("mtpMIB", LOG_PID | LOG_CONS | LOG_NDELAY, MY_FACILITY(0));
#endif				/* defined LOG_PERROR */
	}
	if (sa_logcallog) {
		snmp_enable_calllog();
	}
}
static void
sa_enter(int argc, char *argv[])
{
	if (sa_nomead) {
		pid_t pid;

		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent exits */
			exit(0);
		}
		setsid();	/* become a session leader */
		/* fork once more for SVR4 */
		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent responsible for writing pid file */
			if (sa_nomead || sa_pidfile[0] != '\0') {
				FILE *pidf;

				/* initialize default filename */
				if (sa_pidfile[0] == '\0')
					snprintf(sa_pidfile, sizeof(sa_pidfile), "/var/run/%s.pid", sa_program);
				if (sa_output > 1) {
					snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Writing daemon pid to file %s", sa_program, sa_pidfile);
				}
				if ((pidf = fopen(sa_pidfile, "w+"))) {
					fprintf(pidf, "%d", (int) pid);
					fflush(pidf);
					fclose(pidf);
				} else {
					snmp_log(MY_FACILITY(LOG_ERR), "%s: %m", sa_program);
					snmp_log(MY_FACILITY(LOG_ERR), "%s: Could not write pid to file %s", sa_program, sa_pidfile);
					sa_exit(2);
					/* no return */
				}
			}
			/* parent exits */
			exit(0);
		}
		/* child continues */
		/* release current directory */
		if (chdir("/") < 0) {
			perror(argv[0]);
			exit(2);
		}
		umask(0);	/* clear file creation mask */
		/* rearrange file streams */
		fclose(stdin);
	}
	/* continue as foreground or background */
	sa_init_logging(argc, argv);
	sa_sig_catch();
	snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Startup complete.", sa_program);
}
static void
sa_mloop(int argc, char *argv[])
{
	if (sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as AgentX client\n", argv[0]);
		/* run as an AgentX client */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
	} else {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master agent\n", argv[0]);
		/* run as SNMP master */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
	}
	if (sa_alarms) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using application alarms\n", argv[0]);
		/* use application alarms */
		ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
	}
	/* initialize agent */
	init_agent("mtpMIB");
	/* initialize MIB */
	init_mtpMIB();
	/* initialize SNMP */
	init_snmp("mtpMIB");
	if (!sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master\n", argv[0]);
#if !defined NETSNMP_DS_APPLICATION_ID
		init_master_agent(710, NULL, NULL);
#else
		init_master_agent();
#endif
	}
	for (;;) {
		int retval;

		/* to use select or poll you need to use the snmp_select_info() to obtain the fd of the agentx socket and add it to the fdset. */
		/* note that SIGALRM is used by snmp: use the snmp_alarm() api instead */
#if 0
		if (snmp_select() == 0) {
			if (sa_alarms == 0)
				run_alarms();
		}
#endif
		retval = agent_check_and_process(1);	/* 0 == don't block */
		if (retval == 0) {
			/* alarm occurred, alarm conditions checked */
		} else if (retval == -1) {
			/* error (or signal) ocurred */
			if (sa_alm_signal) {
				sa_alm_action();
			}
			if (sa_pol_signal) {
				sa_pol_action();
			}
			if (sa_hup_signal) {
				sa_hup_action();
			}
			if (sa_int_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("mtpMIB");
				sa_int_action();	/* no return */
			}
			if (sa_trm_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("mtpMIB");
				sa_trm_action();	/* no return */
			}
		} else if (retval > 0) {
			/* processed packets */
			if (sa_fclose) {
				/* close files after each request */
				if (sa_fd != 0) {
					int fd = sa_fd;

					sa_fd = 0;
					close(fd);
				}
			}
			sa_stats_refresh = 1;
			sa_request++;
		}
	}
	if (sa_debug)
		snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
	snmp_shutdown("mtpMIB");
}

int
main(int argc, char *argv[])
{
	for (;;) {
		int c, val, fd;
		char *cptr;
		struct passwd *pw;
		struct group *gr;
		struct stat st;

#if defined _GNU_SOURCE
		int option_index = 0;
                /* *INDENT-OFF* */
                static struct option long_options[] = {
                        {"log-addresses",	no_argument,		NULL, 'a'},
                        {"append",		no_argument,		NULL, 'A'},
                        {"config-file",		required_argument,	NULL, 'c'},
                        {"no-configs",		no_argument,		NULL, 'C'},
                        {"dump",		no_argument,		NULL, 'd'},
                        {"debug",		optional_argument,	NULL, 'D'},
                        {"debug-tokens",	optional_argument,	NULL, 'D'},
                        {"dont-fork",		no_argument,		NULL, 'f'},
                        {"gid",			required_argument,	NULL, 'g'},
                        {"groupid",		required_argument,	NULL, 'g'},
                        {"help",		no_argument,		NULL, 'h'},
                        {"?",			no_argument,		NULL, 'h'},
                        {"help-directives",	no_argument,		NULL, 'H'},
                        {"initialize",		required_argument,	NULL, 'I'},
                        {"init-modules",	required_argument,	NULL, 'I'},
                        {"keep-open",		no_argument,		NULL, 'k'},
                        {"log-file",		optional_argument,	NULL, 'l'},
                        {"logfile",		optional_argument,	NULL, 'l'},
                        {"Lf",			optional_argument,	NULL, 'l'},
                        {"LF",			required_argument,	NULL, 'l'},
                        {"log-stderr",		no_argument,		NULL, 'L'},
                        {"Le",			no_argument,		NULL, 'L'},
                        {"LE",			required_argument,	NULL, 'L'},
                        {"mibs",		required_argument,	NULL, 'm'},
                        {"master",		no_argument,		NULL, 'M'},
                        {"mibdirs",		required_argument,	NULL, 'M'},
                        {"nodaemon",		no_argument,		NULL, 'n'},
                        {"name",		required_argument,	NULL, 'n'},
                        {"dry-run",		no_argument,		NULL, 'N'},
                        {"log-stdout",		no_argument,		NULL, 'o'},
                        {"Lo",			no_argument,		NULL, 'o'},
                        {"LO",			required_argument,	NULL, 'o'},
                        {"port",		required_argument,	NULL, 'p'},
                        {"pidfile",		required_argument,	NULL, 'P'},
                        {"quiet",		no_argument,		NULL, 'q'},
                        {"quick",		no_argument,		NULL, 'q'},
                        {"noroot",		no_argument,		NULL, 'r'},
                        {"log-syslog",		no_argument,		NULL, 's'},
                        {"Ls",			no_argument,		NULL, 's'},
                        {"LS",			required_argument,	NULL, 's'},
                        {"syslog",		no_argument,		NULL, 's'},
                        {"sysctl-file",		required_argument,	NULL, 'S'},
                        {"agent-alarms",	no_argument,		NULL, 't'},
                        {"transport",		optional_argument,	NULL, 'T'},
                        {"uid",			required_argument,	NULL, 'u'},
                        {"userid",		required_argument,	NULL, 'u'},
                        {"dont-remove-pidfile",	no_argument,		NULL, 'U'},
                        {"leave-pidfile",	no_argument,		NULL, 'U'},
                        {"version",		no_argument,		NULL, 'v'},
                        {"verbose",		optional_argument,	NULL, 'V'},
                        {"agentx-socket",	required_argument,	NULL, 'x'},
                        {"agentx",		no_argument,		NULL, 'X'},
                        {"copying",		no_argument,		NULL, 'y'},
#if 0
                        {"directory",		required_argument,	NULL, 'd'},
                        {"basename",		required_argument,	NULL, 'b'},
                        {"outfile",		required_argument,	NULL, 'o'},
                        {"errfile",		required_argument,	NULL, 'e'},
#endif
                        { 0, }
                };
                /* *INDENT-ON* */

		c = getopt_long_only(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy", long_options, &option_index);
#else				/* defined _GNU_SOURCE */
		c = getopt(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy");
#endif				/* defined _GNU_SOURCE */
		if (c == -1) {
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: done options processing\n", argv[0]);
			break;
		}
		switch (c) {
		case 0:
			goto bad_usage;
		case 'a':	/* -a, --log-addresses */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging addresses\n", argv[0]);
			sa_logaddr++;
			break;
		case 'A':	/* -A, --append */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will not truncate logfile\n", argv[0]);
#if defined NETSNMP_DS_LIB_APPEND_LOGFILES
			ds_set_boolean(DS_LIBRARY_ID, NETSNMP_DS_LIB_APPEND_LOGFILES, 1);
#endif				/* defined NETSNMP_DS_LIB_APPEND_LOGFILES */
			sa_appendlog = 1;
			break;
		case 'c':	/* -c, --config-file CONFIGFILE */
			if (optarg == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using configuration file %s\n", argv[0], optarg);
			ds_set_string(DS_LIBRARY_ID, DS_LIB_OPTIONALCONFIG, optarg);
			break;
		case 'C':	/* -C, --no-configs */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: not reading default config files\n", argv[0]);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DONT_READ_CONFIGS, 1);
			break;
		case 'd':	/* -d, --dump */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting packet dump\n", argv[0]);
			sa_dump = 1;
			// snmp_set_dump_packet(sa_dump);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DUMP_PACKET, sa_dump);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, sa_dump);
			break;
		case 'D':	/* -D, --debug [LEVEL], --debug-tokens [TOKENS] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing debug verbosity\n", argv[0]);
			if (optarg == NULL) {
				/* no option: must be -D, --debug */
				sa_debug++;
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging all tokens\n", argv[0]);
				if (sa_debug)
					debug_register_tokens("ALL");
			} else {
				cptr = optarg;
				if ((val = strtol(optarg, &cptr, 0)) < 0)
					goto bad_option;
				if (*cptr == '\0') {
					/* it is just a number, must be -D, --debug [LEVEL] */
					sa_debug = val;
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				} else {
					/* not a number, must be -D, --debug-tokens TOKENS */
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging tokens %s\n", argv[0], optarg);
					debug_register_tokens(optarg);
				}
			}
			break;
		case 'f':	/* -f, --dont-fork */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing daemon mode\n", argv[0]);
			sa_nomead = 0;
			break;
		case 'u':	/* -u, --uid, --userid UID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* UID can be name or number */
			if ((pw = (*cptr == '\0') ? getpwuid((uid_t) val) : getpwnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as uid %s(%d)\n", argv[0], pw->pw_name, pw->pw_uid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_USERID, pw->pw_uid);
			break;
		case 'g':	/* -g, --gid, --groupdid GID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* GID can be name or number */
			if ((gr = (*cptr == '\0') ? getgrgid((gid_t) val) : getgrnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as gid %s(%d)\n", argv[0], gr->gr_name, gr->gr_gid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_GROUPID, gr->gr_gid);
			break;
		case 'h':	/* -h, --help, -?, --? */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing help message\n", argv[0]);
			sa_help(argc, argv);
			exit(0);
		case 'H':	/* -H, --help-directives */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing config directives\n", argv[0]);
			sa_help_directives(argc, argv);
			exit(0);
		case 'I':	/* -I, --init-modules, --initialize MODULE[{,| |:}MODULE]* */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will initialize modules: %s\n", argv[0], optarg);
			add_to_init_list(optarg);
			break;
		case 'k':	/* -k, --keep-open */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: keeping files open\n", argv[0]);
			sa_fclose = 0;
			break;
		case 'l':	/* -l, --log-file, --logfile, -Lf, -LF p1[-p2] [LOGFILE] */
			if (optarg != NULL)
				strncpy(sa_logfile, optarg, sizeof(sa_logfile));
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will log to file %s\n", argv[0], sa_logfile);
			sa_logfillog = 1;
			break;
		case 'L':	/* -L, --log-stderr, -Le, -LE p1[-p2] */
			/* Note that the recent NET-SNMP version of this option is far more complicated: -Le is the same as the old version of the option; -Lf LOGFILE is like the -l option; -Ls is
			   like the -s option; -Lo logs messages to standard output; -LX p1[-p2] [LOGFILE], where X = E, F, S or O, logs priority p1 and above to X, or p1 thru p2 to X. */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to standard error\n", argv[0]);
			sa_logstderr = 1;
			break;
		case 'm':	/* -m, --mibs MIBS */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBS %s\n", argv[0], optarg);
			break;
		case 'M':	/* -M, --master or -M, --mibdirs MIBDIRS */
			if (optarg) {
				/* -M, --mibdirs MIBDIRS */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBDIRS %s\n", argv[0], optarg);
			} else {
				/* -M, --master */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting SNMP master\n", argv[0]);
				sa_agentx = 0;
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
			}
			break;
		case 'n':	/* -n, --nodaemon or -n, --name NAME */
			if (optarg) {
				/* -n, --name NAME */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using name %s\n", argv[0], optarg);
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, optarg);
			} else {
				/* -n, --nodaemon */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing deamon mode\n", argv[0]);
				sa_nomead = 0;
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, basename(argv[0]));
			}
			break;
		case 'N':	/* -N, --dry-run */
#if defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for dry-runs startup\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_QUIT_IMMEDIATELY, 1);
			break;
#else				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -N option not supported\n", argv[0]);
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
		case 'o':	/* -o, --log-stdout, -Lo, -LO p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to stdout\n", argv[0]);
			sa_logstdout = 1;
			break;
		case 'p':	/* -p, --port PORTNUM or -p, --pidfile PIDFILE */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0 || val > 16383)
				goto bad_option;
			if (*cptr == '\0') {
				char buf[4096];

				/* -p, --port PORTNUM */
				if ((cptr = ds_get_string(DS_APPLICATION_ID, DS_AGENT_PORTS)))
					snprintf(buf, sizeof(buf), "%s,%s", cptr, optarg);
				else
					strncpy(buf, optarg, sizeof(buf));
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PORTS, buf);
				break;
			}
			/* fall through */
		case 'P':	/* -p, -P, --pidfile PIDFILE */
			if (optarg) {
				/* either it exists */
				if (stat(optarg, &st) == -1) {
					/* or we can create it */
					if ((fd = open(optarg, O_CREAT, 0600)) == -1) {
						perror(argv[0]);
						goto bad_option;
					}
					close(fd);
				}
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting pid file to %s\n", argv[0], optarg);
				strncpy(sa_pidfile, optarg, sizeof(sa_pidfile));
			}
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using pidfile %s\n", argv[0], sa_pidfile);
			break;
		case 'q':	/* -q, --quiet, --quick */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing normal output\n", argv[0]);
			sa_debug = 0;
			sa_output = 0;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			// snmp_set_quick_print();
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_QUICK_PRINT, 1);
			break;
		case 'r':	/* -r, --noroot */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for non-root access\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
			break;
		case 's':	/* -s, --log-syslog, -Ls, -LS p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to system logs\n", argv[0]);
			sa_logsyslog = 1;
			break;
		case 'S':	/* -S, -sysctl-file FILENAME */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using %s for backing\n", argv[0], optarg);
			strncpy(sa_sysctlf, optarg, sizeof(sa_sysctlf));
			break;
		case 't':	/* -t, --agent-alarms */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting agent alarms\n", argv[0]);
			sa_alarms = 0;
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
			break;
		case 'T':	/* -T, --transport [TRANSPORT] */
			if (optarg == NULL)
				goto udp_transport;
			if (!strcasecmp("TCP", optarg)) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to TCP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val |= SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else if (!strcasecmp("UDP", optarg)) {
			      udp_transport:
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to UDP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val &= ~SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else
				goto bad_option;
			break;
		case 'U':
#if defined NETSNMP_DS_AGENT_LEAVE_PIDFILE
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will leave pidfile after shutdown\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_LEAVE_PIDFILE, 1);
#else
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -U option not supported\n");
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_LEAVE_PIDFILE */
			break;
		case 'v':	/* -v, --version */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing version message\n", argv[0]);
			sa_version(argc, argv);
			exit(0);
		case 'V':	/* -V, --verbose [LEVEL] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing output verbosity\n", argv[0]);
			if (optarg == NULL) {
				sa_output++;
			} else {
				if ((val = strtol(optarg, NULL, 0)) < 0)
					goto bad_option;
				sa_output = val;
			}
			if (sa_output > 1)
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 1);
			else
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			break;
		case 'x':	/* -x, --agentx-socket SOCKET */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX socket to %s\n", argv[0], optarg);
			ds_set_string(DS_APPLICATION_ID, DS_AGENT_X_SOCKET, optarg);
			// ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_AGENTX_MASTER, 1);
			break;
		case 'X':	/* -X, --agentx */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX sub-agent\n", argv[0]);
			sa_agentx = 1;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
			break;
		case 'y':	/* -y, --copying */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing copying message\n", argv[0]);
			sa_copying(argc, argv);
			exit(0);
		case '?':
		case ':':
		default:
		      bad_option:
			optind--;
			goto bad_nonopt;
		      bad_nonopt:
			if (sa_output || sa_debug) {
				if (optind < argc) {
					fprintf(stderr, "%s: syntax error near '", argv[0]);
					while (optind < argc)
						fprintf(stderr, "%s ", argv[optind++]);
					fprintf(stderr, "'\n");
				} else {
					fprintf(stderr, "%s: missing option or argument", argv[0]);
					fprintf(stderr, "\n");
				}
				fflush(stderr);
			      bad_usage:
				sa_usage(argc, argv);
			}
			exit(2);
		}
	}
	if (optind < argc) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: excess non-option arguments\n", argv[0]);
		goto bad_nonopt;
	}
	sa_enter(argc, argv);	/* daemonize if necessary */
	sa_mloop(argc, argv);	/* execute main loop */
	exit(0);
}
#endif				/* !defined MODULE */
#endif				/* defined MASTER */
