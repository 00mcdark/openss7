% -*- texinfo -*- vim: ft=texinfo
% vim: ft=texinfo nosmartindent nocindent noautoindent tw=100
% =========================================================================
%
% @(#) $Id: sli.texi,v 0.9.2.7 2008-08-03 05:05:17 brian Exp $
%
% =========================================================================
%
% Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
%
% All Rights Reserved.
%
% Permission is granted to make and distribute verbatim copies of this
% manual provided the copyright notice and this permission notice are
% preserved on all copies.
%
% Permission is granted to copy and distribute modified versions of this
% manual under the conditions for verbatim copying, provided that the
% entire resulting derived work is distributed under the terms of a
% permission notice identical to this one.
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any successor
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified $Date: 2008-08-03 05:05:17 $ by $Author: brian $
%
% =========================================================================
\input texinfo @c -*- texinfo -*-
@c vim: ft=texinfo nosmartindent nocindent noautoindent tw=100
@c %**start of header
@setfilename sli.info
@include texi/args.texi
@set MANUAL_TITLE Signalling Link Interface (SLI)
@set MANUAL_TYPE Specification
@settitle @value{MANUAL_TITLE}
@c %**end of header

@dircategory OpenSS7
@direntry
* SLI: (sli).			Signalling Link Interface
@end direntry

@include texi/args.texi
@set MANUAL_TITLE Signalling Link Interface (SLI)
@set MANUAL_TYPE Specification

@comment The following copyright information goes at the head of each .info file.
@ifinfo
This file documents the OpenSS7 @value{MANUAL_TITLE}.

This is Edition @value{PACKAGE_VERSION}, last updated @value{PACKAGE_DATE}, for
@value{PACKAGE_TITLE} version @value{PACKAGE_VERSION} release @value{PACKAGE_RELEASE} published by
@uref{http://www.openss7.com/,OpenSS7 Corporation}.


Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock}


All Rights Reserved.

Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of OpenSS7 Corporation not be used in
advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  OpenSS7 Corporation makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@ignore
Permission is granted to process this file through Tex and print the results, provided the printed
document carries copying permission notice identical to this one except for the removal of this
paragraph (this paragraph not being relevant to the printed manual).

@end ignore
OpenSS7 Corporation disclaims all warranties with regard to this documentation including all implied
warranties of merchantability, fitness for a particular purpose, non-infringement, or title; that
the contents of the document are suitable for any purpose, or that the implementation of such
contents will not infringe on any third party patents, copyrights, trademarks or other rights..  In
no event shall OpenSS7 Corporation be liable for any direct, indirect, special or consequential
damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action
of contract, negligence or other tortious action, arising out of or in connection with any use of
this document or the performance or implementation of the contents thereof.

OpenSS7 Corporation reserves the right to revise this software and documentation for any reason,
including but not limited to, conformity with standards promulgated by various agencies, utilization
of advances in the state of the technical arts, or the reflection of changes in the design of any
techniques, or procedures embodied, described, or referred to herein.  OpenSS7 Corporation is under
no obligation to provide any feature listed herein.
@end ifinfo

@include texi/args.texi
@set MANUAL_TITLE Signalling Link Interface (SLI)
@set MANUAL_TYPE Specification

@shorttitlepage @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@titlepage
@titlefont{@value{MANUAL_TITLE}}
@sp 0.5
@title @value{MANUAL_TYPE}
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}
@subtitle Updated @value{PACKAGE_DATE}
@sp 0.2
@subtitle Distributed with Package @value{PACKAGE}-@value{VERSION}
@sp 2
@subtitle Copyright @copyright{} 2008  OpenSS7 Corporation
@subtitle All Rights Reserved.
@sp 4
@quotation
@subheading Abstract
This document is a @value{MANUAL_TYPE} containing technical details concerning the implementation of
the @value{MANUAL_TITLE} for OpenSS7.  It contains recommendations on software architecture as well
as platform and system applicability of the @value{MANUAL_TITLE}.  It provides abstraction of the
signalling link interface to these components as well as providing a basis for signalling link
control for other signalling link protocols.
@end quotation
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock}

@noindent
All Rights Reserved.

@subsubheading Published by:
@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
Unauthorized distribution or duplication is prohibited.

@sp 1

@ignore
@noindent
This software and related documentation is protected by copyright and distributed under licenses
restricting its use, copying, distribution and decompilation.  No part of this software or related
documentation may be reproduced in any form by any means without the prior written authorization of
the copyright holder, and licensors, if any.

@noindent
The recipient of this document, by its retention and use, warrants that the recipient will protect
this information and keep it confidential, and will not disclose the information contained in this
document without the written permission of its owner.

@noindent
OpenSS7 Corporation reserves the right to revise this software and documentation for any reason,
including but not limited to, conformity with standards promulgated by various agencies, utilization
of advances in the state of the technical arts, or the reflection of changes in the design of any
techniques, or procedures embodied, described, or referred to herein.  OpenSS7 Corporation is under
no obligation to provide any feature listed herein.
@end ignore

@noindent
Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of OpenSS7 Corporation not be used in
advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  OpenSS7 Corporation makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@subsubheading Notice:

@noindent
@b{OpenSS7 Corporation disclaims all warranties with regard to this documentation including all
implied warranties of merchantability, fitness for a particular purpose, non-infringement, or title;
that the contents of the document are suitable for any purpose, or that the implementation of such
contents will not infringe on any third party patents, copyrights, trademarks or other rights..  In
no event shall OpenSS7 Corporation be liable for any direct, indirect, special or consequential
damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action
of contract, negligence or other tortious action, arising out of or in connection with any use of
this document or the performance or implementation of the contents thereof.}

@sp 1

@noindent
OpenSS7 Corporation reserves the right to revise this software and documentation for any reason,
including but not limited to, conformity with standards promulgated by various agencies, utilization
of advances in the state of the technical arts, or the reflection of changes in the design of any
techniques, or procedures embodied, described, or referred to herein.  OpenSS7 Corporation is under
no obligation to provide any feature listed herein.

@vskip 0pt
@end titlepage
@iftex
@headings off
@everyheading @thistitle @| @thisfile @| @thischaptername
@evenheading @thischapter @| @| @thisfile
@oddheading @thistitle @| @| @thischaptername
@everyfooting Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE} @| @value{PACKAGE_DATE} @| @thispage
@evenfooting @thispage @| @| Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}
@oddfooting @value{PACKAGE_DATE} @| @| @thispage
@end iftex
@page

@c Define an index of primitives
@defcodeindex pr
@c Define an index of primitive values
@defcodeindex pv
@c Define an index of primitive error values
@defcodeindex pe
@c Define an index of protocol states
@defcodeindex st
@c Define an index of input-output controls
@defcodeindex ct
@c Define an index of manual pages.
@defcodeindex mp

@c frags out automake
@c @ifnottex
@c @c concatenate indices for text, html and info
@syncodeindex pr cp
@syncodeindex pv cp
@syncodeindex pe cp
@syncodeindex st cp
@syncodeindex mp cp
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex ct cp
@c @end ifnottex

@include texi/macros.texi
@include texi/versions.texi

@iftex

@macro prim{name}
@code{\name\}@prindex \name\
@end macro

@macro pval{name}
@code{\name\}@pvindex \name\
@end macro

@macro perr{name}
@code{\name\}@peindex \name\
@end macro

@macro psta{name}
@code{\name\}@stindex \name\
@end macro

@macro parm{name}
@code{\name\}@vrindex \name\
@end macro

@macro pioc{name}
@code{\name\}@ctindex \name\
@end macro

@end iftex

@ifnottex
@c skip deep indexing for plain text, html and info
@c it messes up column with maximums (texinfo bug)

@macro prim{name}
@code{\name\}
@end macro

@macro pval{name}
@code{\name\}
@end macro

@macro perr{name}
@code{\name\}
@end macro

@macro psta{name}
@code{\name\}
@end macro

@macro parm{name}
@code{\name\}
@end macro

@macro pioc{name}
@code{\name\}
@end macro

@end ifnottex

@ifnottex
@node Top
@top Signalling Link Interface
@end ifnottex

@menu
* Preface::
* Introduction::
* The Signalling Link Layer::
* SLI Services Definition::
* SLI Primitives::
* Diagnostics Requirements::
@c * Addendum for ITU-T Q.703 Conformance::
@c * Addendum for ANSI T1.111.3 Conformance::
@c * Addendum for ETSI ETS 300 008-1 Conformance::
@c * Addendum for RFC 4165 Conformance::
@c * Mapping of SLI Primitives to ITU-T Q.703::
@c * Mapping of SLI Primitives to ANSI T1.111.3::
@c * State/Event Tables::
@c * Primitive Precedence Tables::
* LMI Header File Listing::
* SLI Header File Listing::
* License::
* Glossary::
* Acronyms::
* References::
@c @iftex
@c * Indices::
@c @end iftex
@c @ifnottex
* Index::
@c @end ifnottex
@end menu

@iftex
@c insert list of figures and tables for printed manuals
@page
@heading List of Figures
@listoffloats Figure
@page
@heading List of Tables
@listoffloats Table
@end iftex

@node Preface
@unnumbered Preface

@section Security Warning

@noindent
Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of @cite{OpenSS7 Corporation} not be used
in advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  @cite{OpenSS7 Corporation} makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} disclaims all warranties with regard to this
documentation including all implied warranties of merchantability, fitness for a particular purpose,
non-infringement, or title; that the contents of the document are suitable for any purpose, or that
the implementation of such contents will not infringe on any third party patents, copyrights,
trademarks or other rights.  In no event shall @cite{OpenSS7 Corporation} be liable for any direct,
indirect, special or consequential damages or any damages whatsoever resulting from loss of use,
data or profits, whether in an action of contract, negligence or other tortious action, arising out
of or in connection with any use of this document or the performance or implementation of the
contents thereof.

@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} is making this documentation available as a
reference point for the industry.  While @cite{OpenSS7 Corporation} believes that these interfaces
are well defined in this release of the document, minor changes may be made prior to products
conforming to the interfaces being made available.

@section Abstract

This document is a @value{MANUAL_TYPE} containing technical details concerning the implementation of
the @value{MANUAL_TITLE} for OpenSS7.  It contains recommendations on software architecture as well
as platform and system applicability of the @value{MANUAL_TITLE}.

@noindent
This document specifies a @value{MANUAL_TITLE} Specification in support of the OpenSS7 Signalling
Link (SL) protocol stacks.  It provides abstraction of the signalling link interface to these
components as well as providing a basis for signalling link control for other link control
protocols.

@section Purpose
@cpindex STREAMS

The purpose of this document is to provide technical documentation of the @value{MANUAL_TITLE}.
This document is intended to be included with the OpenSS7 @cite{STREAMS} software package released
by @cite{OpenSS7 Corporation}.  It is intended to assist software developers, maintainers and users
of the @value{MANUAL_TITLE} with understanding the software architecture and technical interfaces
that are made available in the software package.

@section Intent

It is the intent of this document that it act as the primary source of information concerning the
@value{MANUAL_TITLE}.  This document is intended to provide information for writers of OpenSS7
@value{MANUAL_TITLE} applications as well as writers of OpenSS7 @value{MANUAL_TITLE} Users.

@section Audience

The audience for this document is software developers, maintainers and users and integrators of the
@value{MANUAL_TITLE}.  The target audience is developers and users of the OpenSS7 SS7 stack.

@section Disclaimer

Although the author has attempted to ensure that the information in this document is complete and
correct, neither the Author nor OpenSS7 Corporation will take any responsibility in it.

@section Revision History

Take care that you are working with a current version of this documentation: you will not be
notified of updates.  To ensure that you are working with a current version, check the
@uref{http://www.openss7.org/,OpenSS7 Project} website for a current version.

Only the texinfo or roff source is controlled.  A printed (or postscript) version of this document
is an @strong{UNCONTROLLED VERSION}.

@smallexample

$Log: sli.texi,v $
Revision 0.9.2.7  2008-08-03 05:05:17  brian
- conditional @syncodeindex frags out automake, fails distcheck

Revision 0.9.2.6  2008-07-11 09:36:13  brian
- updated documentation

Revision 0.9.2.5  2008-04-29 07:10:40  brian
- updating headers for release

Revision 0.9.2.4  2007/08/14 12:17:05  brian
- GPLv3 header updates

Revision 0.9.2.3  2007/08/03 13:34:54  brian
- manual updates, put ss7 modules in public release

Revision 0.9.2.2  2007/07/09 09:04:51  brian
- working up SLI specification

Revision 0.9.2.1  2007/07/04 08:24:58  brian
- added new files

@end smallexample

@node Introduction
@chapter Introduction

This document specifies a @cite{STREAMS}-based
@cpindex STREAMS
kernel-level instantiation of the ITU-T @value{MANUAL_TITLE} definition.  The @value{MANUAL_TITLE}
enables the user of a a signalling link service to access and use any of a variety of
conforming signalling link providers without specific knowledge of the provider's protocol.
The service interface is designed to support any network signalling link protocol and user
signalling link protocol.  This interface only specifies access to signalling link
service providers, and does not address issues concerning signalling link management,
protocol performance, and performance analysis tools.

This specification assumes that the reader is familiar with ITU-T state machines and signalling link
interfaces (e.g.  Q.703, Q.2210), and @cite{STREAMS}.
@cpindex STREAMS

@section Related Documentation

@itemize ---
@item @strong{ITU-T Recommendation Q.703 (White Book)}
@item @strong{ITU-T Recommendation Q.2210 (White Book)}
@item @strong{ANSI T1.111.3/2002}
@item @strong{System V Interface Definition, Issue 2 - Volume 3}
@end itemize

@subsection Role

This document specifies an interface that supports the services provided by the @dfn{Signalling
System No. 7 (SS7)} for ITU-T, ANSI and ETSI applications as described in ITU-T Recommendation
Q.703, ITU-T Recommendation Q.2210, ANSI T1.111.3, ETSI ETS 300 008-1.  These specifications are
targeted for use by developers and testers of protocol modules that require signalling link
service.

@section Definitions, Acronyms, Abbreviations
@cpindex STREAMS

@table @dfn
@item LM
Local Management.
@item LMS
Local Management Service.
@item LMS User
A user of Local Management Services.
@item LMS Provider
A provider of Local Management Services.
@item Originating SL User
A SL-User that initiates a Signalling Link.
@item Destination SL User
A SL-User with whom an originating SL user wishes to establish a Signalling Link.
@item ISO
International Organization for Standardization
@item SL User
Kernel level protocol or user level application that is accessing the services
of the Signalling Link sub-layer.
@item SL Provider
Signalling Link sub-layer entity/entities that provide/s the services of the
Signalling Link interface.
@item SLI
Signalling Link Interface
@item TIDU
Signalling Link Interface Data Unit
@item TSDU
Signalling Link Service Data Unit
@item OSI
Open Systems Interconnection
@item QOS
Quality of Service
@item STREAMS
A communication services development facility first available with UNIX System V Release 3.
@end table

@node The Signalling Link Layer
@chapter The Signalling Link Layer

@menu
* Model of the SLI::
* SLI Services::
* Purpose of the SLI::
@end menu

The Signalling Link Layer provides the means to manage the association of SL-Users into
connections.  It is responsible for the routing and management of data to and from signalling link
connections between SL-user entities.

@node Model of the SLI
@section Model of the SLI
@cpindex STREAMS

The SLI defines the services provided by the signalling link layer to the signalling link user at
the boundary between the signalling link provider and the signalling link user entity.  The
interface consists of a set of primitives defined as @cite{STREAMS} messages that provide access to
the signalling link layer services, and are transferred between the SLS user entity and the SLS
provider.  These primitives are of two types; ones that originate from the SLS user, and other that
originate from the SLS provider.  The primitives that originate from the SLS user make requests to
the SLS provider, or respond to an indication of an event of the SLS provider.  The primitives that
originate from the SLS provider are either confirmations of a request or are indications to the CCS
user that an event has occurred.  @figref{1} shows the model of the SLI.

@figuresized{sli01,1,Model of the SLI,3.0in}

The SLI allows the SLS provider to be configured with any signalling link layer user (such as a
signalling link application) that also conforms to the SLI.  A signalling link layer user can also
be a user program that conforms to the SLI and accesses the SLS provider via @manref{putmsg(2s)} and
@manref{getmsg(2s)} system calls.  The typical configuration, however, is to link a signalling link
stream beneath a message transfer part multiplexing driver.

@node SLI Services
@section SLI Services

The features of the SLI are defined in terms of the services provided by the SLS provider, and the
individual primitives that may flow between the SLS user and the SLS provider.

The SDLI Services are broken into two groups: local management services and protocol services.
Local management services are responsible for the local management of streams, assignment of streams
to physical points of attachment, enabling and disabling of streams, management of options
associated with a stream, and general acknowledgement and event reporting for the stream.  Protocol
services consist of .

@subsection Local Management

Local management services are listed in @tabref{1}.

@tabfig{lmit01,1,Local Management Services}

The local management services interface is described in @ref{Local Management Services}, and the
primitives are detailed in @ref{Local Management Service Primitives}.  The local management services
interface is defined by the @file{ss7/lmi.h} header file (@pxref{LMI Header File Listing}).

@subsection Protocol

Protocol services are listed in @tabref{2}.

@tabfig{slit02,2,Protocol Services}

The protocol services interface is described in @ref{Protocol Services}, and the primitives are
detailed in @ref{Protocol Service Primitives}.  The protocol services interface is defined by the
@file{ss7/sli.h} header file (@pxref{SLI Header File Listing}).

@node Purpose of the SLI
@section Purpose of the SLI

The SLI is typically implemented as a device driver controlling an intelligent protocol controller
device that provides access to channels.  The purpose behind exposing this low level interface is
that almost all communications channel devices can be placed into a SS7 HDLC mode, where a data
stream can be exchanged between the driver and the medium.  The SLI provides and inteface that, once
implemented as a driver for a new device, can provide complete and verified SS7 signalling link
capabilities by linking under a generic MTP (Message Transfer Part) multiplex driver
an open device stream.

This allows MTP drivers to be verified independently for correct operation and then simply
used for all manner of new device drivers that can implement the SLI interface.

@node SLI Services Definition
@chapter SLI Services Definition

@menu
* Local Management Services::
* Protocol Services::
@end menu

@node Local Management Services
@section Local Management Services

@menu
* Acknowledgement Service::
* Information Reporting Service::
* Physical Point of Attachment Service::
* Initialization Service::
* Options Management Service::
* Error Reporting Service::
* Statistics Reporting Service::
* Event Reporting Service::
@end menu

@node Acknowledgement Service
@subsection Acknowledgement Service

The acknowledgement service provides the LMS user with the ability to receive positive and negative
acknowledgements regarding the successful or unsuccessful completion of services.

@itemize @bullet

@item @b{@prim{LMI_OK_ACK}}:
The @prim{LMI_OK_ACK} message is used by the LMS provider to indicate successful receipt and
completion of a service primitive request that requires positive acknowledgement.

@item @b{@prim{LMI_ERROR_ACK}}:
The @prim{LMI_ERROR_ACK} message is used by the LMS provider to indicate successful receipt and
failure to complete a service primitive request that requires negative acknowledgement.

@end itemize

A successful invocation of the acknowledgement service is illustrated in @figref{15}.

@figuresized{lmi15,15,Message Flow: Successful Acknowledgement Service,4.0in}

As illustrated in @figref{15}, the
service primitives for which a positive acknowledgement may be returned are the
@prim{LMI_ATTACH_REQ} and @prim{LMI_DETACH_REQ}.

An unsuccessful invocation of the acknowledgement service is illustrated in @figref{16}.

@figuresized{lmi16,16,Message Flow: Unsuccessful Acknowledgement Service,4.0in}

As illustrated in @figref{16}, the
service primitives for which a negative acknowledgement may be returned are the
@prim{LMI_INFO_REQ}, @prim{LMI_ATTACH_REQ}, @prim{LMI_DETACH_REQ},
@prim{LMI_ENABLE_REQ}, @prim{LMI_DISABLE_REQ} and @prim{LMI_OPTMGMT_REQ} messages.

@node Information Reporting Service
@subsection Information Reporting Service

The information reporting service provides the LMS user with the ability to elicit information from
the LMS provider.

@itemize @bullet

@item @b{@prim{LMI_INFO_REQ}}:
The @prim{LMI_INFO_REQ} message is used by the LMS user to request information about the LMS
provider.

@item @b{@prim{LMI_INFO_ACK}}:
The @prim{LMI_INFO_ACK} message is issued by the LMS provider to provide requested information about
the LMS provider.

@end itemize

A successful invocation of the information reporting service is illustrated in @figref{2}.

@figuresized{lmi02,2,Message Flow: Successful Information Reporting Service,4.0in}

@node Physical Point of Attachment Service
@subsection Physical Point of Attachment Service

The local management interface provides the LMS user with the ability to associate a stream to a
physical point of appearance (@dfn{PPA}) or to disassociate a stream from a PPA.  The local
management interface provides for two styles of LMS provider:

@subsubheading Style 1 LMS Provider

A @dfn{Style 1} LMS provider is a provider that associates a stream with a PPA at the time of the
first @manref{open(2)} call for the device, and disassociates a stream from a PPA at the time of the
last @manref{close(2)} call for the device.

Physical points of attachment (PPA) are assigned to major and minor device number combinations.
When the major and minor device number combination is opened, the opened stream is automatically
associated with the PPA for the major and minor device number combination.  The last close of the
device disassociates the PPA from the stream.

Freshly opened @dfn{Style 1} LMS provider streams start life in the @psta{LMI_DISABLED} state.

This approach is suitable for LMS providers implemented as real or pseudo-device drivers and is
applicable when the number of minor devices is small and static.

@subsubheading Style 2 LMS Provider

A @dfn{Style 2} LMS provider is a provider that associates a stream with a PPA at the time that the
LMS user issues the @prim{LMI_ATTACH_REQ} message.  Freshly opened streams are not associated with any
PPA.  The @dfn{Style 2} LMS provider stream is disassociated from a PPA when the stream is closed
or when the LMS user issues the @prim{LMI_DETACH_REQ} message.

Freshly opened @dfn{Style 2} LMS provider streams start life in the @psta{LMI_UNATTACHED} state.

This approach is suitable for LMS providers implemented as clone real or pseudo-device drivers  and
is applicable when the number of minor devices is large or dynamic.

@menu
* PPA Attachment Service::
* PPA Detachment Service::
@end menu

@node PPA Attachment Service
@subsubsection PPA Attachment Service

The PPA attachment service provides the LMS user with the ability to attach a @dfn{Style 2} LMS
provider stream to a physical point of appearance (PPA).

@itemize @bullet

@item @b{@prim{LMI_ATTACH_REQ}}:
The @prim{LMI_ATTACH_REQ} message is issued by the LMS user to request that a @dfn{Style 2} LMS
provider stream be attached to a specified physical point of appearance (PPA).

@item @b{@prim{LMI_OK_ACK}}:
Upon successful receipt and processing of the @prim{LMI_ATTACH_REQ} message, the LMS provider
acknowledges the success of the service completion with a @prim{LMI_OK_ACK} message.

@item @b{@prim{LMI_ERROR_ACK}}:
Upon successful receipt but failure to process the @prim{LMI_ATTACH_REQ} message, the LMS provider
acknowledges the failure of the service completion with a @prim{LMI_ERROR_ACK} message.

@end itemize

A successful invocation of the attachment service is illustrated in @figref{3}.

@figuresized{lmi03,3,Message Flow: Successful Attachment Service,4.0in}


@node PPA Detachment Service
@subsubsection PPA Detachment Service

The PPA detachment service provides the LMS user with the ability to detach a @dfn{Style 2} LMS
provider stream from a physical point of attachment (PPA).

@itemize @bullet

@item @b{@prim{LMI_DETACH_REQ}}:
The @prim{LMI_DETACH_REQ} message is issued by the LMS user to request that a @dfn{Style 2} LMS
provider stream be detached from the attached physical point of appearance (PPA).

@item @b{@prim{LMI_OK_ACK}}:
Upon successful receipt and processing of the @prim{LMI_DETACH_REQ} message, the LMS provider
acknowledges the success of the service completion with a @prim{LMI_OK_ACK} message.

@item @b{@prim{LMI_ERROR_ACK}}:
Upon successful receipt but failure to process the @prim{LMI_DETACH_REQ} message, the LMS provider
acknowledges the failure of the service completion with a @prim{LMI_ERROR_ACK} message.

@end itemize

A successful invocation of the detachment service is illustrated in @figref{4}.

@figuresized{lmi04,4,Message Flow: Successful Detachment Service,4.0in}

@node Initialization Service
@subsection Initialization Service

The initialization service provides the LMS user with the abilty to enable and disable the stream
for the associated PPA.

@menu
* Interface Enable Service::
* Interface Disable Service::
@end menu

@node Interface Enable Service
@subsubsection Interface Enable Service

The interface enable service provides the LMS user with the ability to enable an LMS provider
stream that is associated with a PPA.  Enabling the interface permits the LMS user to exchange
protocol service interface messages with the LMS provider.

@itemize @bullet

@item @b{@prim{LMI_ENABLE_REQ}}:
The @prim{LMI_ENABLE_REQ} message is issued by the LMS user to request that the protocol service
interface be enabled.

@item @b{@prim{LMI_ENABLE_CON}}:
Upon successful enabling of the protocol service interface, the LMS provider acknowledges
successful completion of the service by issuing a @prim{LMI_ENABLE_CON} message to the LMS user.

@item @b{@prim{LMI_ERRORK_ACK}}:
Upon unsuccessful enabling of the protocol service interface, the LMS provider acknowledges the
failure to complete the service by issuing an @prim{LMI_ERROR_ACK} message to the LMS user.

@end itemize

A successful invocation of the enable service is illustrated in @figref{5}.

@figuresized{lmi05,5,Message Flow: Successful Enable Service,4.0in}

@node Interface Disable Service
@subsubsection Interface Disable Service

The interface disable service provides the LMS user with the ability to disable an LMS provider
stream that is associated with a PPA.  Disabling the interface withdraws the LMS user's ability to
exchange protocol service interface messages with the LMS provider.

@itemize @bullet

@item @b{@prim{LMI_DISABLE_REQ}}:
The @prim{LMI_DISABLE_REQ} message is issued by the LMS user to request that the protocol service
interface be disabled.

@item @b{@prim{LMI_DISABLE_CON}}:
Upon successful disabling of the protocol service interface, the LMS provider acknowledges
successful completion of the service by issuing a @prim{LMI_DISABLE_CON} message to the LMS user.

@item @b{@prim{LMI_ERRORK_ACK}}:
Upon unsuccessful disabling of the protocol service interface, the LMS provider acknowledges the
failure to complete the service by issuing an @prim{LMI_ERROR_ACK} message to the LMS user.

@end itemize

A successful invocation of the disable service is illustrated in @figref{6}.

@figuresized{lmi06,6,Message Flow: Successful Disable Service,4.0in}

@node Options Management Service
@subsection Options Management Service

The options management service provides the LMS user with the ability to control and affect various
generic and provider-specific options associated with the LMS provider.

@itemize @bullet

@item @b{@prim{LMI_OPTMGMT_REQ}}:
The LMS user issues a @prim{LMI_OPTMGMT_REQ} message when it wishes to interrogate or affect the
setting of various generic or provider-specific options associated with the LMS provider for the
stream upon which the message is issued.

@item @b{@prim{LMI_OPTMGMT_ACK}}:
Upon successful receipt of the @prim{LMI_OPTMGMT_REQ} message, and successful options processing, the
LMS provider acknowledges the successful completion of the service with an @prim{LMI_OPTMGMT_ACK}
message.

@item @b{@prim{LMI_ERROR_ACK}}:
Upon successful receipt of the @prim{LMI_OPTMGMT_REQ} message, and unsuccessful options processing, the
LMS provider acknowledges the failure to complete the service by issuing an @prim{LMI_ERROR_ACK}
message to the LMS user.

@end itemize

A successful invocation of the options management service is illustrated in @figref{7}.

@figuresized{lmi07,7,Message Flow: Successful Options Management Service,4.0in}

@node Error Reporting Service
@subsection Error Reporting Service

The error reporting service provides the LMS provider with the ability to indicate asynchronous
errors to the LMS user.

@itemize @bullet

@item @b{@prim{LMI_ERROR_IND}}:
The LMS provider issues the @prim{LMI_ERROR_IND} message to the LMS user when it needs to indicate an
asynchronous error (such as the unusability of the communications medium).

@end itemize

A successful invocation of the error reporting service is illustrated in @figref{8}.

@figuresized{lmi08,8,Message Flow: Successful Error Reporting Service,4.0in}

@node Statistics Reporting Service
@subsection Statistics Reporting Service

@itemize @bullet

@item @b{@prim{LMI_STATS_IND}}:

@end itemize

A successful invocation of the statistics reporting service is illustrated in @figref{9}.

@figuresized{lmi09,9,Message Flow: Successful Statistics Reporting Service,4.0in}

@node Event Reporting Service
@subsection Event Reporting Service

The event reporting service provides the LMS provider with the ability to indicate specific
asynchronous management events to the LMS user.

@itemize @bullet

@item @b{@prim{LMI_EVENT_IND}}:
The LMS provider issues the @prim{LMI_EVENT_IND} message to the LMS user when it wishes to indicate
an asynchronous (management) event to the LMS user.

@end itemize

A successful invocation of the event reporting service is illustrated in @figref{10}.

@figuresized{lmi10,10,Message Flow: Successful Event Reporting Service,4.0in}

@node Protocol Services
@section Protocol Services

Protocol services are specific to the Signalling Link interface.  These services consist of
initialization of the link and preparation for the transfer of signal units, the transfer of signal
units, transmit and receive congestion control, BSNT retrieval, buffer updating, buffer clearing,
local processor outage, remote processor outage, link options management and management event
notification.

The service primitives that implement the protocol services are described in detail in @ref{Protocol
Service Primitives}.

@menu
* Link Initialization Services::
* Data Transfer Service::
* Congestion Services::
* Restoration Services::
* Processor Outage Services::
* Link Option Management Service::
* Event Notification Service::
@end menu

@node Link Initialization Services
@subsection Link Initialization Services

The link initialization services provide the SLS user with the ability to power on the terminal, set
emergency status, start the signalling link and stop the signalling link.
The service primitives that implement the link initialization services are described in detail in
@ref{Link Initialization Service Primitives}.

@menu
* Power On Service::
* Emergency Service::
* Start Service::
* Stop Service::
@end menu

@node Power On Service
@subsubsection Power On Service

The power on service provides the SLS user with the ability to power on the signalling data
terminal.  The signalling data terminal must be powered on at least once before the link can be
started.

@itemize @bullet

@item @b{@prim{SL_POWER_ON_REQ}}:
The @prim{SL_POWER_ON_REQ} message is used by the SLS user to request that the SLS provider
power on the signalling data terminal.  If the signalling data terminal does not require power
(such as a software module), this serves to initialize the signalling data terminal functions.

@end itemize

A successful invocation of the power on service is illustrated in @figref{17}.

@figuresized{sli17,17,Message Flow: Successful Power On Service,4.0in}

@node Emergency Service
@subsubsection Emergency Service

The emergency service provides the SLS user with the ability to specify whether normal or emergency
alignment procedures should take effect on the current or next alignment procedure.  Emergency
alignment procedures have a shorter duration (short proving period) than normal alignment
procedures.  Some SS7 protocol variants (TTC) always use emergency alignment procedures and are not
affected by this service.

@itemize @bullet

@item @b{@prim{SL_EMERGENCY_REQ}}:
The @prim{SL_EMERGENCY_REQ} message is used by the SLS user to request that the emergency
alignment procedure should take effect on the current or next alignment of the signalling link.

@item @b{@prim{SL_EMERGENCY_CEASES_REQ}}:
The @prim{SL_EMERGENCY_CEASES_REQ} message is used by the SLS user to request that the normal
alignment procedure should take effect on the current or next alignment of the signalling link.

@end itemize

A successful invocation of the emergency service is illustrated in @figref{18}.

@figuresized{sli18,18,Message Flow: Successful Emergency Service,4.0in}

@node Start Service
@subsubsection Start Service

The start service provides the SLS user with the ability to align the signalling link and have it
placed into service.  The start service must be successfully invoked on both sides of the signalling
link before the signalling link is able to exchange message signal units.

@itemize @bullet

@item @b{@prim{SL_START_REQ}}:
The @prim{SL_START_REQ} message is used by the SLS user to request that the signalling link be
aligned a placed into service.

@item @b{@prim{SL_IN_SERVICE_IND}}:
The @prim{SL_IN_SERVICE_IND} message is used by the SLS provider to indicate that the
signalling link has been successfully aligned and has been placed into service at Level 2.

@end itemize

A successful invocation of the start service is illustrated in @figref{19}.

@figuresized{sli19,19,Message Flow: Successful Start Service,4.0in}

A unsuccessful invocation of the start service is illustrated in @figref{20}.

@figuresized{sli20,20,Message Flow: Unsuccessful Start Service,4.0in}

@node Stop Service
@subsubsection Stop Service

The stop service provides the SLS user and provider with the ability to take a signalling link out
of service.  Once the stop service has successfully completed, the signalling link is no longer able
to exchange message signal units.

@itemize @bullet

@item @b{@prim{SL_STOP_REQ}}:
The @prim{SL_STOP_REQ} message is used by the SLS user to request that the signalling link be
taken out of service.

@item @b{@prim{SL_OUT_OF_SERVICE_IND}}:
The @prim{SL_OUT_OF_SERVICE_IND} message is used by the SLS provider to indicate that the
signalling link has been taken out of service by the SLS provider.

@end itemize

A successful invocation of the stop service is illustrated in @figref{21}.

@figuresized{sli21,21,Message Flow: Successful Stop Service,4.0in}

@node Data Transfer Service
@subsection Data Transfer Service

The data transfer service provides the SLS user with the ability to exchange message signal units
on the signalling link.
The service primitives that implement the data transfer service are described in detail in
@ref{Data Transfer Service Primitives}.

@itemize @bullet

@item @b{@prim{SL_PDU_REQ}}:
The @prim{SL_PDU_REQ} message is used by the SLS user to request that a message signal unit be
sent on the signalling link.

@item @b{@prim{SL_PDU_IND}}:
The @prim{SL_PDU_IND} message is used by the SLS provider to indicate that a message signal
unit has been received on the signalling link.

@end itemize

A successful invocation of the data transfer service is illustrated in @figref{22}.

@figuresized{sli22,22,Message Flow: Successful Data Transfer Service,4.0in}

@node Congestion Services
@subsection Congestion Services

The congestion services provide the SLS user with the ability to invoke a receive congestion policy.
They also provide the SLS provider with the ability to indicate transmit congestion levels.
The service primitives that implement the congestion services are described in detail in
@ref{Congestion Service Primitives}.

@menu
* Transmit Congestion Service::
* Receive Congestion Service::
@end menu

@node Transmit Congestion Service
@subsubsection Transmit Congestion Service

The transmit congestion service provides the SLS provider with the ability to indicate transmit
congestion (and corresponding levels) to the SLS user.  There are 4 levels of congestion, 0, 1, 2
and 3.  Each congestion level has an onset threshold and an abatement threshold.  When the transmit
buffer occupancy exceeds the onset threshold for the level, congestion is indicated at that level.
When the transmit buffer occupancy falls below the abatement threshold for the level, congestion
abatement is indicated.  Some SS7 protocol variants do not have congestion levels and only signal
the presence or lack of congestion.

When congestion is indicated at a level, the SLS user should discard messages that have a message
priority that is less than the level at which congestion has been indicated.

@itemize @bullet

@item @b{@prim{SL_LINK_CONGESTED_IND}}:
The @prim{SL_LINK_CONGESTED_IND} message is used by the SLS provider to indicate that
congestion onset has occurred for the congestion level indicated in the message.

@item @b{@prim{SL_LINK_CONGESTION_CEASED_IND}}:
The @prim{SL_LINK_CONGESTION_CEASED_IND} message is used by the SLS provider to indicate
that congestion abatement has occurred for the congestion level indicated in the message.

@end itemize

A successful indication of the transmit congestion service is illustrated in @figref{23}.

@figuresized{sli23,23,Message Flow: Successful Transmit Congestion Service,4.0in}

@node Receive Congestion Service
@subsubsection Receive Congestion Service

The receive congestion service provides the SLS user with the ability to specify that receive
congestion is in effect or has abated and the policy to use for received message signal units under
congestion.  A discard policy indicates that received message signal units should be discarded (and
not acknowledged); receive congestion is signalled to the sending side of the signalling link.  An
accept policy indicates that received message signal units should not be discarded and should be
acknowledged; receive congestion is signalled to the sending side of the signalling link.  When
receive congestion abates, the abatement of receive congestion is signalled to the sending side of
the signalling link.

The SLS provider may also perform its own receive congestion onset, abatement and policy.  The SLS
provider does not indicate its current receive congestion level or policy to the SLS user.

@itemize @bullet

@item @b{@prim{SL_NO_CONGESTION_REQ}}:
The @prim{SL_NO_CONGESTION_REQ} message is used by the SLS user to specify that receive
congestion has abated and that receive congestion should no longer be signalled to the sending side
of the signalling link.

@item @b{@prim{SL_CONGESTION_ACCEPT_REQ}}:
The @prim{SL_CONGESTION_ACCEPT_REQ} message is used by the SLS user to specify that receive
congestion has onset and that receive congestion should be signalled to the sending side of the
signalling link.  The congestion policy is an accept policy that allows message signal units to
continue to be delivered to the SLS user and acknowledged to the remote end of the signalling link.

@item @b{@prim{SL_CONGESTION_DISCARD_REQ}}:
The @prim{SL_CONGESTION_DISCARD_REQ} message is used by the SLS user to specify that receive
congestion has onset and that receive congestion should be signalled to the sending side of the
signalling link.  The congestion policy is a discard policy that requires the SLS provider to
discard message signal units without delivering them to the SLS user and they are not to be
acknowledged to the remote end of the signalling link. 

@end itemize

A successful invocation of the receive congestion service is illustrated in @figref{24}.

@figuresized{sli24,24,Message Flow: Successful Receive Congestion Service,4.0in}

@node Restoration Services
@subsection Restoration Services

Restoration services consist of the services necessary to change over a link, update its buffers,
and clearing any unnecessarily old MSUs from the receive buffer or retransmission buffer.  The
service primitives that implement the restoration services are detailed in @ref{Restoration Service
Primitives}.

@menu
* BSNT Retrieval Service::
* Buffer Updating Service::
* Buffer Clearing Service::
@end menu

@node BSNT Retrieval Service
@subsubsection BSNT Retrieval Service

The BSNT retrieval service is a somewhat optional service in support of the sequenced changeover
procedure of the Message Transfer Part.  It is @samp{somewhat} optional due to the possibility that
time-controlled changeover is always used, per ETSI ETS 300 008-1.

@itemize @bullet

@item @b{@prim{SL_RETRIEVE_BSNT_REQ}}:
The @prim{SL_RETRIEVE_BSNT_REQ} message is used by the SLS user to request that the SLS
provider indicate the last transmitted backward sequence number (BSNT).

@item @b{@prim{SL_BSNT_IND}}:
The @prim{SL_BSNT_IND} message is used by the SLS provider to indicate the last transmitted
backward sequence number (BSNT) when requested by the SLS user with a
@prim{SL_RETRIEVE_BSNT_REQ} message.

@item @b{@prim{SL_BSNT_NOT_RETRIEVABLE_IND}}:
The @prim{SL_BSNT_NOT_RETRIEVABLE_IND} message is used by the SLS provider to indicate that
the last transmitted backward sequence number (BSNT) is not available when requested by the SLS user
with a @prim{SL_RETRIEVE_BSNT_REQ} message.  This may be due to hardware or other failures.

@end itemize

A successful invocation of the BSNT retrieval service is illustrated in @figref{25}.

@figuresized{sli25,25,Message Flow: Successful BSNT Retreival Service,4.0in}

An unsuccessful invocation of the BSNT retrieval service is illustrated in @figref{26}.

@figuresized{sli26,26,Message Flow: Unsuccessful BSNT Retrieval Service,4.0in}

@node Buffer Updating Service
@subsubsection Buffer Updating Service

The buffer updating service provides the SLS user with the ability to update the retransmission
buffer and collect messages that have not been successfully received by the remote side of the
signalling link during a sequenced changeover procedure.  The SLS user specifies the FSNC (the
forward sequence number confirmed received by the remote end of the signalling link).  The SLS
provider uses the FSNC to purge successfully received messages from the retransmission buffer and
then indicates the remaining contents of the retransmission buffer and the transmission buffer to
the SLS user.

The SLS user may also clear the retransmission buffer using the buffer clearing service before
retrieving messages.  This this case, the messages retrieved by the SLS provider will be the
contents of the transmission buffer.  The combination of the two services are used to perform the
time controlled changeover procedure.

@itemize @bullet

@item @b{@prim{SL_RETRIEVAL_REQUEST_AND_FSNC_REQ}}:
The @prim{SL_RETRIEVAL_REQUEST_AND_FSNC_REQ} message is used by the SLS user to request
the SLS provider update the retransmission buffer to reflect the value of the specified FSNC and
retrieve and indicate the contents of the updated retransmission buffer followed by the contents of
the transmission buffer to the SLS user.

@item @b{@prim{SL_RETRIEVED_MESSAGE_IND}}:
The @prim{SL_RETRIEVED_MESSAGE_IND} message is used by the SLS provider to indicate one
message from the retransmission buffer or transmission buffer.

@item @b{@prim{SL_RETRIEVAL_COMPLETE_IND}}:
The @prim{SL_RETRIEVAL_COMPLETE_IND} message is used by the SLS provider to indicate that the
retrieval of messages from the retransmission buffer and transmission buffer is complete.

@item @b{@prim{SL_RETRIEVAL_NOT_POSSIBLE_IND}}:
The @prim{SL_RETRIEVAL_NOT_POSSIBLE_IND} message is used by the SLS provider to indicate
that the updating of the retransmission buffer to the specified FSNC and retrieval of messages from
the retransmission buffer and transmission buffer is not possible.  This may be due to hardware
failure.

@end itemize

A successful invocation of the buffer updating service is illustrated in @figref{27}.

@figuresized{sli27,27,Message Flow: Successful Buffer Updating Service,4.0in}

An unsuccessful invocation of the buffer updating service is illustrated in @figref{28}.

@figuresized{sli28,28,Message Flow: Unsuccessful Buffer Updating Service,4.0in}

@node Buffer Clearing Service
@subsubsection Buffer Clearing Service

The buffer clearing service provides the SLS user with the ability to request that all message
buffers be cleared (receive buffer, retransmission buffer, transmission buffer) and that the SLS
provider indicate when the receive and retransmission buffer are cleared.  It also provides the SLS
user with the ability to clear only the retransmission buffer and receive and indication when the
buffer is cleared.

Clearing of all buffers is performed when the signalling link has been blocked (local or remote
processor outage) for a long duration and messages contained in the buffer are too old to be
processed.

Clearing of the retransmission buffer is performed as part of the time-controlled changeover
procedure, when the value of the FSNC has not been received in a sequenced changeover message from
the adjacent signalling point.

@itemize @bullet

@item @b{@prim{SL_CLEAR_BUFFERS_REQ}}:
The @prim{SL_CLEAR_BUFFERS_REQ} message is used by the SLS user to request that all message
buffers (receive, retransmit, transmit) be cleared.

@item @b{@prim{SL_CLEAR_RTB_REQ}}:
The @prim{SL_CLEAR_RTB_REQ} message is used by the SLS user to request that only the
retransmission buffer be cleared as part of a time-controlled changeover procedure.

@item @b{@prim{SL_RB_CLEARED_IND}}:
The @prim{SL_RB_CLEARED_IND} message is used by the SLS provider to indicate when the receive
buffer has been successfully cleared.

@item @b{@prim{SL_RTB_CLEARED_IND}}:
The @prim{SL_RTB_CLEARED_IND} message is used by the SLS provider to indicate when the
retransmission buffer has been successfully cleared.

@end itemize

A successful invocation of the buffer clearing service is illustrated in @figref{29} and
@figref{32}.

@figuresized{sli29,29,Message Flow: Successful Buffer Clearing Service,4.0in}

@figuresized{sli32,32,Message Flow: Successful Buffer Clearing Service,4.0in}

@node Processor Outage Services
@subsection Processor Outage Services

The processor outage services provide the SLS user with the ability to request a local processor
outage as well as being informed of a local or remote processor outage.
The service primitives that implement the processor outage services are described in detail in
@ref{Processor Outage Service Primitives}.

@menu
* Local Processor Outage Service::
* Remote Processor Outage Service::
@end menu

@node Local Processor Outage Service
@subsubsection Local Processor Outage Service

The local processor outage service provides the SLS user with the ability to both request a local
processor outage as well as be informed of a local processor outage.  Local processor outage occurs
when the SLS user is unable to pass message signal units for transmission or accept received message
signal units, or the SLS provider is unable to deliver received message signal units or accept
message signal units for transmission.  Local processor outage conditions can exist independently
within the SLS user and within the SLS provider.

@itemize @bullet

@item @b{@prim{SL_LOCAL_PROCESSOR_OUTAGE_REQ}}:
The @prim{SL_LOCAL_PROCESSOR_OUTAGE_REQ} message is used by the SLS user to specify that a
local processor outage condition exists due to a condition within the SLS user.

@item @b{@prim{SL_LOCAL_PROCESSOR_OUTAGE_IND}}:
The @prim{SL_LOCAL_PROCESSOR_OUTAGE_IND} message is used by the SLS provider to indicate
that a local processor outage condition exists due to a condition within the SLS provider.

@item @b{@prim{SL_RESUME_REQ}}:
The @prim{SL_RESUME_REQ} message is used by the SLS use to specify that a local processor outage
condition no longer exists within the SLS user.

@item @b{@prim{SL_LOCAL_PROCESSOR_RECOVERED_IND}}:
The @prim{SL_LOCAL_PROCESSOR_RECOVERED_IND} message is used by the SLS provider to indicate
that a local processor outage condition no longer exists within the SLS provider.

@end itemize

A successful invocation of the local processor outage service is illustrated in @figref{30}.

@figuresized{sli30,30,Message Flow: Successful Processor Outage Service,4.0in}

@node Remote Processor Outage Service
@subsubsection Remote Processor Outage Service

The remote processor outage service provides the SLS user with the ability to be informed of remote
processor outage conditions.  Remote processor outage occurs when the remote SLS user is
experiencing a local processor outage.  Remote processor outage conditions can exist independent of
local processor outage conditions.

@itemize @bullet

@item @b{@prim{SL_REMOTE_PROCESSOR_OUTAGE_IND}}:
The @prim{SL_REMOTE_PROCESSOR_OUTAGE_IND} message is used by the SLS provider to indicate
that a remote processor outage condition exists.

@item @b{@prim{SL_REMOTE_PROCESSOR_RECOVERED_IND}}:
The @prim{SL_REMOTE_PROCESSOR_RECOVERED_IND} message is used by the SLS provider to indicate
that a remote processor has recovered.

@item @b{@prim{SL_CONTINUE_REQ}}:
The @prim{SL_CONTINUE_REQ} message is used by the SLS user to request that a signalling link
continue from where it left off after a remote processor has recovered.

@end itemize

A successful indication of the remote processor outage service is illustrated in @figref{31}.

@figuresized{sli31,31,Message Flow: Successful Processor Outage Service,4.0in}

@node Link Option Management Service
@subsection Link Option Management Service

The link option management service provides the SLS user with the ability to alter signalling link
options.
The service primitives that implement the link option management services are described in detail in
@ref{Link Option Management Service Primitives}.

@itemize @bullet

@item @b{@prim{SL_OPTMGMT_REQ}}:
The @prim{SL_OPTMGMT_REQ} message is used by the SLS user to request that link options be
managed.

@item @b{@prim{SL_OPTMGMT_ACK}}:
The @prim{SL_OPTMGMT_ACK} message is used by the SLS provider to acknowledge link option
management actions.

@end itemize

A successful invocation of the link options management service is illustrated in @figref{33}.

@figuresized{sli33,33,Message Flow: Successful Link Options Management Service,4.0in}

@node Event Notification Service
@subsection Event Notification Service

The event notification service provides the SLS user with the ability to register with the SLS
provider to receive provider-specific event notifications.  Event notifications normally
correspond to management indications on the SS7 signalling link.
The service primitives that implement the event notification services are described in detail in
@ref{Event Notification Service Primitives}.

@itemize @bullet

@item @b{@prim{SL_NOTIFY_REQ}}:
The @prim{SL_NOTIFY_REQ} message is used by the SLS user to register with the SLS provider to
receive specified event notifications.

@item @b{@prim{SL_NOTIFY_IND}}:
The @prim{SL_NOTIFY_IND} message is used by the SLS provider to indicate the occurrence of
registered events to the SLS user.

@end itemize

A successful invocation of the event notification service is illustrated in @figref{34}.

@figuresized{sli34,34,Message Flow: Successful Event Notification Service,4.0in}


@node SLI Primitives
@chapter SLI Primitives

@menu
* Local Management Service Primitives::
* Protocol Service Primitives::
@end menu

@node Local Management Service Primitives
@section Local Management Service Primitives

These service primitives implement the local management services (@pxref{Local Management
Services}).

@menu
* Acknowledgement Service Primitives::
* Information Reporting Service Primitives::
* Physical Point of Attachment Service Primitives::
* Initialization Service Primitives::
* Options Management Service Primitives::
* Event Reporting Service Primitives::
@end menu

@node Acknowledgement Service Primitives
@subsection Acknowledgement Service Primitives

These service primitives implement the acknowledgement service (@pxref{Acknowledgement Service}).

@menu
* LMI_OK_ACK::
* LMI_ERROR_ACK::
@end menu

@node LMI_OK_ACK
@subsubsection LMI_OK_ACK

@subsubheading Description

This primitive is used to acknowledge receipt and successful service completion for
primitives requiring acknowledgement that have no confirmation primitive.

@subsubheading Format
@tpindex lmi_ok_ack_t

This primitive consists of one @msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_long lmi_correct_primitive;
    lmi_ulong lmi_state;
} lmi_ok_ack_t;
@end verbatim
@end display

@subsubheading Parameters

The service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_OK_ACK}.

@item lmi_correct_primitive
Indicates the service primitive that was received and serviced correctly.  This field can be one of
the following values:

@table @prim

@ignore
@item LMI_INFO_REQ
Information request.
@end ignore
@item LMI_ATTACH_REQ
Attach request.
@item LMI_DETACH_REQ
Detach request.
@ignore
@item LMI_ENABLE_REQ
Enable request.
@item LMI_DISABLE_REQ
Disable request.
@item LMI_OPTMGMT_REQ
Options management request.
@item LMI_INFO_ACK
Information acknowledgement.
@item LMI_OK_ACK
Successful receipt acknowledgement.
@item LMI_ERROR_ACK
Error acknowledgement.
@item LMI_ENABLE_CON
Enable confirmation.
@item LMI_DISABLE_CON
Disable confirmation.
@item LMI_OPTMGMT_ACK
Options Management acknowledgement.
@item LMI_ERROR_IND
Error indication.
@item LMI_STATS_IND
Statistics indication.
@item LMI_EVENT_IND
Event indication.
@end ignore

@end table

@item lmi_state

Indicates the current state of the LMS provider at the time that the primitive was issued.
This field can be one of the following values:

@table @psta

@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@ignore
@item LMI_ATTACH_PENDING
Waiting for attach.
@end ignore
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@ignore
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@end ignore
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@ignore
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.
@end ignore

@end table

@end table

@subsubheading State

This primitive is issued by the LMS provider in the @psta{LMI_ATTACH_PENDING} or
@psta{LMI_DETACH_PENDING} state.

@subsubheading New State

The new state is @psta{LMI_UNATTACHED} or @psta{LMI_DISABLED}, depending on thee primitive to
which the message is responding.

@page
@node LMI_ERROR_ACK
@subsubsection LMI_ERROR_ACK

@subsubheading Description

The error acknowledgement primitive is used to acknowledge receipt and unsuccessful service
completion for primitives requiring acknowledgement.

@subsubheading Format
@tpindex lmi_error_ack_t

The error acknowledgement primitive consists of one @msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_errno;
    lmi_ulong lmi_reason;
    lmi_long lmi_error_primitive;
    lmi_ulong lmi_state;
} lmi_error_ack_t;
@end verbatim
@end display

@subsubheading Parameters

The error acknowledgement primitive contains the following parameters:

@table @parm

@item lmi_primitive

Indicates the primitive type.  Always @prim{LMI_ERROR_ACK}.

@item lmi_errno

Indicates the LM error number.
This field can have one of the following values:

@table @perr
@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.
@end table

@item lmi_reason

Indicates the reason for failure.  This field is protocol-specific.  When the @parm{lmi_errno} field
is @perr{LMI_SYSERR}, the @parm{lmi_reason} field is the UNIX error number as described in
@manref{errno(3)}.

@item lmi_error_primitive

Indicates the primitive that was in error.
This field can have one of the following values:

@table @prim
@item LMI_INFO_REQ
Information request.
@item LMI_ATTACH_REQ
Attach request.
@item LMI_DETACH_REQ
Detach request.
@item LMI_ENABLE_REQ
Enable request.
@item LMI_DISABLE_REQ
Disable request.
@item LMI_OPTMGMT_REQ
Options management request.
@item LMI_INFO_ACK
Information acknowledgement.
@item LMI_OK_ACK
Successful receipt acknowledgement.
@item LMI_ERROR_ACK
Error acknowledgement.
@item LMI_ENABLE_CON
Enable confirmation.
@item LMI_DISABLE_CON
Disable confirmation.
@item LMI_OPTMGMT_ACK
Options Management acknowledgement.
@item LMI_ERROR_IND
Error indication.
@item LMI_STATS_IND
Statistics indication.
@item LMI_EVENT_IND
Event indication.
@end table

@item lmi_state

Indicates the state of the LMS provider at the time that the primitive was issued.  This field can
have one of the following values:

@table @psta
@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@item LMI_ATTACH_PENDING
Waiting for attach.
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.
@end table

@end table

@subsubheading State

This primitive can be issued in any state for which a local acknowledgement is not pending.  The
LMS provider state at the time that the primitive was issued is indicated in the primitive.

@subsubheading New State

The new state remains unchanged.

@page
@node Information Reporting Service Primitives
@subsection Information Reporting Service Primitives

These service primitives implement the information reporting service (@pxref{Information Reporting
Service}).

@menu
* LMI_INFO_REQ::
* LMI_INFO_ACK::
@end menu

@node LMI_INFO_REQ
@subsubsection LMI_INFO_REQ

@subsubheading Description

This LMS user originated primitive is issued by the LMS user to request that the LMS provider
return information concerning the capabilities and state of the LMS provider.

@subsubheading Format
@tpindex lmi_info_req_t

The primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_ulong lmi_primitive;
} lmi_info_req_t;
@end verbatim
@end display

@subsubheading Parameters

This primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the primitive type.  Always @prim{LMI_INFO_REQ}.

@end table

@subsubheading State

This primitive may be issued in any state but only when a local acknowledgement is not pending.

@subsubheading New State

The new state remains unchanged.

@subsubheading Response

This primitive requires the LMS provider to acknowledge receipt of the primitive as follows:

@itemize @minus

@item @b{Successful}:
The LMS provider is required to acknowledge receipt of the primitive and provide the requested
information using the @prim{LMI_INFO_ACK} primitive.

@item @b{Unsuccessful (non-fatal errors)}:
The LMS provider is required to negatively acknowledge the primitive using the @prim{LMI_ERROR_ACK}
primitive, and include the reason for failure in the primitive.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}: applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node LMI_INFO_ACK
@subsubsection LMI_INFO_ACK

@subsubheading Description

This LMS provider originated primitive acknowledges receipt and successful processing of the
@prim{LMI_INFO_REQ} primitive and provides the request information concerning the LMS provider.

@subsubheading Format
@tpindex lmi_info_ack_t

This message is formatted a one @msg{M_PROTO} or @msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_version;
    lmi_ulong lmi_state;
    lmi_ulong lmi_max_sdu;
    lmi_ulong lmi_min_sdu;
    lmi_ulong lmi_header_len;
    lmi_ulong lmi_ppa_style;
    lmi_uchar lmi_ppa_addr[0];
} lmi_info_ack_t;
@end verbatim
@end display

@subsubheading Parameters

The information acknowledgement service primitive has the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_INFO_ACK}.

@item lmi_version
Indicates the version of this specification that is being used by the LMS provider.

@item lmi_state
Indicates the state of the LMS provider at the time that the information acknowledgement service
primitive was issued.  This field can be one of the following values:

@table @psta

@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@item LMI_ATTACH_PENDING
Waiting for attach.
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.

@end table

@item lmi_max_sdu
Indicates the maximum size of a Service Data Unit.

@item lmi_min_sdu
Indicates the minimum size of a Service Data Unit.

@item lmi_header_len
Indicates the amount of header space that should be reserved for placing LMS provider headers.

@item lmi_ppa_style
Indicates the PPA style of the LMS provider.  This value can be one of the following values:

@table @pval

@item LMI_STYLE1
PPA is implicitly attached by @manref{open(2)}.

@item LMI_STYLE2
PPA must be explicitly attached using @prim{LMI_ATTACH_REQ}.

@end table

@item lmi_ppa_addr
This is a variable length field.  The length of the field is determined by the length of the
@msg{M_PROTO}
or @msg{M_PCPROTO} message block.

For a @dfn{Style 2} driver, when @parm{lmi_ppa_style} is @pval{LMI_STYLE2}, and when in an attached state,
this field providers the current PPA associated with the stream; the length is typically 4 bytes.

For a @dfn{Style 1} driver, when @parm{lmi_ppa_style} is @pval{LMI_STYLE1}, the length it 0 bytes.

@end table

@subsubheading State

This primitive can be issued in any state where a local acknowledgement is not pending.

@subsubheading New State

The new state remains unchanged.

@page
@node Physical Point of Attachment Service Primitives
@subsection Physical Point of Attachment Service Primitives

These service primitives implement the physical point of attachment service (@pxref{Physical Point
of Attachment Service}).

@menu
* LMI_ATTACH_REQ::
* LMI_DETACH_REQ::
@end menu

@node LMI_ATTACH_REQ
@subsubsection LMI_ATTACH_REQ

@subsubheading Description

This LMS user originated primitive requests that the stream upon which the primitive is issued by
associated with the specified Physical Point of Attachment (PPA).  This primitive is only applicable
to @dfn{Style 2} LMS provider streams, that is, streams that return @pval{LMI_STYLE2} in the
@parm{lmi_ppa_style} field of the @prim{LMI_INFO_ACK}.

@subsubheading Format
@tpindex lmi_attach_req_t

This primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_uchar lmi_ppa[0];
} lmi_attach_req_t;
@end verbatim
@end display

@subsubheading Parameters

The attach request primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the service primitive type.  Always @prim{LMI_ATTACH_REQ}.

@item lmi_ppa
Specifies the Physical Point of Attachment (PPA) to which to associated the @dfn{Style 2} stream.
This is a variable length identifier whose length is determined by the length of the @msg{M_PROTO} message
block.

@end table

@subsubheading State

This primitive is only valid in state @psta{LMI_UNATTACHED} and when a local acknowledgement is not
pending.

@subsubheading New State

Upon success, the new state is @psta{LMI_ATTACH_PENDING}.  Upon failure, the state remains unchanged.

@subsubheading Response

The attach request service primitive requires that the LMS provider respond as follows:

@itemize @minus

@item @b{Successful}:
The LMS provider acknowledges receipt of the primitive and successful outcome of the attach service
with a @prim{LMI_OK_ACK} primitive.  The new state is @psta{LMI_DISABLED}.

@item @b{Unsuccessful (non-fatal errors)}:
The LMS provider acknowledges receipt of the primitive and failure of the attach service with a
@prim{LMI_ERROR_ACK} primitive containing the reason for failure.  The new state remains unchanged.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}:  applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node LMI_DETACH_REQ
@subsubsection LMI_DETACH_REQ

@subsubheading Description

This LMS user originated primitive request that the stream upon which the primitive is issued be
disassociated from the Physical Point of Appearance (PPA) to which it is currently attached.  This
primitive is only applicable to @dfn{Style 2} LMS provider streams, that is, streams that return
@pval{LMI_STYLE2} in the @parm{lmi_ppa_style} field of the @prim{LMI_INFO_ACK}.

@subsubheading Format
@tpindex lmi_detach_req_t

The detach request service primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
} lmi_detach_req_t;
@end verbatim
@end display

@subsubheading Parameters

The detach request service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the service primitive type.  Always @prim{LMI_DETACH_REQ}.

@end table

@subsubheading State

This primitive is valid in the @psta{LMI_DISABLED} state and when no local acknowledgement is pending.

@subsubheading New State

Upon success, the new state is @psta{LMI_DETACH_PENDING}.  Upon failure, the state remains unchanged.

@subsubheading Response

The detach request service primitive requires that the LMS provider respond as follows:

@itemize @minus

@item @b{Successful}:
The LMS provider acknowledges receipt of the primitive and successful outcome of the detach service
with a @prim{LMI_OK_ACK} primitive.  The new state is @psta{LMI_UNATTACHED}.

@item @b{Unsuccessful (non-fatal errors)}:
The LMS provider acknowledges receipt of the primitive and failure of the detach service with a
@prim{LMI_ERROR_ACK} primitive containing the reason for failure.  The new state remains unchanged.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}:  applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node Initialization Service Primitives
@subsection Initialization Service Primitives

Initialization service primitives allow the LMS user to enable or disable the protocol service
interface.  Enabling the protocol service interface may require that some action be taken to prepare
the protocol service interface for use or to remove it from use.  For example, where the PPA
corresponds to a signalling data link identifier as defined in Q.704, it may be necessary to perform
switching to connect or disconnect the circuit identification code associated with the signalling
data link identifier.

These service primitives implement the initialization service (@pxref{Initialization Service}).

@menu
* LMI_ENABLE_REQ::
* LMI_ENABLE_CON::
* LMI_DISABLE_REQ::
* LMI_DISABLE_CON::
@end menu

@node LMI_ENABLE_REQ
@subsubsection LMI_ENABLE_REQ

@subsubheading Description

This LMS user originated primitive request that the LMS provider perform the actions necessary to
enable the protocol service interface and confirm that it is enabled.  This primitive is applicable
to both styles of PPA.

@subsubheading Format
@tpindex lmi_enable_req_t

The enable request service primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_uchar lmi_rem[0];
} lmi_enable_req_t;
@end verbatim
@end display

@subsubheading Parameters

The enable request service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the service primitive type.  Always @prim{LMI_ENABLE_REQ}.

@item lmi_rem
Specifies a remote address to which to connect the PPA.  The need for and form of this address is
provider-specific.  The length of the field is determined by the length of the @msg{M_PROTO} message
block.  This remote address could be a circuit identification code, an IP address, or some other
form of circuit or channel identifier.

@end table

@subsubheading State

This primitive is valid in the @psta{LMI_DISABLED} state and when no local acknowledgement is pending.

@subsubheading New State

Upon success the new state is @psta{LMI_ENABLE_PENDING}.  Upon failure, the state remains unchanged.

@subsubheading Response

The enable request service primitive requires that the LMS provider acknowledge receipt of the
primitive as follows:

@itemize @minus

@item @b{Successful}:
When successful, the LMS provider acknowledges successful completion of the enable service with an
@prim{LMI_ENABLE_CON} primitive.  The new state is @psta{LMI_ENABLED}.

@item @b{Unsuccessful (non-fatal errors)}:
When unsuccessful, the LMS provider acknowledges the failure of the  enable service wtih an
@prim{LMI_ERROR_ACK} primitive containing the error.  The new state remains unchanged.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}:  applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node LMI_ENABLE_CON
@subsubsection LMI_ENABLE_CON

@subsubheading Description

This LMS provider originated primitive is issued by the LMS provider to confirm the successful
completion of the enable service.

@subsubheading Format
@tpindex lmi_enable_con_t

The enable confirmation service primitive consists of one @msg{M_PROTO} message block, structured as
follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_state;
} lmi_enable_con_t;
@end verbatim
@end display

@subsubheading Parameters

The enable confirmation service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_ENABLE_CON}.

@item lmi_state
Indicates the state following issuing the enable confirmation primitive.  This field can take on one
of the following values:

@table @psta

@ignore
@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@item LMI_ATTACH_PENDING
Waiting for attach.
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@end ignore
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@ignore
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.
@end ignore

@end table

@end table

@subsubheading State

This primitive is issued by the LMS provider in the @psta{LMI_ENABLE_PENDING} state.

@subsubheading New State

The new state is @psta{LMI_ENABLED}.

@page
@node LMI_DISABLE_REQ
@subsubsection LMI_DISABLE_REQ

@subsubheading Description

This LMS user originated primitive requests that the LMS provider perform the actions necessary to
disable the protocol service interface and confirm that it is disabled.  The primitive is applicable
to both styles of PPA.

@subsubheading Format
@tpindex lmi_disable_req_t

The disable request service primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
} lmi_disable_req_t;
@end verbatim
@end display

@subsubheading Parameters

The disable request service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the service primitive type.  Always @prim{LMI_DISABLE_REQ}.

@end table

@subsubheading State

The disable request service primitive is valid in the @psta{LMI_ENABLED} state and when no local
acknowledgement is pending.

@subsubheading New State

Upon success, the new state is @psta{LMI_DISABLE_PENDING}.  Upon failure, the state remains unchanged.

@subsubheading Response

The disable request service primitive requires the LMS provider to acknowledge receipt of the
primitive as follows:

@itemize @minus

@item @b{Successful}:
When successful, the LMS provider acknowledges successful completion of the disable service with an
@prim{LMI_DISABLE_CON} primitive.  The new state is @psta{LMI_DISABLED}.

@item @b{Unsuccessful (non-fatal errors)}:
When unsuccessful, the LMS provider acknowledges the failure of the disable service with an
@prim{LMI_ERROR_ACK} primitive containing the error.  The new state remains unchanged.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}:  applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node LMI_DISABLE_CON
@subsubsection LMI_DISABLE_CON

@subsubheading Description

This LMS provider originated primitive is issued by the LMS provider to confirm the successful
completion of the disable service.

@subsubheading Format
@tpindex lmi_disable_con_t

The disable confirmation service primitive consists of one @msg{M_PROTO} message block, structured as
follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_state;
} lmi_disable_con_t;
@end verbatim
@end display

@subsubheading Parameters

The disable confirmation service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_DISABLE_CON}.

@item lmi_state
Indicates the state following issuing the disable confirmation primitive.  This field can take on one
of the following values:

@table @psta

@ignore
@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@item LMI_ATTACH_PENDING
Waiting for attach.
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@end ignore
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@ignore
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.
@end ignore

@end table

@end table

@subsubheading State

This primitive is issued by the LMS provider in the @psta{LMI_DISABLE_PENDING} state.

@subsubheading New State

The new state is @psta{LMI_DISABLED}.

@page
@node Options Management Service Primitives
@subsection Options Management Service Primitives

The options management service primitives allow the LMS user to negotiate options with the LMS
provider, retrieve the current and default values of options, and check that values specified for
options are correct.

The options management service primitive implement the options management service (@pxref{Options
Management Service}).

@menu
* LMI_OPTMGMT_REQ::
* LMI_OPTMGMT_ACK::
@end menu

@node LMI_OPTMGMT_REQ
@subsubsection LMI_OPTMGMT_REQ

@subsubheading Description

This LMS user originated primitive requests that LMS provider options be managed.

@subsubheading Format
@tpindex lmi_optmgmt_req_t

The option management request service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_opt_length;
    lmi_ulong lmi_opt_offset;
    lmi_ulong lmi_mgmt_flags;
} lmi_optmgmt_req_t;
@end verbatim
@end display

@subsubheading Parameters

The option management request service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the service primitive type.  Always @prim{LMI_OPTMGMT_REQ}.

@item lmi_opt_length
Specifies the length of the options.

@item lmi_opt_offset
Specifies the offset, from the beginning of the @msg{M_PROTO} message block, of the start of the options.

@item lmi_mgmt_flags
Specifies the management flags which determine what operation the LMS provider is expected to
perform on the specified options.  This field can assume one of the following values:

@table @pval

@item LMI_NEGOTIATE
Negotiate the specified value of each specified option and return the negotiated value.

@item LMI_CHECK
Check the validity of the specified value of each specified option and return the result.  Do not
alter the current value assumed by the LMS provider.

@item LMI_DEFAULT
Return the default value for the specified options (or all options).  Do not alter the current value
assumed by the LMS provider.

@item LMI_CURRENT
Return the current value for the specified options (or all options).  Do not alter the current value
assumed by the LMS provider.

@end table

@end table

@subsubheading State

This primitive is valid in any state where a local acknowledgement is not pending.

@subsubheading New State

The new state remains unchanged.

@subsubheading Response

The option management request service primitive requires the LMS provider to acknowledge receipt of
the primitive as follows:

@itemize @minus

@item @b{Successful}:
Upon success, the LMS provider acknowledges receipt of the service primitive and successful
completion of the options management service with an @prim{LMI_OPTMGMT_ACK} primitive containing the
options management result.  The state remains unchanged.

@item @b{Unsuccessful (non-fatal errors)}:
Upon failure, the LMS provider acknowledges receipt of the service primitive and failure to
complete the options management service with an @prim{LMI_ERROR_ACK} primitive containing the error.
The state remains unchanged.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}:  applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node LMI_OPTMGMT_ACK
@subsubsection LMI_OPTMGMT_ACK

@subsubheading Description

This LMS provider originated primitive is issued by the LMS provider upon successful completion of
the options management service.  It indicates the outcome of the options management operation
requested by the LMS user in a @prim{LMI_OPTMGMT_REQ} primitive.

@subsubheading Format
@tpindex lmi_optmgmt_ack_t

The option management acknowledgement service primitive consists of one @msg{M_PCPROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_opt_length;
    lmi_ulong lmi_opt_offset;
    lmi_ulong lmi_mgmt_flags;
} lmi_optmgmt_ack_t;
@end verbatim
@end display

@subsubheading Parameters

The option management acknowledgement service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_OPTMGMT_ACK}.

@item lmi_opt_length
Indicates the length of the returned options.

@item lmi_opt_offset
Indicates the offset of the returned options from the start of the @msg{M_PCPROTO} message block.

@item lmi_mgmt_flags
Indicates the returned management flags.  These flags indicate the overall success of the options
management service.  This field can assume one of the following values:

@table @pval

@item LMI_SUCCESS
The LMS provider succeeded in negotiating or returning all of the options specified by the LMS
user in the @prim{LMI_OPTMGMT_REQ} primitive.

@item LMI_FAILURE
The LMS provider failed to negotiate one or more of the options specified by the LMS user.

@item LMI_PARTSUCCESS
The LMS provider negotiated a value of lower quality for one or more of the options specified by
the LMS user.

@item LMI_READONLY
The LMS provider failed to negotiate one ore more of the options specified by the LMS user because
the option is treated as read-only by the LMS provider.

@item LMI_NOTSUPPORT
The LMS provider failed to recognize one or more of the options specified by the LMS user.

@end table

@end table

@subsubheading State

This primitive is issued by the LMS provider in direct response to an @prim{LMI_OPTMGMT_REQ} primitive.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

The LMS provider follows the following rules when processing option management service requests:

@itemize ---

@item
When the @parm{lmi_mgmt_flags} field in the @prim{LMI_OPTMGMT_REQ} primitive is set to @pval{LMI_NEGOTIATE},
the LMS provider will attempt to negotiate a value for each of the options specified in the
request.

@item
When the flags are @pval{LMI_DEFAULT}, the LMS provider will return the default values of the specified
options, or the default values of all options known to the LMS provider if no options were
specified.

@item
When the flags are @pval{LMI_CURRENT}, the LMS provider will return the current values of the specified
options, or all options.

@item
When the flags are @pval{LMI_CHECK}, the LMS provider will attempt to negotiate a value for each of the
options specified in the request and return the resulg of the negotiation, but will not affect the
current value of the option.

@end itemize

@page
@node Event Reporting Service Primitives
@subsection Event Reporting Service Primitives

The event reporting service primitives allow the LMS provider to indicate asynchronous errors,
events and statistics collection to the LMS user.

These service primitives implement the event reporting service (@pxref{Event Reporting Service}).

@menu
* LMI_ERROR_IND::
* LMI_STATS_IND::
* LMI_EVENT_IND::
@end menu

@node LMI_ERROR_IND
@subsubsection LMI_ERROR_IND

@subsubheading Description

This LMS provider originated service primitive is issued by the LMS provider when it detects and
asynchronous error event.  The service primitive is applicable to all styles of PPA.

@subsubheading Format
@tpindex lmi_error_ind_t

The error indication service primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_errno;
    lmi_ulong lmi_reason;
    lmi_ulong lmi_state;
} lmi_error_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The error indication service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_ERROR_IND}.

@item lmi_errno
Indicates the LMI error number describing the error.  This field can have one of the following
values:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@item lmi_reason

Indicates the reason for failure.  This field is protocol-specific.  When the @parm{lmi_errno} field
is @perr{LMI_SYSERR}, the @parm{lmi_reason} field is the UNIX error number as described in
@manref{errno(3)}.

@item lmi_state

Indicates the state of the LMS provider at the time that the primitive was issued.
This field can have one of the following values:

@table @psta
@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@item LMI_ATTACH_PENDING
Waiting for attach.
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.
@end table

@end table

@subsubheading State

This primitive can be issued in any state for which a local acknowledgement is not pending.  The
LMS provider state at the time that the primitive was issued is indicated in the primitive.

@subsubheading New State

The new state remains unchanged.

@page
@node LMI_STATS_IND
@subsubsection LMI_STATS_IND

@subsubheading Description

This LMS provider originated primitive is issued by the LMS provider to indicate a periodic
statistics collection event.  The service primitive is applicable to all styles of PPA.

@subsubheading Format
@tpindex lmi_stats_ind_t

The statistics indication service primitive consists of one @msg{M_PROTO} message block, structured as
follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_interval;
    lmi_ulong lmi_timestamp;
} lmi_stats_ind_t;
@end verbatim
@end display

Following this structure within the @msg{M_PROTO} message block is the provider-specific statistics.

@subsubheading Parameters

The statistics indication service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_STATS_IND}.

@item lmi_interval
Indicates the statistics collection interval to which the statistics apply.  This interval is
specified in milliseconds.

@item lmi_timestamp
Indicates the UNIX time (from epoch) at which statistics were collected.  The timestamp is given in
milliseconds from epoch.

@end table

@subsubheading State

This service primitive may be issued by the LMS provider in any state in which a local
acknowledgement is not pending.

@subsubheading New State

The new state remains unchanged.

@page
@node LMI_EVENT_IND
@subsubsection LMI_EVENT_IND

@subsubheading Description

This LMS provider originated primitive is issued by the LMS provider to indicate an asynchronous
event.  The service primitive is applicable to all styles of PPA.

@subsubheading Format
@tpindex lmi_event_ind_t

The event indication service primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_objectid;
    lmi_ulong lmi_timestamp;
    lmi_ulong lmi_severity;
} lmi_event_ind_t;
@end verbatim
@end display

Following this structure within the @msg{M_PROTO} message block is the provider-specific event
information.

@subsubheading Parameters

THe event indication service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_EVENT_IND}.

@item lmi_objectid
Indicates the provider-specific object identifier that identifies the managed object to which the
event is associated.

@item lmi_timestamp
Indicates the UNIX time from epoch (in milliseconds).

@item lmi_severity
Indicates the provider-specific severity of the event.

@end table

@subsubheading State

This service primitive can be issued by the LMS provider in any state where a local
acknowledgement is not pending.  Normally the LMS provider must be in the @psta{LMI_ENABLED} state for
event reporting to occur.

@subsubheading New State

The new state remains unchanged.

@page
@node Protocol Service Primitives
@section Protocol Service Primitives

Protocol service primitives implement the Signalling Link interface protocol.  Protocol service
primitives provide the SLS user with the ability to initialize the link, transfer data on the link,
request and receive reports of receive and transmit congestion, restore failed signalling links,
handle processor outage conditions, manage options and register for and receive event notifications.

These service primitives implement the protocol services (@pxref{Protocol Services}).

@menu
* Link Initialization Service Primitives::
* Data Transfer Service Primitives::
* Congestion Service Primitives::
* Restoration Service Primitives::
* Processor Outage Service Primitives::
* Link Option Management Service Primitives::
* Event Notification Service Primitives::
@end menu

@node Link Initialization Service Primitives
@subsection Link Initialization Service Primitives

The link initialization primitives permit the SLS user to power on the signalling data terminal,
specify emergency or normal alignment, start the signalling link and bring it into service, and stop
the signalling link or be informed of link failures.

These service primitives implement the link initialization services (@pxref{Link Initialization
Services}).

@menu
Power On:
* SL_POWER_ON_REQ::

Emergency:
* SL_EMERGENCY_REQ::
* SL_EMERGENCY_CEASES_REQ::

Start:
* SL_START_REQ::
* SL_IN_SERVICE_IND::

Stop:
* SL_OUT_OF_SERVICE_IND::
* SL_STOP_REQ::
@end menu

@node SL_POWER_ON_REQ
@subsubsection SL_POWER_ON_REQ

@subsubheading Description

The SLS user originated service primitive request that the SLS provider power on the signalling data
terminal.  Not all signalling data terminals can be powered on independent of the existence of the
signalling link interface.  Software signalling data terminals will mark idle on signalling links
until they are powered on, after which they will idle FISUs.

@subsubheading Format
@tpindex sl_power_on_req_t

The power on service primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_power_on_req_t;
@end verbatim
@end display

@subsubheading Parameters

The power on service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_POWER_ON_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state.
This primitive is valid in the @psta{SL_STATE_POWER_OFF} link state; however, when issued in
another link state the primitive is ignored and does not generate a non-fatal error.

@subsubheading New State

The new link state is @psta{SL_STATE_OUT_OF_SERVICE}.

@subsubheading Rules

@subsubheading Response

The power on service primitive does not require receipt acknowledgement from the SLS provider.

@itemize @minus

@item @b{Successful:}
When successful, the power on service primitive does not require acknowledgement.  

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider indicates failure using an @prim{LMI_ERROR_ACK} primitive
containing the error.

@end itemize

Note that the SLS provider should ignore this primitive, and not generate a non-fatal error, when
the management interface is in the @psta{LMI_ENABLED} state and the link state is other than
@psta{SL_STATE_POWER_OFF}.

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node SL_EMERGENCY_REQ
@subsubsection SL_EMERGENCY_REQ

@subsubheading Description

The emergency request service primitive provides the SLS user with the ability to specify that
emergency alignment procedures should be used on the current or next alignment of the signalling
link.  Emergency alignment procedures a shorter in duration (shorter proving period) than normal
alignment procedures.

@subsubheading Format
@tpindex sl_emergency_req_t;

The emergency request service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message
block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_emergency_req_t;
@end verbatim
@end display

@subsubheading Parameters

The emergency request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_EMERGENCY_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state.  The primitive is valid
in any link state.

@subsubheading New State

The management and link state remains unchanged.

@subsubheading Response

The emergency request service primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, the emergency request service primitive does not require receipt acknowledgement.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider negatively acknowledges the primitive with an
@prim{LMI_ERROR_ACK} primitive containing the error.

@end itemize

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table


@page
@node SL_EMERGENCY_CEASES_REQ
@subsubsection SL_EMERGENCY_CEASES_REQ

@subsubheading Description

The emergency ceases request service primitive provides the SLS user with the ability to specify
that normal alignment procedures should be used on the current or next alignment of the signalling
link.  Normal alignment procedures are longer in duration (longer proving period) than emergency
alignment procedures.

@subsubheading Format
@tpindex sl_emergency_ceases_req_t

The emergency ceases request primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message
block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_emergency_ceases_req_t;
@end verbatim
@end display

@subsubheading Parameters

The emergency ceases request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_EMERGENCY_CEASES_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state.  The primitive is valid
in any link state.

@subsubheading New State

The management and link state remains unchanged.

@subsubheading Response

The emergency ceases request service primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, the emergency ceases request service primitive does not require receipt acknowledgement.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider negatively acknowledges the primitive with an
@prim{LMI_ERROR_ACK} primitive containing the error.

@end itemize

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table


@page
@node SL_START_REQ
@subsubsection SL_START_REQ

@subsubheading Description

The start request service primitive allows the SLS user to request that a signalling link be aligned
and brought into service by the SLS provider.

@subsubheading Format
@tpindex sl_start_req_t

The start request service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message
block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_start_req_t;
@end verbatim
@end display

@subsubheading Parameters

The start request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_START_REQ}.

@end table

@subsubheading State

This primitive is only valid in management state @psta{LMI_ENABLED}.  This primitive is valid in
link state @psta{SL_STATE_OUT_OF_SERVICE}.

@subsubheading New State

The new link state is @psta{SL_STATE_INITIAL_ALIGNMENT}.

@subsubheading Response

The start request service primitive requires a response from the SLS provider indicating the success
or failure of the start request.

@itemize @minus

@item @b{Successful link start:}
When successful, the SLS provider indicates success with the @prim{SL_IN_SERVICE_IND}
primitive indicating that the signalling link has been brought into service.  A significant delay in
time might exist between the request and the in-service indication.  This results in the
@psta{SL_STATE_IN_SERVICE} link state.

@item @b{Unuccessful link start:}
When unsuccessful, the SLS provider indicates failure to bring the link in-service with the
@prim{SL_OUT_OF_SERVICE_IND} primitive, containing the reason for failure.  This results int
the @psta{SL_STATE_OUT_OF_SERVICE} link state.

@item @b{Non-fatal errors:}
Non-fatal errors are indicated by the SLS provider using the @prim{LMI_ERROR_ACK} primitive with
the error number and reason contained.

@end itemize

When the management state is @psta{LMI_ENABLED}, but the link state is other than
@psta{SL_STATE_OUT_OF_SERVICE} and @psta{SL_STATEPOWER_OFF}, the SLS provider should
ignore the @prim{SL_START_REQ} primitive and not generate a non-fatal error.

@subsubheading Reason for Failure

Applicable reasons for unsuccessful link start are as follows:

@table @perr

@item SL_FAIL_UNSPECIFIED
The signalling link failed for an unspecified reason.
@item SL_FAIL_CONG_TIMEOUT
The signalling link failed because of congestion timeout (T6 expiry).
@item SL_FAIL_ACK_TIMEOUT
The signalling link failed because of acknowledgement timeout (T7 expiry).
@item SL_FAIL_ABNORMAL_BSNR
The signalling link failed because of receipt of an abnormal backward sequence number (BSNR).
@item SL_FAIL_ABNORMAL_FIBR
The signalling link failed because of receipt of an abnormal forward indicator bit (FIBR).
@item SL_FAIL_SUERM_EIM
The signalling link failed because the SUERM or EIM error rate threshold was exceeded.
@item SL_FAIL_ALIGNMENT_NOT_POSSIBLE
The signalling link failed because the AERM threshold was exceeded and the maximum number of proving
periods was exceeded.
@item SL_FAIL_RECEIVED_SIO
The signalling link failed due to receipt of an SIO during or after alignment.
@item SL_FAIL_RECEIVED_SIN
The signalling link failed due to receipt of an SIN after proving.
@item SL_FAIL_RECEIVED_SIE
The signalling link failed due to receipt of an SIE after proving.
@item SL_FAIL_RECEIVED_SIOS
The signalling link failed due to receipt of an SIOS.
@item SL_FAIL_T1_TIMEOUT
The signalling link failed due to failure to align with remote (T1 timeout).

@end table

Applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table


@page
@node SL_IN_SERVICE_IND
@subsubsection SL_IN_SERVICE_IND

@subsubheading Description

The in-service indication service primitive is issued by the SLS provider to indicate to the SLS
user that a previously invoked link start has successfully aligned and brought the signalling link
into service.

@subsubheading Format
@tpindex sl_in_service_ind_t

The in-service indication service primitive consists of one @msg{M_PROTO} message block, structured
as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_in_service_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The in-service indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_IN_SERVICE_IND}.

@end table

@subsubheading State

This primitive is only issued in the @psta{LMI_ENABLED} management state.  This primitive is only
issued in the @psta{SL_STATE_ALIGNED_READY} state.

@subsubheading New State

The new link state is @psta{SL_STATE_IN_SERVICE}.

@subsubheading Rules

The following rules are observed by the SLS provider when issuing the in-service indication
primitive:

@itemize ---

@item
The primitive is only issued in response to a @prim{SL_START_REQ} primitive that was issued from
the @psta{SL_STATE_OUT_OF_SERVICE} state.

@item
The primitive is only issued once the signalling link has achieved the
@psta{SL_STATE_IN_SERVICE} state.

@end itemize



@page
@node SL_OUT_OF_SERVICE_IND
@subsubsection SL_OUT_OF_SERVICE_IND

@subsubheading Description

The out-of-service indication service primitive is issued by the SLS provider to indicate to the SLS
user that a previously invoked link start has been unsuccessful, or that a previously in-service
signalling link has failed.

@subsubheading Format
@tpindex sl_out_of_service_ind_t

The out-of-service indication service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO}
message block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_timestamp;
    sl_ulong sl_reason;
} sl_out_of_service_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The out-of-service indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_OUT_OF_SERVICE_IND}.

@item sl_timestamp
Indication the time of the failure.  The time is indicated as UNIX time from epoch in milliseconds.

@item sl_reason
Indicates the reason for failure to start the link or the reason for failure of an in-service link.
The @parm{sl_reason} field can assume one of the following values:

@table @pval

@item SL_FAIL_UNSPECIFIED
The signalling link failed for an unspecified reason.
@item SL_FAIL_CONG_TIMEOUT
The signalling link failed because of congestion timeout (T6 expiry).
@item SL_FAIL_ACK_TIMEOUT
The signalling link failed because of acknowledgement timeout (T7 expiry).
@item SL_FAIL_ABNORMAL_BSNR
The signalling link failed because of receipt of an abnormal backward sequence number (BSNR).
@item SL_FAIL_ABNORMAL_FIBR
The signalling link failed because of receipt of an abnormal forward indicator bit (FIBR).
@item SL_FAIL_SUERM_EIM
The signalling link failed because the SUERM or EIM error rate threshold was exceeded.
@item SL_FAIL_ALIGNMENT_NOT_POSSIBLE
The signalling link failed because the AERM threshold was exceeded and the maximum number of proving
periods was exceeded.
@item SL_FAIL_RECEIVED_SIO
The signalling link failed due to receipt of an SIO during or after alignment.
@item SL_FAIL_RECEIVED_SIN
The signalling link failed due to receipt of an SIN after proving.
@item SL_FAIL_RECEIVED_SIE
The signalling link failed due to receipt of an SIE after proving.
@item SL_FAIL_RECEIVED_SIOS
The signalling link failed due to receipt of an SIOS.
@item SL_FAIL_T1_TIMEOUT
The signalling link failed due to failure to align with remote (T1 timeout).

@end table

@end table

@subsubheading State

This primitive is only issued in the @psta{LMI_ENABLED} management state.  This primitive is only
issued from a link state other than @psta{SL_STATE_OUT_OF_SERVICE} or
@psta{SL_STATE_POWER_OFF}.

@subsubheading New State

The new link state is @psta{SL_STATE_OUT_OF_SERVICE}.

@subsubheading Rules

The following rules are observed by the SLS provider when issuing the out-of-service indication
primitive:

@itemize ---

@item
The primitive is only issued in response to a @prim{SL_START_REQ} primitive that was issued from
the @psta{SL_STATE_OUT_OF_SERVICE} state, or as a result of a link failure from the
@psta{SL_STATE_IN_SERVICE} state.

@item
The primitive is only issued once the signalling link has achieved the
@psta{SL_STATE_OUT_OF_SERVICE} state.

@end itemize


@page
@node SL_STOP_REQ
@subsubsection SL_STOP_REQ

@subsubheading Description

The stop request primitive allows the SLS user to request that a signalling link be brought out of
service by the SLS provider.

@subsubheading Format
@tpindex sl_stop_req_t

The stop request service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_stop_req_t;
@end verbatim
@end display

@subsubheading Parameters

The stop request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_STOP_REQ}.

@end table

@subsubheading State

This primitive is only valid in management state @psta{LMI_ENABLED}.  This primitive is valid in
link state
@psta{SL_STATE_INITIAL_ALIGNMENT},
@psta{SL_STATE_ALIGNED_READY},
@psta{SL_STATE_ALIGNED_NOT_READY} or
@psta{SL_STATE_IN_SERVICE}.

@subsubheading New State

The new link state is @psta{SL_STATE_OUT_OF_SERVICE}.

@subsubheading Response

The stop request service primitive does not require receipt acknowledgement from the SLS provider.

@itemize @minus

@item @b{Successful:}
When successful, the SLS provider does not need to acknowledge the stop request service primitive.
The resulting link state is @psta{SL_STATE_OUT_OF_SERVICE}.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider negatively acknowledges the stop request service primitive with
a @prim{LMI_ERROR_ACK} primitive containing the error and reason.  The resulting state is
unchanged.

@end itemize

When the management state is @psta{LMI_ENABLED}, but the link state is
@psta{SL_STATE_POWER_OFF} or @psta{SL_STATE_OUT_OF_SERVICE}, the SLS provider should
ignore the @prim{SL_STOP_REQ} primitive and not generate a non-fatal error.

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table


@page
@node Data Transfer Service Primitives
@subsection Data Transfer Service Primitives

Data transfer service primitives provider the SLS user with the ability to send and receive message
signal units on an in-service signalling link.
These service primitives implement the data transfer service (@pxref{Data Transfer Service}).

@menu
* SL_PDU_REQ::
* SL_PDU_IND::
@end menu

@node SL_PDU_REQ
@subsubsection SL_PDU_REQ

@subsubheading Description

The PDU request service primitive provides the SLS user with the ability to request that a message
signal unit be transmitted on an in-service signalling link.

@subsubheading Format
@tpindex sl_pdu_req_t

The PDU request service primitive consists of zero or one @msg{M_PROTO} message block and one
@msg{M_DATA} message block containing the message signal unit.  The structure of the @msg{M_PROTO}
message block is as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_mp;
} sl_pdu_req_t;
@end verbatim
@end display

@subsubheading Parameters

The PDU request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_PDU_REQ}.

@item sl_mp
Specifies the message priority for the message signal unit.  Message priorities are
provider-specific, but are typically between 0 and 3.  This message priority field is only
applicable to SS7 protocol variants that place message priority bits in a field of the Level 2
header (TTC).

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state, and is valid from the
@psta{SL_STATE_IN_SERVICE} link state.

@subsubheading New State

The management and link state remains unchanged.

@subsubheading Rules

The following rules are observed when issuing the PDU request service primitive:

@itemize ---

@item
The @msg{M_PROTO} message block is optional and is only necessary for the TTC SS7 protocol variant,
or an SS7 protocol variant which places message priority bits into the Level 2 header.

@item
The PDU request service primitive does not require a response from the SLS provider.

@end itemize

@subsubheading Response

The PDU request service primitive is not acknowledged.


@page
@node SL_PDU_IND
@subsubsection SL_PDU_IND

@subsubheading Description

The PDU indication service primitive provides the SLS user with the ability to receive message
signal units from a signalling link.

@subsubheading Format
@tpindex sl_pdu_ind_t

The PDU indication service primitive consists of zero or more @msg{M_PROTO} message blocks and one
or more @msg{M_DATA} message blocks containing the message signal unit.  The structure of the
@msg{M_PROTO} message block is as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_mp;
} sl_pdu_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The PDU indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_PDU_IND}.

@item sl_mp
Indicates the message priority of the message signal unit.  Message priorities are
provider-specific, but are typically between 0 and 3.  This message priority field is only
applicable to SS7 protocol variants that place message priority bits in a field of the Level 2
header (e.g. TTC).

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state, and is valid from the
@psta{SL_STATE_IN_SERVICE} link state.

@subsubheading New State

The management and link states remain unchanged.

@subsubheading Rules

The following rules are observed when issuing the PDU indication service primitive:

@itemize ---

@item
The @msg{M_PROTO} message block is optional and is only necessary for the TTC SS7 protocol variant,
or an SS7 protocol variant that passes message priority bits from the Level 2 header.

@item
The PDU indication service primitive does not require a response from the SLS user.

@end itemize


@page
@node Congestion Service Primitives
@subsection Congestion Service Primitives

These service primitives implement the congestion services (@pxref{Congestion Services}).

@menu
Transmit Congestion:
* SL_LINK_CONGESTED_IND::
* SL_LINK_CONGESTION_CEASED_IND::

Receive Congestion:
* SL_CONGESTION_DISCARD_REQ::
* SL_CONGESTION_ACCEPT_REQ::
* SL_NO_CONGESTION_REQ::
@end menu

@node SL_LINK_CONGESTED_IND
@subsubsection SL_LINK_CONGESTED_IND

@subsubheading Description

The link congested indication service primitive provides the SLS provider with the ability to
inidicate link transmit congestion onset at a congestion level to the SLS user.

@subsubheading Format
@tpindex sl_link_cong_ind_t

The link congested indication service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO}
message block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_timestamp;
    sl_ulong sl_cong_status;            /* congestion status */
    sl_ulong sl_disc_status;            /* discard status */
} sl_link_cong_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The link congested indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_LINK_CONGESTED_IND}.

@item sl_timestamp
Indicates the time at which the change in congestion status occurred.  This is UNIX time from epoch
timestamp in milliseconds.

@item sl_cong_status
Indicates the congestion status.  The congestion status is the maximum level at which transmit congestion
onset has occurred.  This field is provider-specific but can typically take on a value from 0 to 3.
The SLS user should signal congestion to the senders of messages with message priority less than the
congestion status but should not discard messages of that priority.

@item sl_disc_status
Indicates the discard status.  The discard status is the maximum level at which transmit congestion discard
has occurred.  This field is provider-specific but can typically take on a value from 0 to 3.
The SLS user should signal congestion to senders of message with message priority less than the
discard status and should also discard messages of that priority.

@end table

@subsubheading State

This primitive is only issued in the @psta{LMI_ENABLED} management state and the
@psta{SL_STATE_IN_SERVICE} link state.

@subsubheading New State

The management and link state remain unchanged.

@subsubheading Rules

The SLS provider observes the following rules when issuing the link congested indication service
primitive:

@itemize ---

@item
The service primitive is only issued from the @psta{SL_STATE_IN_SERVICE} link state.

@item
The service primitive is only issued from the @psta{LMI_ENABLED} management state.

@item
The service primitive is only issued when the congestion status or discard status increases from the
value that was last indicated with either a @prim{SL_LINK_CONGESTION_IND} or
@prim{SL_LINK_CONGESTION_CEASED_IND} primitive.

@end itemize

@subsubheading Response

The SLS user upon receiving this primitive should avoid sending messages of message priority less
than the transmit congestion status, and must not send messages of message priority less than the
discard status.  The SLS provider does not actually discard messages with message priority less than
the discard status: it is the responsibility of the SLS user to discard lower priority messages.

Typically the SLS user is the SS7 Message Transfer Part.  The SS7 MTP issues congestion indications
to local MTP-Users and issues transfer-controlled messages to sending signalling points when
transmit congestion onset occurs.  When transmit congestion discard occurs, the SS7 MTP continues
to issue congestion indications to local MTP-User and transfer-controlled message to sending
signalling points, but also discards messages with insufficient priority for the discard level.

@page
@node SL_LINK_CONGESTION_CEASED_IND
@subsubsection SL_LINK_CONGESTION_CEASED_IND

@subsubheading Description

The link congestion ceased indication service primitive allows the SLS provider to indicate to the
SLS user when transmit congestion abates.

@subsubheading Format
@tpindex sl_link_cong_ceased_ind_t

The link congestion ceased service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO}
message block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_timestamp;
    sl_ulong sl_cong_status;            /* congestion status */
    sl_ulong sl_disc_status;            /* discard status */
} sl_link_cong_ceased_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The link congestion ceased service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_CONGESTION_CEASED_IND}.

@item sl_timestamp
Indicates the time at which the change in transmit congestion status occurred.  This is UNIX time from epoch
timestamp in milliseconds.

@item sl_cong_status
Indicates the congestion status.  The congestion status is the maximum level at which transmit
congestion onset has occurred.  This field is provider-specific but can typically take on a value
from 0 to 3.  The SLS user should signal congestion to the senders of messages with message priority
less than the congestion status but should not discard messages of that priority.

@item sl_disc_status
Indicates the discard status.  The discard status is the maximum level at which transmit congestion
discard has occurred.  This field is provider-specific but can typically take on a value from 0 to
3.  The SLS user should signal congestion to senders of message with message priority less than the
discard status and should also discard messages of that priority.

@end table

@subsubheading State

This primitive is only issued in the @psta{LMI_ENABLED} management state and the
@psta{SL_STATE_IN_SERVICE} link state.

@subsubheading New State

The management and link state remain unchanged.

@subsubheading Rules

The SLS provider observes the following rules when issuing the link congestion ceased indication
service primitive:

@itemize ---

@item
The service primitive is only issued from the @psta{SL_STATE_IN_SERVICE} link state.

@item
The service primitive is only issued from the @psta{LMI_ENABLED} management state.

@item
The service primitive is only issued when the congestion status or discard status decreases from the
value that was last indicated with either a @prim{SL_LINK_CONGESTION_IND} or
@prim{SL_LINK_CONGESTION_CEASED_IND} primitive.

@end itemize

@subsubheading Response

The SLS user upon receiving this primitive should cease discarding or sending congestion indications
or transfer-controlled messages for the congestion level which has abated.


@page
@node SL_CONGESTION_DISCARD_REQ
@subsubsection SL_CONGESTION_DISCARD_REQ

@subsubheading Description

The congestion discard request service primitive is used by the SLS user to specify receive
congestion discard.

Normally an SLS user will first signal receive congestion onset with the
@prim{SL_CONGESTION_ACCEPT_REQ} primitive before signalling receive congestion discard with
this @prim{SL_CONGESTION_DISCARD_REQ} primitive.  The congestion discard service primitive
requests that the SLS provider discard all new undelivered message signal units and not acknowledge
them to the remote SLS provider.  The SLS provider will also generate receive congestion indications
to the remote SLS provider (i.e. will periodically generate SIB).

@subsubheading Format
@tpindex sl_cong_discard_req_t

The congestion discard request service primitive consists of one @msg{M_PCPROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_cong_discard_req_t;
@end verbatim
@end display

@subsubheading Parameters

The congestion discard request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_CONGESTION_DISCARD_REQ}.

@end table

@subsubheading State

This primitive is valid only in @psta{LMI_ENABLED} management state.  It is valid in
@psta{SL_STATE_IN_SERVICE} link state.

@subsubheading New State

The link and management state remains the same.

@subsubheading Rules

The SLS user should observe the following rules when issuing the congestion discard request service
primitive:

@itemize ---

@item
The SLS user should not generate a congestion discard request unless a congestion accept request was
previously issued.

@item
The SLS user should not generate a congestion discard request unless a congestion accept request was
previously issued @emph{and} a message signal unit has been delivered since the congestion accept
request was issued.

@end itemize

@subsubheading Response

The congestion discard request service primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, this primitive does not require acknowledgement.  The state remains the same.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider negatively acknowledges the primitive using the
@prim{LMI_ERROR_ACK} primitive containing the error and reason.  The state remains the same.

@end itemize

Note that if the SLS provider is in the @psta{LMI_ENABLED} state, but the link is not in the
@psta{SL_STATE_IN_SERVICE} state, the primitive should be ignored and no non-fatal error
generated.

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table


@page
@node SL_CONGESTION_ACCEPT_REQ
@subsubsection SL_CONGESTION_ACCEPT_REQ

@subsubheading Description

The congestion accept request service primitive is used by the SLS user to specify receive
congestion onset.

@subsubheading Format
@tpindex sl_cong_accept_req_t

The congestion accept request service primitive consists of one @msg{M_PCPROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_cong_accept_req_t;
@end verbatim
@end display

@subsubheading Parameters

The congestion accept request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_CONGESTION_ACCEPT_REQ}.

@end table

@subsubheading State

This primitive is valid only in @psta{LMI_ENABLED} management state.  It is valid in
@psta{SL_STATE_IN_SERVICE} link state.

@subsubheading New State

The link and management state remains the same.

@subsubheading Response

The congestion accept request service primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, this primitive does not require acknowledgement.  The state remains the same.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider negatively acknowledges the primitive using the
@prim{LMI_ERROR_ACK} primitive containing the error and reason.  The state remains the same.

@end itemize

Note that if the SLS provider is in the @psta{LMI_ENABLED} state, but the link is not in the
@psta{SL_STATE_IN_SERVICE} state, the primitive should be ignored and no non-fatal error
generated.

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table


@page
@node SL_NO_CONGESTION_REQ
@subsubsection SL_NO_CONGESTION_REQ

@subsubheading Description

The no congestion request service primitive is used by the SLS user to specify receive
congestion abatement.

@subsubheading Format
@tpindex sl_no_cong_req_t

The no congestion request service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO}
message block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_no_cong_req_t;
@end verbatim
@end display

@subsubheading Parameters

The no congestion request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_NO_CONGESTION_REQ}.

@end table

@subsubheading State

This primitive is valid only in @psta{LMI_ENABLED} management state.  It is valid in
@psta{SL_STATE_IN_SERVICE} link state.

@subsubheading New State

The link and management state remains the same.

@subsubheading Response

The no congestion request service primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, this primitive does not require acknowledgement.  The state remains the same.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider negatively acknowledges the primitive using the
@prim{LMI_ERROR_ACK} primitive containing the error and reason.  The state remains the same.

@end itemize

Note that if the SLS provider is in the @psta{LMI_ENABLED} state, but the link is not in the
@psta{SL_STATE_IN_SERVICE} state, the primitive should be ignored and no non-fatal error
generated.

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table



@page
@node Restoration Service Primitives
@subsection Restoration Service Primitives

The restoration service primitives permit the SLS user to perform functions necessary for BSNT
retrieval to initiate or respond to sequenced changeover, buffer updating to respond to sequenced or
time-controlled changeover, and buffer clearing to respond to time-controlled changeover or
processor outage related failures.

These service primitives implement the restoration services (@pxref{Restoration Services}).

@menu
BSNT Retrieval:
* SL_RETRIEVE_BSNT_REQ::
* SL_BSNT_IND::
* SL_BSNT_NOT_RETRIEVABLE_IND::

Buffer Updating:
* SL_RETRIEVAL_REQUEST_AND_FSNC_REQ::
* SL_RETRIEVED_MESSAGE_IND::
* SL_RETRIEVAL_COMPLETE_IND::
* SL_RETRIEVAL_NOT_POSSIBLE_IND::

Buffer Clearing:
* SL_CLEAR_BUFFERS_REQ::
* SL_CLEAR_RTB_REQ::
* SL_RB_CLEARED_IND::
* SL_RTB_CLEARED_IND::
@end menu

@node SL_RETRIEVE_BSNT_REQ
@subsubsection SL_RETRIEVE_BSNT_REQ

@subsubheading Description

The retrieve BSNT request service primitive allows the SLS user to request retrieval of the BSNT
(backward sequence number transmitted) which indicates the sequence number of the remove message
signal unit sent that was last acknowledged.  This function is necessary to properly generate or
respond to a sequenced changeover procedure by the SLS user.

@subsubheading Format
@tpindex sl_retrieve_bsnt_req_t

The retrieve BSNT request service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO}
message block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_retrieve_bsnt_req_t;
@end verbatim
@end display

@subsubheading Parameters

The retrieve BSNT request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_RETRIEVE_BSNT_REQ}.

@end table

@subsubheading State

This primitive is valid only in the @psta{LMI_ENABLED} management state.  The primitive is valid
in the @psta{SL_STATE_OUT_OF_SERVICE} state.

@subsubheading New State

The new state is unchanged.

@subsubheading Rules

The SLS user should observe the following rules when issuing the retrieve BSNT request service
primitive:

@itemize ---

@item
The SLS user should ensure that the link is in the @psta{SL_STATE_OUT_OF_SERVICE} state
before issuing this primitive.  One easy way to ensure that the link is in this state is to issue
the stop request @prim{SL_STOP_REQ}.

@end itemize

@subsubheading Response

This service primitive requires the SLS provider to acknowledge success of failure of the retrieval
operation.

@itemize @minus

@item @b{Successful retrieval:}
When successful, the SLS provider indicate the retrieved BSNT value using the @prim{SL_BSNT_IND}
primitive containing the BSNT value.  The management and link states remain the same.

@item @b{Unsuccessful retrieval:}
When unsuccessful, the SLS provider indicates that the BSNT value cannot be retrieved using the
@prim{SL_BSNT_NOT_RETRIEVABLE_IND}.  The management and link states remain the same.

@item @b{Non-fatal errors:}
When a non-fatal error occurs, the SLS provider indicates the error using the
@prim{LMI_ERROR_ACK} primitive containing the error and the reason.

@end itemize

When the management state is @psta{LMI_ENABLED} and the link state is other than
@psta{SL_STATE_OUT_OF_SERVICE}, the SLS provider should respond with
@prim{SL_BSNT_NOT_RETRIEVABLE_IND} instead of generating a non-fatal error.

@subsubheading Reason for Failure

Most SLS providers are always successful in retrieving the BSNT value.  Applicable reasons for
failing to retrieve the BSNT value are as follows:

@enumerate

@item Hardware failure.

@item The signalling link is in the incorrect state (e.g. the in-service state).

@end enumerate

Applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node SL_BSNT_IND
@subsubsection SL_BSNT_IND

@subsubheading Description

The BSNT indication service primitive is originated by the SLS provider to indicate the retrieved
BSNT value in response to a @prim{SL_RETRIEVE_BSNT_REQ} primitive from the SLS user.

@subsubheading Format
@tpindex sl_bsnt_ind_t

The BSNT indication service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message
block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_bsnt;
} sl_bsnt_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The BSNT indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_BSNT_IND}.

@item sl_bsnt
Indicates the value of the BSNT.  The format of the BSNT value is provider-specific but is typically
a 7-bit or 12-bit sequence number.

@end table

@subsubheading State

This primitive is valid in management state @psta{LMI_ENABLED} and link state
@psta{SL_STATE_OUT_OF_SERVICE}.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

The SLS provider observes the following rules when issuing a BSNT indication service primitive:

@itemize ---

@item
The primitive is only issued from the @psta{LMI_ENABLED} management state and the
@psta{SL_STATE_OUT_OF_SERVICE} link state.

@item
The primitive is only issued in response to an outstanding @prim{SL_RETRIEVE_BSNT_REQ}
primitive when it is possible for the SLS provider to retrieve the BSNT value.

@end itemize

@subsubheading Response

The primitive does not require a response from the SLS user.


@page
@node SL_BSNT_NOT_RETRIEVABLE_IND
@subsubsection SL_BSNT_NOT_RETRIEVABLE_IND

@subsubheading Description

The BSNT not retrievable indication service primitive is originated by the SLS provider to indicate
that the BSNT value cannot be retrieved in response to a @prim{SL_RETRIEVE_BSNT_REQ} primitive
from the SLS user.

@subsubheading Format
@tpindex sl_bsnt_not_retr_ind_t

The BSNT not retrievable indication service primitive consists of one @msg{M_PROTO} or
@msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_bsnt;
} sl_bsnt_not_retr_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The BSNT not retrievable indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_BSNT_NOT_RETRIEVABLE_IND}.

@item sl_bsnt
Indicates the value of the BSNT.  This value is the known value of the last acknowledged message
signal unit from the remote peer or minus one (-1UL) indicating that a reasonable BSNT value is not
known.  The format of the BSNT is provider-specific, but is typically a 7-bit or 12-bit sequence
number.

@end table

@subsubheading State

This primitive is valid in management state @psta{LMI_ENABLED} and is valid in any link state.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

The SLS provider observes the following rules when issuing the BSNT not retrievable indication
service primitive:

@itemize ---

@item
The primitive is only issued from the @psta{LMI_ENABLED} management state, but may be issued from
any link state.

@item
The primitive is only issued in response to an outstanding @prim{SL_RETRIEVE_BSNT_REQ}
primitive when it is not possible for the SLS provider to retrieve the BSNT value.

@item
When issued, a non-fatal error for the same request will not be issued.

@end itemize

@subsubheading Response

The primitive does not require a response from the SLS user.


@page
@node SL_RETRIEVAL_REQUEST_AND_FSNC_REQ
@subsubsection SL_RETRIEVAL_REQUEST_AND_FSNC_REQ

@subsubheading Description

The retrieval request and FSNC request service primitive is originated by the SLS user when it
wishes to update the retransmission buffer with the last known acknowledged message (FSNC).  The
last known acknowledged message is acquired by the SLS user with the sequence changeover procedure
of the message transfer part.  The primitive requests that the SLS provider update the
retransmission buffer and then deliver the contents of the updated retransmission buffer and
transmit buffers to the SLS user.

@subsubheading Format
@tpindex sl_retrieval_req_and_fsnc_t

The retrieval request and FSNC request service primitive consists of one @msg{M_PROTO} or
@msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_fsnc;
} sl_retrieval_req_and_fsnc_t;
@end verbatim
@end display

@subsubheading Parameters

The retrieval request and FSNC request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_RETRIEVAL_REQ_AND_FSNC_REQ}.

@item sl_fsnc
Specifies the value of the FSNC (forward sequence number confirmed).  This is the last known message
to be acknowledge by the remote SLS provider.  The format of the FSNC is provider-specific, but is
typically a 7-bit or 12-bit sequence number.

@end table

@subsubheading State

This primitive is only valid in management state @psta{LMI_ENABLED} and is valid in link state
@psta{SL_STATE_OUT_OF_SERVICE}.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

@subsubheading Response

The retrieval request and FSNC request service primitive request the SLS provider to acknowledge
the result of the retrieval action as follows:

@itemize @minus

@item @b{Successful retrieval:}
When successful, the SLS provider indicates the updated contents of the retransmission buffer and the
contents of the transmission buffer using the @prim{SL_RETRIEVED_MESSAGE_IND} primitive
followed by a @prim{SL_RETRIEVAL_COMPLETE_IND} primitive.  The state remains unchanged.

@item @b{Unsuccessful retrieval:}
When unsuccessful, the SLS provider indicates failure to retrieve the contents of the buffers with
the @prim{SL_RETRIEVAL_NOT_POSSIBLE_IND} primitive.

@item @b{Non-fatal errors:}
When a non-fatal error occurs, the SLS provider indicates the error using the
@prim{LMI_ERROR_ACK} primitive containing the error and the reason.  The state remains
unchanged.

@end itemize

When the management stat is @psta{LMI_ENABLED} and the link state is other than
@psta{SL_STATE_OUT_OF_SERVICE}, the SLS provider should respond with
@prim{SL_RETRIEVAL_NOT_POSSIBLE_IND} instead of generating a non-fatal error.

@subsubheading Reason for Failure

Most SLS providers are always successful in retrieving the updated contents of the retransmission
buffer and transmission buffer.  Applicable reasons for failing to retrieve the updated buffer
contents are as follows:

@enumerate

@item Hardware failure.

@item The signalling link is in the incorrect link state (e.g. the in-service state).

@item The specified value of FSNC does not match and is not adjacent to a message contained in the
retransmission buffer.

@end enumerate

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table


@page
@node SL_RETRIEVED_MESSAGE_IND
@subsubsection SL_RETRIEVED_MESSAGE_IND

@subsubheading Description

The retrieved message indication service primitive is originated by the SLS provider to transfer the
contents of the updated retransmission buffer and transmission buffer to the SLS user.  One
primitive is used for each message retrieved.  The oldest message in the buffers is indicated first.

@subsubheading Format
@tpindex sl_retrieved_msg_ind_t

The retrieved message indication service primitive consists of one @msg{M_PROTO} message block
followed by one or more @msg{M_DATA} message blocks containing the retrieved message signal unit in
the same format as it was presented to the SLS provider for transmission.  The @msg{M_PROTO}
message block is structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_mp;
} sl_retrieved_msg_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The retrieve message indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_RETRIEVED_MESSAGE_IND}.

@item sl_mp
Indicates the message priority for the message that was specified in the @prim{SL_PDU_REQ}
primitive from the SLS user when the message was submitted for transmission.  Message priorities are
provider-specific, but are typically between 0 and 3.  This message priority field is only
applicable to SS7 protocol variants that place message priority bits in a field of the Level 2
header, such as TTC.

@end table

@subsubheading State

This primitive is only issued in management state @psta{LMI_ENABLED} and link state
@psta{SL_STATE_OUT_OF_SERVICE}.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

The SLS provider observes the following rules when issuing a retrieved message indication service
primitive:

@itemize ---

@item
The primitive is only issued from the @psta{LMI_ENABLED} management state and the
@psta{SL_STATE_OUT_OF_SERVICE} link state.

@item
The primitive is only issued in response to an outstanding
@prim{SL_RETRIEVAL_REQUEST_AND_FSNC_REQ} primitive when it is possible for the SLS
provider to update and retrieve message signal units from the retransmission and transmission
buffers.

@item
The primitive is not issued when the updated retransmission buffer and transmission buffer are empty.

@end itemize

@subsubheading Response

This primitive does not require response from the SLS user.


@page
@node SL_RETRIEVAL_COMPLETE_IND
@subsubsection SL_RETRIEVAL_COMPLETE_IND

@subsubheading Description

The retrieval complete indication service primitive is originated by the SLS provider to indicate
the completion of transfer of the contents of the updated retransmission buffer and transmission
buffer to the SLS user.  The primitive is issued in response to a
@prim{SL_RETRIEVAL_REQUEST_AND_FSNC_REQ} primitive issued by the SLS user.

@subsubheading Format
@tpindex sl_retrieval_comp_ind_t

The retrieval complete indication service primitive consists of one @msg{M_PROTO} message block and
zero or more @msg{M_DATA} message blocks containing the last retrieved message signal unit in the
same format as it was presented to the SLS provider for transmission.  The @msg{M_PROTO} message
block is structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_mp;
} sl_retrieval_comp_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The retrieval complete indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_RETRIEVAL_COMPLETE_IND}.

@item sl_mp
When accompanied by @msg{M_DATA} message blocks containing the last retrieved message signal unit,
the @parm{sl_mp} field indicates the message priority for that message that was specified in the
@prim{SL_PDU_REQ} primitive from the SLSL user when the message was submitted for transmission.
Message priorities are provider-specific, but are typically between 0 and 3.  This message priority
field is only applicable to SS7 protocol variants that place message priority bits in a field of the
Level 2 header, such as TTC.

@end table

@subsubheading State

This primitive is only issued in management state @psta{LMI_ENABLED} and link state
@psta{SL_STATE_OUT_OF_SERVICE}.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

The SLS provider observes the following rules when issuing a retrieval complete indication service
primitive:

@itemize ---

@item
The primitive is only issued from the @psta{LMI_ENABLED} management state and the
@psta{SL_STATE_OUT_OF_SERVICE} link state.

@item
The primitive is only issued in response to an outstanding
@prim{SL_RETRIEVAL_REQUEST_AND_FSNC_REQ} primitive when transfer of the updated
retransmission buffer and transmission buffer is complete.

@item
A message signal unit is not attached to the primitive in @msg{M_DATA} message blocks when the
updated retransmission and transmission buffers were empty.

@item
Attaching the last retrieved message to the primitive in @msg{M_DATA} message blocks is optional
and not recommended: the @prim{SL_RETRIEVED_MESSAGE_IND} primitive should be used to transfer
all retrieved message signal units first.

@item
Upon receipt of the retrieval complete indication service primitive, the SLS user will consider the
retrieval operation complete.

@end itemize

@subsubheading Response

This primitive does not require a response from the SLS user.

@subsubheading Reason for Failure


@page
@node SL_RETRIEVAL_NOT_POSSIBLE_IND
@subsubsection SL_RETRIEVAL_NOT_POSSIBLE_IND

@subsubheading Description

The retrieval not possible indication service primitive is originated by the SLS provider to
indicate that the updated contents of the retransmission and transmission buffers is not possible.
The primitive is issued in response to a @prim{SL_RETREIVAL_REQUEST_AND_FSNC_REQ}
primitive received from the SLS user.

@subsubheading Format
@tpindex sl_retrieval_not_poss_ind_t

The retrieval not possible indication service primitive consists of one @msg{M_PROTO} message
block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_retrieval_not_poss_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The retrieval not possible indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_RETRIEVAL_NOT_POSSIBLE_IND}.

@end table

@subsubheading State

This primitive is only issued from the @psta{LMI_ENABLED} management state, but may be issued from
any link state.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

The SLS provider observes the following rules when issuing the retrieval not possible indication
service primitive:

@itemize ---

@item
The primitive is only issued from the @psta{LMI_ENABLED} management state, but may be issued from
any link state.

@item
The primitive is only issued in response to an outstanding
@prim{SL_RETRIEVAL_REQUEST_AND_FSNC_REQ} primitive when it is not possible to update and
retrieve the updated contents of the retransmission and transmission buffers.

@item
When issued, a non-fatal error will not be issued for the same request.

@item
Upon receipt of the primitive, the SLS user shall consider the retrieval operation complete.

@end itemize

@subsubheading Response

The primitive does not require a response from the SLS user.


@page
@node SL_CLEAR_BUFFERS_REQ
@subsubsection SL_CLEAR_BUFFERS_REQ

@subsubheading Description

The clear buffers request service primitive is originated by the SLS user to request that all
message buffers be cleared by the SLS provider.  This includes receive buffer, retransmission buffer
and transmission buffers.

@subsubheading Format
@tpindex sl_clear_buffers_req_t

The clear buffers request service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO}
message block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_clear_buffers_req_t;
@end verbatim
@end display

@subsubheading Parameters

The clear buffers request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_CLEAR_BUFFERS_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state and the
@psta{SL_STATE_OUT_OF_SERVICE} link state.

@subsubheading New State

The new state remains unchanged.

@subsubheading Response

The clear buffers request service primitive requires the SLS provider to indicate when the receive
buffer and retransmission buffers are cleared, as follows:

@itemize @minus

@item @b{Successful:}
When successful, the SLS provider clears the receive buffer, retransmission buffer and transmission
buffer.  When the receive buffer is cleared, the SLS provider indicates the clearing with the
@prim{SL_RB_CLEARED_IND} primitive.  When the retransmission buffer is cleared, the SLS
provider indicates the clearing with the @prim{SL_RTB_CLEARED_IND} primitive.  The state
remains unchanged.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider negatively acknowledges the primitive using the
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state remains
unchanged.

@end itemize

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table


@page
@node SL_CLEAR_RTB_REQ
@subsubsection SL_CLEAR_RTB_REQ

@subsubheading Description

The clear RTB request service primitive is originated by the SLS user to request that only the
retransmission buffer be cleared by the SLS provider.  This primitive is used in conjunction with
the time-controlled changeover procedure of the message transfer part.

@subsubheading Format
@tpindex sl_clear_rtb_req_t

The clear RTB request service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message
block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_clear_rtb_req_t;
@end verbatim
@end display

@subsubheading Parameters

The clear RTB request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_CLEAR_RTB_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state and the
@psta{SL_STATE_OUT_OF_SERVICE} link state.

@subsubheading New State

The new state remains unchanged.

@subsubheading Response

The clear RTB request service primitive requires the SLS provider to indicate when the
retransmission buffer has been cleared, as follows:

@itemize @minus

@item @b{Successful:}
When successful, the SLS provider clears the retransmission buffer.  When the retransmission buffer
is cleared, the SLS provider indicates the clearing with the @prim{SL_RTB_CLEARED_IND}
primitive.  The state remains unchanged.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider negatively acknowledges the primitive using the
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state remains
unchanged.

@end itemize

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table


@page
@node SL_RB_CLEARED_IND
@subsubsection SL_RB_CLEARED_IND

@subsubheading Description

The RB cleared indication service primitive is originated by the SLS provider whenever the receive
buffer has been cleared; either in response to a @prim{SL_CLEAR_BUFFERS_REQ} primitive from
the SLS user, or due to internal state machine operations.

@subsubheading Format
@tpindex sl_rb_cleared_ind_t

The RB cleared indication service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO}
message block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_rb_cleared_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The RB cleared indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_RB_CLEARED_IND}.

@end table

@subsubheading State

This primitive is only issued by the SLS provider in the @psta{LMI_ENABLED} management state and
the @psta{SL_STATE_OUT_OF_SERVICE} link state.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

The SLS provider observes the following rules when issuing the RB cleared indication service
primitive:

@itemize ---

@item
The primitive is only issued from the @psta{LMI_ENABLED} management state and the
@psta{SL_STATE_OUT_OF_SERVICE} link state.

@item
The primitive is issued in response to a @prim{SL_CLEAR_BUFFERS_REQ} primitive from the SLS
user.

@item
The primitive is also issued in response to internal state machine transitions.

@end itemize

@subsubheading Response

This primitive does not require a response from the SLS user.


@page
@node SL_RTB_CLEARED_IND
@subsubsection SL_RTB_CLEARED_IND

@subsubheading Description

The RTB cleared indication service primitive is originated by the SLS provider whenever the
retransmission buffer has been cleared; either in response to a @prim{SL_CLEAR_BUFFERS_REQ} or
@prim{SL_CLEAR_RTB_REQ} primitive, or due to internal state machine operations.

@subsubheading Format
@tpindex sl_rtb_cleared_ind_t

The RTB cleared indication service primitive consists of one @msg{M_PROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_rtb_cleared_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The RTB cleared indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_RTB_CLEARED_IND}.

@end table

@subsubheading State

The primitive is only issued by the SLS provider from the @psta{LMI_ENABLED} management state and
the @psta{SL_STATE_OUT_OF_SERVICE} link state.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

The SLS provider observes the following rules when issuing the RTB cleared indication service
primitive:

@itemize ---

@item
The primitive is only issued from the @psta{LMI_ENABLED} management state and the
@psta{SL_STATE_OUT_OF_SERVICE} link state.

@item
The primitive is issued in response to a @prim{SL_CLEAR_BUFFERS_REQ} or
@prim{SL_CLEAR_RTB_REQ} primitive from the SLS user.

@item
The primitive is also issued in response to internal state machine transitions.

@end itemize

@subsubheading Response

This primitive does not require a response from the SLS user.



@page
@node Processor Outage Service Primitives
@subsection Processor Outage Service Primitives

The processor outage service primitive permit the SLS user the ability to assert and resume from a
local processor outage condition as well as being informed by the SLS provider when a local or
remote processor outage condition is in effect or has cleared.  The SLS user is also able, using
these and other primitives, to recover from a local or remote processor outage condition.

These service primitives implement the processor outage services (@pxref{Processor Outage Services}).

@menu
Local Processor Outage:
* SL_LOCAL_PROCESSOR_OUTAGE_REQ::
* SL_LOCAL_PROCESSOR_OUTAGE_IND::
* SL_RESUME_REQ::
* SL_LOCAL_PROCESSOR_RECOVERED_IND::

Remote Processor Outage:
* SL_REMOTE_PROCESSOR_OUTAGE_IND::
* SL_REMOTE_PROCESSOR_RECOVERED_IND::
* SL_CONTINUE_REQ::
@end menu

@node SL_LOCAL_PROCESSOR_OUTAGE_REQ
@subsubsection SL_LOCAL_PROCESSOR_OUTAGE_REQ

@subsubheading Description

The local processor outage request service primitive allows the SLS user to specify that a local
processor outage condition exists.

@subsubheading Format
@tpindex sl_local_proc_outage_req_t

The local processor outage request service primitive consists of one @msg{M_PROTO} or
@msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_local_proc_outage_req_t;
@end verbatim
@end display

@subsubheading Parameters

The local processor outage request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_LOCAL_PROCESSOR_OUTAGE_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state but is valid from any link
state.

@subsubheading New State

The new state is @psta{SL_STATE_PROCESSOR_OUTAGE}.

@subsubheading Response

This primitive does not request a response from the SLS provider.

@itemize @minus

@item @b{Successful:}
When successful, the link moves to the @psta{SL_STATE_PROCESSOR_OUTAGE} state and a local
processor outage condition is asserted.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider will negatively acknowledge the primitive using the
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state remains
unchanged.

@end itemize

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table


@page
@node SL_LOCAL_PROCESSOR_OUTAGE_IND
@subsubsection SL_LOCAL_PROCESSOR_OUTAGE_IND

@subsubheading Description

The local processor outage indication service primitive is originated by the SLS provider when it
detects a local processor outage condition internal to the SLS provider.

@subsubheading Format
@tpindex sl_loc_proc_out_ind_t

The local processor outage indication service primitive consists of on @msg{M_PROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_timestamp;
} sl_loc_proc_out_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The local processor outage indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_LOCAL_PROCESSOR_OUTAGE_IND}.

@item sl_timestamp
Indicates the time at which the detection of local processor outage occurred.  This is UNIX time from
epoch timestamp in milliseconds.

@end table

@subsubheading State

This primitive is only issued by the SLS provider in the @psta{LMI_ENABLED} management state and
active or blocked link state.

@subsubheading New State

The new state is @psta{SL_STATE_PROCESSOR_OUTAGE}.

@subsubheading Rules

The SLS provider observes the following rules when issuing the local processor outage indication
service primitive:

@itemize ---

@item
The primitive is only issued in the @psta{LMI_ENABLED} management state.

@item
SLS provider detection of local processor outage and SLS user detection of local processor outage
are independent conditions.

@item
The SLS provider will issue a @prim{SL_LOCAL_PROCESSOR_RECOVERED_IND} primitive when the
local processor outage condition is no longer in effect.

@end itemize

@subsubheading Response

This primitive does not require a response from the SLS user.


@page
@node SL_RESUME_REQ
@subsubsection SL_RESUME_REQ

@subsubheading Description

The resume request service primitive allows the SLS user to specify that a local processor outage
condition is no longer in effect.  That is, that the local processor has recovered.

@subsubheading Format
@tpindex sl_resume_req_t

The resume request service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message
block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_resume_req_t;
@end verbatim
@end display

@subsubheading Parameters

The resume request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_RESUME_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state and when the link is in
the @psta{SL_STATE_PROCESSOR_OUTAGE} state with a local processor outage condition asserted by
the SLS user with a previous @prim{SL_LOCAL_PROCESSOR_OUTAGE_REQ} primitive.

@subsubheading New State

The new state is @psta{SL_STATE_IN_SERVICE} provided that no other processor outage condition
is currently asserted.

@subsubheading Response

This primitive does not request a response from the SLS provider.

@itemize @minus

@item @b{Successful:}
When successful, the link moves to the @psta{SL_STATE_IN_SERVICE} state and the local
processor outage condition is removed.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider will negatively acknowledge the primitive using the
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state remains
unchanged.

@end itemize

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table


@page
@node SL_LOCAL_PROCESSOR_RECOVERED_IND
@subsubsection SL_LOCAL_PROCESSOR_RECOVERED_IND

@subsubheading Description

The local processor recovered indication service primitive is originated by the SLS provider when it
detects a remote processor recovery condition.

@subsubheading Format
@tpindex sl_loc_proc_recovered_ind_t

The local processor recovered indication service primitive consists of one @msg{M_PROTO} message
block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_timestamp;
} sl_loc_proc_recovered_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The local processor recovered indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_LOCAL_PROCESSOR_RECOVERED_IND}.

@item sl_timestamp
Indicates the time at which the detection of local processor recovery occurred.  This is UNIX time
from epoch timestamp in milliseconds.

@end table

@subsubheading State

This primitive is only issued by the SLS provider in the @psta{LMI_ENABLED} management state and
the link state of @psta{SL_STATE_PROCESSOR_OUTAGE} with local outage asserted by the SLS
provider.

@subsubheading New State

The new state is @psta{SL_STATE_IN_SERVICE} provided that no other processor outage condition
(SLS user local, or remote) exists.

@subsubheading Rules

The SLS provider observes the following rules when issuing a local processor recovered indication
service primitive:

@itemize ---

@item
The primitive is only issued in the @psta{LMI_ENABLED} management state.

@item
The SLS provider will only issue this primitive after it has issued a
@prim{SL_LOCAL_PROCESSOR_OUTAGE_IND} primitive and when the local processor outage condition
is no longer in effect.

@end itemize

@subsubheading Response

This primitive does not require a respnose from the SLS user, nevertheless, the SLS user will
typically attempt to continue on the link or restore it using restoration service primitives.


@page
@node SL_REMOTE_PROCESSOR_OUTAGE_IND
@subsubsection SL_REMOTE_PROCESSOR_OUTAGE_IND

@subsubheading Description

The remote processour outage indication service primitive is originated by the SLS provider when it
detects a remote processor outage condition.

@subsubheading Format
@tpindex sl_rem_proc_out_ind_t

The remove processor outage indication service primitive consists of one @msg{M_PROTO} message
block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_timestamp;
} sl_rem_proc_out_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The remove processor outage indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_REMOTE_PROCESSOR_OUTAGE_IND}.

@item sl_timestamp
Indicates the time at which the detection of remote processor outage occurred.  This is UNIX time from
epoch timestamp in milliseconds.

@end table

@subsubheading State

This primitive is only issued by the SLS provider in the @psta{LMI_ENABLED} management state and
active or blocked link state.

@subsubheading New State

The new state is @psta{SL_STATE_PROCESSOR_OUTAGE}.

@subsubheading Rules

The SLS provider observes the following rules when issuing the remote processor outage indication
service primitive:

@itemize ---

@item
The primitive is only issued in the @psta{LMI_ENABLED} management state.

@item
The SLS provider will issue a @prim{SL_REMOTE_PROCESSOR_RECOVERED_IND} primitive when the
remote processor outage condition is no longer in effect.

@end itemize

@subsubheading Response

This primitive does not require a response from the SLS user.


@page
@node SL_REMOTE_PROCESSOR_RECOVERED_IND
@subsubsection SL_REMOTE_PROCESSOR_RECOVERED_IND

@subsubheading Description

The remote processor recovered indication service primitive is originated by the SLS provider when
it detects a remote processor recovery condition.

@subsubheading Format
@tpindex sl_rem_proc_recovered_ind_t

The remote processor recovered indication service primitive consists of one @msg{M_PROTO} message
block, structured as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
    sl_ulong sl_timestamp;
} sl_rem_proc_recovered_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The remote processor recovered indication service primitive contains the following parameters:

@table @parm

@item sl_primitive
Indicates the service primitive type.  Always @prim{SL_REMOTE_PROCESSOR_RECOVERED_IND}.

@item sl_timestamp
Indicates the time at which the detection of remote processor recovery occurred.  This is UNIX time
from epoch timestamp in milliseconds.

@end table

@subsubheading State

This primitive is only issued by the SLS provider in the @psta{LMI_ENABLED} management state and
the link state of @psta{SL_STATE_PROCESSOR_OUTAGE} with remote process outage asserted.

@subsubheading New State

The new state is unchanged.

@subsubheading Rules

The SLS provider observes the following rules when issuing a remote processor recovered indication
service primitive:

@itemize ---

@item
The primitive is only issued in the @psta{LMI_ENABLED} management state.

@item
The SLS provider will only issue this primitive after it was issued a
@prim{SL_REMOTE_PROCESSOR_OUTAGE_IND} primitive when the remote processor outage condition
is no longer in effect.

@end itemize

@subsubheading Response

This primitive does not require a response from the SLS user, nevertheless, the SLS user will
typically attempt to continue on the link or restore it using restoration service primitives.


@page
@node SL_CONTINUE_REQ
@subsubsection SL_CONTINUE_REQ

@subsubheading Description

The continue request service primitive is originated by the SLS user to request that a link
previously in a remote processor outage condition, or a SLS provider detected local process outage
condition, be continued.  This action is normally performed where processor outage has not been of a
long duration and it is not necessary to fail or otherwise restore the signalling link.

@subsubheading Format
@tpindex sl_continue_req_t

The continue request service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message
block, formatted as follows:

@display
@verbatim
typedef struct {
    sl_long sl_primitive;
} sl_continue_req_t;
@end verbatim
@end display

@subsubheading Parameters

The continue request service primitive contains the following parameters:

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_CONTINUE_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state and valid in the
@psta{SL_STATE_PROCESSOR_OUTAGE} state where local (SLS provider detected) or remote processor
recovery has been indicated.

@subsubheading New State

The new state is @psta{SL_STATE_IN_SERVICE}, provided that there is no other processor outage
condition in effect.

@subsubheading Response

This primitive does not require receipt acknowledgement by the SLS provider.

@itemize @minus

@item @b{Successful:}
When successful, the primtiive does not require acknowledgement and the link moves to the
@psta{SL_STATE_IN_SERVICE} state.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider negatively acknowledges the primitive using an
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state reamins
unchanged.

@end itemize

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table



@page
@node Link Option Management Service Primitives
@subsection Link Option Management Service Primitives

The link option management service primitives provide another mechanism for options management
separate from the local management interface (i.e. the @prim{LMI_OPTMGMT_REQ} and
@prim{LMI_OPTMGMT_ACK} primitives).  These service primitives are not currently supported by any
SLS provider and their use is @emph{deprecated}.

These service primitives implement the link option management service (@pxref{Link Option Management
Service}).

@menu
* SL_OPTMGMT_REQ::
* SL_OPTMGMT_ACK::
@end menu

@node SL_OPTMGMT_REQ
@subsubsection SL_OPTMGMT_REQ

@subsubheading Description

This SLS user originated primitive requests that the SLS provider options be managed.

@subsubheading Format
@tpindex lmi_optmgmt_req_t

The link option management request service primitive consists of one @msg{M_PROTO} or
@msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_opt_length;
    lmi_ulong lmi_opt_offset;
    lmi_ulong lmi_mgmt_flags;
} lmi_optmgmt_req_t;
@end verbatim
@end display

@subsubheading Parameters

The link option management request service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the service primitive type.  Always @prim{SL_OPTMGMT_REQ}.

@item lmi_opt_length
Specifies the length of the options.

@item lmi_opt_offset
Specifies the offset, from the beginning of the @msg{M_PROTO} message block, of the start of the options.

@item lmi_mgmt_flags
Specifies the management flags which determine what operation the LMS provider is expected to
perform on the specified options.  This field can assume one of the following values:

@table @pval

@item LMI_NEGOTIATE
Negotiate the specified value of each specified option and return the negotiated value.

@item LMI_CHECK
Check the validity of the specified value of each specified option and return the result.  Do not
alter the current value assumed by the LMS provider.

@item LMI_DEFAULT
Return the default value for the specified options (or all options).  Do not alter the current value
assumed by the LMS provider.

@item LMI_CURRENT
Return the current value for the specified options (or all options).  Do not alter the current value
assumed by the LMS provider.

@end table

@end table

@subsubheading State

This primitive is valid in any state where a local acknowledgement is not pending.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

@subsubheading Response

The link option management request service primitive requires the LMS provider to acknowledge receipt of
the primitive as follows:

@itemize @minus

@item @b{Successful}:
Upon success, the LMS provider acknowledges receipt of the service primitive and successful
completion of the link options management service with an @prim{SL_OPTMGMT_ACK} primitive containing the
link options management result.  The state remains unchanged.

@item @b{Unsuccessful (non-fatal errors)}:
Upon failure, the LMS provider acknowledges receipt of the service primitive and failure to
complete the link options management service with an @prim{LMI_ERROR_ACK} primitive containing the error.
The state remains unchanged.

@end itemize

@subsubheading Reason for Failure

@b{Non-Fatal Errors}:  applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node SL_OPTMGMT_ACK
@subsubsection SL_OPTMGMT_ACK

@subsubheading Description

This LMS provider originated primitive is issued by the LMS provider upon successful completion of
the link options management service.  It indicates the outcome of the link options management operation
requested by the LMS user in a @prim{SL_OPTMGMT_REQ} primitive.

@subsubheading Format
@tpindex lmi_optmgmt_ack_t

The link option management acknowledgement service primitive consists of one @msg{M_PCPROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_opt_length;
    lmi_ulong lmi_opt_offset;
    lmi_ulong lmi_mgmt_flags;
} lmi_optmgmt_ack_t;
@end verbatim
@end display

@subsubheading Parameters

The link option management acknowledgement service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{SL_OPTMGMT_ACK}.

@item lmi_opt_length
Indicates the length of the returned options.

@item lmi_opt_offset
Indicates the offset of the returned options from the start of the @msg{M_PCPROTO} message block.

@item lmi_mgmt_flags
Indicates the returned management flags.  These flags indicate the overall success of the link options
management service.  This field can assume one of the following values:

@table @pval

@item LMI_SUCCESS
The LMS provider succeeded in negotiating or returning all of the options specified by the LMS
user in the @prim{LMI_OPTMGMT_REQ} primitive.

@item LMI_FAILURE
The LMS provider failed to negotiate one or more of the options specified by the LMS user.

@item LMI_PARTSUCCESS
The LMS provider negotiated a value of lower quality for one or more of the options specified by
the LMS user.

@item LMI_READONLY
The LMS provider failed to negotiate one ore more of the options specified by the LMS user because
the option is treated as read-only by the LMS provider.

@item LMI_NOTSUPPORT
The LMS provider failed to recognize one or more of the options specified by the LMS user.

@end table

@end table

@subsubheading State

This primitive is issued by the LMS provider in direct response to an @prim{SL_OPTMGMT_REQ} primitive.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

The LMS provider follows the following rules when processing link option management service requests:

@itemize ---

@item
When the @parm{lmi_mgmt_flags} field in the @prim{SL_OPTMGMT_REQ} primitive is set to @pval{LMI_NEGOTIATE},
the LMS provider will attempt to negotiate a value for each of the options specified in the
request.

@item
When the flags are @pval{LMI_DEFAULT}, the LMS provider will return the default values of the specified
options, or the default values of all options known to the LMS provider if no options were
specified.

@item
When the flags are @pval{LMI_CURRENT}, the LMS provider will return the current values of the specified
options, or all options.

@item
When the flags are @pval{LMI_CHECK}, the LMS provider will attempt to negotiate a value for each of the
options specified in the request and return the resulg of the negotiation, but will not affect the
current value of the option.

@end itemize



@page
@node Event Notification Service Primitives
@subsection Event Notification Service Primitives

The event notification service primitives provide another mechanism for event notification separate
from the local management interface (i.e. the @prim{LMI_EVENT_IND} primitive).  These service
primitives are not currently supported by any SLS provider and their use is @emph{deprecated}.

These service primitives implement the event notification service (@pxref{Event Notification Service}).

@menu
* SL_NOTIFY_REQ::
* SL_NOTIFY_IND::
@end menu

@node SL_NOTIFY_REQ
@subsubsection SL_NOTIFY_REQ

@subsubheading Description

This SLS user originated primitives requests that the SLS provider register the SLS user for various
events.

@subsubheading Format

Not documented.

@subsubheading Parameters

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_NOTIFY_REQ}.

@end table

@subsubheading State

Any state.

@subsubheading New State

Unchanged.

@subsubheading Response

This primitive does not require receipt acknolwedgement from the SLS provider.

@itemize @minus

@item @b{Successful:}
When successful, the events are registered and no acknowledgement is required.
The state remains unchanged.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SLS provider generates a negative acknowledgement using a
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.
The state remains unchanged.

@end itemize

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@subsubheading Notes

This primitive is @emph{deprecated} and has been replaced by the local management inteface event
reporting service discussed in @ref{Event Reporting Service}.


@page
@node SL_NOTIFY_IND
@subsubsection SL_NOTIFY_IND

@subsubheading Description

This SLS provider originated primitive indicates that an event for which the SLS provider has
registered has occurred.

@subsubheading Format

Not documented.

@subsubheading Parameters

@table @parm

@item sl_primitive
Specifies the service primitive type.  Always @prim{SL_NOTIFY_IND}.

@end table

@subsubheading State

Any state.

@subsubheading New State

Unchanged.

@subsubheading Rules

The SLS provider observes the following rules when issuing the event notification indication service
primtiive:

@itemize ---

@item
This primitive is only issued by the SLS provider for event for which the SLS user has explicitly
registered with the @prim{SL_NOTIFY_REQ} primitive.

@item
Specific events are provider-specific.

@end itemize

@subsubheading Notes

This primitive is @emph{deprecated} and has been replaced by the local management inteface event
reporting service discussed in @ref{Event Reporting Service}.



@node Diagnostics Requirements
@chapter Diagnostics Requirements

Two error handling facilities should be provided to the SLS user: one to handle non-fatal errors,
and the other to handle fatal errors.

@section Non-Fatal Error Handling Facility

These are errors that do not change the state of the SLS interface as seen by the SLS user and
provide the user with the option of reissuing the SL primitive with the corrected options
specification.  The non-fatal error handling is provided only to those primitives that require
acknowledgements, and uses the @prim{LMI_ERROR_ACK} to report these errors.  These errors retain the
state of the SLS interface the same as it was before the SL provider received the primitive that
was in error.  Syntax errors and rule violations are reported via the non-fatal error handling
facility.

@section Fatal Error Handling Facility

These errors are issued by the SL provider when it detects errors that are not correctable by the
SL user, or if it is unable to report a correctible error to the SLS user.  Fatal errors are
indicated via the STREAMS message type @code{M_ERROR} with the UNIX system error @code{EPROTO}.  The
@code{M_ERROR} STREAMS message type will result in the failure of all the UNIX system calls on the
stream.  The SLS user can recover from a fatal error by having all the processes close the files
associated with the stream, and then reopening them for processing.

@ignore
@node Addendum for ITU-T Q.703 Conformance
@unnumbered Addendum for ITU-T Q.703 Conformance

@node Addendum for ANSI T1.111.3 Conformance
@unnumbered Addendum for ANSI T1.111.3 Conformance

@node Addendum for ETSI ETS 300 008-1 Conformance
@unnumbered Addendum for ETSI ETS 300 008-1 Conformance

@node Addendum for RFC 4165 Conformance
@unnumbered Addendum for RFC 4165 Conformance

@node Mapping of SLI Primitives to ITU-T Q.703
@appendix Mapping of SLI Primitives to ITU-T Q.703

@node Mapping of SLI Primitives to ANSI T1.111.3
@appendix Mapping of SLI Primitives to ANSI T1.111.3

@node State/Event Tables
@appendix State/Event Tables

@node Primitive Precedence Tables
@appendix Primitive Precedence Tables
@end ignore

@node LMI Header File Listing
@appendix LMI Header File Listing

@noindent
@smallformat
@verbatiminclude lmi.h
@end smallformat

@node SLI Header File Listing
@appendix SLI Header File Listing

@noindent
@smallformat
@verbatiminclude sli.h
@end smallformat

@node License
@unnumbered License

@menu
* GNU Free Documentation License::
@end menu

@include texi/fdl.texi

@node Glossary
@unnumbered Glossary

@table @emph

@item Signalling Data Link Service Data Unit

A grouping of SDL user data whose boundaries are preserved from one end of the signalling data link
connection to the other.

@item Data transfer

The phase in connection and connectionless modes that supports the transfer of data between to
signalling data link users.

@item SDL provider

The signalling data link layer protocol that provides the services of the signalling data link
interface.

@item SDL user

The user-level application or user-level or kernel-level protocol that accesses the services of the
signalling data link layer.

@item Local management

The phase in connection and connectionless modes in which a SDL user initializes a stream and
attaches a PPA address to the stream.  Primitives in this phase generate local operations only.

@item PPA

The point at which a system attaches itself to a physical communications medium.

@item PPA identifier

An identifier of a particular physical medium over which communication transpires.
@end table

@node Acronyms
@unnumbered Acronyms

@multitable {LMS Provider}{International Telecommunication Union - Telecom Sector}
@item ITU-T @tab International Telecommunications Union - Telecom Sector
@item LMS Provider @tab A provider of Local Management Services
@item LMS @tab Local Management Service
@item LMS User @tab A user of Local Management Services
@item LM @tab Local Management
@item PPA @tab Physical Point of Attachment
@item SDLI @tab Signalling Data Link Interface
@item SDL SDU @tab Signalling Data Link Service Data Unit
@item SDLS @tab Signalling Data Link Service
@item SDL @tab Signalling Data Link
@item SDTI @tab Signalling Data Terminal Interface
@item SDTS @tab Signalling Data Terminal Service
@item SDT @tab Signalling Data Terminal
@item SLI @tab Signalling Link Interface
@item SLS @tab Signalling Link Service
@item SL @tab Signalling Link
@item SS7 @tab Signalling System No. 7
@end multitable

@node References
@unnumbered References

@multitable {000}{Geoffrey Gerrien, ``CDI - Application Program Interface Guide,'' Gcom, Inc., March 1999.}
@item [1] @anchor{Q.700} @tab @uref{http://www.itu.int/rec/T-REC-Q.700/,ITU-T Recommendation Q.700},
@cite{Introduction to CCITT Signalling System No. 7},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@item [2] @anchor{Q.701} @tab @uref{http://www.itu.int/rec/T-REC-Q.701/,ITU-T Recommendation Q.701},
@cite{Functional Description of the Message Transfer Part (MTP) of Signalling System No. 7},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@item [3] @anchor{Q.702} @tab @uref{http://www.itu.int/rec/T-REC-Q.702/,ITU-T Recommendation Q.702},
@cite{Signalling System No. 7---Signalling Data Link},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@item [4] @anchor{Q.703} @tab @uref{http://www.itu.int/rec/T-REC-Q.703/,ITU-T Recommendation Q.703},
@cite{Signalling System No. 7---Signalling Link},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@item [5] @anchor{Q.704} @tab @uref{http://www.itu.int/rec/T-REC-Q.704/,ITU-T Recommendation Q.704},
@cite{Message Transfer Part---Signalling Network Functions and Messages},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@item [6] @anchor{CDIAPI} @tab
Geoffrey Gerrietts; Dave Grothe, Mikel Matthews, Dave Healy,
@cite{CDI---Application Program Interface Guide},
March 1999,
(Savoy, IL),
GCOM, Inc.
@item [7] @anchor{Q.771} @tab @uref{http://www.itu.int/rec/T-REC-Q.771/,ITU-T Recommendation Q.771},
@cite{Signalling System No. 7---Functional Description of Transaction Capabilities},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@end multitable

@ifnotplaintext
@c skip indexes for plain text (regex search works better)
@c @iftex
@c @node Indices
@c @unnumbered Indices
@c @end iftex

@c @ifnottex
@c @c concatenate indices for html and info
@node Index
@unnumbered Index
@printindex cp
@c @end ifnottex

@c @iftex
@c @menu
@c * Concept Index::
@c * Protocol State Index::
@c * Primitive Index::
@c * Primitive Structure and Type Index::
@c * Primitive Structure Field Index::
@c * Primitive Values Index::
@c * Primitive Error Values Index::
@c * Input-Output Control Index::
@c * Manual Page Index::
@c @end menu
@c 
@c @node Concept Index
@c @section Concept Index
@c @printindex cp
@c 
@c @page
@c @node Protocol State Index
@c @section Protocol State Index
@c @printindex st
@c 
@c @page
@c @node Primitive Index
@c @section Primitive Index
@c @printindex pr
@c 
@c @page
@c @node Primitive Structure and Type Index
@c @section Primitive Structure and Type Index
@c @printindex tp
@c 
@c @page
@c @node Primitive Structure Field Index
@c @section Primitive Structure Field Index
@c @printindex vr
@c 
@c @page
@c @node Primitive Values Index
@c @section Primitive Values Index
@c @printindex pv
@c 
@c @page
@c @node Primitive Error Values Index
@c @section Primitive Error Values Index
@c @printindex pe
@c 
@c @page
@c @node Input-Output Control Index
@c @section Input-Output Control Index
@c @printindex ct
@c 
@c @page
@c @node Manual Page Index
@c @section Manual Page Index
@c @printindex mp
@c @end iftex
@end ifnotplaintext

@page
@shortcontents
@page
@contents
@bye
