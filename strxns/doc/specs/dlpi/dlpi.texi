% -*- texinfo -*- vim: ft=texinfo
% vim: ft=texinfo nosmartindent nocindent noautoindent tw=120
% =========================================================================
%
% @(#) $Id: dlpi.texi,v 0.9.2.2 2005/06/19 10:57:00 brian Exp $
%
% =========================================================================
%
% Copyright (C) 2001-2005  OpenSS7 Corporation <www.openss7.com>
%
% All Rights Reserved.
%
% Permission is granted to make and distribute verbatim copies of this
% manual provided the copyright notice and this permission notice are
% preserved on all copies.
%
% Permission is granted to copy and distribute modified versions of this
% manual under the conditions for verbatim copying, provided that the
% entire resulting derived work is distributed under the terms of a
% permission notice identical to this one
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any successor
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified $Date: 2005/06/19 10:57:00 $ by $Author: brian $
%
% =========================================================================
\input texinfo @c -*- texinfo -*-
@c vim: ft=texinfo nosmartindent nocindent noautoindent tw=120
@c %**start of header
@setfilename dlpi.info
@settitle Data Link Provider Interface Specification
@c %**end of header

@dircategory OpenGroup
@direntry
* DLPI: (dlpi).                 Data Link Provider Interface Specification
@end direntry

@include texi/args.texi

@ifinfo
This file documents the X/Open Data Link Provider Interface.

This is Edition @value{PACKAGE_VERSION}, last updated @value{PACKAGE_DATE}, for
@value{PACKAGE_TITLE} version @value{PACKAGE_VERSION} release
@value{PACKAGE_RELEASE} published by @uref{http://www.openss7.com/,OpenSS7
Corporation}.  This specification was originally published by UNIX International
OSI Work Group in Revision: 2.0.0 (1992/08/17).

Copyright @copyright{} 2001-2005  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*
Copyright @copyright{} 1992       UNIX International, Inc.

All Rights Reserved.

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@ignore
Permission is granted to process this file through Tex and print the results,
provided the printed document carries copying permission notice identical to
this one except for the removal of this paragraph (this paragraph not being
relevant to the printed manual).

@end ignore
Permission to use, copy, modify, and distribute this documentation for any
purpose and without fee is hereby granted, provided that the above copyright
notice appears in all copies and that both that copyright notice and this
permission notice appear in supporting documentation, and that the name UNIX
International not be used in advertising or publicity pertaining to distribution
of the software without specific, written prior permission.  UNIX International
makes no representations about the suitability of this documentation for any
purpose.  It is provided ``as is'' without express or implied warranty.

Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided the entire resulting
derived work is distributed under the terms of a permission notice identical to
this one.

Permission is granted to copy and distribute translations of this manual into
another language, under the above conditions for modified versions.
@end ifinfo

@include texi/args.texi

@shorttitlepage Data Link Provider Interface Specification
@titlepage
@titlefont{Data Link Provider Interface}
@sp 0.5
@title Specification
@subtitle UNIX International
@subtitle OSI Work Group
@subtitle Revision: 2.0.0
@subtitle August 17, 1992
@sp 0.2
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}
@subtitle Updated @value{PACKAGE_DATE}
@sp 0.2
@subtitle Distributed with Package @value{PACKAGE}-@value{VERSION}
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll

@subsubheading Published by:

@center UNIX International
@center Waterview Corporate Center
@center 20 Waterview Boulevard
@center Parsippany, NJ 07054
@sp 1
@center for further information, contact:
@center Vice President of Marketing
@sp 1
@center Phone: +1 201-263-8400
@center Fax: +1 201-263-8401
@sp 1

@ignore
@subsubheading International Offices:

@multitable @columnfractions .33 .33 .34
@item

@noindent
UNIX International @*
Asian/Pacific Office @*
Shinei Bldg. 1F @*
Kameido @*
Koto-ku, Tokyo 136 @*
Japan

@noindent
Phone: (81) 3-3636-1122 @*
Fax: (81) 3-3636-1121

@tab

@noindent
UNIX International @*
Australian Office @*
22/74 - 76 Monarch St. @*
Cremorne, NSW 2090 @*
Australia

@noindent
Phone: (61) 2-953-7838 @*
Fax: (61) 2 953-3542

@tab

@noindent
UNIX International @*
Pacific Basin Office @*
Cintech II @*
75 Science Park Drive @*
Singapore Science Park @*
Singapore 0511 @*
Singapore

@noindent
Phone: (32) 2-672-3700 @*
Fax: (32) 2-672-4415

@end multitable

@multitable @columnfractions .5 .5
@item

@noindent
UNIX International @*
European Office @*
25, Avenue de Beaulieu @*
1160 Brussels @*
Belgium

@noindent
Phone: (65) 776-0313 @*
Fax: (65) 776-0421

@tab

@noindent
@ 

@end multitable
@end ignore

@noindent
Copyright @copyright{} 2001-2005  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*
Copyright @copyright{} 1992       UNIX International, Inc. @*

@noindent
All Rights Reserved. @*

@noindent
Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@noindent
Permission to use, copy, modify, and distribute this documentation for any
purpose and without fee is hereby granted, provided that the above copyright
notice appears in all copies and that both that copyright notice and this
permission notice appear in supporting documentation, and that the name UNIX
International not be used in advertising or publicity pertaining to distribution
of the software without specific, written prior permission.  UNIX International
makes no representations about the suitability of this documentation for any
purpose.  It is provided ``as is'' without express or implied warranty.

@noindent
@b{UNIX INTERNATIONAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
DOCUMENTATION, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
IN NO EVENT SHALL UNIX INTERNATIONAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
DOCUMENTATION.}

@subsubheading Notice:

@noindent
This document is based on the UNIX System Laboratories Data Link Provider
Interface (NPI) specification which was used with permission by the UNIX
International OSI Work Group (UI OSIWG).  Participation inthe UI OSIWG is open
to UNIX International members and other interested parties.  For further
information contact UNIX International at the addresses above.

@noindent
UNIX International is making this documentation available as a reference point
for the industry.  While UNIX International believes that these interfaces are
well defined in this release of the document, minor changes may be made prior to
products conforming to the interfaces being made available from UNIX System
Laboratories or UNIX International members.

@subsubheading Trademarks:

@noindent
UNIX(R) is a registered trademark of UNIX System Laboratories in the United
States and other countries.
X/Open(TM) is a trademark of the X/Open Company Ltd. in the UK and other
countries.
OpenSS7(TM) is a trademark of OpenSS7 Corporation in the United States and other
countries.

@page
@vskip 0pt plus 1filll

@subsubheading Published by:

@sp 1

@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
Copyright @copyright{} 2001-2005  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*
All Rights Reserved.

@noindent
Unauthorized distribution or duplication is prohibited.

@noindent
This software and related documentation is protected by copyright and
distributed under licenses restricting its use, copying, distribution and
decompilation.  No part of this software or related documentation may be
reproduced in any form by any means without the prior written authorization of
the copyright holder, and licensors, if any.

@noindent
The recipient of this document, by its retention and use, warrants that the
recipient will protect this information and keep it confidential, and will not
disclose the information contained in this document without the written
permission of its owner.

@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} reserves the right to revise
this software and documentation for any reason, including but not limited to,
conformity with standards promulgated by various agencies, utilization of
advances in the state of the technical arts, or the reflection of changes in the
design of any techniques, or procedures embodied, described, or referred to
herein.  @uref{http://www.openss7.com/,OpenSS7 Corporation} is under no
obligation to provide any feature listed herein.

@vskip 0pt
@end titlepage
@iftex
@headings off
@everyheading @thistitle @| @thisfile @| @thischaptername
@evenheading @thischapter @| @| @thisfile
@oddheading @thistitle @| @| @thischaptername
@everyfooting Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE} @| @value{PACKAGE_DATE} @| @thispage
@evenfooting @thispage @| @| Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}
@oddfooting @value{PACKAGE_DATE} @| @| @thispage
@end iftex
@page

@c Define an index of primitives
@defindex pr
@c Define an index of primitive values
@defindex pv
@c Define an index of protocol states
@defindex st

@syncodeindex pr cp
@syncodeindex pv cp
@syncodeindex tp cp
@syncodeindex vr cp

@macro tabfig {image, number, caption}

@iftex
@float Table,Table \number\
@image{\image\}
@caption{\caption\}
@end float
@end iftex
@ifnottex
@image{\image\} @anchor{Table \number\}@center @emph{Table \number\.@:  \caption\}
@end ifnottex

@end macro

@macro tabfigsized {image, number, caption, size}

@iftex
@float Table,Table \number\
@image{\image\,\size\}
@caption{\caption\}
@end float
@end iftex
@ifnottex
@image{\image\,\size\} @anchor{Table \number\}@center @emph{Table \number\.@:  \caption\}
@end ifnottex

@end macro

@macro tabref {number}
@iftex
@emph{@ref{Table \number\}}
@end iftex
@ifnottex
@emph{@ref{Table \number\}}
@end ifnottex
@end macro

@macro figure {image, number, caption}

@iftex
@c @cartouche
@float Figure,Figure \number\
@image{\image\}
@caption{\caption\}
@end float
@c @end cartouche
@end iftex
@ifnottex
@image{\image\} @anchor{Figure \number\}@center @emph{Figure \number\.@:  \caption\}
@set fignum \number\
@end ifnottex

@end macro

@macro figuresized {image, number, caption, size}

@iftex
@c @cartouche
@float Figure,Figure \number\
@image{\image\,\size\}
@caption{\caption\}
@end float
@c @end cartouche
@end iftex
@ifnottex
@image{\image\,\size\} @anchor{Figure \number\}@center @emph{Figure \number\.@:  \caption\}
@set fignum \number\
@end ifnottex

@end macro

@macro figref {number}
@iftex
@emph{@ref{Figure \number\}}
@end iftex
@ifnottex
@emph{@ref{Figure \number\}}
@end ifnottex
@end macro

@ifnottex
@node Top
@top Data Link Provider Interface
@end ifnottex

@menu
* Introduction::
* Model of the Data Link Layer::
* DLPI Services::
* DLPI Primitives::
* Quality of Data Link Service::
* References::
* Optional Primitives to perform Essential Management Functions::
* Allowable Sequence of DLPI Primitives::
* Precedence of DLPI Primitives::
* Glossary of DLPI Terms and Acronyms::
* Guidelines for Protocol Independent DLS Users::
* Required Information for DLS Provider-Specific Addenda::
* DLPI Header File::
* Index::
@end menu


@node Introduction
@chapter Introduction

This document specifies a STREAMS kernel-level instantiation of the ISO Data
Link Service DefinitionDIS 8886[1] and Logical Link Control DIS 8802/2 (LLC)[2].
Where the two standards do not conform, DIS 8886 prevails.

The Data Link Provider Interface (DLPI) enables a data link service user to
access and use any of a varietyof conforming data link service providers without
special knowledge of the provider's protocol.  Specifically, the interface is
intended to support X.25 LAPB, BX.25 level 2, SDLC, ISDN LAPD,Ethernet(TM),
CSMA/CD, FDDI, token ring, token bus, and Bisync.  Among the expected data link
service users are implementations of the OSI network layer and SNA path control.

The interface specifies access to data link service providers, and does not
define a specific protocolimplementation.  Thus, issues of network management,
protocol performance, and performance analysis tools are beyond the scope of
this document and should be addressed by specific implementations of a datalink
provider.  However, accompanying each provider implementation should be
information that describes the protocol-specific behavior of that provider.
Currently, there are plans to come up with a setof implementor's
agreements/guidelines for common data link providers.  These agreements will
address issues such as DLSAP address space, subsequent addresses, ppa access and
control, QOS, supportedservices etc.

This specification assumes the reader is familiar with OSI Reference Model[4]
terminology, OSI Data LinkServices, and STREAMS.

@section Document Organization

This specification is organized as follows:

* @ref{Model of the Data Link Layer,,Model of the Data Link Layer},
presents background on the structure of the data link layer of the OSI Reference
Model, and explains the intended architecture in the STREAMS environment.
Datalink addressing concepts are also presented.

* @ref{DLPI Services,,DLPI Services},
presents an overview of the services provided by DLPI.

* @ref{DLPI Primitives,,DLPI Primitives},
describes the detailed syntax and semantics of each DLPI primitive that crosses
the data link interface.

* @ref{Quality of Data Link Service,,Quality of Data Link Service},
describes the quality-of-service parameters supported by DLPI and the rules for
negotiating/selecting the values of those parameters.

* @ref{Optional Primitives to perform Essential Management Functions,,Optional Primitives to perform Essential Management Functions},
optional primitives to perform certain essential management functions.

* @ref{Allowable Sequence of DLPI Primitives,,Allowable Sequence of DLPI Primitives},
describes the allowable sequence of DLPI primitives that may be issued across
the interface.

* @ref{Precedence of DLPI Primitives,,Precedence of DLPI Primitives},
presents a summary of the precedence of DLPI primitivesas they are queued by the
DLS provider and/or DLS user.

* @ref{Glossary of DLPI Terms and Acronyms,,Glossary of DLPI Terms and Acronyms},
presents a Glossary of DLPI Terms and Acronyms.

* @ref{Guidelines for Protocol Independent DLS Users,,Guidelines for Protocol Independent DLS Users},
summarizes guidelines a DLS user implementation must follow to be fully
protocol-independent.

* @ref{Required Information for DLS Provider-Specific Addenda,,Required Information for DLS Provider-Specific Addenda},
presents the information that should be documented for each DLS provider
implementation.

* @ref{DLPI Header File,,DLPI Header File},
presents the header file containing DLPI structure and constantdefinitions
needed by a DLS user or provider implemented to use the interface.

@node Model of the Data Link Layer
@chapter Model of the Data Link Layer

@menu
* Model of the Service Interface::
* Modes of Communication::
* DLPI Addressing::
* The Connection Management Stream::
@end menu

The data link layer (layer 2 in the OSI Reference Model) is responsible for the
transmission and error-free delivery of bits of information over a physical
communications medium.

The model of the data link layer is presented here to describe concepts that are
used throughout the specification of DLPI.  It is described in terms of an
interface architecture, as well as addressing concepts needed to identify
different components of that architecture.  The description of the model
assumes familiarity with the OSI Reference Model.

@node Model of the Service Interface
@section Model of the Service Interface

Each layer of the OSI Reference Model has two standards:

@itemize @bullet
@item one that defines the services provided by the layer, and
@item one that defines the protocol through which layer services are provided.
@end itemize

DLPI is an implementation of the first type of standard.  It specifies an
interface to the services of the datalink layer.  The following figure depicts
the abstract view of DLPI.

@figuresized{dlpi_fig1,1,Abstract View of DLPI,4in}

The data link interface is the boundary between the network and data link layers
of the OSI Reference Model.  The network layer entity is the user of the services
of the data link interface (DLS user), and the data link layer entity is the
provider of those services (DLS provider).  This interface consists of a set
ofprimitives that provide access to the data link layer services, plus the rules
for using those primitives (state transition rules).  A data link interface
service primitive might request a particular service or indicate apending event.

To provide uniformity among the various UNIX system networking products, an
effort is underway todevelop service interfaces that map to the OSI Reference
Model.  A set of kernel-level interfaces, based on the STREAMS development
environment, constitute a major portion of this effort.  The service
primitivesthat make up these interfaces are defined as STREAMS messages that are
transferred between the user andprovider of the service.  DLPI is one such
kernel-level interface, and is targeted for STREAMS protocol modules that either
use or provide data link services.  In addition, user programs that wish to
access a STREAMS-based data link provider directly may do so using the putmsg(2)
and getmsg(2) system calls.

Referring to the abstract view of DLPI (@figref{1}), the DLS provider is
configured as a STREAMS driver, and the DLS user accesses the provider using
open(2) to establish a stream to the DLS provider.  Thestream acts as a
communication endpoint between a DLS user and the DLS provider.  After the stream
is created, the DLS user and DLS provider communicate via the messages presented
later in this specification.

DLPI is intended to free data link users from specific knowledge of the
characteristics of the data linkprovider.  Specifically, the definition of DLPI
hopes to achieve the goal of allowing a DLS user to be implemented independent
of a specific communications medium.  Any data link provider (supporting
anycommunications medium) that conforms to the DLPI specification may be
substituted beneath the DLS user to provide the data link services.  Support of a
new DLS provider should not require any changes tothe implementation of the DLS
user.

@node Modes of Communication
@section Modes of Communication

@menu
* Connection-mode Service (1)::
* Connectionless-mode Service::
* Acknowledged Connectionless-mode Service::
@end menu

The data link provider interface supports three modes of communication:
connection, connectionless andacknowledged connectionless.  The connection mode
is circuit-oriented and enables data to be transferred over a pre-established
connection in a sequenced manner.  Data may be lost or corrupted in this
servicemode, however, due to provider-initiated resynchronization or connection
aborts.

The connectionless mode is message-oriented and supports data transfer in
self-contained units with nological relationship required between units.  Because
there is no acknowledgement of each data unit transmission, this service mode
can be unreliable in the most general case.  However, a specific DLSprovider can
provide assurance that messages will not be lost, duplicated, or reordered.

The acknowledged connectionless mode provides the means by which a data link
user can send data andrequest the return of data at the same time.  Although the
exchange service is connectionless, in-sequence delivery is guaranteed for data
sent by the initiating station.  The data unit transfer is point-to-point.

@node Connection-mode Service (1)
@subsection Connection-mode Service
The connection-mode service is characterized by four phases of communication:
local management,connection establishment, data transfer, and connection
release.

@subsubsection Local Management
This phase enables a DLS user to initialize a stream for use in communication
and establish an identitywith the DLS provider.

@subsubsection Connection Establishment
This phase enables two DLS users to establish a data link connection between
them to exchange data.  Oneuser (the calling DLS user) initiates the connection
establishment procedures, while another user (the called DLS user) waits for
incoming connect requests.  The called DLS user is identified by an
addressassociated with its stream (as will be discussed shortly).

A called DLS user may either accept or deny a request for a data link
connection.  If the request isaccepted, a connection is established between the
DLS users and they enter the data transfer phase.  For both the calling and
called DLS users, only one connection may be established per stream.  Thus,
thestream is the communication endpoint for a data link connection.  The called
DLS user may choose to accept a connection on the stream where it received the
connectrequest, or it may open a new stream to the DLS provider and accept the
connection on this new, responding stream.  By accepting the connection on a
separate stream, the initial stream can be designatedas a listening stream
through which all connect requests will be processed.  As each request arrives, a
new stream (communication endpoint) can be opened to handle the connection,
enabling subsequent requests tobe queued on a single stream until they can be
processed.

@subsubsection Data Transfer
In this phase, the DLS users are considered peers and may exchange data
simultaneously in both directionsover an established data link connection.
Either DLS user may send data to its peer DLS user at any time.  Data sent by a
DLS user is guaranteed to be delivered to the remote user in the order in which
it was sent.

@subsubsection Connection Release
This phase enables either the DLS user, or the DLS provider, to break an
established connection.  Therelease procedure is considered abortive, so any data
that has not reached the destination user when the connection is released may be
discarded by the DLS provider.

@node Connectionless-mode Service
@subsection Connectionless-mode Service
The connectionless mode service does not use the connection establishment and
release phases of theconnection-mode service.  The local management phase is
still required to initialize a stream.  Once initialized, however, the
connectionless data transfer phase is immediately entered.  Because there is
noestablished connection, however, the connectionless data transfer phase
requires the DLS user to identify the destination of each data unit to be
transferred.  The destination DLS user is identified by the addressassociated
with that user (as will be discussed shortly).

Connectionless data transfer does not guarantee that data units will be
delivered to the destination user inthe order in which they were sent.
Furthermore, it does not guarantee that a given data unit will reach the
destination DLS user, although a given DLS provider may provide assurance that
data will not be lost.

@node Acknowledged Connectionless-mode Service
@subsection Acknowledged Connectionless-mode Service
The acknowledged connectionless mode service also does not use the connection
establishment andrelease phases of the connection-mode service.  The local
management phase is still required to initialize a stream.  Once initialized, the
acknowledged connectionless data transfer phase is immediately entered.

Acknowledged connectionless data transfer guarantees that data units will be
delivered to the destinationuser in the order in which they were sent.  A data
link user entity can send a data unit to the destination DLS User, request a
previously prepared data unit from the destination DLS User, or exchange data
units.

@node DLPI Addressing
@section DLPI Addressing

@menu
* Physical Attachment Identification::
* Data Link User Identification::
@end menu

Each user of DLPI must establish an identity to communicate with other data link
users.  This identityconsists of two pieces.  First, the DLS user must somehow
identify the physical medium over which it will communicate.  This is
particularly evident on systems that are attached to multiple physical
media.Second, the DLS user must register itself with the DLS provider so that
the provider can deliver protocol data units destined for that user.  The
following figure illustrates the components of this identificationapproach,
which are explained below.

@figuresized{dlpi_fig2,2,Data Link Addressing Components,4in}

@node Physical Attachment Identification
@subsection Physical Attachment Identification

The physical point of attachment (PPA in @figref{2}) is the point at which a
system attaches itself to aphysical communications medium.  All communication on
that physical medium funnels through the PPA.  On systems where a DLS provider
supports more than one physical medium, the DLS user must identifywhich medium
it will communicate through.  A PPA is identified by a unique PPA identifier .
For mediathat support physical layer multiplexing of multiple channels over a
single physical medium (such as the B and D channels of ISDN), the PPA
identifier must identify the specific channel over which communicationwill
occur.

Two styles of DLS provider are defined by DLPI, distinguished by the way they
enable a DLS user tochoose a particular PPA.  The style 1 provider assigns a PPA
based on the major/minor device the DLSuser opened.  One possible implementation
of a style 1 driver would reserve a major device for each PPAthe data link
driver would support.  This would allow the STREAMS clone open feature to be used
for eachPPA configured.  This style of provider is appropriate when few PPAs will
be supported.

If the number of PPAs a DLS provider will support is large, a style 2 provider
implementation is moresuitable.  The style 2 provider requires a DLS user to
explicitly identify the desired PPA using a special attach service primitive.
For a style 2 driver, the open(2) creates a stream between the DLS user and
DLSprovider, and the attach primitive then associates a particular PPA with that
stream.  The format of thePPA identifier is specific to the DLS provider, and
should be described in the provider-specific addendum documentation.

DLPI provides a mechanism to get and/or modify the physical address.  The
primitives to handle thesefunctions are described in Appendix A.  The physical
address value can be modified in a post-attached state.  This would modify the
value for all streams for that provider for a particular PPA.  The
physicaladdress cannot be modified if even a single stream for that PPA is in
the bound state.

The DLS User uses the supported primitives (DL_ATTACH_REQ,
DL_BIND_REQ, DL_ENABMULTI_REQ, DL_PROMISCON_REQ) to define a set of enabled
physical and SAP address components on a per Stream basis.  It is invalid for a
DLS Provider to ever send upstream a data messagefor which the DLS User on that
stream has not requested.  The burden is on the provider to enforce by any means
that it chooses, the isolation of SAP and physical address space effects on a
per-stream basis.

@node Data Link User Identification
@subsection Data Link User Identification

A data link user's identity is established by associating it with a data link
service access point (DLSAP),which is the point through which the user will
communicate with the data link provider.  A DLSAP is identified by a DLSAP
address.

The DLSAP address identifies a particular data link service access point that is
associated with a stream(communication endpoint).  A bind service primitive
enables a DLS user to either choose a specific DLSAP by specifying its DLSAP
address, or to determine the DLSAP associated with a stream by retrieving the
bound DLSAP address.  This DLSAP address can then be used by other DLS users to
accessa specific DLS user.  The format of the DLSAP address is specific to the
DLS provider, and should be described in the provider-specific addendum
documentation.  However, DLPI provides a mechanism fordecomposing the DLSAP
address into component pieces.  The DL_INFO_ACK primitive returns the length of
the SAP component of the DLSAP address, along with the total length of the DLSAP
address.

Certain DLS Providers require the capability of binding on multiple DLSAP
addresses.  This can beachieved through subsequent binding of DLSAP addresses.
DLPI supports peer and hierarchical bindingof DLSAPs.  When the User requests
peer addressing, the DLSAP specified in a subsequent bind may be used in lieu of
the DLSAP bound in the DL_BIND_REQ.  This will allow for a choice to be made
betweena number of DLSAPs on a stream when determining traffic based on DLSAP
values.  An example of this would be to specify various ether_type values as
DLSAPs.  The DL_BIND_REQ, for example, could beissued with ether_type value of
IP, and a subsequent bind could be issued with ether type value of ARP.  The
Provider may now multiplex off of the ether_type field and allow for either IP
or ARP traffic to be sent up this stream.

When the DLS User requests hierarchical binding, the subsequent bind will
specify a DLSAP that will beused in addition to the DLSAP bound using a
DL_BIND_REQ.  This will allow additional information to be specified, that will
be used in a header or used for demultiplexing.  An example of this would be to
usehierarchical bind to specify the OUI (Organizationally Unique Identifier) to
be used by SNAP.

If a DLS Provider supports peer subsequent bind operations, the first SAP that
is bound is used as thesource SAP when there is ambiguity.

DLPI supports the ability to associate several streams with a single DLSAP,
where each stream may be aunique data link connection endpoint.  However, not all
DLS providers can support such configurations because some DLS providers may
have no mechanism beyond the DLSAP address for distinguishingmultiple
connections.  In such cases, the provider will restrict the DLS user to one
stream per DLSAP.

@node The Connection Management Stream
@section The Connection Management Stream

The earlier description of the connection-mode service assumed that a DLS user
bound a DLSAP to thestream it would use to receive connect requests.  In some
instances, however, it is expected that a given service may be accessed through
any one of several DLSAPs.  To handle this scenario, a separate streamwould be
required for each possible destination DLSAP, regardless of whether any DLS user
actually requested a connection to that DLSAP.  Obvious resource problems can
result in this scenario.

To obviate the need for tying up system resources for all possible destination
DLSAPs, a "connectionmanagement stream" utility is defined in DLPI.  A connection
management stream is one that receives any connect requests that are not
destined for currently bound DLSAPs capable of receiving connectindications.
With this mechanism, a special listener can handle incoming connect requests
intended for a set of DLSAPs by opening a connection management stream to the
DLS provider that will retrieve allconnect requests arriving through a
particular PPA.  In the model, then, there may be a connection management stream
per PPA.

@node DLPI Services
@chapter DLPI Services

@menu
* Local Management Services::
* Connection-mode Services::
* Connectionless-mode Services::
* Acknowledged Connectionless-mode Services::
* An Example::
@end menu

The various features of the DLPI interface are defined in terms of the services
provided by the DLSprovider, and the individual primitives that may flow between
the DLS user and DLS provider.

The data link provider interface supports three modes of service: connection,
connectionless andacknowledged connectionless.  The connection mode is
circuit-oriented and enables data to be transferred over an established
connection in a sequenced manner.  The connectionless mode is message-oriented
andsupports data transfer in self-contained units with no logical relationship
required between units.  The acknowledged connectionless mode is message-oriented
and guarantees that data units will be delivered tothe destination user in the
order in which they were sent.  This specification also defines a set of local
management functions that apply to all modes of service.

The XID and TEST services that are supported by DLPI are listed below.  The DLS
User can issue an XIDor TEST request to the DLS Provider.  The Provider will
transmit an XID or TEST frame to the peer DLS Provider.  On receiving a response,
the DLS Provider sends a confirmation primitive to the DLS User.  Onreceiving an
XID or TEST frame from the peer DLS Provider, the local DLS Provider sends up an
XID or TEST indication primitive to the DLS User.  The User must respond with an
XID or TEST response frameto the Provider.

The services are tabulated below and described more fully in the remainder of
this section.

@tabfig{dlpi_tab1,1a,Cross-Reference of DLS Services and Primitives}
@tabfig{dlpi_tab2,1b,Cross-Reference of DLS Services and Primitives}
@tabfig{dlpi_tab3,1c,Cross-Reference of DLS Services and Primitives}

@node Local Management Services
@section Local Management Services

@menu
* Information Reporting Service::
* Attach Service::
* Bind Service::
@end menu

The local management services apply to the connection, connectionless and
acknowledged connectionlessmodes of transmission.  These services, which fall
outside the scope of standards specifications, define the method for
initializing a stream that is connected to a DLS provider.  DLS provider
information reportingservices are also supported by the local management
facilities.

@node Information Reporting Service
@subsection Information Reporting Service
This service provides information about the DLPI stream to the DLS user.  The
message DL_INFO_REQrequests the DLS provider to return operating information
about the stream.  The DLS provider returns the information in a DL_INFO_ACK
message.

@figuresized{dlpi_fig3,3,Message Flow: Information Reporting,4in}

@node Attach Service
@subsection Attach Service
The attach service assigns a physical point of attachment (PPA) to a stream.
This service is required for style 2 DLS providers (see section 2.3.1, Physical
Attachment Identification) to specify the physicalmedium over which
communication will occur.  The DLS provider indicates success with a DL_OK_ACK;
failure with a DL_ERROR_ACK.  The normal message sequence is illustrated in
thefollowing figure.

@figuresized{dlpi_fig4,4,Message Flow: Attaching a Stream to a Physical Line,4in}

A PPA may be disassociated with a stream using the DL_DETACH_REQ.  The normal
message sequenceis illustrated in the following figure.

@figuresized{dlpi_fig5,5,Message Flow: Detaching a Stream from a Physical Line,4in}

@node Bind Service
@subsection Bind Service
The bind service associates a data link service access point (DLSAP) with a
stream.  The DLSAP isidentified by a DLSAP address.

DL_BIND_REQ requests that the DLS provider bind a DLSAP to a stream.  It also
notifies the DLSprovider to make the stream active with respect to the DLSAP for
processing connectionless and acknowledged connectionless data transfer and
connection establishment requests.  Protocol-specificactions taken during
activation should be described in DLS provider-specific addenda.

The DLS provider indicates success with a DL_BIND_ACK; failure with a
DL_ERROR_ACK.

Certain DLS providers require the capability of binding on multiple DLSAP
addresses.  DL_SUBS_BIND_REQ provides that added capability.  The DLS provider
indicates success with a DL_SUBS_BIND_ACK; failure with a DL_ERROR_ACK.  The
normal flow of messages is illustrated in the following figure.

@figuresized{dlpi_fig6,6,Message Flow: Binding a Stream to a DLSAP,4in}

DL_UNBIND_REQ requests the DLS provider to unbind all DLSAP(s) from a stream.
The DL_UNBIND_REQ also unbinds all the subsequently bound DLSAPs that have not
been unbound.  The DLS provider indicates success with a DL_OK_ACK; failure with
a DL_ERROR_ACK.

DL_SUBS_UNBIND_REQ requests the DLS Provider to unbind the subsequently bound
DLSAP.  The DLS Provider indicates success with a DL_OK_ACK; failure with a
DL_ERROR_ACK.

@figuresized{dlpi_fig7,7,Message Flow: Unbinding a Stream from a DLSAP,4in}

DL_ENABMULTI_REQ requests the DLS Provider to enable specific multicast
addresses on a per streambasis.  The Provider indicates success with a DL_OK_ACK;
failure with a DL_ERROR_ACK.

@figuresized{dlpi_fig8,8,Message Flow: Enabling a specific multicast address on a Stream,4in}

DL_DISABMULTI_REQ requests the DLS Provider to disable specific multicast
addresses on a perStream basis.  The Provider indicates success with a DL_OK_ACK;
failure with a DL_ERROR_ACK.

@figuresized{dlpi_fig9,9,Message Flow: Disabling a specific multicast address on a Stream,4in}

DL_PROMISCON_REQ requests the DLS Provider to enable promiscuous mode on a per
Stream basis,either at the physical level or at the SAP level.  The Provider
indicates success with a DL_OK_ACK; failure with a DL_ERROR_ACK.

@figuresized{dlpi_fi10,10,Message Flow: Enabling promiscuous mode on a Stream,4in}

DL_PROMISCOFF_REQ requests the DLS Provider to disable promiscuous mode on a per
Stream basis,either at the physical level or at the SAP level.  The Provider
indicates success with a DL_OK_ACK; failure with a DL_ERROR_ACK.

@figuresized{dlpi_fi11,11,Message Flow: Disabling promiscuous mode on a Stream,4in}

@node Connection-mode Services
@section Connection-mode Services
The connection-mode services enable a DLS user to establish a data link
connection, transfer data overthat connection, reset the link, and release the
connection when the conversation has terminated.

@menu
* Connection Establishment Service::
* Data Transfer Service::
* Connection Release Service::
* Reset Service::
@end menu

@node Connection Establishment Service
@subsection Connection Establishment Service

@menu
* Normal Connection Establishment::
* Connection Establishment Rejections::
@end menu

The connection establishment service establishes a data link connection between
a local DLS user and aremote DLS user for the purpose of sending data.  Only one
data link connection is allowed on each stream.

@node Normal Connection Establishment
@subsubsection Normal Connection Establishment
In the connection establishment model, the calling DLS user initiates connection
establishment, while thecalled DLS user waits for incoming requests.
DL_CONNECT_REQ requests that the DLS provider establish a connection.
DL_CONNECT_IND informs the called DLS user of the request, which may beaccepted
using DL_CONNECT_RES.  DL_CONNECT_CON informs the calling DLS user that the
connection has been established.

The normal sequence of messages is illustrated in the following figure.

@figuresized{dlpi_fi12,12,Message Flow: Successful Connection Establishment,4in}

Once the connection is established, the DLS users may exchange user data using
DL_DATA_REQ and DL_DATA_IND.

The DLS user may accept an incoming connect request on either the stream where
the connect indicationarrived or an alternate, responding stream.  The responding
stream is indicated by a token in the DL_CONNECT_RES.  This token is a value
associated with the responding stream, and is obtained byissuing a DL_TOKEN_REQ
on that stream.  The DLS provider responds to this request by generating a token
for the stream and returning it to the DLS user in a DL_TOKEN_ACK.  The normal
sequence ofmessages for obtaining a token is illustrated in the following
figure.

@figuresized{dlpi_fi13,13,Message Flow: Token Retrieval,4in}

In the typical connection establishment scenario, the called DLS user processes
one connect indication at atime, accepting the connection on another stream.
Once the user responds to the current connect indication, the next connect
indication (if any) can be processed.  DLPI also enables the called DLS user to
multi-thread incoming connect indications.  The user can receive multiple connect
indications beforeresponding to any of them.  This enables the DLS user to
establish priority schemes on incoming connect requests.

@node Connection Establishment Rejections
@subsubsection Connection Establishment Rejections
In certain situations, the connection establishment request cannot be completed.
The following paragraphsdescribe the occasions under which DL_DISCONNECT_REQ and
DL_DISCONNECT_IND primitives will flow during connection establishment, causing
the connect request to be aborted.

The following figure illustrates the situation where the called DLS user chooses
to reject the connectrequest by issuing DL_DISCONNECT_REQ instead of
DL_CONNECT_RES.

@figuresized{dlpi_fi14,14,Message Flow: Called DLS User Rejection of Connection Establishment Attempt,4in}

The following figure illustrates the situation where the DLS provider rejects a
connect request for lack ofresources or other reason.  The DLS provider sends
DL_DISCONNECT_IND in response to DL_CONNECT_REQ.

@figuresized{dlpi_fi15,15,Message Flow: DLS Provider Rejection of a Connection Establishment Attempt,4in}

The following figures illustrate the situation where the calling DLS user
chooses to abort a previousconnection attempt.  The DLS user issues
DL_DISCONNECT_REQ at some point following a DL_CONNECT_REQ.  The resulting
sequence of primitives depends on the relative timing of theprimitives involved,
as defined in the following time sequence diagrams.

@figuresized{dlpi_fi16,16,Message Flow: Both Primitives are Destroyed by Provider,4in}

@figuresized{dlpi_fi17,17,Message Flow: DL_DISCONNECT Indication Arrives before DL_CONNECT Response is Sent,4in}

@figuresized{dlpi_fi18,18,Message Flow: DL_DISCONNECT Indication Arrives after DL_CONNECT Response is Sent,4in}

@node Data Transfer Service
@subsection Data Transfer Service
The connection-mode data transfer service provides for the exchange of user data
in either direction or inboth directions simultaneously between DLS users.  Data
is transmitted in logical groups called data link service data units (DLSDUs).
The DLS provider preserves both the sequence and boundaries of DLSDUsas they are
transmitted.

Normal data transfer is neither acknowledged nor confirmed.  It is up to the DLS
users, if they so choose,to implement a confirmation protocol.

Each DL_DATA_REQ primitive conveys a DLSDU from the local DLS user to the DLS
provider.Similarly, each DL_DATA_IND primitive conveys a DLSDU from the DLS
provider to the remote DLS user.  The normal flow of messages is illustrated in
the figure below.

@figuresized{dlpi_fi19,19,Message Flow: Normal Data Transfer,4in}

@node Connection Release Service
@subsection Connection Release Service
The connection release service provides for the DLS users or the DLS provider to
initiate the connectionrelease.  Connection release is an abortive operation,
and any data in transit (has not been delivered to the DLS user) may be
discarded.

DL_DISCONNECT_REQ requests that a connection be released.  DL_DISCONNECT_IND
informs the DLS user that a connection has been released.  Normally, one DLS user
requests disconnection and the DLS provider issues an indication of the ensuing
release to the other DLS user, as illustrated by themessage flow in the
following figure.

@figuresized{dlpi_fi20,20,Message Flow: DLS User-Invoked Connection Release,4in}

The next figure illustrates that when two DLS users independently invoke the
connection release service,neither receives a DL_DISCONNECT_IND.

@figuresized{dlpi_fi21,21,Message Flow: Simultaneous DLS User Invoked Connection Release,4in}

The next figure illustrates that when the DLS provider initiates the connection
release service, each DLSuser receives a DL_DISCONNECT_IND.

@figuresized{dlpi_fi22,22,Message Flow: DLS Provider Invoked Connection Release,4in}

The next figure illustrates that when the DLS provider and the local DLS user
simultaneously invoke theconnection release service, the remote DLS user
receives a DL_DISCONNECT_IND.

@figuresized{dlpi_fi23,23,Message Flow: Simultaneous DLS User & DLS Provider Invoked Connection Release,4in}

@node Reset Service
@subsection Reset Service
The reset service may be used by the DLS user to resynchronize the use of a data
link connection, or by the DLS provider to report detected loss of data
unrecoverable within the data link service.

Invocation of the reset service will unblock the flow of DLSDUs if the data link
connection is congested;DLSDUs may be discarded by the DLS provider.  The DLS
user or users that did not invoke the reset will be notified that a reset has
occurred.  A reset may require a recovery procedure to be performed by the DLS
users.

The interaction between each DLS user and the DLS provider will be one of the
following:

@itemize @bullet
@item a DL_RESET_REQ from the DLS user, followed by a DL_RESET_CON from the DLS provider;
@item a DL_RESET_IND from the DLS provider, followed by a DL_RESET_RES from the DLS user.
@end itemize

The DL_RESET_REQ acts as a synchronization mark in the stream of DLSDUs that are
transmitted by theissuing DLS user; the DL_RESET_IND acts as a synchronization
mark in the stream of DLSDUs that are received by the peer DLS user.  Similarly,
the DL_RESET_RES acts as a synchronization mark in thestream of DLSDUs that are
transmitted by the responding DLS user; the DL_RESET_CON acts as a
synchronization mark in the stream of DLSDUs that are received by the DLS user
which originally issuedthe reset.

The resynchronizing properties of the reset service are that:

@itemize @bullet

@item No DLSDU transmitted by the DLS user before the synchronization mark in
that transmitted streamwill be delivered to the other DLS user after the
synchronization mark in that received stream.

@item The DLS provider will discard all DLSDUs submitted before the issuing of
the DL_RESET_REQ thathave not been delivered to the peer DLS user when the DLS
provider issues the DL_RESET_IND.

@item The DLS provider will discard all DLSDUs submitted before the issuing of
the DL_RESET_RES thathave not been delivered to the initiator of the
DL_RESET_REQ when the DLS provider issues the DL_RESET_CON.

@item No DLSDU transmitted by a DLS user after the synchronization mark in that
transmitted stream willbe delivered to the other DLS user before the
synchronization mark in that received stream.

@end itemize

The complete message flow depends on the origin of the reset, which may be the
DLS provider or either DLS user.  The following figure illustrates the message
flow for a reset invoked by one DLS user.

@figuresized{dlpi_fi24,24,Message Flow: DLS User-Invoked Connection Reset,4in}

The following figure illustrates the message flow for a reset invoked by both
DLS users simultaneously.

@figuresized{dlpi_fi25,25,Message Flow: Simultaneous DLS User-Invoked Connection Reset,4in}

The following figure illustrates the message flow for a reset invoked by the DLS
provider.

@figuresized{dlpi_fi26,26,Message Flow: DLS Provider-Invoked Connection Reset,4in}

The following figure illustrates the message flow for a reset invoked
simultaneously by one DLS user andthe DLS provider.

@figuresized{dlpi_fi27,27,Message Flow: Simultaneous DLS User & DLS Provider Invoked Connection Reset,4in}

@node Connectionless-mode Services
@section Connectionless-mode Services

@menu
* Connectionless Data Transfer Service::
* QOS Management Service (1)::
* Error Reporting Service (1)::
* XID and TEST Service::
@end menu

The connectionless-mode services enable a DLS user to transfer units of data to
peer DLS users withoutincurring the overhead of establishing and releasing a
connection.  The connectionless service does not, however, guarantee reliable
delivery of data units between peer DLS users (e.g.  lack of flow control
maycause buffer resource shortages that result in data being discarded).

Once a stream has been initialized via the local management services, it may be
used to send and receiveconnectionless data units.

@node Connectionless Data Transfer Service
@subsection Connectionless Data Transfer Service
The connectionless data transfer service provides for the exchange of user data
(DLSDUs) in eitherdirection or in both directions simultaneously without having
to establish a data link connection.  Data transfer is neither acknowledged nor
confirmed, and there is no end-to-end flow control provided.  Assuch, the
connectionless data transfer service cannot guarantee reliable delivery of data.
However, a specific DLS provider can provide assurance that messages will not be
lost, duplicated, or reordered.

DL_UNITDATA_REQ conveys one DLSDU to the DLS provider.  DL_UNITDATA_IND conveys
one DLSDU to the DLS user.  The normal flow of messages is illustrated in the
figure below.

@figuresized{dlpi_fi28,28,Message Flow: Connectionless Data Transfer,4in}

@node QOS Management Service (1)
@subsection QOS Management Service
The QOS (Quality of Service) management service enables a DLS user to specify
the quality of service itcan expect for each invocation of the connectionless
data transfer service.  The DL_UDQOS_REQ directs the DLS provider to set the QOS
parameters to the specified values.  The normal flow of messages isillustrated in
the figure below.

@figuresized{dlpi_fi29,29,Message Flow: Connectionless Data Transfer,4in}

@node Error Reporting Service (1)
@subsection Error Reporting Service
The connectionless-mode error reporting service may be used to notify a DLS user
that a previously sentdata unit either produced an error or could not be
delivered.  This service does not, however, guarantee that an error indication
will be issued for every undeliverable data unit.

@figuresized{dlpi_fi29b,29b,-,4in}

@node XID and TEST Service
@subsection XID and TEST Service

The XID and TEST service enables the DLS User to issue an XID or TEST request to
the DLS Provider.On receiving a response for the XID or TEST frame transmitted
to the peer DLS Provider, the DLS Provider sends up an XID or TEST confirmation
primitive to the DLS User.  On receiving an XID or TESTframe from the peer DLS
Provider, the local DLS Provider sends up an XID or TEST indication respectively
to the DLS User.  The DLS User must respond with an XID or TEST response
primitive.

If the DLS User requested automatic handling of the XID or TEST response, at
bind time, the DLSProvider will send up an error acknowledgement on receiving an
XID or TEST request.  Also, no indications will be generated to the DLS User on
receiving XID or TEST frames from the remote side.

The normal flow of messages is illustrated in the figure below.

@figuresized{dlpi_fi30,30,Message Flow: XID Service,4in}

@figuresized{dlpi_fi31,31,Message Flow: TEST Service,4in}

@node Acknowledged Connectionless-mode Services
@section Acknowledged Connectionless-mode Services

@menu
* Acknowledged Connectionless-mode Data Transfer Services::
* QOS Management Service (2)::
* Error Reporting Service (2)::
@end menu

The acknowledged connectionless-mode services are designed for general use for
the reliable transfer ofinformations between peer DLS Users.  These services are
intended for applications that require acknowledgement of cross-LAN data unit
transfer, but wish to avoid the complexity that is viewed asbeing associated
with the connection-mode services.  Although the exchange service is
connectionless, insequence delivery is guaranteed for data sent by the
initiating station.

@node Acknowledged Connectionless-mode Data Transfer Services
@subsection Acknowledged Connectionless-mode Data Transfer Services
The acknowledged connectionless-mode data transfer services provide the means by
which the DLS Userscan exchange DLSDUs which are acknowledged at the LLC
sublayer, without the establishment of a Data Link connection.  The services
provide a means by which a local DLS User can send a data unit to the peer DLS
User, request a previously prepared data unit, or exchange data units with the
peer DLS User.

@figuresized{dlpi_fi32,32,Message Flow: Acknowledged Connectionless-Mode Data Unit Transmission service,4in}

The next figure illustrates the acknowledged connectionless-mode data unit
exchange service.

@figuresized{dlpi_fi33,33,Message Flow: Acknowledged Connectionless-Mode Data Unit Exchange service,4in}

The next figure illustrates the Reply Data Unit Preparation service.

@figuresized{dlpi_fi34,34,Message Flow: Acknowledged Connectionless-Mode Reply Data Unit Preparation Service,4in}

@node QOS Management Service (2)
@subsection QOS Management Service
The Quality of Service (QOS) management service enables a DLS User to specify
the quality of service itcan expect for each invocation of the acknowledged
connectionless data transfer service.  The DL_UDQOS_REQ directs the DLS provider
to set the QOS parameters to the specified values.  The normalflow of messages is
illustrated in section 3.3.2, (Connectionless mode services).

@node Error Reporting Service (2)
@subsection Error Reporting Service
The acknowledged connectionless mode error reporting service is the same as the
unacknowledgedconnectionless-mode error reporting service.  For the message flow,
refer to section 3.3.3.


@node An Example
@section An Example
To bring it all together, the following example illustrates the primitives that
flow during a complete,connection-mode sequence between stream open and stream
close.

@figuresized{dlpi_fi35,35,Message Flow: A Connection-mode Example,3.75in}

@node DLPI Primitives
@chapter DLPI Primitives

@menu
* Local Management Service Primitives::
* Connection-mode Service Primitives::
* Connectionless-mode Service Primitives::
* Primitives to handle XID and TEST operations::
* Acknowledged Connectionless-mode Service Primitives::
@end menu

The kernel-level interface to the data link layer defines a STREAMS-based
message interface between theprovider of the data link service (DLS provider)
and the consumer of the data link service (DLS user).  STREAMS provides the
mechanism in which DLPI primitives may be passed between the DLS user and DLS
provider.

Before DLPI primitives can be passed between the DLS user and the DLS provider,
the DLS user mustestablish a stream to the DLS provider using open(2).  The DLS
provider must therefore be configured as aSTREAMS driver.  When interactions
between the DLS user and DLS provider have completed, the stream may be closed.

The STREAMS messages used to transport data link service primitives across the
interface have one of thefollowing formats:

@itemize @bullet
@item One M_PROTO message block followed by zero or more M_DATA blocks.  The
M_PROTO messageblock contains the data link layer service primitive type and all
relevant parameters associated with the primitive.  The M_DATA block(s) contain
any DLS user data that might be associated with the serviceprimitive.
@item One M_PCPROTO message block containing the data link layer service
primitive type and all relevantparameters associated with the service primitive.
@item One or more M_DATA message blocks conveying user data.
@end itemize

The information contained in the M_PROTO or M_PCPROTO message blocks must begin
on a byteboundary that is appropriate for structure alignment (e.g.  word-aligned
on the AT&T 3B2 Computer).  STREAMS will allocate buffers that begin on such a
boundary.  However, these message blocks maycontain information whose
representation is described by a length and an offset within the block.  An
example is the DLSAP address (dl_addr_length and dl_addr_offset) in the
DL_BIND_ACK primitive.The offset of such information within the message block is
not guaranteed to be properly aligned for casting the appropriate data type
(such as an int or a structure).

Appendix B defines the sequence in which DLPI primitives can be passed between
DLS user and DLSprovider, and Appendix C summarizes the precedence rules
associated with each primitive for ordering the primitives on the DLS provider
and DLS user queues.

The following sections describe the format of the primitives that support the
services described in theprevious section.  The primitives are grouped into four
general categories for presentation:

@itemize @bullet
@item Local Management Service Primitives
@item Connection-mode Service Primitives
@item Connectionless-mode Service Primitives
@item Acknowledged Connectionless-mode Service Primitives
@end itemize


@node Local Management Service Primitives
@section Local Management Service Primitives

@menu
* PPA Initialization / De-initialization::
* Message DL_INFO_REQ (dl_info_req_t)::
* Message DL_INFO_ACK (dl_info_ack_t)::
* Message DL_ATTACH_REQ (dl_attach_req_t)::
* Message DL_DETACH_REQ (dl_detach_req_t)::
* Message DL_BIND_REQ (dl_bind_req_t)::
* Message DL_BIND_ACK (dl_bind_ack_t)::
* Message DL_UNBIND_REQ (dl_unbind_req_t)::
* Message DL_SUBS_BIND_REQ (dl_subs_bind_req_t)::
* Message DL_SUBS_BIND_ACK (dl_subs_bind_ack_t)::
* Message DL_SUBS_UNBIND_REQ (dl_subs_unbind_req_t)::
* Message DL_ENABMULTI_REQ (dl_enabmulti_req_t)::
* Message DL_DISABMULTI_REQ (dl_disabmulti_req_t)::
* Message DL_PROMISCON_REQ (dl_promiscon_re q_t)::
* Message DL_PROMISCOFF_REQ (dl_promiscoff_req_t)::
* Message DL_OK_ACK (dl_ok_ack_t)::
* Message DL_ERROR_ACK (dl_error_ack_t)::
@end menu

This section describes the local management service primitives that are common
to the connection,connectionless and acknowledged connectionless service modes.
These primitives support the Information Reporting, Attach, Bind,
enabling/disabling of multicast addresses and turning on/off thepromiscuous
mode.  Once a stream has been opened by a DLS user, these primitives initialize
the stream, preparing it for use.

@node PPA Initialization / De-initialization
@subsection PPA Initialization / De-initialization
The PPA associated with each stream must be initialized before the DLS provider
can transfer data overthe medium.  The initialization and de-initialization of
the PPA is a network management issue, but DLPI must address the issue because
of the impact such actions will have on a DLS user.  More specifically, DLPI
requires the DLS provider to initialize the PPA associated with a stream at some
point before it completes the processing of the DL_BIND_REQ.  Guidelines for
initialization and de-initialization of aPPA by a DLS provider are presented
here.

A DLS provider may initialize a PPA using the following methods:

@itemize @bullet
@item pre-initialized by some network management mechanism before the DL_BIND_REQ is received; or
@item automatic initialization on receipt of a DL_BIND_REQ or DL_ATTACH_REQ.
@end itemize

A specific DLS provider may support either of these methods, or possibly some
combination of the two,but the method implemented has no impact on the DLS user.
From the DLS user's viewpoint, the PPA is guaranteed to be initialized on
receipt of a DL_BIND_ACK.  For automatic initialization, this implies thatthe
DL_BIND_ACK may not be issued until the initialization has completed.

If pre-initialization has not been performed and/or automatic initialization
fails, the DLS provider will failthe DL_BIND_REQ.  Two errors, DL_INITFAILED and
DL_NOTINIT, may be returned in the DL_ERROR_ACK response to a DL_BIND_REQ if PPA
initialization fails.  DL_INITFAILED is returnedwhen a DLS provider supports
automatic PPA initialization, but the initialization attempt failed.  DL_NOTINIT
is returned when the DLS provider requires pre-initialization, but the PPA is
not initializedbefore the DL_BIND_REQ is received.

A DLS provider may handle PPA de-initialization using the following methods:

@itemize @bullet
@item automatic de-initialization upon receipt of the final DL_DETACH_REQ (for
style 2 providers) or DL_UNBIND_REQ (for style 1 providers), or upon closing of
the last stream associated with the PPA;
@item automatic de-initialization after expiration of a timer following the last
DL_DETACH_REQ, DL_UNBIND_REQ, or close as appropriate; or
@item no automatic de-initialization; administrative intervention is required to
de-initialize the PPA at somepoint after it is no longer being accessed.
@end itemize

A specific DLS provider may support any of these methods, or possibly some
combination of them, but themethod implemented has no impact on the DLS user.
From the DLS user's viewpoint, the PPA is guaranteed to be initialized and
available for transmission until it closes or unbinds the stream associatedwith
the PPA.

DLS provider-specific addendum documentation should describe the method chosen
for PPA initializationand de-initialization.

@page
@node Message DL_INFO_REQ (dl_info_req_t)
@subsection Message DL_INFO_REQ (dl_info_req_t)
Requests information of the DLS provider about the DLPI stream.  This information
includes a set ofprovider-specific parameters, as well as the current state of
the interface.

@subsubheading Message Format
The message consists of one M_PCPROTO message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_info_req_t;
@tpindex dl_info_req_t
@end example

@subsubheading Parameters

@vtable @var

@item dl_primitive
conveys DL_INFO_REQ.

@end vtable

@subsubheading State
The message is valid in any state in which a local acknowledgement is not
pending, as described inAppendix B, Allowable Sequence of DLPI Primitives.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
The DLS provider responds to the information request with a DL_INFO_ACK.


@page
@node Message DL_INFO_ACK (dl_info_ack_t)
@subsection Message DL_INFO_ACK (dl_info_ack_t)
This message is sent in response to DL_INFO_REQ; it conveys information about
the DLPI stream to the DLS user.

@subsubheading Message Format
The message consists of one M_PCPROTO message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_max_sdu;
        ulong dl_min_sdu;
        ulong dl_addr_length;
        ulong dl_mac_type;
        ulong dl_reserved;
        ulong dl_current_state;
        long dl_sap_length;
        ulong dl_service_mode;
        ulong dl_qos_length;
        ulong dl_qos_offset;
        ulong dl_qos_range_length;
        ulong dl_qos_range_offset;
        ulong dl_provider_style;
        ulong dl_addr_offset;
        ulong dl_version;
        ulong dl_brdcst_addr_length;
        ulong dl_brdcst_addr_offset;
        ulong dl_growth;
@} dl_info_ack_t;
@tpindex dl_info_ack_t
@end example

@subsubheading Parameters

@vtable @var
@item dl_primitive
conveys DL_INFO_ACK.

@item dl_max_sdu
conveys the maximum number of bytes that may be transmitted in a DLSDU.  This
value must be a positive integer that is greater than or equal to the value of
dl_min_sdu.

@item dl_min_sdu
conveys the minimum number of bytes that may be transmitted in a DLSDU.  The
value is never less than one.

@item dl_addr_length
conveys the length, in bytes, of the provider's DLSAP address.  In the case of a
hierarchical subsequent bind, the length returned is the total length i.e
Physical address + SAP + subsequentaddress length.

@item dl_mac_type
conveys the type of medium supported by this DLPI stream.  Possible values
include:

@vtable @var
@item DL_CSMACD
The medium is Carrier Sense Multiple Access with Collision Detection (ISO8802/3).
@item DL_TPB
The medium is Token-Passing Bus (ISO 8802/4).
@item DL_TPR
The medium is Token-Passing Ring (ISO 8802/5).
@item DL_METRO
The medium is Metro Net (ISO 8802/6).
@item DL_ETHER
The medium is Ethernet Bus.
@item DL_HDLC
The medium is a bit synchronous communication line.
@item DL_CHAR
The medium is a character synchronous communication line (e.g.  BISYNC).
@item DL_CTCA
The medium is a channel-to-channel adapter.
@item DL_FDDI
The medium is a Fiber Distributed Data Interface.
@item DL_OTHER
Any other medium not listed above.
@end vtable

@item dl_reserved
is a reserved field whose value must be set to zero.

@item dl_current_state
conveys the state of the DLPI interface for the stream when the DLS provider
issued this acknowledgement.  See Appendix B for a list of DLPI states and an
explanation of each.
@item dl_sap_length
indicates the current length of the SAP component of the DLSAP address.  It may
have a negative, zero or positive value.  A positive value indicates the
ordering of the SAP andPHYSICAL component within the DLSAP address as SAP
component followed by PHYSICAL component.  A negative value indicates PHYSICAL
followed by the SAP.  A zero value indicatesthat no SAP has yet been bound.  The
absolute value of the dl_sap_length provides the length of the SAP component
within the DLSAP address.
@item dl_service_mode
if returned before the DL_BIND_REQ is processed, this conveys which service
modes (connection-mode, connectionless-mode or acknowledged connectionless-mode,
or anycomibination of these modes) the DLS provider can support.  It contains a
bit-mask specifying one or more than one of the following values:

@vtable @var
@item DL_CODLS
connection-oriented data link service;
@item DL_CLDLS
connectionless data link service;
@item DL_ACLDLS
acknowledged connectionless data link service;
@end vtable

Once a specific service mode has been bound to the stream, this field returns
that specific servicemode.

@item dl_qos_length
conveys the length, in bytes, of the negotiated/selected values of the quality
of service (QOS) parameters.  Section 5, Quality of Data Link Service, describes
quality of service and itsassociated parameters completely.  For connection-mode
service, the returned values are those agreed during negotiation.  For
connectionless-mode service, the values are those currentlyselected by the DLS
user.  If quality of service has not yet been negotiated, default values will be
returned; these values correspond to those that will be applied by the DLS
provider on a connectrequest in connection-mode service, or those that will be
applied to each data unit transmission in connectionless-mode service.  If the
DLS provider supports both connection-mode andconnectionless-mode services but
the DLS user has not yet bound a specific service mode, the DLS provider may
return either connection-mode or connectionless-mode QOS parameter values.

The QOS values are conveyed in the structures defined in section 5.3, QOS Data
Structures.  Forany parameter the DLS provider does not support or cannot
determine, the corresponding entry will be set to DL_UNKNOWN.  If the DLS
provider does not support any QOS parameters, this length field will be set to
zero.

@item dl_qos_offset
conveys the offset from the beginning of the M_PCPROTO block where the current
quality of service parameters begin.

@item dl_qos_range_length
conveys the length, in bytes, of the available range of QOS parameter values
supported by the DLS provider.  For connection-mode service, this is the range
available to the calling DLS user ina connect request.  For connectionless-mode,
this is the range available for each data unit transmission.  If the DLS provider
supports both connection-mode and connectionless-modeservices but the DLS user
has not yet bound a specific service mode, the DLS provider may return either
connection-mode or connectionless-mode QOS parameter values.  The range of
available QOS values is conveyed in the structures defined in section 5.3, QOS
Data Structures.  For any parameter the DLS provider does not support or cannot
determine, thecorresponding entry will be set to DL_UNKNOWN.  If the DLS provider
does not support any QOS parameters, this length field will be set to zero.

@item dl_qos_range_offset
conveys the offset from the beginning of the M_PCPROTO block where the available
range of quality of service parameters begins.

@item dl_provider_style
conveys the style of DLS provider associated with the DLPI stream (see section
2.3.1, Physical Attachment Identification).  The following provider classes are
defined:

@vtable @var
@item DL_STYLE1
The PPA is implicitly attached to the DLPI stream by opening the
appropriatemajor/minor device number.
@item DL_STYLE2
The DLS user must explicitly attach a PPA to the DLPI stream using DL_ATTACH_REQ.
@end vtable

DLS users implemented in a protocol-independent manner must access this
parameter todetermine whether the DLS attach service must be invoked explicitly.

@item dl_addr_offset
conveys the offset of the address that is bound to the associated stream.  If the
DLS user issues a DL_INFO_REQ prior to binding a DLSAP, the value of dl_addr_len
will be 0 and consequentlyindicate that there has been no address bound.

@item dl_version
indicates the current version of the dlpi that's supported.

@item dl_brdcst_addr
lengthindicates the length of the physical broadcast address.

@item dl_brdcst_addr_offset
indicates the offset of the physical broadcast address from the beginning of the
PCPROTO block.

@item dl_growth
conveys a growth field for future use.  The value of this field will be zero.

@end vtable

@subsubheading State
The message is valid in any state in response to a DL_INFO_REQ.

@subsubheading New State
The resulting state is unchanged.


@page
@node Message DL_ATTACH_REQ (dl_attach_req_t)
@subsection Message DL_ATTACH_REQ (dl_attach_req_t)
Requests the DLS provider associate a physical point of attachment (PPA) with a
stream.  DL_ATTACH_REQ is needed for style 2 DLS providers to identify the
physical medium over whichcommunication will transpire.  The request may not be
issued to a style 1 DLS provider; doing so maycause errors.

The DLS provider may initialize the physical line on receipt of this primitive
or the DL_BIND_REQ.Otherwise, the line must be initialized through some
management mechanism before this request is issued by the DLS user.  Either way,
the physical link must be initialized and ready for use on successfulcompletion
of the DL_BIND_REQ.

@subsubheading Message Format
The message consists of one M_PROTO message block, which contains the following
structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_ppa;
@} dl_attach_req_t;
@tpindex dl_attach_req_t
@end example

@subsubheading Parameters

@vtable @var
@item dl_primitive
conveys DL_ATTACH_REQ.

@item dl_ppa
conveys the identifier of the physical point of attachment to be associated with
the stream.  The format of the identifier is provider-specific, and it must
contain sufficient information todistinguish the desired PPA from all possible
PPAs on a system.

At a minimum, this must include identification of the physical medium over
whichcommunication will transpire.  For media that multiplex multiple channels
over a single physical medium, this identifier should also specify a specific
channel to be used for communication(where each channel on a physical medium is
associated with a separate PPA).

Because of the provider-specific nature of this value, DLS user software that is
to be protocolindependent should avoid hard-coding the PPA identifier.  The DLS
user should retrieve the necessary PPA identifier from some other entity (such
as a management entity) and insert itwithout inspection into the DL_ATTACH_REQ.
@end vtable

@subsubheading State
The message is valid in state DL_UNATTACHED.

@subsubheading New State
The resulting state is DL_ATTACH_PENDING.

@subsubheading Response
If the attach request is successful, DL_OK_ACK is sent to the DLS user resulting
in state DL_UNBOUND.

If the request fails, message DL_ERROR_ACK is returned and the resulting state
is unchanged.

@subsubheading Reasons for Failure

@vtable @var
@item DL_BADPPA
The specified PPA is invalid.
@item DL_ACCESS
The DLS user did not have proper permission to use the requested PPA.
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in the DL_ERROR_ACK.
@end vtable


@page
@node Message DL_DETACH_REQ (dl_detach_req_t)
@subsection Message DL_DETACH_REQ (dl_detach_req_t)
For style 2 DLS providers, this requests the DLS provider detach a physical
point of attachment (PPA)from a stream.  The request may not be issued to a style
1 DLS provider; doing so may cause errors.

@subsubheading Message Format
The message consists of one M_PROTO message block, which contains the following
structure.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_detach_req_t;
@tpindex dl_detach_req_t
@end example

@subsubheading Parameters

@vtable @var
@item dl_primitive
conveys DL_DETACH_REQ.
@end vtable

@subsubheading State
The message is valid in state DL_UNBOUND.

@subsubheading New State
The resulting state is DL_DETACH_PENDING.

@subsubheading Response
If the detach request is successful, DL_OK_ACK is sent to the DLS user resulting
in state DL_UNATTACHED.

If the request fails, message DL_ERROR_ACK is returned and the resulting state
is unchanged.

@subsubheading Reasons for Failure

@vtable @var
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in the DL_ERROR_ACK.
@end vtable

@page
@node Message DL_BIND_REQ (dl_bind_req_t)
@subsection Message DL_BIND_REQ (dl_bind_req_t)
Requests the DLS provider bind a DLSAP to the stream.  The DLS user must identify
the address of the DLSAP to be bound to the stream.  For connection-mode service,
the DLS user also indicates whether it will accept incoming connection requests
on the stream.  Finally, the request directs the DLS provider toactivate the
stream associated with the DLSAP.

A stream is viewed as active when the DLS provider may transmit and receive
protocol data units destinedto or originating from the stream.  The PPA
associated with each stream must be initialized upon completion of the
processing of the DL_BIND_REQ (see section 4.1.1, PPA Initialization /
Deinitialization).  More specifically, the DLS user is ensured that the PPA is
initialized when the DL_BIND_ACK is received.  If the PPA cannot be initialized,
the DL_BIND_REQ will fail.

A stream may be bound as a "connection management" stream, such that it will
receive all connectrequests that arrive through a given PPA (see section 2.4,
The Connection Management Stream).  In thiscase, the dl_sap will be ignored.

@subsubheading Message Format
The message consists of one M_PROTO message block, which contains the following
structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_sap;
        ulong dl_max_conind;
        ushort dl_service_mode;
        ushort dl_conn_mgmt;
        ulong dl_xidtest_flg;
@} dl_bind_req_t;
@tpindex dl_bind_req_t
@end example

@subsubheading Parameters

@vtable @var
@item dl_primitive
conveys DL_BIND_REQ.

@item dl_sap
conveys sufficient information to identify the DLSAP that will be bound to the
DLPI stream (see section 2.3, DLPI Addressing, for a description of DLSAP
addresses).  The format of thisinformation is specific to a given DLS provider,
and may contain the full DLSAP address or some portion of that address
sufficient to uniquely identify the DLSAP in question.  The full address ofthe
bound DLSAP will be returned in the DL_BIND_ACK.

The following rules are used by the DLS provider when binding a DLSAP address.

@itemize @bullet
@item The DLS provider must define and manage its DLSAP address space.

@item DLPI allows the same DLSAP to be bound to multiple streams, but a given
DLS provider mayneed to restrict its address space to allow one stream per
DLSAP.

@item The DLS provider may not be able to bind the specified DLSAP address for
the followingreasons:

@enumerate
@item the DLS provider may statically associate a specific DLSAP with each
stream; or
@item the DLS provider may only support one stream per DLSAP and the DLS
userattempted to bind a DLSAP that was already bound to another stream.
@end enumerate

In case (1), the value of dl_sap is ignored by the DLS provider and the
DL_BIND_ACKreturns the DLSAP address that is already associated with the stream.
In case (2), if the DLS provider cannot bind the given DLSAP to the stream, it
may attempt to choose an alternate DLSAP and return that on the DL_BIND_ACK.  If
an alternate DLSAP cannot be chosen, the DLS provider will return a DL_ERROR_ACK
and set dl_errno to DL_NOADDR.
@end itemize

Because of the provider-specific nature of the DLSAP address, DLS user software
that is to beprotocol independent should avoid hard-coding this value.  The DLS
user should retrieve the necessary DLSAP address from some other entity (such as
a management entity or higher layerprotocol entity) and insert it without
inspection into the DL_BIND_REQ.

@item dl_max_conind
conveys the maximum number of outstanding DL_CONNECT_IND messages allowed on the
DLPI stream.  If the value is zero, the stream cannot accept any DL_CONNECT_IND
messages.If greater than zero, the DLS user will accept DL_CONNECT_IND messages
up to the given value before having to respond with a DL_CONNECT_RES or a
DL_DISCONNECT_REQ (seesection 4.2.1, Multi-threaded Connection Establishment,
for details on how this value is used tosupport multi-threaded connect
processing).  The DLS provider may not be able to support the value supplied in
dl_max_conind, as specified by the following rules.

@itemize @bullet
@item If the provider cannot support the specified number of outstanding connect
indications, itshould set the value down to a number it can support.

@item Only one stream that is bound to the indicated DLSAP may have an allowed
number ofmaximum outstanding connect indications greater than zero.  If a
DL_BIND_REQ specifies a value greater than zero, but another stream has already
bound itself to the DLSAP with avalue greater than zero, the DLS provider will
fail the request, setting dl_errno to DL_BOUND on the DL_ERROR_ACK.

@item If a stream with dl_max_conind greater than zero is used to accept a
connection, the streamwill be found busy during the duration of the connection,
and no other streams may be bound to the same DLSAP with a value of
dl_max_conind greater than zero.  This restrictionprevents more than one stream
bound to the same DLSAP from receiving connect indications and accepting
connections.  Accepting a connection on such a stream is only allowed if thereis
just a single outstanding connect indication being processed.

@item A DLS user should always be able to request a dl_max_conind value of zero,
since thisindicates to the DLS provider that the stream will only be used to
originate connect requests.

@item A stream with a negotiated value of dl_max_conind that is greater than
zero may not originateconnect requests.

@end itemize

This field is ignored in connectionless-mode service.

@item dl_service_mode
conveys the desired mode of service for this stream, and may contain one of the
following:

@vtable @var
@item DL_CODLS
connection-oriented data link service;
@item DL_CLDLS
connectionless data link service.
@item DL_ACLDLS
acknowledged connectionless data link service.
@end vtable

If the DLS provider does not support the requested service mode, a DL_ERROR_ACK
will begenerated, specifying DL_UNSUPPORTED.

@item dl_conn_mgmt
if non-zero, indicates that the stream is the "connection management" stream for
the PPA to which the stream is attached.  When an incoming connect request
arrives, the DLS provider willfirst look for a stream bound with dl_max_conind
greater than zero that is associated with thedestination DLSAP.  If such a stream
is found, the connect indication will be issued on that stream.  Otherwise, the
DLS provider will issue the connect indication on the "connection management"
stream for that PPA, if one exists.  Only one "connection management" stream
isallowed per PPA, so an attempt to bind a second "connection management" stream
on a PPA will fail with the DLPI error set to DL_BOUND.  When dl_conn_mgmt is
non-zero, the value of dl_sap will be ignored.  In connectionless-mode service,
dl_conn_mgmt is ignored by the DLSprovider.

@item dl_xidtest_flg
indicates to the DLS Provider that XID and/or TEST responses for this stream are
to be automatically generated by the DLS Provider.  The DLS Provider will not
generate DL_XID_INDand/or DL_TEST_IND, and will error a DL_XID_REQ and/or
DL_TEST_REQ.  If the DLS Provider does not support automatic handling of XID
and/or TEST responses, a DL_ERROR_ACK will be generated, specifying DL_NOAUTO,
DL_NOXIDAUTO or DL_NOTESTAUTO.  If the Provider receives an XID or TEST request
from the DLS User, a DL_ERROR_ACK will be generated specifying DL_XIDAUTO or
DL_TESTAUTO respectively.

The dl_xidtest_flg contains a bit-mask specifying zero or more of the following
values:

@vtable @var
@item DL_AUTO_XID
Automatically respond to XID commands.
@item DL_AUTO_TEST
Automatically respond to TEST commands.
@end vtable

@end vtable

@subsubheading State
The message is valid in state DL_UNBOUND.

@subsubheading New State
The resulting state is DL_BIND_PENDING.

@subsubheading Response
If the bind request is successful, DL_BIND_ACK is sent to the DLS user resulting
in state DL_IDLE.

If the request fails, message DL_ERROR_ACK is returned and the resulting state
is unchanged.

@subsubheading Reasons for Failure

@vtable @var
@item DL_BADADDR
The DLSAP address information was invalid or was in an incorrect format.
@item DL_INITFAILED
Automatic initialization of the PPA failed.
@item DL_NOTINIT
The PPA had not been initialized prior to this request.
@item DL_ACCESS
The DLS user did not have proper permission to use the requested DLSAP address.
@item DL_BOUND
The DLS user attempted to bind a second stream to a DLSAP with
dl_max_conindgreater than zero, or the DLS user attempted to bind a second
"connection management" stream to a PPA.
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_NOADDR
The DLS provider could not allocate a DLSAP address for this stream.
@item DL_UNSUPPORTED
The DLS provider does not support requested service mode on this stream.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the DL_ERROR_ACK.
@item DL_NOAUTO
Automatic handling of XID and TEST responses not supported.
@item DL_NOXIDAUTO
Automatic handling of XID response not supported.
@item DL_NOTESTAUTO
Automatic handling of TEST response not supported.
@end vtable

@page
@node Message DL_BIND_ACK (dl_bind_ack_t)
@subsection Message DL_BIND_ACK (dl_bind_ack_t)
Reports the successful bind of a DLSAP to a stream, and returns the bound DLSAP
address to the DLSuser.  This primitive is generated in response to a
DL_BIND_REQ.

@subsubheading Message Format
The message consists of one M_PCPROTO message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_sap;
        ulong dl_addr_length;
        ulong dl_addr_offset;
        ulong dl_max_conind;
        ulong dl_xidtest_flg;
@} dl_bind_ack_t;
@tpindex dl_bind_ack_t
@end example

@subsubheading Parameters

@vtable @var
@item dl_primitive
conveys DL_BIND_ACK.

@item dl_sap
conveys the DLSAP address information associated with the bound DLSAP.  It
corresponds to the dl_sap field of the associated DL_BIND_REQ, which contains
either part or all of the DLSAPaddress.  For that portion of the DLSAP address
conveyed in the DL_BIND_REQ, this field contains the corresponding portion of
the address for the DLSAP that was actually bound.

@item dl_addr_length
conveys the length of the complete DLSAP address that was bound to the DLPI
stream (see section 2.3, DLPI Addressing, for a description of DLSAP addresses).
The bound DLSAP ischosen according to the guidelines presented under the
description of DL_BIND_REQ.

@item dl_addr_offset
conveys the offset from the beginning of the M_PCPROTO block where the DLSAP
address begins.

@item dl_max_conind
conveys the allowed, maximum number of outstanding DL_CONNECT_IND messages to be
supported on the DLPI stream.  If the value is zero, the stream cannot accept
any DL_CONNECT_IND messages.  If greater than zero, the DLS user will accept
DL_CONNECT_IND messages up to the given value before having to respond with
a DL_CONNECT_RES or a DL_DISCONNECT_REQ.  The rules for negotiating this value are
presented under the description of DL_BIND_REQ.

@item dl_xidtest_flg
conveys the XID and TEST responses supported by the provider.
@vtable @var
@item DL_AUTO_XID XID
response handled automatically.
@item DL_AUTO_TEST TEST
response handled automatically.
@end vtable
If no value is specified in dl_xidtest_flg, it indicates that automatic handling
of XID and TESTresponses is not supported by the Provider.

@end vtable

@subsubheading State
The message is valid in state DL_BIND_PENDING.

@subsubheading New State
The resulting state is DL_IDLE.

@page
@node Message DL_UNBIND_REQ (dl_unbind_req_t)
@subsection Message DL_UNBIND_REQ (dl_unbind_req_t)
Requests the DLS provider to unbind the DLSAP that had been bound by a previous
DL_BIND_REQ fromthis stream.  If one or more DLSAPs were bound to the stream
using a DL_SUBS_BIND_REQ, and have not been unbound using a DL_SUBS_UNBIND_REQ,
the DL_UNBIND_REQ will unbind all thesubesquent DLSAPs for that stream along
with the DLSAP bound using the previous DL_BIND_REQ.

At the successful completion of the request, the DLS user may issue a new
DL_BIND_REQ for apotentially new DLSAP.

@subsubheading Message Format
The message consists of one M_PROTO message block, which contains the following
structure.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_unbind_req_t;
@tpindex dl_unbind_req_t
@end example

@subsubheading Parameters

@vtable @var
@item dl_primitive
conveys DL_UNBIND_REQ.
@end vtable

@subsubheading State
The message is valid in state DL_IDLE.

@subsubheading New State
The resulting state is DL_UNBIND_PENDING.

@subsubheading Response
If the unbind request is successful, DL_OK_ACK is sent to the DLS user resulting
in state DL_UNBOUND.

If the request fails, message DL_ERROR_ACK is returned and the resulting state
is unchanged.

@subsubheading Reasons for Failure

@vtable @var
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the DL_ERROR_ACK.
@end vtable


@page
@node Message DL_SUBS_BIND_REQ (dl_subs_bind_req_t)
@subsection Message DL_SUBS_BIND_REQ (dl_subs_bind_req_t)
Requests the DLS provider bind a subsequent DLSAP to the stream.  The DLS user
must identify theaddress of the subsequent DLSAP to be bound to the stream.

@subsubheading Message Format
The message consists of one M_PROTO message block, which contains the following
structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_subs_sap_offset;
        ulong dl_subs_sap_length;
        ulong dl_subs_bind_class;
@} dl_subs_bind_req_t;
@tpindex dl_subs_bind_req_t
@end example


@subsubheading Parameters

@vtable @var
@item dl_primitive
conveys DL_SUBS_BIND_REQ.

@item dl_subs_sap_offset
conveys the offset of the DLSAP from the beginning of the M_PROTO block.

@item dl_subs_sap_length
conveys the length of the specified DLSAP.

@item dl_subs_bind_class
Specifies either peer or hierarchical addressing
@vtable @var
@item DL_PEER_BIND
specifies peer addressing.  The DLSAP specified is used in lieu of the DLSAP bound
in the BIND request.

@item DL_HIERARCHICAL_BIND
specifies hierarchical addressing.  The DLSAP specified is used inaddition to the
DLSAP specified using the BIND request.

@end vtable
@end vtable

@subsubheading State
The message is valid in state DL_IDLE.

@subsubheading New State
The resulting state is DL_SUBS_BIND_PND.

@subsubheading Response
If the subsequent bind request is successful, DL_SUBS_BIND_ACK is sent to the
DLS user resulting instate DL_IDLE.

If the request fails, message DL_ERROR_ACK is returned and the resulting state
is unchanged.

@subsubheading Reasons for Failure

@vtable @var
@item DL_BADADDR
The DLSAP address information was invalid or was in an incorrect format.

@item DL_ACCESS
The DLS user did not have proper permission to use the requested DLSAP address.

@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_SYSERR
A System error has occurred and the UNIX system error is indicated in
the DL_ERROR_ACK.

@item DL_UNSUPPORTED
Requested addressing class not supported.

@item DL_TOOMANY
Limit exceeded on the maximum number of DLSAPs per stream.
@end vtable

@page
@node Message DL_SUBS_BIND_ACK (dl_subs_bind_ack_t)
@subsection Message DL_SUBS_BIND_ACK (dl_subs_bind_ack_t)
Reports the succesful bind of a subsequent DLSAP to a stream, and returns the
bound DLSAP address tothe DLS user.  This primitive is generated in response to a
DL_SUBS_BIND_REQ.

@subsubheading Message Format
The message consists of one M_PCPROTO message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_subs_sap_offset;
        ulong dl_subs_sap_length;
@} dl_subs_bind_ack_t;
@tpindex dl_subs_bind_ack_t
@end example

@subsubheading Parameters

@vtable @var
@item dl_primitive
conveys DL_SUBS_BIND_ACK.
@item dl_subs_sap_offset
conveys the offset of the DLSAP from the beginning of the M_PCPROTO block.
@item dl_subs_sap_length
conveys the length of the specified DLSAP.
@end vtable

@subsubheading State
The message is valid in state DL_SUBS_BIND_PND

@subsubheading New State
The resulting state is DL_IDLE.

@page
@node Message DL_SUBS_UNBIND_REQ (dl_subs_unbind_req_t)
@subsection Message DL_SUBS_UNBIND_REQ (dl_subs_unbind_req_t)
Requests the DLS Provider to unbind the DLSAP that had been bound by a
previous DL_SUBS_BIND_REQ from this stream.

@subsubheading Message Format
The message consists of one M_PROTO message block, which contains the following
structure:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_subs_sap_offset;
        ulong dl_subs_sap_length;
@} dl_subs_unbind_req_t;
@tpindex dl_subs_unbind_req_t
@end example

@subsubheading Parameters

@vtable @var
@item dl_primitive
conveys DL_SUBS_UNBIND_REQ.
@item dl_subs_sap_offset
conveys the offset of the DLSAP from the beginning of the M_PROTO block.
@item dl_subs_sap_length
conveys the length of the specified DLSAP.
@end vtable

@subsubheading State
The message is valid in state DL_IDLE.

@subsubheading New State
The resulting state is DL_SUBS_UNBIND_PND.

@subsubheading Response
If the unbind request is successful, a DL_OK_ACK is sent to the DLS User.  The
resulting state is DL_IDLE.

If the request fails, message DL_ERROR_ACK is returned and the resulting state
is unchanged.

@subsubheading Reasons for failure

@vtable @var
@item DL_OUTSTATE
The primitive was issued from an invalid state
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the DL_ERROR_ACK.
@item DL_BADADDR
The DLSAP address information was invalid or was in an incorrect format.
@end vtable

@page
@node Message DL_ENABMULTI_REQ (dl_enabmulti_req_t)
@subsection Message DL_ENABMULTI_REQ (dl_enabmulti_req_t)
Requests the DLS Provider to enable specific multicast addresses on a per Stream
basis.  It is invalid for a DLS Provider to pass upstream messages that are
destined for any address other than those explicitly enabled on that Stream by
the DLS User.

@subsubheading Message Format
The message consists of one M_PROTO message block, which contains the following
structure:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_addr_length;
        ulong dl_addr_offset;
@} dl_enabmulti_req_t;
@tpindex dl_enabmulti_req_t
@end example

@subsubheading Parameters

@vtable @var
@item dl_primitive
conveys DL_ENABMULTI_REQ
@item dl_addr_length
conveys the length of the multicast address
@item dl_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
multicast address begins
@end vtable

@subsubheading State
This message is valid in any state in which a local acknowledgement is not
pending with the exception of DL_UNATTACH.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the enable request is successful, a DL_OK_ACK is sent to the DLS user.

If the request fails, message DL_ERROR_ACK is returned and the resulting state is
unchanged.

@subsubheading Reasons for failure

@vtable @var
@item DL_BADADDR
Address information was invalid or was in an incorrect format.
@item DL_TOOMANY
Too many multicast address enable attempts.  Limit exceeded.
@item DL_OUTSTATE
The primitive was issued from an invalid state
@item DL_NOTSUPPORTED
The primitive is known, but not supported by the DLS Provider.
@end vtable


@page
@node Message DL_DISABMULTI_REQ (dl_disabmulti_req_t)
@subsection Message DL_DISABMULTI_REQ (dl_disabmulti_req_t)
Requests the DLS Provider to disable specific multicast addresses on a per
Stream basis.

@subsubheading Message Format
The message consists of one M_PROTO message block, which contains the following
structure:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_addr_length;
        ulong dl_addr_offset;
@} dl_disabmulti_req_t;
@tpindex dl_disabmulti_req_t
@end example

@subsubheading Parameters

@vtable @var
@item dl_primitive
conveys DL_DISABMULTI_REQ
@item dl_addr_length
conveys the length of the physical address
@item dl_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
multicast address begins
@end vtable

@subsubheading State
This message is valid in any state in which a local acknowledgement is not
pending with the exception of DL_UNATTACH.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the disable request is successful, a DL_OK_ACK is sent to the DLS user.

If the request fails, message DL_ERROR_ACK is returned and the resulting state is
unchanged.

@subsubheading Reasons for failure
@vtable @var
@item DL_BADADDR
Address information was invalid or in an incorrect format.
@item DL_NOTENAB
Address specified is not enabled.
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_NOTSUPPORTED
Primitive is known, but not supported by the DLS Provider.
@end vtable

@page
@node Message DL_PROMISCON_REQ (dl_promiscon_re q_t)
@subsection Message DL_PROMISCON_REQ (dl_promiscon_re q_t)
This primitive requests the DLS Provider to enable promiscuous mode on a per
Stream basis, either at thephysical level or at the SAP level.

The DL Provider will route all received messages on the media to the DLS User
until either a DL_DETACH_REQ or a DL_PROMISCOFF_REQ is received or the Stream is
closed.

@subsubheading Message Format
The message consists of one M_PROTO message block, which contains the following
structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_level;
@} dl_promiscon_req_t;
@tpindex dl_promiscon_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_PROMISCON_REQ
@item dl_level
indicates promiscuous mode at the physical or SAP level
@vtable @var
@item DL_PROMISC_PHYS
indicates promiscuous mode at the physical level
@item DL_PROMISC_SAP
indicates promiscuous mode at the SAP level
@item DL_PROMISC_MULTI
indicates promiscuous mode for all multicast addresses
@end vtable
@end vtable

@subsubheading State
The message is valid in any state when there is no pending acknowledgement.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If enabling of promiscuous mode is successful, a DL_OK_ACK is returned.
Otherwise, a DL_ERROR_ACK is returned.

@subsubheading Reasons for Failure
@vtable @var
@item DL_OUTSTATE
The primitive was issued from an invalid state
@item DL_SYSERR
A System error has occurred and the UNIX System error is indicated in the DL_ERROR_ACK.
@item DL_NOTSUPPORTED
Primitive is known but not supported by the DLS Provider
@item DL_UNSUPPORTED
Requested service is not supplied by the provider.
@end vtable

@page
@node Message DL_PROMISCOFF_REQ (dl_promiscoff_req_t)
@subsection Message DL_PROMISCOFF_REQ (dl_promiscoff_req_t)
This primitive requests the DLS Provider to disable promiscuous mode on a per
Stream basis, either at thephysical level or at the SAP level.

@subsubheading Message Format
The message consists of one M_PROTO message block, which contains the following
structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_level;
@} dl_promiscoff_req_t;
@tpindex dl_promiscoff_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_PROMISCOFF_REQ
@item dl_level
indicates promiscuous mode at the physical or SAP level
@vtable @var
@item DL_PROMISC_PHYS
indicates promiscuous mode at the physical level
@item DL_PROMISC_SAP
indicates promiscuous mode at the SAP level
@item DL_PROMISC_MULTI
indicates promiscuous mode for all multicast addresses
@end vtable
@end vtable

@subsubheading State
The message is valid in any state in which the promiscuous mode is enabled and
there is no pendingacknowledgement.

@subsubheading New State
The resulting state is unchanged.

@subheading Response
If the promiscuous mode disabling is successful, a DL_OK_ACK is returned.
Otherwise, a DL_ERROR_ACK is returned.

@subsubheading Reasons for Failure
@vtable @var
@item DL_OUTSTATE
The primitive was issued from an invalid state
@item DL_SYSERR
A System error has occurred and the UNIX System error is indicated in the DL_ERROR_ACK.
@item DL_NOTSUPPORTED
Primitive is known but not supported by the DLS Provider
@item DL_NOTENAB Mode not enabled.
@end vtable

@page
@node Message DL_OK_ACK (dl_ok_ack_t)
@subsection Message DL_OK_ACK (dl_ok_ack_t)
Acknowledges to the DLS user that a previously issued request primitive was
received successfully.  It isonly initiated for those primitives that require a
positive acknowledgement.

@subsubheading Message Format
The message consists of one M_PCPROTO message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correct_primitive;
@} dl_ok_ack_t;
@tpindex dl_ok_ack_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_OK_ACK.
@item dl_correct_primitive
identifies the successfully received primitive that is being acknowledged.
@end vtable

@subsubheading State
The message is valid in response to a DL_ATTACH_REQ, DL_DETACH_REQ,
DL_UNBIND_REQ, DL_CONNECT_RES, DL_RESET_RES, DL_DISCON_REQ, DL_SUBS_UNBIND_REQ,
DL_PROMISCON_REQ, DL_ENABMULTI_REQ, DL_DISABMULTI_REQ or DL_PROMISCOFF_REQ from
any of several states as defined in Appendix B.

@subsubheading New State
The resulting state depends on the current state and is defined fully in
Appendix B.

@page
@node Message DL_ERROR_ACK (dl_error_ack_t)
@subsection Message DL_ERROR_ACK (dl_error_ack_t)
Informs the DLS user that a previously issued request or response was invalid.
It conveys the identity ofthe primitive in error, a DLPI error code, and if
appropriate, a UNIX system error code.

Whenever this primitive is generated, it indicates that the DLPI state is
identical to what it was before theerroneous request or response.

@subsubheading Message Format
The message consists of one M_PCPROTO message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_error_primitive;
        ulong dl_errno;
        ulong dl_unix_errno;
@} dl_error_ack_t;
@tpindex dl_error_ack_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_ERROR_ACK.
@item dl_error_prim
identifies the primitive in error.
@item dl_errno
conveys the DLPI error code associated with the failure.  See the individual
request or response for the error codes that are applicable.  In addition to
those errors:
@itemize --
@item DL_BADPRIM
error is returned if an unrecognized primitive is issued by the DLS user.
@item DL_NOTSUPPORTED
error is returned if an unsupported primitive is issued by the DLSuser.
@end itemize
@item dl_unix_errno
conveys the UNIX system error code associated with the failure.  This value
should be non-zeroonly when dl_errno is set to DL_SYSERR.  It is used to report
UNIX system failures that preventthe processing of a given request or response.
@end vtable

@subsubheading State
The message is valid in every state where an acknowledgement or confirmation of
a previous request orresponse is pending.

@subsubheading New State
The resulting state is that from which the acknowledged request or response was
generated.

@page
@node Connection-mode Service Primitives
@section Connection-mode Service Primitives
This section describes the service primitives that support the connection-mode
service of the data linklayer.  These primitives support the connection
establishment, connection-mode data transfer, and connection release services
described earlier.

@menu
* Multi-threaded Connection Establishment::
* Message DL_CONNECT_REQ (dl_connect_req_t)::
* Message DL_CONNECT_IND (dl_connect_ind_t)::
* Message DL_CONNECT_RES (dl_connect_res_t)::
* Message DL_CONNECT_CON (dl_connec t_con_t)::
* Message DL_TOKEN_REQ (dl_token_req_t)::
* Message DL_TOKEN_ACK (dl_token_ack_t)::
* Message DL_DATA_REQ::
* Message DL_DATA_IND::
* Message DL_DISCONNECT_REQ (dl_disconnect_req_t)::
* Message DL_DISCONNECT_IND (dl_disc onnect_ind_t)::
* Message DL_RESET_REQ (dl_re set_req_t)::
* Message DL_RESET_IND (dl_reset_ind_t)::
* Message DL_RESET_RES (dl_reset_res_t)::
* Message DL_RESET_CON (dl_reset_con_t)::
@end menu

@node Multi-threaded Connection Establishment
@subsection Multi-threaded Connection Establishment
In the connection establishment model, the calling DLS user initiates a request
for a connection, and thecalled DLS user receives each request and either
accepts or rejects it.  In the simplest form (singlethreaded), the called DLS
user is passed a connect indication and the DLS provider holds any
subsequentindications until a response for the current outstanding indication is
received.  At most one connect indication is outstanding at any time.

DLPI also enables a called DLS user to multi-thread connect indications and
responses.  This capability isdesirable, for example, when imposing a priority
scheme on all DLS users attempting to establish a connection.  The DLS provider
will pass all connect indications to the called DLS user (up to some
pre-established limit as set by DL_BIND_REQ and DL_BIND_ACK).  The called DLS
user may then respond to the requests in any order.

To support multi-threading, a correlation value is needed to associate responses
with the appropriateconnect indication.  A correlation value is contained in
each DL_CONNECT_IND, and the DLS user must use this value in the DL_CONNECT_RES
or DL_DISCONNECT_REQ primitive used to accept or rejectthe connect request.  The
DLS user can also receive a DL_DISCONNECT_IND with a correlation value when the
calling DLS user or the DLS provider abort a connect request.

Once a connection has been accepted or rejected, the correlation value has no
meaning to a DLS user.  The DLS provider may reuse the correlation value in
another DL_CONNECT_IND.  Thus, the lifetime of a correlation value is the
duration of the connection establishment phase, and as good programming
practiceit should not be used for any other purpose by the DLS provider.

The DLS provider assigns the correlation value for each connect indication.
Correlation values must beunique among all outstanding connect indications on a
given stream.  The values may, but need not, be unique across all streams to the
DLS provider.  The correlation value must be a positive, non-zero value.There is
no implied sequencing of connect indications using the correlation value; the
values do not have to increase sequentially for each new connect indication.

@page
@node Message DL_CONNECT_REQ (dl_connect_req_t)
@subsection Message DL_CONNECT_REQ (dl_connect_req_t)
Requests the DLS provider establish a data link connection with a remote DLS
user.  The request containsthe DLSAP address of the remote (called) DLS user and
quality of service parameters to be negotiated during connection establishment.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_qos_length;
        ulong dl_qos_offset;
        ulong dl_growth;
@} dl_connect_req_t;
@tpindex dl_connect_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_CONNECT_REQ.

@item dl_dest_addr_length
conveys the length of the DLSAP address that identifies the DLS user with whom a
connection is to be established.  If the called user is implemented using DLPI,
this address is the full DLSAPaddress returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_qos_length
conveys the length of the quality of service (QOS) parameter values desired by
the DLS user initiating a connection.  The desired QOS values are conveyed in the
appropriate structuredefined in section 5.3, QOS Data Structures.  A full
specification of these QOS parameters andrules for negotiating their values is
presented in section 5, Quality of Data Link Service.

If the DLS user does not wish to specify a particular QOS value, the
value DL_QOS_DONT_CARE may be specified.  If the DLS user does not care to specify
any QOS parameter values, this field may be set to zero.

@item dl_qos_offset
conveys the offset from the beginning of the M_PROTO message block where the
quality of service parameters begin.

@item dl_growth
defines a growth field for future enhancements to this primitive.  Its value must
be set to zero.

@end vtable

@subsubheading State
The message is valid in state DL_IDLE.

@subsubheading New State
The resulting state is DL_OUTCON_PENDING.

@subsubheading Response
There is no immediate response to the connect request.  However, if the connect
request is accepted by thecalled DLS user, DL_CONNECT_CON is sent to the calling
DLS user, resulting in state DL_DATAXFER.

If the connect request is rejected by the called DLS user, the called DLS user
cannot be reached, or the DLS provider and/or called DLS user do not agree on the
specified quality of service, a DL_DISCONNECT_IND is sent to the calling DLS
user, resulting in state DL_IDLE.

If the request is erroneous, message DL_ERROR_ACK is returned and the resulting
state is unchanged.

@subsubheading Reasons for Failure
@vtable @var
@item DL_BADADDR
The destination DLSAP address was in an incorrect format or contained
invalidinformation.
@item DL_BADQOSPARAM
The quality of service parameters contained invalid values.
@item DL_BADQOSTYPE
The quality of service structure type was not supported by the DLS provider.
@item DL_ACCESS
The DLS user did not have proper permission to use the requested DLSAP address.
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the DL_ERROR_ACK.
@end vtable


@page
@node Message DL_CONNECT_IND (dl_connect_ind_t)
@subsection Message DL_CONNECT_IND (dl_connect_ind_t)
Conveys to the local DLS user that a remote (calling) DLS user wishes to
establish a data link connection.The indication contains the DLSAP address of
the calling and called DLS user, and the quality of service parameters as
specified by the calling DLS user and negotiated by the DLS provider.

The DL_CONNECT_IND also contains a number that allows the DLS user to correlate
a subsequent DL_CONNECT_RES, DL_DISCONNECT_REQ, or DL_DISCONNECT_IND with the
indication (see section 4.2.1, Multi-threaded Connection Establishment).

The number of outstanding DL_CONNECT_IND primitives issued by the DLS provider
must not exceedthe value of dl_max_conind as returned on the DL_BIND_ACK.  If
this limit is reached and an additionalconnect request arrives, the DLS provider
must not pass the corresponding connect indication to the DLS user until a
response is received for an already outstanding indication.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_called_addr_length;
        ulong dl_called_addr_offset;
        ulong dl_calling_addr_length;
        ulong dl_calling_addr_offset;
        ulong dl_qos_length;
        ulong dl_qos_offset;
        ulong dl_growth;
@} dl_connect_ind_t;
@tpindex dl_connect_ind_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_CONNECT_IND.

@item dl_correlation
conveys the correlation number to be used by the DLS user to associate this
message with the DL_CONNECT_RES, DL_DISCONNECT_REQ, or DL_DISCONNECT_IND that is
to follow.This value, then, enables the DLS user to multi-thread connect
indications and responses.  All outstanding connect indications must have a
distinct, non-zero correlation value set by the DLSprovider.

@item dl_called_addr_length
conveys the length of the address of the DLSAP for which this DL_CONNECT_IND
primitive is intended.  This address is the full DLSAP address specified by the
calling DLS user and istypically the value returned on the DL_BIND_ACK
associated with the given stream.

@item dl_called_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
called DLSAP address begins.

@item dl_calling_addr_length
conveys the length of the address of the DLSAP from which the DL_CONNECT_REQ
primitive was sent.

@item dl_calling_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
calling DLSAP address begins.

@item dl_qos_length
conveys the range of quality of service parameter values desired by the calling
DLS user and negotiated by the DLS provider.  The range of QOS values is conveyed
in the appropriatestructure defined in section 5.3, QOS Data Structures.  A full
specification of these QOSparameters and rules for negotiating their values is
presented in section 5, Quality of Data Link Service.

For any parameter the DLS provider does not support or cannot determine, the
correspondingparameter values will be set to DL_UNKNOWN.  If the DLS provider
does not support any QOS parameters, this length field will be set to zero.

@item dl_qos_offset
conveys the offset from the beginning of the M_PROTO message block where the
quality of service parameters begin.

@item dl_growth
defines a growth field for future enhancements to this primitive.  Its value will
be set to zero.
@end vtable

@subsubheading State
The message is valid in state DL_IDLE, or state DL_INCON_PENDING when the
maximum number ofoutstanding DL_CONNECT_IND primitives has not been reached on
this stream.

@subsubheading New State
The resulting state is DL_INCON_PENDING, regardless of the current state.

@subsubheading Response
The DLS user must eventually send either DL_CONNECT_RES to accept the connect
request or DL_DISCONNECT_REQ to reject the connect request.  In either case, the
responding message must convey the correlation number received in the
DL_CONNECT_IND.  The DLS provider will use thecorrelation number to identify the
connect request to which the DLS user is responding.

@page
@node Message DL_CONNECT_RES (dl_connect_res_t)
@subsection Message DL_CONNECT_RES (dl_connect_res_t)
Directs the DLS provider to accept a connect request from a remote (calling) DLS
user on a designatedstream.  The DLS user may accept the connection on the same
stream where the connect indication arrived, or on a different stream that has
been previously bound.  The response contains the correlationnumber from the
corresponding DL_CONNECT_IND, selected quality of service parameters, and an
indication of the stream on which to accept the connection.

After issuing this primitive, the DLS user may immediately begin transferring
data using the DL_DATA_REQ primitive.  If the DLS provider receives one or more
DL_DATA_REQ primitives from the local DLS user before it has completed
connection establishment, however, it must queue the datatransfer requests
internally until the connection is successfully established.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_resp_token;
        ulong dl_qos_length;
        ulong dl_qos_offset;
        ulong dl_growth;
@} dl_connect_res_t;
@tpindex dl_connect_res_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_CONNECT_RES.

@item dl_correlation
conveys the correlation number that was received with the DL_CONNECT_IND
associated with the connection request.  The DLS provider will use the
correlation number to identify the connectindication to which the DLS user is
responding.

@item dl_resp_token
if non-zero, conveys the token associated with the responding stream on which
the DLS provider is to establish the connection; this stream must be in the
state DL_IDLE.  The token value for astream can be obtained by issuing a
DL_TOKEN_REQ on that stream.  If the DLS user is accepting the connection on the
stream where the connect indication arrived, this value must bezero.  See section
2.2.1.2, Connection Establishment, for a description of the connection
responsemodel.

@item dl_qos_length
conveys the length of the quality of service parameter values selected by the
called DLS user.  The selected QOS values are conveyed in the appropriate
structure as defined in section 5.3, QOS Data Structures.  A full specification
of these QOS parameters and rules for negotiating theirvalues is presented in
section 5, Quality of Data Link Service.

If the DLS user does not care which value is selected for a particular QOS
parameter, the value DL_QOS_DONT_CARE may be specified.  If the DLS user does not
care which values are selected for all QOS parameters, this field may be set to
zero.

@item dl_qos_offset
conveys the offset from the beginning of the M_PROTO message block where the
quality of service parameters begin.

@item dl_growth
defines a growth field for future enhancements to this primitive.  Its value must
be set to zero.
@end vtable

@subsubheading State
The primitive is valid in state DL_INCON_PENDING.

@subsubheading New State
The resulting state is DL_CONN_RES_PENDING.

@subsubheading Response
If the connect response is successful, DL_OK_ACK is sent to the DLS user.  If no
outstanding connectindications remain, the resulting state for the current
stream is DL_IDLE; otherwise it remains DL_INCON_PENDING.  For the responding
stream (designated by the parameter dl_resp_token), theresulting state is
DL_DATAXFER.  If the current stream and responding stream are the same, the
resulting state of that stream is DL_DATAXFER.  These streams may only be the
same when the responsecorresponds to the only outstanding connect indication.

If the request fails, DL_ERROR_ACK is returned on the stream where the
DL_CONNECT_RES primitivewas received, and the resulting state of that stream and
the responding stream is unchanged.

@subsubheading Reasons for Failure
@vtable @var
@item DL_BADTOKEN
The token for the responding stream was not associated with a currently open
stream.
The quality of service parameters contained invalid values.
@item DL_BADQOSTYPE
The quality of service structure type was not supported by the DLS provider.
@item DL_BADCORR
The correlation number specified in this primitive did not correspond to a
pendingconnect indication.
@item DL_ACCESS
The DLS user did not have proper permission to use the responding stream.
@item DL_OUTSTATE
The primitive was issued from an invalid state, or the responding stream was not
in avalid state for establishing a connection.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the DL_ERROR_ACK.
@item DL_PENDING
Current stream and responding stream is the same and there is more than
oneoutstanding connect indication.
@end vtable

@page
@node Message DL_CONNECT_CON (dl_connec t_con_t)
@subsection Message DL_CONNECT_CON (dl_connec t_con_t)
Informs the local DLS user that the requested data link connection has been
established.  The primitivecontains the DLSAP address of the responding DLS user
and the quality of service parameters as selected by the responding DLS user.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_resp_addr_length;
        ulong dl_resp_addr_offset;
        ulong dl_qos_length;
        ulong dl_qos_offset;
        ulong dl_growth;
@} dl_connect_con_t;
@tpindex dl_connect_con_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_CONNECT_CON.

@item dl_resp_addr_length
conveys the length of the address of the responding DLSAP associated with the
newly established data link connection.

@item dl_resp_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
responding DLSAP address begins.

@item dl_qos_length
conveys the length of the quality of service parameter values selected by the
responding DLS user.  The selected QOS values are conveyed in the appropriate
structure defined in section 5.3, QOS Data Structures.  A full specification of
these QOS parameters and rules for negotiatingtheir values is presented in
section 5, Quality of Data Link Service.

For any parameter the DLS provider does not support or cannot determine, the
correspondingparameter value will be set to DL_UNKNOWN.  If the DLS provider does
not support any QOS parameters, this length field will be set to zero.

@item dl_qos_offset
conveys the offset from the beginning of the M_PROTO message block where the
quality of service parameters begin.

@item dl_growth
defines a growth field for future enhancements to this primitive.  Its value will
be set to zero.

@end vtable

@subsubheading State
The message is valid in state DL_OUTCON_PENDING.

@subsubheading New State
The resulting state is DL_DATAXFER.


@node Message DL_TOKEN_REQ (dl_token_req_t)
@subsection Message DL_TOKEN_REQ (dl_token_req_t)
Requests that a connection response token be assigned to the stream and returned
to the DLS user.  This token can be supplied in the DL_CONNECT_RES primitive to
indicate the stream on which a connection will be established.  Message Format
The message consists of one M_PCPROTO message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_token_req_t;
@tpindex dl_token_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_TOKEN_REQ.
@end vtable

@subsubheading State
The message is valid in any state in which a local acknowledgement is not
pending, as described inAppendix B, Allowable Sequence of DLPI Primitives.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
The DLS provider responds to the information request with a DL_TOKEN_ACK.

@page
@node Message DL_TOKEN_ACK (dl_token_ack_t)
@subsection Message DL_TOKEN_ACK (dl_token_ack_t)
This message is sent in response to DL_TOKEN_REQ; it conveys the connection
response token assignedto the stream.

@subsubheading Message Format
The message consists of one M_PCPROTO message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_token;
@} dl_token_ack_t;
@tpindex dl_token_ack_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_TOKEN_ACK.
@item dl_token
conveys the connection response token associated with the stream.  This value
must be a non-zero value.  The DLS provider will generate a token value for each
stream upon receipt of the first DL_TOKEN_REQ primitive issued on that stream.
The same token value will be returned in response to all subsequent DL_TOKEN_REQ
primitives issued on a stream.
@end vtable

@subsubheading State
The message is valid in any state in response to a DL_TOKEN_REQ.

@subsubheading New State
The resulting state is unchanged.


@page
@node Message DL_DATA_REQ
@subsection Message DL_DATA_REQ
Conveys a complete DLSDU from the DLS user to the DLS provider for transmission
over the data linkconnection.

The DLS provider guarantees to deliver each DLSDU to the remote DLS user in the
same order asreceived from the local DLS user.  If the DLS provider detects
unrecoverable data loss during data transfer, this may be indicated to the DLS
user by a DL_RESET_IND, or by a DL_DISCONNECT_IND (ifthe connection is lost).

@subsubheading Message Format
The message consists of one or more M_DATA message blocks containing at least
one byte of data.

To simplify support of a read(2)/write(2) interface to the data link layer, the
DLS provider must recognizeand process messages that consist of one or more
M_DATA message blocks with no preceding M_PROTO message block.  This message type
may originate from the write(2) system call.@footnote{This does not imply that
DLPI will directly support a pure read(2)/write(2).  If such an interface is
desired, a STREAMS modulecould be implemented to be pushed above the DLS
provider.}

@subsubheading State
The message is valid in state DL_DATAXFER.  If it is received in state DL_IDLE
or DL_PROV_RESET_PENDING, it should be discarded without generating an error.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the request is valid, no response is generated.

If the request is erroneous, a STREAMS M_ERROR message should be issued to the
DLS user specifyingan errno value of EPROTO.  This action should be interpreted
as a fatal, unrecoverable, protocol error.  Arequest is considered erroneous
under the following conditions.

@itemize --
@item The primitive was issued from an invalid state.  If the request is issued
in state DL_IDLE or DL_PROV_RESET_PENDING, however, it is silently discarded with
no fatal error generated.
@item The amount of data in the current DLSDU is not within the DLS provider's
acceptable bounds asspecified by dl_min_sdu and dl_max_sdu in the DL_INFO_ACK.
@end itemize

@subsubheading Note (Support of Direct User-Level Access)
A STREAMS module would implement "more" field processing itself to support
direct user-level access.This module could collect messages and send them in one
larger message to the DLS provider, or break large DLSDUs passed to the DLS user
into smaller messages.  The module would only be pushed if the DLS user was a
user-level process.


@page
@node Message DL_DATA_IND
@subsection Message DL_DATA_IND
Conveys a DLSDU from the DLS provider to the DLS user.  The DLS provider
guarantees to deliver each DLSDU to the local DLS user in the same order as
received from the remote DLS user.  If the DLS provider detects unrecoverable
data loss during data transfer, this may be indicated to the DLS user by
a DL_RESET_IND, or by a DL_DISCONNECT_IND (if the connection is lost).

@subsubheading Message Format
The message consists of one or more M_DATA blocks containing at least one byte
of data.

@subsubheading State
The message is valid in state DL_DATAXFER.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_DISCONNECT_REQ (dl_disconnect_req_t)
@subsection Message DL_DISCONNECT_REQ (dl_disconnect_req_t)
Requests the DLS provider to disconnect an active data link connection or one
that was in the process ofactivation, either outgoing or incoming, as a result
of an earlier DL_CONNECT_IND or DL_CONNECT_REQ.  If an incoming DL_CONNECT_IND is
being refused, the correlation numberassociated with that connect indication
must be supplied.  The message indicates the reason for the disconnect.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_reason;
        ulong dl_correlation;
@} dl_disconnect_req_t;
@tpindex dl_disconnect_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_DISCONNECT_REQ.
@item dl_reason
conveys the reason for the disconnect.
@subsubheading Reasons for Disconnect
@vtable @var
@item DL_DISC_NORMAL_CONDITION
normal release of a data link connection
@item DL_DISC_ABNORMAL_CONDITION
abnormal release of a data link connection
@item DL_CONREJ_PERMANENT_COND
a permanent condition caused the rejection of a connect request
@item DL_CONREJ_TRANSIENT_COND
a transient condition caused the rejection of a connect request
@item DL_DISC_UNSPECIFIED
reason unspecified
@end vtable

@item dl_correlation
if non-zero, conveys the correlation number that was contained in the
DL_CONNECT_IND being rejected (see section 4.2.1, Multi-threaded Connection
Establishment).  This value permits the DLS provider to associate the primitive
with the proper DL_CONNECT_IND when rejecting an incoming connection.  If the
disconnect request is releasing a connection that is alreadyestablished, or is
aborting a previously sent DL_CONNECT_REQ, the value of dl_correlationshould be
zero.
@end vtable


@subsubheading State
The message is valid in any of the states: DL_DATAXFER,
DL_INCON_PENDING, DL_OUTCON_PENDING, DL_PROV_RESET_PENDING,
DL_USER_RESET_PENDING.

@subsubheading New State
The resulting state is one of the disconnect pending states, as defined in
Appendix B.

@subsubheading Response
If the disconnect is successful, DL_OK_ACK is sent to the DLS user resulting in
state DL_IDLE.

If the request fails, message DL_ERROR_ACK is returned, and the resulting state
is unchanged.

@subsubheading Reasons for Failure
@vtable @var
@item DL_BADCORR
The correlation number specified in this primitive did not correspond to a
pendingconnect indication.

@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the DL_ERROR_ACK.

@end vtable


@page
@node Message DL_DISCONNECT_IND (dl_disc onnect_ind_t)
@subsection Message DL_DISCONNECT_IND (dl_disc onnect_ind_t)
Informs the DLS user that the data link connection on this stream has been
disconnected, or that a pendingconnection (either DL_CONNECT_REQ or
DL_CONNECT_IND) has been aborted.

The primitive indicates the origin and the cause of the disconnect.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_originator;
        ulong dl_reason;
        ulong dl_correlation;
@} dl_disconnect_ind_t;
@tpindex dl_disconnect_ind_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_DISCONNECT_IND.

@item dl_originator
conveys whether the disconnect was DLS user or DLS provider originated (DL_USER
or DL_PROVIDER, respectively).

@item dl_reason
conveys the reason for the disconnect.

@subsubheading Reasons for Disconnect

@vtable @var
@item DL_DISC_PERMANENT_CONDITION
connection released due to permanent condition

@item DL_DISC_TRANSIENT_CONDITION
connection released due to transient condition

@item DL_CONREJ_DEST_UNKNOWN
unknown destination for connect request

@item DL_CONREJ_DEST_UNREACH_PERMANENT
could not reach destination for connect request - permanent condition

@item DL_CONREJ_DEST_UNREACH_TRANSIENT
could not reach destination for connect request - transient condition

@item DL_CONREJ_QOS_UNAVAIL_PERMANENT
requested quality of service parameters permanently unavailable during
connection establishment

@item DL_CONREJ_QOS_UNAVAIL_TRANSIENT
requested quality of service parameters temporarily unavailable during
connection establishment

@item DL_DISC_UNSPECIFIED
reason unspecified
@end vtable

@item dl_correlation
if non-zero, conveys the correlation number that was contained in the
DL_CONNECT_IND that is being aborted (see section 4.2.1, Multi-threaded
Connection Establishment).  This valuepermits the DLS user to associate the
message with the proper DL_CONNECT_IND.  If the disconnect indication is
indicating the release of a connection that is already established, or
is indicating the rejection of a previously sent DL_CONNECT_REQ, the value of
dl_correlation will be zero.
@end vtable

@subsubheading State
The message is valid in any of the states: DL_DATAXFER,
DL_INCON_PENDING, DL_OUTCON_PENDING, DL_PROV_RESET_PENDING,
DL_USER_RESET_PENDING.

@subsubheading New State
The resulting state is DL_IDLE.

@page
@node Message DL_RESET_REQ (dl_re set_req_t)
@subsection Message DL_RESET_REQ (dl_re set_req_t)
Requests that the DLS provider initiate the resynchronization of a data link
connection.  This service isabortive, so no guarantee of delivery can be assumed
about data that is in transit when the reset request is initiated.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_reset_req_t;
@tpindex dl_reset_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_RESET_REQ.
@end vtable

@subsubheading State
The message is valid in state DL_DATAXFER.  New State The resulting state is
DL_USER_RESET_PENDING.

@subsubheading Response
There is no immediate response to the reset request.  However, as
resynchronization completes, DL_RESET_CON is sent to the initiating DLS user,
resulting in state DL_DATAXFER.

If the request fails, message DL_ERROR_ACK is returned and the resulting state
is unchanged.

@subsubheading Reasons for Failure
@vtable @var
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in the DL_ERROR_ACK.
@end vtable

@page
@node Message DL_RESET_IND (dl_reset_ind_t)
@subsection Message DL_RESET_IND (dl_reset_ind_t)
Informs the DLS user that either the remote DLS user is resynchronizing the data
link connection, or the DLS provider is reporting loss of data for which it can
not recover.  The indication conveys the reason for the reset.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_originator;
        ulong dl_reason;
@} dl_reset_ind_t;
@tpindex dl_reset_ind_t
@end example

@subsubheading Parameters
@vtable @var

@item dl_primitive
conveys DL_RESET_IND.

@item dl_originator
conveys whether the reset was originated by the DLS user or DLS provider
(DL_USER or DL_PROVIDER, respectively).

@item dl_reason
conveys the reason for the reset.

@subsubheading Reasons for Reset

@vtable @var

@item DL_RESET_FLOW_CONTROL
indicates flow control congestion

@item DL_RESET_LINK_ERROR
indicates a data link error situation

@item DL_RESET_RESYNCH
indicates a request for resynchronization of a data link connection.

@end vtable
@end vtable

@subsubheading State
The message is valid in state DL_DATAXFER.

@subsubheading New State
The resulting state is DL_PROV_RESET_PENDING.

@subsubheading Response
The DLS user should issue a DL_RESET_RES primitive to continue the
resynchronization procedure.

@page
@node Message DL_RESET_RES (dl_reset_res_t)
@subsection Message DL_RESET_RES (dl_reset_res_t)
Directs the DLS provider to complete resynchronizing the data link connection.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_reset_res_t;
@tpindex dl_reset_res_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_RESET_RES.
@end vtable

@subsubheading State
The primitive is valid in state DL_PROV_RESET_PENDING.

@subsubheading New State
The resulting state is DL_RESET_RES_PENDING.

@subsubheading Response
If the reset response is successful, DL_OK_ACK is sent to the DLS user resulting
in state DL_DATAXFER.

If the reset response is erroneous, DL_ERROR_ACK is returned and the resulting
state is unchanged.

@subsubheading Reasons for Failure
@vtable @var
@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the DL_ERROR_ACK.

@end vtable


@page
@node Message DL_RESET_CON (dl_reset_con_t)
@subsection Message DL_RESET_CON (dl_reset_con_t)
Informs the reset-initiating DLS user that the reset has completed.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_reset_con_t;
@tpindex dl_reset_con_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_RESET_CON.
@end vtable

@subsubheading State
The message is valid in state DL_USER_RESET_PENDING.

@subsubheading New State
The resulting state is DL_DATAXFER.

@page
@node Connectionless-mode Service Primitives
@section Connectionless-mode Service Primitives
This section describes the primitives that support the connectionless-mode
service of the data link layer.These primitives support the connectionless data
transfer service described earlier.

@menu
* Message DL_UNITDATA_REQ (dl_unitdata_req_t)::
* Message DL_UNITDATA_IND (dl_unitdata_ind_t)::
* Message DL_UDERROR_IND (dl_uderror_ind_t)::
* Message DL_UDQOS_REQ (dl_udqos_req_t)::
@end menu

@page
@node Message DL_UNITDATA_REQ (dl_unitdata_req_t)
@subsection Message DL_UNITDATA_REQ (dl_unitdata_req_t)
Conveys one DLSDU from the DLS user to the DLS provider for transmission to a
peer DLS user.

Because connectionless data transfer is an unacknowledged service, the DLS
provider makes noguarantees of delivery of connectionless DLSDUs.  It is the
responsibility of the DLS user to do any necessary sequencing or retransmission
of DLSDUs in the event of a presumed loss.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below, followed byone or more M_DATA blocks containing at least one byte of
data.  The amount of user data that may be transferred in a single DLSDU is
limited.  This limit is conveyed by the parameter dl_max_sdu in the DL_INFO_ACK
primitive.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        dl_priority_t dl_priority;
@} dl_unitdata_req_t;
@tpindex dl_unitdata_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_UNITDATA_REQ.

@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS user.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_priority
indicates the priority value within the supported range for this particular DLSDU.

@end vtable

@subsubheading State
The message is valid in state DL_IDLE.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the DLS provider accepts the data for transmission, there is no response.
This does not, however,guarantee that the data will be delivered to the
destination DLS user, since the connectionless data transfer is not a confirmed
service.

If the request is erroneous, message DL_UDERROR_IND is returned, and the
resulting state is unchanged.

If for some reason the request cannot be processed, the DLS provider may
generate a DL_UDERROR_IND to report the problem.  There is, however, no guarantee
that such an error report will be generated for all undeliverable data units,
since connectionless data transfer is not a confirmed service.

@subsubheading Reasons for Failure
@vtable @var
@item DL_BADADDR
The destination DLSAP address was in an incorrect format or contained
invalidinformation.

@item DL_BADDATA
The amount of data in the current DLSDU exceeded the DLS provider's DLSDU limit.

@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_UNSUPPORTED
Requested priority not supplied by provider.

@end vtable

@page
@node Message DL_UNITDATA_IND (dl_unitdata_ind_t)
@subsection Message DL_UNITDATA_IND (dl_unitdata_ind_t)
Conveys one DLSDU from the DLS provider to the DLS user.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below, followed byone or more M_DATA blocks containing at least one byte of
data.  The amount of user data that may be transferred in a single DLSDU is
limited.  This limit is conveyed by the parameter dl_max_sdu in the DL_INFO_ACK
primitive.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
        ulong dl_group_address;
@} dl_unitdata_ind_t;
@tpindex dl_unitdata_ind_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_UNITDATA_IND.

@item dl_dest_addr_length
conveys the length of the address of the DLSAP where this DL_UNITDATA_IND is
intended to be delivered.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_src_addr_length
conveys the length of the DLSAP address of the sending DLS user.

@item dl_src_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
source DLSAP address begins.

@item dl_group_address
is set by the DLS Provider upon receiving and passing upstream a data message
when the destination address of the data message is a multicast or broadcast
address.

@end vtable

@subsubheading State
The message is valid in state DL_IDLE.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_UDERROR_IND (dl_uderror_ind_t)
@subsection Message DL_UDERROR_IND (dl_uderror_ind_t)
Informs the DLS user that a previously sent DL_UNITDATA_REQ produced an error or
could not bedelivered.  The primitive indicates the destination DLSAP address
associated with the failed request, and conveys an error value that specifies
the reason for failure.

@subsubheading Message Format
The message consists of either one M_PROTO message block or one M_PCPROTO
message blockcontaining the structure shown below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_unix_errno;
        ulong dl_errno;
@} dl_uderror_ind_t;
@tpindex dl_uderror_ind_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_UDERROR_IND.

@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS user.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_unix_errno
conveys the UNIX system error code associated with the failure.  This value
should be non-zero only when dl_errno is set to DL_SYSERR.  It is used to report
UNIX system failures that preventthe processing of a given request.

@item dl_errno
conveys the DLPI error code associated with the failure.  See Reasons for Failure
in the description of DL_UNITDATA_REQ for the error codes that apply to an
erroneous DL_UNITDATA_REQ.  In addition, the error value DL_UNDELIVERABLE may be
returned if the request was valid but for some reason the DLS provider could not
deliver the data unit (e.g.due to lack of sufficient local buffering to store
the data unit).  There is, however, no guarantee that such an error report will
be generated for all undeliverable data units, since connectionlessdata transfer
is not a confirmed service.

@end vtable

@subsubheading State
The message is valid in state DL_IDLE.
@subsubheading New State
The resulting state is unchanged.


@page
@node Message DL_UDQOS_REQ (dl_udqos_req_t)
@subsection Message DL_UDQOS_REQ (dl_udqos_req_t)
Requests the DLS provider to apply the specified quality of service parameter
values to subsequent dataunit transmissions.  These new values will remain in
effect until another DL_UDQOS_REQ is issued.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_qos_length;
        ulong dl_qos_offset;
@} dl_udqos_req_t;
@tpindex dl_udqos_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_UDQOS_REQ.

@item dl_qos_length
conveys the length, in bytes, of the requested quality of service parameter
values.  The values are conveyed in the appropriate structure defined in section
5.3, QOS Data Structures.  The availablerange of QOS values that may be selected
is specified by the dl_qos_range_length and dl_qos_range_offset parameters in
the DL_INFO_ACK primitive.

For any parameter whose value the DLS user does not wish to select, the
value DL_QOS_DONT_CARE may be set and the DLS provider will maintain the current
value for that parameter.  See section 5, Quality of Data Link Service, for a
full description of the quality ofservice parameters.

@item dl_qos_offset
conveys the offset from the beginning of the M_PROTO message block where the
quality of service parameters begin.

@end vtable

@subsubheading State
The message is valid in state DL_IDLE.

@subsubheading New State
The resulting state is DL_UDQOS_PENDING.

@subsubheading Response
If the quality of service request is successful, DL_OK_ACK is sent to the DLS
user and the resulting stateis DL_IDLE.

If the request fails, message DL_ERROR_ACK is returned and the resulting state
is unchanged.

@subsubheading Reasons for Failure
@vtable @var
@item DL_BADQOSPARAM
The quality of service parameters contained values outside the range of those
supportedby the DLS provider.

@item DL_BADQOSTYPE
The quality of service structure type was not supported by the DLS provider.

@item DL_OUTSTATE
The primitive was issued from an invalid state.

@end vtable

@page
@node Primitives to handle XID and TEST operations
@section Primitives to handle XID and TEST operations

@menu
* Message DL_TEST_REQ (dl_test_req_t)::
* Message DL_TEST_IND (dl_test_ind_t)::
* Message DL_TEST_RES (dl_test_res_t)::
* Message DL_TEST_CON (dl_test_con_t)::
* Message DL_XID_REQ (dl_xid_req_t)::
* Message DL_XID_IND (dl_xid_ind_t)::
* Message DL_XID_RES (dl_xid_res_t)::
* Message DL_XID_CON (dl_xid_con_t)::
@end menu

This section describes the service primitives that support the XID and TEST
operations.  The DLS User canissue these primitives to the DLS Provider
requesting the provider to send an XID or a TEST frame.  On receipt of an XID or
TEST frame from the remote side, the DLS Provider can send the
appropriateindication to the User.

@page
@node Message DL_TEST_REQ (dl_test_req_t)
@subsection Message DL_TEST_REQ (dl_test_req_t)
Conveys one TEST command DLSDU from the DLS User to the DLS Provider for
transmission to a peer DLS Provider.

@subsubheading Message Format
The message consists of one M_PROTO message block, followed by zero or more
M_DATA blockscontaining zero or more bytes of data.  The message structure is as
follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
@} dl_test_req_t;
@tpindex dl_test_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_TEST_REQ

@item dl_flag
indicates flag values for the request as follows:

@vtable @var
@item DL_POLL_FINAL
indicates if the poll/final bit is set.

@end vtable
@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@end vtable

@subsubheading State
The message is valid in states DL_IDLE and DL_DATAXFER.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
On an invalid TEST command request, a DL_ERROR_ACK is issued to the user.  If the
DLS Providerreceives a response from the remote side, a DL_TEST_CON is issued to
the DLS User.  It is recommended that the DLS User use a timeout procedure to
recover from a situation when there is no response from thepeer DLS User.

@subsubheading Reasons for failure
@vtable @var
@item DL_OUTSTATE
The primitive was issued from an invalid state

@item DL_BADADDR
The DLSAP address information was invalid or was in an incorrect format.

@item DL_SYSERR
A System error has occurred and the UNIX System error is indicated in
the DL_ERROR_ACK.

@item DL_NOTSUPPORTED
Primitive is known but not supported by the DLS Provider

@item DL_TESTAUTO
Previous bind request specified automatic handling of TEST responses.

@item DL_UNSUPPORTED
Requested service not supplied by provider.

@end vtable

@page
@node Message DL_TEST_IND (dl_test_ind_t)
@subsection Message DL_TEST_IND (dl_test_ind_t)
Conveys the TEST response/indication DLSDU from the DLS Provider to the DLS
User.

@subsubheading Message Format
The message consists of one M_PROTO message block, followed by zero or more
M_DATA blockscontaining zero or more bytes of data.  The message structure is as
follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
@} dl_test_ind_t;
@tpindex dl_test_ind_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_TEST_IND

@item dl_flag
indicates the flag values associated with the received TEST frame:

@vtable @var
@item DL_POLL_FINAL
indicates if the poll/final bit is set.

@end vtable
@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_src_addr_length
conveys the length of the source DLSAP address.  If the source user is
implemented using DLPI, this address if the full DLSAP address returned on the
DL_BIND_ACK.

@item dl_src_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
source DLSAP address begins.

@end vtable

@subsubheading State
The message is valid in states DL_IDLE and DL_DATAXFER.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_TEST_RES (dl_test_res_t)
@subsection Message DL_TEST_RES (dl_test_res_t)
Conveys the TEST response DLSDU from the DLS User to the DLS Provider in
response to a DL_TEST_IND.

@subsubheading Message Format
The message consists of one M_PROTO message block, followed by zero or more
M_DATA blockscontaining zero or more bytes of data.  The message structure is as
follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
@} dl_test_res_t;
@tpindex dl_test_res_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_TEST_RES

@item dl_flag
indicates the flag values for the response as follows:

@vtable @var
@item DL_POLL_FINAL
indicates if the poll/final bit is set.

@end vtable
@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@end vtable

@subsubheading State
The message is valid in states DL_IDLE and DL_DATAXFER.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_TEST_CON (dl_test_con_t)
@subsection Message DL_TEST_CON (dl_test_con_t)
Conveys the TEST response DLSDU from the DLS Provider to the DLS User in
response to a DL_TEST_REQ.

@subsubheading Message Format
The message consists of one M_PROTO message block, followed by zero or more
M_DATA blockscontaining zero or more bytes of data.  The message structure is as
follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
@} dl_test_con_t;
@tpindex dl_test_con_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_TEST_RES

@item dl_flag
indicates the flag values for the request as follows:

@vtable @var
@item DL_POLL_FINAL
indicates if the poll/final bit is set.

@end vtable
@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_src_addr_length
conveys the length of the source DLSAP address.  If the source user is
implemented using DLPI, this address is the full DLSAP address returned on the
DL_BIND_ACK.

@item dl_src_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
source DLSAP address begins.

@end vtable

@subsubheading State
The message is valid in states DL_IDLE and DL_DATAXFER.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_XID_REQ (dl_xid_req_t)
@subsection Message DL_XID_REQ (dl_xid_req_t)
Conveys one XID DLSDU from the DLS User to the DLS Provider for transmission to
a peer DLS User.

@subsubheading Message Format
The message consists of one M_PROTO message block, followed by zero or more
M_DATA blockscontaining zero or more bytes of data.  The message structure is as
follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
@} dl_xid_req_t;
@tpindex dl_xid_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitiveconveys
DL_XID_REQ

@item dl_flag
indicates the flag values for the response as follows:

@vtable @var
@item DL_POLL_FINAL
indicates status of the poll/final bit in the xid frame.

@end vtable
@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@end vtable

@subsubheading State
The message is valid in state DL_IDLE and DL_DATAXFER.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
On an invalid XID request, a DL_ERROR_ACK is issued to the user.  If the remote
side responds to theXID request, a DL_XID_CON will be sent to the User.  It is
recommended that the DLS User use a timeout procedure on an XID_REQ.  The timeout
may be used if the remote side does not respond to the XIDrequest.

@subsubheading Reasons for failure
@vtable @var
@item DL_BADDATA
The amount of data in the current DLSDU exceeded the DLS Provider's DLSDU limit.

@item DL_XIDAUTO
Previous bind request specified Provider would handle XID.

@item DL_OUTSTATE
The primitive was issued from an invalid state

@item DL_BADADDR
The DLSAP address information was invalid or was in an incorrect format.

@item DL_SYSERR
A System error has occurred and the UNIX System error is indicated in
the DL_ERROR_ACK.

@item DL_NOTSUPPORTED
Primitive is known but not supported by the DLS Provider

@end vtable

@page
@node Message DL_XID_IND (dl_xid_ind_t)
@subsection Message DL_XID_IND (dl_xid_ind_t)
Conveys an XID DLSDU from the DLS Provider to the DLS User.

@subsubheading Message Format
The message consists of one M_PROTO message block, followed by zero or more
M_DATA blockscontaining zero or more bytes of data.  The message structure is as
follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
@} dl_xid_ind_t;
@tpindex dl_xid_ind_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_XID_IND

@item dl_flag
conveys the flag values associated with the received XID frame.

@vtable @var
@item DL_POLL_FINAL
indicates if the received xid frame had the poll/final bit set.

@end vtable
@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_src_addr_length
conveys the length of the source DLSAP address.  If the source user is
implemented using DLPI, this address if the full DLSAP address returned on the
DL_BIND_ACK.

@item dl_src_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
source DLSAP address begins.

@end vtable

@subsubheading State
The message is valid in state DL_IDLE and DL_DATAXFER.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
The DLS User must respond with a DL_XID_RES.

@page
@node Message DL_XID_RES (dl_xid_res_t)
@subsection Message DL_XID_RES (dl_xid_res_t)
Conveys an XID DLSDU from the DLS User to the DLS Provider in response to a
DL_XID_IND.

@subsubheading Message Format
The message consists of one M_PROTO message block, followed by zero or more
M_DATA blockscontaining zero or more bytes of data.  The message structure is as
follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
@} dl_xid_res_t;
@tpindex dl_xid_res_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitiveconveys
DL_XID_RES

@item dl_flag
conveys the flag values associated with the received XID frame.

@vtable @var
@item DL_POLL_FINAL

@end vtable
@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@end vtable

@subsubheading State
The message is valid in states DL_IDLE and DL_DATAXFER.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_XID_CON (dl_xid_con_t)
@subsection Message DL_XID_CON (dl_xid_con_t)
Conveys an XID DLSDU from the DLS Provider to the DLS User in response to a
DL_XID_REQ.

@subsubheading Message Format
The message consists of one M_PROTO message block, followed by zero or more
M_DATA blockscontaining zero or more bytes of data.  The message structure is as
follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
@} dl_xid_con_t;
@tpindex dl_xid_con_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_XID_CON

@item dl_flag
conveys the flag values associated with the received XID frame.

@vtable @var
@item DL_POLL_FINAL

@end vtable
@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_src_addr_length
conveys the length of the source DLSAP address.  If the source user is
implemented using DLPI, this address is the full DLSAP address returned on the
DL_BIND_ACK.

@item dl_src_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
source DLSAP address begins.

@end vtable

@subsubheading State
The message is valid in states DL_IDLE and DL_DATAXFER.

@subsubheading New State
The resulting state is unchanged.

@page
@node Acknowledged Connectionless-mode Service Primitives
@section Acknowledged Connectionless-mode Service Primitives

@menu
* Message DL_DATA_ACK_REQ (dl_data_ack_req_t)::
* Message DL_DATA_ACK_IND (dl_data_ack_ind_t)::
* Message DL_DATA_ACK_STATUS_IND (dl_data_ack_status_ind_t)::
* Message DL_REPLY_REQ (dl_reply_req_t)::
* Message DL_REPLY_IND (dl_reply_ind_t)::
* Message DL_REPLY_STATUS_IND (dl_reply_status_ind_t)::
* Message DL_REPLY_UPDATE_REQ (dl_reply_update_req_t)::
* Message DL_REPLY_UPDATE_STATUS_IND (dl_reply_update_status_ind_t)::
@end menu

This section describes the primitives that support the acknowledged
connectionless-mode service of thedata link layer.  These primitives support the
acknowledged connectionless data transfer service described earlier.

@page
@node Message DL_DATA_ACK_REQ (dl_data_ack_req_t)
@subsection Message DL_DATA_ACK_REQ (dl_data_ack_req_t)
This request is passed to the Data Link Provider to request that a DLSDU be sent
to a peer DLS User usingacknowledged connectionless mode data unit transmission
procedures.

@subsubheading Message Format
Consists of one M_PROTO message block containing the structure shown below,
followed by one or moreM_DATA blocks containing one or more bytes of data.  The
amount of user data that may be transferred in a single DLSDU is limited.  This
limit is conveyed by the parameter dl_max_sdu in the DL_INFO_ACK primitive.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
        ulong dl_priority;
        ulong dl_service_class;
@} dl_data_ack_req_t;
@tpindex dl_data_ack_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_DATA_ACK_REQ

@item dl_correlation
Conveys a unique identifier which will be returned in the DL_DATA_ACK_STATUS_IND
primitive to allow the DLS User to correlate the status to the appropriate
DL_DATA_ACK_REQprimitive.

@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_src_addr_length
conveys the length of the DLSAP address of the source DLS User.

@item dl_src_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
source DLSAP address begins.

@item dl_priority
indicates the priority value within the supported range for this particular
DLSDU.

@item dl_service_class
Specifies whether or not an acknowledge capability in the medium access control
sublayer is to be used for the data unit transmission.

@vtable @var
@item DL_RQST_RSP
Request acknowledgement service from the medium access control sublayer
ifsupported

@item DL_RQST_NORSP
No acknowledgement service requested from the medium access controlsublayer.

@end vtable
@end vtable

@subsubheading State
This message is valid in state DL_IDLE.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the request is erroneous, message DL_ERROR_ACK is returned, and the resulting
state is unchanged.

If the DLS Provider accepts the data for transmission, a DL_DATA_ACK_STATUS_IND
is returned.

Thisindication will indicate the success or failure of the data transmission.
Although the exchange service is connectionless, in-sequence delivery is
guaranteed for data sent by the initiating station.

@subsubheading Reasons for Failure
@vtable @var
@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_BADADDR
The destination DLSAP address was in an incorrect format or contained invalid
information.

@item DL_NOTSUPPORTED
Primitive is valid, but not supported.

@item DL_BADDATA
The amount of data in the current DLSDU exceeded the DLS provider's DLSDU limit.

@item DL_UNSUPPORTED
Requested service or priority not supported by Provider (Request with responseat
the Medium Access Control sublayer).

@end vtable

@page
@node Message DL_DATA_ACK_IND (dl_data_ack_ind_t)
@subsection Message DL_DATA_ACK_IND (dl_data_ack_ind_t)
Conveys one DLSDU from the DLS Provider to the DLS User.  This primitive
indicates the arrival of anon-null, non-duplicate DLSDU from a peer Data Link
User entity.

@subsubheading Message Format
Consists of one M_PROTO message block containing the structure shown below,
followed by one or moreM_DATA blocks containing one or more bytes of data.  The
amount of user data that may be transferred in a single DLSDU is limited.  This
limit is conveyed by the parameter dl_max_sdu in the DL_INFO_ACKprimitive.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
        ulong dl_priority;
        ulong dl_service_class;
@} dl_data_ack_ind_t;
@tpindex dl_data_ack_ind_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_DATA_ACK_IND

@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_src_addr_length
conveys the length of the DLSAP address of the source DLS User.

@item dl_src_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
source DLSAP address begins.  address returned on the DL_BIND_ACK.

@item dl_priority
priority provided for the data unit transmission.

@item dl_service_class
Specifies whether or not an acknowledge capability in the medium access control
sublayer is to be used for the data unit transmission.

@vtable @var
@item DL_RQST_RSP
Use acknowledgement service in the medium access control sublayer.

@item DL_RQST_NORSP No
acknowledgement service to be used in the medium access controlsublayer.

@end vtable
@end vtable

@subsubheading State
This message is valid in state DL_IDLE.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_DATA_ACK_STATUS_IND (dl_data_ack_status_ind_t)
@subsection Message DL_DATA_ACK_STATUS_IND (dl_data_ack_status_ind_t)
Conveys the results of the previous associated DL_DATA_ACK_REQ from the DLS Provider to the DLSUser.

@subsubheading Message Format
Consists of one M_PROTO message block containing the structure shown below.
@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_status;
@} dl_data_ack_status_ind_t;
@tpindex dl_data_ack_status_ind_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_DATA_ACK_STATUS_IND

@item dl_correlation
conveys the unique identifier passed with the DL_DATA_ACK_REQ primitive, to
allow the DLS User correlate the status to the appropriate DL_DATA_ACK_REQ.

@item dl_status
indicates the success or failure of the previous associated acknowledged
connectionless-mode data unit transmission request.

@vtable @var
@item DL_CMD_OK
Command accepted.

@item DL_CMD_RS
Unimplemented or inactivated service.

@item DL_CMD_UE
LLC User Interface error

@item DL_CMD_PE
Protocol error

@item DL_CMD_IP
Permanent implementation dependent error

@item DL_CMD_UN
Resources temporarily unavailable.

@item DL_CMD_IT
Temporary implementation dependent error.

@end vtable
@end vtable

@subsubheading State
This message is valid in state DL_IDLE.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_REPLY_REQ (dl_reply_req_t)
@subsection Message DL_REPLY_REQ (dl_reply_req_t)
This request primitive is passed to the DLS Provider by the DLS User to request
that a DLSDU be returnedfrom a peer DLS Provider or that DLSDUs be exchanged
between stations using acknowledged connectionless mode data unit exchange
procedures.

@subsubheading Message Format
Consists of one M_PROTO message block containing the structure shown below,
followed by one or moreM_DATA blocks with one or more bytes of data.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
        ulong dl_priority;
        ulong dl_service_class;
@} dl_reply_req_t;
@tpindex dl_reply_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_REPLY_REQ

@item dl_correlation
Conveys a unique identifier which will be returned in the DL_REPLY_STATUS_IND
primitive to allow the DLS User to correlate the status to the appropriate
DL_REPLY_REQ primitive.

@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_src_addr_length
conveys the length of the DLSAP address of the source DLS User.

@item dl_src_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
source DLSAP address begins.

@item dl_priority
priority provided for the data unit transmission.

@item dl_service_class
Specifies whether or not an acknowledge capability in the medium access control
sublayer is to be used for the data unit transmission.

@end vtable

@subsubheading State
This primitive is valid in state DL_IDLE.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the request is erroneous, message DL_ERROR_ACK is returned, and the resulting
state is unchanged.  If the message is valid, a DL_REPLY_STATUS_IND is returned.
This will indicate the success or failureof the previous associated acknowledged
connectionless-mode data unit exchange.

@subsubheading Reasons for Failure
@vtable @var
@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_BADADDR
The destination DLSAP address was in an incorrect format or contained
invalidinformation.

@item DL_NOTSUPPORTED
Primitive is valid, but not supported.

@item DL_BADDATA
The amount of data in the current DLSDU exceeded the DLS provider's DLSDU limit.

@item DL_UNSUPPORTED
Requested service not supported by Provider (Request with response at theMedium
Access Control sublayer).

@end vtable

@page
@node Message DL_REPLY_IND (dl_reply_ind_t)
@subsection Message DL_REPLY_IND (dl_reply_ind_t)
This primitive is the service indication primitive for the acknowledged
connectionless-mode data unitexchange service.  It is passed from the DLS
Provider to the DLS User to indicate either a successful request of a DLSDU from
the peer data
link user entity, or exchange of DLSDUs with a peer data link userentity.

@subsubheading Message Format
Consists of one M_PROTO message block containing the structure shown below,
followed by zero ormore M_DATA blocks.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
        ulong dl_priority;
        ulong dl_service_class;
@} dl_reply_ind_t;
@tpindex dl_reply_ind_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_REPLY_IND

@item dl_dest_addr_length
conveys the length of the DLSAP address of the destination DLS User.  If the
destination user is implemented using DLPI, this address is the full DLSAP
address returned on the DL_BIND_ACK.

@item dl_dest_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
destination DLSAP address begins.

@item dl_src_addr_length
conveys the length of the DLSAP address of the source DLS User.

@item dl_src_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
source DLSAP address begins.

@item dl_priority
priority provided for the data unit transmission.

@item dl_service_class
Specifies whether or not an acknowledge capability in the medium access control
sublayer is to be used for the data unit transmission.

@end vtable

@subsubheading State
This primitive is valid in state DL_IDLE.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_REPLY_STATUS_IND (dl_reply_status_ind_t)
@subsection Message DL_REPLY_STATUS_IND (dl_reply_status_ind_t)
This indication primitive is passed from the DLS Provider to the DLS User to
indicate the success orfailure of the previous associated acknowledged
connectionless mode data unit exchange request.

@subsubheading Message Format
Consists of one M_PROTO message block containing the structure shown below,
followed by zero ormore M_DATA blocks.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_status;
@} dl_reply_status_ind_t;
@tpindex dl_reply_status_ind_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_REPLY_STATUS_IND

@item dl_correlation
conveys the unique identifier passed with the DL_REPLY_REQ primitive, to allow
the DLS User correlate the status to the appropriate DL_REPLY_REQ.

@item dl_status
Indicates the success or failure of the previous associated acknowledged
connectionless-mode data unit exchange request.

@vtable @var
@item DL_CMD_OK
Command accepted.

@item DL_CMD_RS
Unimplemented or inactivated service.

@item DL_CMD_UE
LLC User Interface error

@item DL_CMD_PE
Protocol error

@item DL_CMD_IP
Permanent implementation dependent error

@item DL_CMD_UN
Resources temporarily available.

@item DL_CMD_IT
Temporary implementation dependent error.

@item DL_RSP_OK
Response DLSDU present.

@item DL_RSP_RS
Unimplemented or inactivated service.

@item DL_RSP_NE
Response DLSDU never submitted.

@item DL_RSP_NR
Response DLSDU not requested.

@item DL_RSP_UE
LLC User interface error.

@item DL_RSP_IP
Permanent implementation dependent error.

@item DL_RSP_UN
Resources temporarily unavailable.

@item DL_RSP_IT
Temporary implementation dependent error.

@end vtable
@end vtable

@subsubheading State
This primitive is valid in state DL_IDLE.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_REPLY_UPDATE_REQ (dl_reply_update_req_t)
@subsection Message DL_REPLY_UPDATE_REQ (dl_reply_update_req_t)
Conveys a DLSDU to the DLS Provider from the DLS User to be held by the DLS
Provider and sent out ata later time when requested to do so by the peer DLS
Provider.

@subsubheading Message Format
Consists of one M_PROTO message block containing the structure shown below,
followed by one or moreM_DATA blocks.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
@} dl_reply_update_req_t;
@tpindex dl_reply_update_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_REPLY_UPDATE_REQ

@item dl_correlation
conveys context specific information to be returned in the
DL_REPLY_UPDATE_STATUS_IND primitive to allow the DLS User correlate the status
to the appropriate previous request.

@item dl_src_addr_length
conveys the length of the DLSAP address of the source DLS User.

@item dl_src_addr_offset
conveys the offset from the beginning of the M_PROTO message block where the
source DLSAP address begins.

@end vtable

@subsubheading State
This primitive is valid in state DL_IDLE.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the request is erroneous, a DL_ERROR_ACK is returned with the appropriate
error code.  Otherwise, a DL_REPLY_UPDATE_STATUS_IND is returned, which indicates
the success or failure of the DL_REPLY_UPDATE_REQ.

@subsubheading Reasons for failure
@vtable @var
@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_BADDATA
The amount of data in the DLSDU exceeded the DLS Provider's DLSDU limit.

@item DL_NOTSUPPORTED
Primitive is known, but not supported.

@end vtable

@page
@node Message DL_REPLY_UPDATE_STATUS_IND (dl_reply_update_status_ind_t)
@subsection Message DL_REPLY_UPDATE_STATUS_IND (dl_reply_update_status_ind_t)
This primitive is the service confirmation primitive for the reply data unit
preparation service.  Thisprimitive is sent to the DL User from the DLS Provider
to indicate the success or failure of the previous associated data unit
preparation
request.

@subsubheading Message Format
Consists of one M_PROTO message block containing the structure shown below.
@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_status;
@} dl_reply_update_req_t;
@tpindex dl_reply_update_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_UPDATE_STATUS_IND

@item dl_correlation
Indicates the context information passed with the DL_REPLY_UPDATE_REQ to allow
the DLS User correlate the status with the appropriate previous request.

@item dl_status
indicates the success or failure of the previous associated data unit
preparation request.

@vtable @var
@item DL_CMD_OK
Command accepted.

@item DL_CMD_RS
Unimplemented or inactivated service.

@item DL_CMD_UE
LLC User Interface error

@item DL_CMD_PE
Protocol error

@item DL_CMD_IP
Permanent implementation dependent error

@item DL_CMD_UN
Resources temporarily available.

@item DL_CMD_IT
Temporary implementation dependent error.

@item DL_RSP_OK
Response DLSDU present.

@item DL_RSP_RS
Unimplemented or inactivated service.

@item DL_RSP_NE
Response DLSDU never submitted.

@item DL_RSP_NR
Response DLSDU not requested.

@item DL_RSP_UE
LLC User interface error.

@item DL_RSP_IP
Permanent implementation dependent error.

@item DL_RSP_UN
Resources temporarily unavailable.

@item DL_RSP_IT
Temporary implementation dependent error.

@end vtable
@end vtable

@subsubheading State
This primitive is valid in state DL_IDLE.

@subsubheading New State
The resulting state is unchanged.

@page
@node Quality of Data Link Service
@chapter Quality of Data Link Service

@menu
* Overview of Quality of Service::
* QOS Parameter Definitions::
* QOS Data Structures::
* Procedures for QOS Negotiation and Selection::
@end menu

The quality of data link service is defined by the term "Quality of Service"
(QOS), and describes certaincharacteristics of transmission between two DLS
users.  These characteristics are attributable solely to the DLS provider, but
are observable by the DLS users.  The visibility of QOS characteristics enables a
DLSuser to determine, and possibly negotiate, the characteristics of
transmission needed to communicate with the remote DLS user.

@page
@node Overview of Quality of Service
@section Overview of Quality of Service

@menu
* Connection-mode Service (2)::
* QOS for Connectionless-mode and Acknowledged Connectionless-mode Service::
@end menu

Quality of service characteristics apply to both the connection and
connectionless modes of service.  Thesemantics for each mode are discussed below.

@page
@node Connection-mode Service (2)
@subsection Connection-mode Service
"Quality of Service" (QOS) refers to certain characteristics of a data link
connection as observed betweenthe connection endpoints.  QOS describes the
specific aspects of a data link connection that are attributable to the DLS
provider.  QOS is defined in terms of QOS parameters.  The parameters give DLS
users a means of specifying theirneeds.  These parameters are divided into two
groups, based on how their values are determined:

@itemize @bullet
@item QOS parameters that are negotiated on a per-connection basis during
connection establishment; and
@item QOS parameters that are not negotiated during connection establishment.
The values are determinedor known through other methods, usually administrative.
@end itemize

The QOS parameters that can be negotiated during connection establishment are:
throughput, transit delay,priority, and protection.  The QOS parameters for
throughput and transit delay are negotiated end-to-end between the two DLS users
and the DLS provider.  The QOS parameters for priority and protection
arenegotiated locally by each DLS user with the DLS provider.  The QOS parameters
that cannot be negotiated are residual error rate and resilience.  Section 5.4,
Procedures for QOS Negotiation and Selection describes the rules for QOS
negotiation.

Once the connection is established, the agreed QOS values are not renegotiated
at any point.  There is noguarantee by any DLS provider that the original QOS
values will be maintained, and the DLS users are not informed if QOS changes.
The DLS provider also need only record those QOS values selected atconnection
establishment for return in response to the DL_INFO_REQ primitive.

@node QOS for Connectionless-mode and Acknowledged Connectionless-mode Service
@subsection QOS for Connectionless-mode and Acknowledged Connectionless-mode Service
The QOS for connectionless-mode and acknowledged connectionless-mode service
refers tocharacteristics of the data link layer between two DLSAPs, attributable
to the DLS provider.  The QOS applied to each DL_UNITDATA_REQ/DL_DATA_ACK_REQ
primitive may be independent of the QOSapplied to preceding and following
DL_UNITDATA_REQ/DL_DATA_ACK_REQ primitives.  QOS cannot be negotiated between
two DLS users as in the connection-mode service.  Every
DL_UNITDATA_REQ/DL_DATA_ACK_REQ primitive may have certain QOS values
associatedwith it.  The supported range of QOS parameter values is made known to
the DLS user in response to the DL_INFO_REQ primitive.  The DLS user may select
specific QOS parameter values to be associated withsubsequent data unit
transmissions using the DL_UDQOS_REQ primitive.  This selection is a strictly
local management function.  If different QOS values are to be associated with
each transmission, DL_UDQOS_REQ may be issued to alter those values before each
DL_UNITDATA_REQ/DL_DATA_ACK_REQ is issued.

@page
@node QOS Parameter Definitions
@section QOS Parameter Definitions

@menu
* Throughput::
* Transit Delay::
* Priority::
* Protection::
* Residual Error Rate::
* Resilience::
@end menu

This section describes the quality of service parameters supported by DLPI for
both connection-mode andconnectionless-mode services.  The following table
summarizes the supported parameters.  It indicates to which service mode
(connection, connectionless, or both) the parameter applies.  For those
parameterssupported by the connection-mode service, the table also indicates
whether the parameter value is negotiated during connection establishment.  If
so, the table further indicates whether the QOS values arenegotiated end-to-end
among both DLS users and the DLS provider, or locally for each DLS user
independently with the DLS provider.

@tabfig{dlpi_tab4,1x,-}

Parameter Service Mode Negotiation throughput connection end-to-end transit
delay both end-to-end priority both local protection both local residual error
rate both none resilience connection none

@page
@node Throughput
@subsection Throughput
Throughput is a connection-mode QOS parameter that has end-to-end significance.
It is defined as thetotal number of DLSDU bits successfully transferred by a
DL_DATA_REQ/DL_DATA_IND primitive sequence divided by the input/output time, in
seconds, for that sequence.  Successful transfer of a DLSDUis defined to occur
when the DLSDU is delivered to the intended user without error, in proper
sequence, and before connection termination by the receiving DLS user.  The
input/output time for a DL_DATA_REQ/DL_DATA_IND primitive sequence is the
greater of:

@itemize @bullet
@item the time between the first and last DL_DATA_REQ in a sequence; and
@item the time between the first and last DL_DATA_IND in the sequence.
@end itemize

Throughput is only meaningful for a sequence of complete DLSDUs.  Throughput is
specified and negotiated for the transmit and receive directions independently
at connectionestablishment.  The throughput specification defines the target and
minimum acceptable values for a connection.  Each specification is an average
rate.  The DLS user can delay the receipt or sending of DLSDUs.  The delay caused
by a DLS user is notincluded in calculating the average throughput values.

@subsubheading Parameter Format
@example
typedef struct @{
        long dl_target_value;
        long dl_accept_value;
@} dl_through_t;
@tpindex dl_through_t
@end example

This typedef is used to negotiate the transmit and receive throughput values.
@vtable @var
@item dl_target_value
specifies the desired throughput value for the connection in bits/second.

@item dl_accept_value
specifies the minimum acceptable throughput value for the connection in
bits/second.

@end vtable

@page
@node Transit Delay
@subsection Transit Delay
Connection and connectionless modes can specify a transit delay, which indicates
the elapsed timebetween a DL_DATA_REQ or DL_UNITDATA_REQ primitive and the
corresponding DL_DATA_IND or DL_UNITDATA_IND primitive.  The elapsed time is only
computed for DLSDUs successfullytransferred, as described previously for
throughput.

In connection mode, transit delay is negotiated on an end-to-end basis during
connection establishment.For each connection, transit delay is negotiated for
the transmit and receive directions separately by specifying the target value
and maximum acceptable value.  For connectionless-mode service, a DLS userselects
a particular value within the supported range using the DL_UDQOS_REQ primitive,
and the value may be changed for each DLSDU submitted for connectionless
transmission.  The transit delay for an individual DLSDU may be increased if the
receiving DLS user flow controls theinterface.  The average and maximum transit
delay values exclude any DLS user flow control of the interface.  The values are
specified in milliseconds, and assume a DLSDU size of 128 octets.

@subsubheading Parameter Format
@example
typedef struct @{
        long dl_target_value;
        long dl_accept_value;
@} dl_transdelay_t;
@tpindex dl_transdelay_t
@end example

This typedef is used to negotiate the transmit and receive transit delay values.
@vtable @var
@item dl_target_value
specifies the desired transit delay value.

@item dl_accept_value
specifies the maximum acceptable transit delay value.

@end vtable

@page
@node Priority
@subsection Priority
Priority is negotiated locally between each DLS user and the DLS provider in
connection-mode service,and can also be specified for connectionless-mode
service.  The specification of priority is concerned with the relationship
between connections or the relationship between connectionless data transfer
requests.The parameter specifies the relative importance of a connection with
respect to:

@itemize @bullet
@item the order in which connections are to have their QOS degraded, if
necessary; and

@item the order in which connections are to be released to recover resources, if
necessary;

@end itemize

For connectionless-mode service, the parameter specifies the relative importance
of unitdata objects withrespect to gaining use of shared resources.

For connection-mode service, each DLS user negotiates a particular priority
value with the DLS providerduring connection establishment.  The value is
specified by a minimum and a maximum within a given range.  For
connectionless-mode service, a DLS user selects a particular priority value
within thesupported range using the DL_UDQOS_REQ primitive, and the value may be
changed for each DLSDU submitted for connectionless transmission.  This parameter
only has meaning in the context of some management entity or structure able to
judgerelative importance.  The priority has local significance only, with a value
of zero being the highest priority and 100 being the lowest priority.

@subsubheading Parameter Format
@example
typedef struct @{
        long dl_min;
        long dl_max;
@} dl_priority_t;
@tpindex dl_priority_t
@end example

@vtable @var
@item dl_min
specifies the minimum acceptable priority.

@item dl_max
specifies the maximum desired priority.

@end vtable

@page
@node Protection
@subsection Protection
Protection is negotiated locally between each DLS user and the DLS provider in
connection-mode service,and can also be specified for connectionless-mode
service.  Protection is the extent to which a DLS provider attempts to prevent
unauthorized monitoring or manipulation of DLS user-originated
information.Protection is specified by a minimum and maximum protection option
within the following range of possible protection options:

@vtable @var
@item DL_NONE DLS
provider will not protect any DLS user data

@item DL_MONITOR DLS
provider will protect against passive monitoring

@item DL_MAXIMUM DLS
provider will protect against modification, replay, addition, or deletion of DLS
user data

@end vtable

For connection-mode service, each DLS user negotiates a particular value with
the DLS provider duringconnection establishment.  The value is specified by a
minimum and a maximum within a given range.  For connectionless-mode service, a
DLS user selects a particular value within the supported range using
the DL_UDQOS_REQ primitive, and the value may be changed for each DLSDU submitted
for connectionless transmission.  Protection has local significance only.

@subsubheading Parameter Format
@example
typedef struct @{
        long dl_min;
        long dl_max;
@} dl_protect_t;
@tpindex dl_protect_t
@end example

@vtable @var
@item dl_min
specifies the minimum acceptable protection.

@item dl_max
specifies the maximum desired protection.

@end vtable

@page
@node Residual Error Rate
@subsection Residual Error Rate
Residual error rate is the ratio of total incorrect, lost and duplicate DLSDUs
to the total DLSDUstransferred between DLS users during a period of time.  The
relationship between these quantities is defined below:

@example
       DLSDUl + DLSDUi + DLSDUe
RER = ---------------------------
             DLSDUtot
@end example

where

@vtable @var
@item DLSDUtot
= total DLSDUs transferred, which is the total of DLSDUl,  DLSDUi, DLSDUe, and
correctlyreceived DLSDUs.

@item DLSDUe
= DLSDUs received 2 or more times.

@item DLSDUi
= incorrectly received DLSDUs.

@item DLSDUl
= DLSDUs sent, but not received.

@end vtable

@subsubheading Parameter Format

@example
long dl_residual_error;
@end example

The residual error value is scaled by a factor of 1,000,000, since the parameter
is stored as a long integer inthe QOS data structures.  Residual error rate is
not a negotiated QOS parameter.  Its value is determined by procedures outside
the definition of DLPI.  It is assumed to be set by an administrative mechanism,
whichis informed of the value by network management.

@page
@node Resilience
@subsection Resilience
Resilience is meaningful in connection mode only, and represents the probability
of either: DLSprovider-initiated disconnects or DLS provider-initiated resets
during a time interval of 10,000 seconds on a connection.  Resilience is not a
negotiated QOS parameter.  Its value is determined by procedures outside the
definitionof DLPI.  It is assumed to be set by an administrative mechanism, which
is informed of the value by network management.

@subsubheading Parameter Format
@example
typedef struct @{
        long dl_disc_prob;
        long dl_reset_prob;
@} dl_resilience_t;
@tpindex dl_resilience_t
@end example

@vtable @var
@item dl_disc_prob
specifies the probability of receiving a provider-initiated disconnect, scaled
by 10000.

@item dl_reset_prob
specifies the probability of receiving a provider-initiated reset, scaled by
10000.

@end vtable

@page
@node QOS Data Structures
@section QOS Data Structures

@menu
* Structure DL_QOS_CO_RANGE1::
* Structure DL_QOS_CO_SEL1::
* Structure DL_QOS_CL_RANGE1::
* Structure DL_QOS_CL_SEL1::
@end menu

To simplify the definition of the primitives containing QOS parameters and the
discussion of QOSnegotiation, the QOS parameters are organized into four
structures.  This section defines the structures and indicates which structures
apply to which primitives.  Each structure is tagged with a type field contained
in the first four bytes of the structure, similar to thetagging of primitives.
The type field has been defined because of the current volatility of QOS
parameter definition within the international standards bodies.  If new QOS
parameter sets are defined in the futurefor the data link layer, the type field
will enable DLPI to accommodate these sets without breaking existing DLS user or
provider implementations.  However, DLS user and provider software should
becognizant of the possibility that new QOS structure types may be defined in
future issues of the DLPI specification.  If a DLS provider receives a structure
type that it does not understand in a given primitive,the error DL_BADQOSTYPE
should be returned to the DLS user in a DL_ERROR_ACK primitive.

Currently the following QOS structure types are defined:

@vtable @var
@item DL_QOS_CO_RANGE1
QOS range structure for connection-mode service for Issue 1 of DLPI

@item DL_QOS_CO_SEL1
QOS selection structure for connection-mode service for Issue 1 of DLPI

@item DL_QOS_CL_RANGE1
QOS range structure for connectionless-mode service for Issue 1 of DLPI

@item DL_QOS_CL_SEL1
QOS selection structure for connectionless-mode service for Issue 1 of DLPI

@end vtable

The syntax and semantics of each structure type is presented in the remainder of
this section.

@page
@node Structure DL_QOS_CO_RANGE1
@subsection Structure DL_QOS_CO_RANGE1
Structure type DL_QOS_CO_RANGE1 enables a DLS user and DLS provider to pass
between them arange of QOS parameter values in the connection-mode service.  The
format of this structure type is:

@example
typedef struct @{
        ulong dl_qos_type;
        dl_through_t dl_rcv_throughput;
        dl_transdelay_t dl_rcv_trans_delay;
        dl_through_t dl_xmt_throughput;
        dl_transdelay_t dl_xmt_trans_delay;
        dl_priority_t dl_priority;
        dl_protect_t dl_protection;
        long dl_residual_error;
        dl_resilience_t dl_resilience;
@} dl_qos_co_range1_t;
@tpindex dl_qos_co_range1_t
@end example

where the value of dl_qos_type is DL_QOS_CO_RANGE1.  The fields of this structure
correspond to theparameters defined in section 5.2, QOS Parameter Definitions.
The throughput and transit delayparameters are specified for each direction of
transmission on a data link connection.

This structure type is returned in the dl_qos_range_length and
dl_qos_range_offset fields of the DL_INFO_ACK, and specifies the supported ranges
of service quality supported by the DLS provider.  In other words, it specifies
the available range of QOS parameter values that may be specified on
a DL_CONNECT_REQ.

For the DL_CONNECT_REQ and DL_CONNECT_IND primitives, this structure specifies
the negotiablerange of connection-mode QOS parameter values.  See section 5.4,
Procedures for QOS Negotiation and Selection, for the semantics of this
structure in these primitives.

@page
@node Structure DL_QOS_CO_SEL1
@subsection Structure DL_QOS_CO_SEL1
Structure type DL_QOS_CO_SEL1 conveys selected QOS parameter values for
connection-mode servicebetween the DLS user and DLS provider.  The format of this
structure type is:

@example
typedef struct @{
        ulong dl_qos_type;
        long dl_rcv_throughput;
        long dl_rcv_trans_delay;
        long dl_xmt_throughput;
        long dl_xmt_trans_delay;
        long dl_priority;
        long dl_protection;
        long dl_residual_error;
        dl_resilience_t dl_resilience;
@} dl_qos_co_sel1_t;
@tpindex dl_qos_co_sel1_t
@end example

where the value of dl_qos_type is DL_QOS_CO_SEL1.  The fields of this structure
correspond to theparameters defined in section 5.2, QOS Parameter Definitions.
The throughput and transit delayparameters are specified for each direction of
transmission on a data link connection.

This structure type is returned in the dl_qos_length and dl_qos_offset fields of
the DL_INFO_ACK, andspecifies the current or default QOS parameter values
associated with a stream.  Default values are returned prior to connection
establishment, and currently negotiated values are returned when aconnection is
active on the stream.

The structure type is used in the DL_CONNECT_RES to enable the responding DLS
user to selectparticular QOS parameter values from the available range.  The
DL_CONNECT_CON primitive returns the selected values to the calling DLS user in
this structure.  See section 5.4, Procedures for QOS Negotiation and Selection,
for the semantics of this structure in these primitives.

@page
@node Structure DL_QOS_CL_RANGE1
@subsection Structure DL_QOS_CL_RANGE1
Structure type DL_QOS_CL_RANGE1 enables a DLS user and DLS provider to pass
between them arange of QOS parameter values in the connectionless-mode service.
The format of this structure type is:

@example
typedef struct @{
        ulong dl_qos_type;
        dl_transdelay_t dl_trans_delay;
        dl_priority_t dl_priority;
        dl_protect_t dl_protection;
        long dl_residual_error;
@} dl_qos_cl_range1_t;
@tpindex dl_qos_cl_range1_t
@end example

where the value of dl_qos_type is DL_QOS_CL_RANGE1.  The fields of this structure
correspond to theparameters defined in section 5.2, QOS Parameter Definitions .

This structure type is returned in the dl_qos_range_length and
dl_qos_range_offset fields of the DL_INFO_ACK, and specifies the range of
connectionless-mode QOS parameter values supported by the DLS provider on the
stream.  The DLS user may select specific values from this range using
the DL_UDQOS_REQ primitive, as described in section 5.4, Procedures for QOS
Negotiation and Selection .

@page
@node Structure DL_QOS_CL_SEL1
@subsection Structure DL_QOS_CL_SEL1
Structure type DL_QOS_CL_SEL1 conveys selected QOS parameter values for
connectionless-modeservice between the DLS user and DLS provider.  The format of
this structure type is:

@example
typedef struct @{
        ulong dl_qos_type;
        long dl_trans_delay;
        long dl_priority;
        long dl_protection;
        long dl_residual_error;
@} dl_qos_cl_sel1_t;
@tpindex dl_qos_cl_sel1_t
@end example

where the value of dl_qos_type is DL_QOS_CL_SEL1.  The fields of this structure
correspond to the parameters defined in section 5.2, QOS Parameter Definitions .

This structure type is returned in the dl_qos_length and dl_qos__offset fields
of the DL_INFO_ACK, andspecifies the current or default QOS parameter values
associated with a stream.  Default values are returned until the DLS user issues
a DL_UDQOS_REQ to change the values, after which the currentlyselected values
will be returned.  The structure type is also used in the DL_UDQOS_REQ primitive
to enable a DLS user to select particular QOS parameter values from the
supported range, as described insection 5.4, Procedures for QOS Negotiation and
Selection.

@page
@node Procedures for QOS Negotiation and Selection
@section Procedures for QOS Negotiation and Selection

@menu
* Connection-mode QOS Negotiation::
* Connectionless-mode QOS Selection::
@end menu

This section describes the methods used for negotiating and/or selecting QOS
parameter values.  In theconnection-mode service, some QOS parameter values may
be negotiated during connection establishment.  For connectionless-mode service,
parameter values may be selected for subsequent datatransmission.

Throughout this section, two special QOS values are referenced.  These are
defined for all the parametersused in QOS negotiation and selection.  The values
are:

@vtable @var
@item DL_UNKNOWN
This value indicates that the DLS provider does not know the valuefor the field
or does not support that parameter.

@item DL_QOS_DONT_CARE
This value indicates that the DLS user does not care to what valuethe QOS
parameter is set.

@end vtable

These values are used to distinguish between DLS providers that support and
negotiate QOS parametersand those that cannot.  The following sections include
the interpretation of these values during QOS negotiation and selection.

@page
@node Connection-mode QOS Negotiation
@subsection Connection-mode QOS Negotiation
The current connection-mode QOS parameters can be divided into three types as
follows:

@itemize @bullet
@item Those that are negotiated end-to-end between peer DLS users and the DLS
provider during connectionestablishment (throughput and transit delay);

@item those that are negotiated locally between each DLS user and the DLS
provider during connectionestablishment (priority and protection); and

@item those that cannot be negotiated (residual error rate and resilience).
@end itemize

The rules for processing these three types of parameters during connection
establishment are described inthis section.

The current definition of most existing data link protocols does not describe a
mechanism for negotiatingQOS parameters during connection establishment.  As
such, DLPI does not require every DLS provider implementation to support QOS
negotiation.  If a given DLS provider implementation cannot support
QOSnegotiation, two alternatives are available:

@itemize
@item The DLS provider may specify that any or all QOS parameters are unknown.
This is indicated to the DLS user in the DL_INFO_ACK, where the values in the QOS
range field (indicated by dl_qos_range_length and dl_qos_range_offset) and the
current QOS field (indicated by dl_qos_length and dl_qos_offset) of this
primitive are set to DL_UNKNOWN.  This value will also be indicated onthe
DL_CONNECT_IND and DL_CONNECT_CON primitives.  If the DLS provider does not
support any QOS parameters, the QOS length field may be set to zero in each of
these of these primitives.

@item The DLS provider may interpret QOS parameters with strictly local
significance, and their values inthe DL_CONNECT_IND primitive will be set to
DL_UNKNOWN.
@end itemize

A DLS user need not select a specific value for each QOS parameter.  The special
QOS parameter value, DL_QOS_DONT_CARE, is used if the DLS user does not care what
quality of service is provided for a particular parameter.  The negotiation
procedures presented below explain the exact semantics of thisvalue during
connection establishment.

If QOS parameters are supported by the DLS provider, the provider will define a
set of default QOSparameter values that are used whenever DL_QOS_DONT_CARE is
specified for a QOS parameter value.  These default values can be defined for all
DLS users or can be defined on a per DLS user basis.  Thedefault parameter value
set is returned in the QOS field (indicated by dl_qos_length and dl_qos_offset)
ofthe DL_INFO_ACK before a DLS user negotiates QOS parameter values.

DLS provider addendum documentation must describe the known ranges of support
for the QOSparameters and the default values, and also specify whether they are
used in a local manner only.  The following procedures are used to negotiate QOS
parameter values during connection establishment.

@table @asis
@item (1)
The DL_CONNECT_REQ specifies the DLS user's desired range of QOS values in the
dl_qos_co_range1_t structure.  The target and least-acceptable values are
specified for throughputand transit delay, as described in section 5.2.1,
Throughput, and section 5.2.2, Transit Delay.  The target value is the value
desired by the calling DLS user for the QOS parameters.  The least acceptable
value is the lowest value the calling user will accept.  These values are
specifiedseparately for both the transmit and receive directions of the
connection.

If either value is set to DL_QOS_DONT_CARE the DLS provider will supply a
default value, subject to the following consistency constraints:

@itemize --
@item If DL_QOS_DONT_CARE is specified for the target value, the value chosen by
the DLSprovider may not be less than the least-acceptable value.

@item If DL_QOS_DONT_CARE is specified for the least-acceptable value, the value
set by the DLS provider cannot be greater than the target value.

@item If DL_QOS_DONT_CARE is specified for both the target and least-acceptable
value, the DLS provider is free to select any value, without constraint, for the
target and leastacceptable values.
@end itemize

For priority and protection, the DL_CONNECT_REQ specifies a minimum and maximum
desiredvalue as defined in section 5.2.3, Priority, and section 5.2.4,
Protection.  As with throughput andtransit delay, the DLS user may specify a
value of DL_QOS_DONT_CARE for either the minimum or maximum value.  The DLS
provider will interpret this value subject to the followingconsistency
constraints:

@itemize --
@item If DL_QOS_DONT_CARE is specified for the maximum value, the value chosen
by the DLS provider may not be less than the minimum value.

@item If DL_QOS_DONT_CARE is specified for the minimum value, the value set by
the DLSprovider cannot be greater than the maximum value.

@item If DL_QOS_DONT_CARE is specified for both the minimum and maximum values,
the DLS provider is free to select any value, without constraint, for the
maximum and minimum values.
@end itemize

The values of the residual error rate and resilience parameters in the
DL_CONNECT_REQ have no meaning and are ignored by the DLS provider.

If the value of dl_qos_length in the DL_CONNECT_REQ is set to zero by the DLS
user, the DLSprovider should treat all QOS parameter values as if they were set
to DL_QOS_DONT_CARE, selecting any value in its supported range.

If the DLS provider cannot support throughput, transit delay, priority, and
protection values withinthe ranges specified in the DL_CONNECT_REQ, a
DL_DISCONNECT_IND should be sent to the calling DLS user.

@item (2)
If the requested ranges of values for throughput and transit delay in the
DL_CONNECT_REQ areacceptable to the DLS provider, the QOS parameters will be
adjusted to values the DLS provider will support.  Only the target value may be
adjusted, and it is set to a value the DLS provider iswilling to provide (which
may be of lower QOS than the target value).  The least-acceptable value cannot be
modified.  The updated QOS range is then sent to the called DLS user in the
dl_qos_co_range1_t structure of the DL_CONNECT_IND, where it is interpreted as
the availablerange of service.

If the requested range of values for priority and protection in the
DL_CONNECT_REQ isacceptable to the DLS provider, an appropriate value within the
range is selected and saved for each parameter; these selected values will be
returned to the DLS user in the corresponding DL_CONNECT_CON primitive.  Because
priority and protection are negotiated locally, the DL_CONNECT_IND will not
contain values selected during negotiation with the calling DLSuser.  Instead,
the DLS provider will offer a range of values in the DL_CONNECT_IND that will be
supported locally for the called DLS user.

The DLS provider will also include the supported values for residual error rate
and resilience in the DL_CONNECT_IND that is passed to the called DLS user.

If the DLS provider does not support negotiation of throughput, transit delay,
priority, orprotection, a value of DL_UNKNOWN should be set in the
least-acceptable, target, minimum, and maximum value fields of the
DL_CONNECT_IND.  Also, if the DLS provider does not supportany particular QOS
parameter, DL_UNKNOWN should be specified in all value fields for that
parameter.  If the DLS provider does not support any QOS parameters, the value of
dl_qos_lengthmay be set to zero in the DL_CONNECT_IND.

@item (3)
Upon receiving the DL_CONNECT_IND, the called DLS user examines the QOS
parameter valuesand selects a specific value from the proffered range of the
throughput, transit delay, priority, and protection parameters.  If the called
DLS user does not agree on values in the given range, theconnection should be
refused with a DL_DISCONNECT_REQ primitive.  Otherwise, the selected values are
returned to the DLS provider in the dl_qos_co_sel1_t structure of
the DL_CONNECT_RES primitive.

The values of residual error rate and resilience in the DL_CONNECT_RES are
ignored by the DLSprovider.  These parameters may not be negotiated by the called
DLS user.  The selected values of throughput and transit delay are meaningful,
however, and are adopted for the connection by the DLS provider.  Similarly, the
selected priority and protection values are adopted with local significance for
the called DLS user.

If the user specifies DL_QOS_DONT_CARE for either throughput, transit delay,
priority, orprotection on the DL_CONNECT_RES, the DLS provider will select a
value from the range specified for that parameter in the DL_CONNECT_IND
primitive.  Also, a value of zero in the dl_qos_length field of the
DL_CONNECT_RES is equivalent to DL_QOS_DONT_CARE for allQOS parameters.

@item (4)
Upon completion of connection establishment, the values of throughput and
transit delay asselected by the called DLS user are returned to the calling DLS
user in the dl_qos_co_sel1_tstructure of the DL_CONNECT_CON primitive.  The
values of priority and protection that were selected by the DLS provider from
the range indicated in the DL_CONNECT_REQ will also bereturned in the
DL_CONNECT_CON.  This primitive will also contain the values of residual error
rate and resilience associated with the newly established connection.  The DLS
provider also savesthe negotiated QOS parameter values for the connection, so
that they may be returned in response to a DL_INFO_REQ primitive.

As with DL_CONNECT_IND, if the DLS provider does not support negotiation of
throughput,transit delay, priority, or protection, a value of DL_UNKNOWN should
be returned in the selected value fields.  Furthermore, if the DLS provider does
not support any particular QOS parameter, DL_UNKNOWN should be specified in all
value fields for that parameter, or the value of dl_qos_length may be set to
zero in the DL_CONNECT_CON primitive.

@end table

@page
@node Connectionless-mode QOS Selection
@subsection Connectionless-mode QOS Selection
This section describes the procedures for selecting QOS parameter values that
will be associated with thetransmission of connectionless data or acknowledged
connectionless data.

As with connection-mode protocols, the current definition of most existing
(acknowledged) connectionlessdata link protocols does not define a quality of
service concept.  As such, DLPI does not require every DLS provider
implementation to support QOS parameter selection.  The DLS provider may specify
thatany or all QOS parameters are unsupported.  This is indicated to the DLS user
in the DL_INFO_ACK, where the values in the supported range field (indicated by
dl_qos_range_length and dl_qos_range_offset)and the current QOS field (indicated
by dl_qos_length and dl_qos_offset) of this primitive are set to DL_UNKNOWN.

If the DLS provider supports no QOS parameters, the QOS length fields in the
DL_INFO_ACK may be set to zero.  If the DLS provider supports QOS parameter
selection, the DL_INFO_ACK primitive will specify thesupported range of
parameter values for transit delay, priority, protection and residual error
rate.  Default values are also returned in the DL_INFO_ACK.

For each DL_UNITDATA_REQ/DL_DATA_ACK_REQ, the DLS provider should apply the
currentlyselected QOS parameter values to the transmission.  If no values have
been selected, the default values should be used.

At any point during data transfer, the DLS user may issue a DL_UDQOS_REQ
primitive to select newvalues for the transit delay, priority, and protection
parameters.  These values are selected using the dl_qos_cl_sel1_t structure.
The residual error rate parameter is ignored by this primitive and cannot be
setby a DLS user.

In the DL_UDQOS_REQ, the DLS user need not require a specific value for every
QOS parameter.  DL_QOS_DONT_CARE may be specified if the DLS user does not care
what quality of service is provided for a particular parameter.  When specified,
the DLS provider should retain the current (ordefault if no previous selection
has occurred) value for that parameter.

@node References
@unnumbered References
@enumerate
@item International Organization for Standardization, "Data Link Service
Definition for Open SystemsInterconnection," DIS 8886, February 1987.

@item International Organization for Standardization, "Logical Link Control,"
DIS 8802/2, 1985.

@item

@item CCITT Recommendation X.200, "Reference Model of Open Systems
Interconnection for CCITTApplications," 1984.
@end enumerate

@node Optional Primitives to perform Essential Management Functions
@appendix Optional Primitives to perform Essential Management Functions

@menu
* Message DL_PHYS_ADDR_REQ (dl_phys_addr_req_t)::
* Message DL_PHYS_ADDR_ACK (dl_phys_addr_ack_t)::
* Message DL_SET_PHYS_ADDR_REQ (dl_set_phys_addr_req_t)::
* Message DL_GET_STATISTICS_REQ (dl_get_statistics_req_t)::
* Message DL_GET_STATISTICS_ACK (dl_get_statistics_ack_t)::
@end menu

This appendix presents the optional primitives to perform essential management
functions.  Themanagement functions supported are get and set of physical
address, and statistics gathering.

@page
@node Message DL_PHYS_ADDR_REQ (dl_phys_addr_req_t)
@appendixsec Message DL_PHYS_ADDR_REQ (dl_phys_addr_req_t)
This primitive requests the DLS provider to return either the default (factory)
or the current value of thephysical address associated with the stream depending
upon the value of the address type selected in the request.

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_addr_type;
@} dl_phys_addr_req_t;
@tpindex dl_phys_addr_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_PHYS_ADDR_REQ;

@item dl_addr_type
conveys the type of address requested - factory physical address or current
physical address

@vtable @var
@item DL_FACT_PHYS_ADDR
factory physical address DL_CURR_PHYS_ADDR current physical address

@end vtable
@end vtable

@subsubheading State
The message is valid in any attached state in which a local acknowledgement is
not pending.  For a style 2provider, this would be after a PPA is attached using
the DL_ATTACH_REQ.  For a Style 1 provider, the PPA is implicitly attached after
the stream is opened.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
The provider responds to the request with a DL_PHYS_ADDR_ACK if the request is
supported.Otherwise, a DL_ERROR_ACK is returned.

@subsubheading Reasons for failure
@vtable @var
@item DL_NOTSUPPORTED
Primitive is known, but not supported by the DLS Provider.
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@end vtable

@page
@node Message DL_PHYS_ADDR_ACK (dl_phys_addr_ack_t)
@appendixsec Message DL_PHYS_ADDR_ACK (dl_phys_addr_ack_t)
This primitive returns the value for the physical address to the link user in
response to a DL_PHYS_ADDR_REQ.

@subsubheading Message Format
The message consists of M_PCPROTO message block containing the following
structure:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_addr_length;
        ulong dl_addr_offset;
@} dl_phys_addr_ack_t;
@tpindex dl_phys_addr_ack_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_PHYS_ADDR_ACK

@item dl_addr_length
conveys length of the physical address.  dl_addr_offsetconveys the offset from
the beginning of the M_PCPROTO message block.

@end vtable

@subsubheading State
The message is valid in any state in response to a DL_PHYS_ADDR_REQ.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_SET_PHYS_ADDR_REQ (dl_set_phys_addr_req_t)
@appendixsec Message DL_SET_PHYS_ADDR_REQ (dl_set_phys_addr_req_t)
Sets the physical address value for all streams for that provider for a
particular PPA.

@subsubheading Message Format
The message consists of M_PROTO message block which contains the following
structure:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_addr_length;
        ulong dl_addr_offset;
@} dl_set_phys_addr_req_t;
@tpindex dl_set_phys_addr_req_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_SET_PHYS_ADDR_REQ

@item dl_addr_offset
conveys the offset from the beginning of the M_PROTO message block
dl_addr_lengthconveys the length of the requested hardware address

@end vtable

@subsubheading State
The message is valid in any attached state in which a local acknowledgement is
not pending.  For a Style 2provider, this would be after a PPA is attached using
the DL_ATTACH_REQ.  For a Style 1 provider, the PPA is implicitly attached after
the stream is opened.

@subsubheading New State
The resulting state is unchanged

@subsubheading Response
The provider responds to the request with a DL_OK_ACK on successful completion.
Otherwise, a DL_ERROR_ACK is returned.

@subsubheading Reasons for failure
@vtable @var
@item DL_BADADDR
The address information was invalid or was in an incorrect format.
@item DL_NOTSUPPORTED
Primitive is known, but not supported by the DLS Provider.
@item DL_SYSERR
A system error has occurred DL_OUTSTATE The primitive was issued from an invalid state.
@item DL_BUSY
One or more streams for that particular PPA are in the DL_BOUND state.
@end vtable

@page
@node Message DL_GET_STATISTICS_REQ (dl_get_statistics_req_t)
@appendixsec Message DL_GET_STATISTICS_REQ (dl_get_statistics_req_t)
Directs the DLS provider to return statistics

@subsubheading Message Format
The message consists of one M_PROTO message block containing the structure shown
below:

@example
typedef struct @{
        ulong dl_primitive;
@} dl_get_statistics_req_t;
@tpindex dl_get_statistics_req_t
@end example

@subsubheading Parameters
@vtable @var
dl_primitiveconveys DL_GET_STATISTICS_REQ
@end vtable

@subsubheading State
The message is valid in any state in which a local acknowledgement is not
pending.

@subsubheading New State
The resulting state is unchanged

@subsubheading Response
The DLS Provider responds to this request with a DL_GET_STATISTICS_ACK if the
primitive issupported.  Otherwise, a DL_ERROR_ACK is returned.

@subsubheading Reasons for failure
@vtable @var
@item DL_NOTSUPPORTED
Primitive is known but not supported by the DLS Provider.
@end vtable

@page
@node Message DL_GET_STATISTICS_ACK (dl_get_statistics_ack_t)
@appendixsec Message DL_GET_STATISTICS_ACK (dl_get_statistics_ack_t)
Returns statistics in reponse to the DL_GET_STATISTICS_REQ.  The contents of the
statistics block isdefined in the DLS Provider specific addendum.

@subsubheading Message Format
The message consists of one M_PCPROTO message block containing the structure
shown below:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_stat_length;
        ulong dl_stat_offset;
@} dl_get_statistics_ack_t;
@tpindex dl_get_statistics_ack_t
@end example

@subsubheading Parameters
@vtable @var
@item dl_primitive
conveys DL_GET_STATISTICS_ACK

@item dl_stat_len
conveys the length of the statistics structure dl_stat_offsetconveys the offset
from the beginning of the M_PCROTO message block where the statistics
information resides.

@end vtable

@subsubheading State
The message is valid in any state in which a local acknowledgement is not
pending.

@subsubheading New State
The resulting state is unchanged

@page
@node Allowable Sequence of DLPI Primitives
@appendix Allowable Sequence of DLPI Primitives

@menu
* DLPI States::
* Variables and Actions for State Transition Table::
* DLPI User-Originated Events::
* DLPI Provider-Originated Events::
* DLPI State Transition Table::
@end menu

This appendix presents the allowable sequence of DLPI primitives.  The sequence
is described using astate transition table that defines possible states as
viewed by the DLS user.  The state transition table describes transitions based
on the current state of the interface and a given DLPI event.  Each
transitionconsists of a state change and possibly an interface action.  The
states, events, and related transition actions are described below, followed by
the state transition table itself.

@page
@node DLPI States
@appendixsec DLPI States
The following table describes the states associated with DLPI.  It presents the
state name used in the statetransition table, the corresponding DLPI state name
used throughout this specification, a brief description of the state, and an
indication of whether the state is valid for connection-oriented data link
service (DL_CODLS), connectionless data link service (DL_CLDLS), acknowledged
connectionless data link service (ACLDLS) or all.

@tabfig{dlpi_tab5,2a,DLPI States}
@tabfig{dlpi_tab6,2b,DLPI States}
@tabfig{dlpi_tab7,2c,DLPI States}

@page
@node Variables and Actions for State Transition Table
@appendixsec Variables and Actions for State Transition Table
The following tables describe variables and actions used to describe the DLPI
state transitions.  The variables are used to distinguish various uses of the
same DLPI primitive.  For example, a DL_CONNECT_RES causes a different state
transition depending on the current number of outstanding connect indications.
To distinguish these different connect response events, a variable is used to
track thenumber of outstanding connect indications.

@tabfig{dlpi_tab8,3,DPLI State Transition Table Variables}

The actions represent steps the DLS provider must take during certain state
transitions to maintain theinterface state.  When an action is indicated in the
state transition table, the DLS provider should change the state as indicated
and perform the specified action.

@tabfig{dlpi_tab9,4,DPLI State Transition Actions}

@page
@node DLPI User-Originated Events
@appendixsec DLPI User-Originated Events
The following table describes events initiated by the DLS user that correspond
to the various request andresponse primitives of DLPI.  The table presents the
event name used in the state transition table, a brief description of the event
(including the corresponding DLPI primitive), and an indication of whether
theevent is valid for connection-oriented data link service (DL_CODLS),
connectionless data link service (DL_CLDLS), acknowledged connectionless data
link service (DL_ACLDLS) or all.

@tabfig{dlpi_ta10,5,DLPI User-Originated Events}

@page
@node DLPI Provider-Originated Events
@appendixsec DLPI Provider-Originated Events
The following table describes the events initiated by the DLS provider that
correspond to the variousindication, confirmation, and acknowledgement
primitives of DLPI.  The table presents the event name used in the state
transition table, a brief description of the event (including the corresponding
DLPIprimitive), and an indication of whether the event is valid for
connection-oriented data link service (DL_CODLS), connectionless data link
service (DL_CLDLS), acknowledged connectionless service (DL_ACDLS) or all.

@tabfig{dlpi_ta11,6,DLPI Provider-Originated Events}

@page
@node DLPI State Transition Table
@appendixsec DLPI State Transition Table
@tabref{7}, @tabref{8}, @tabref{9} and @tabref{10} describe the DLPI state
transitions.  Each column represents a state of DLPI (@tabref{2a}) and each row
represents a DLPI event (@tabref{5} and @tabref{6}).  The intersecting transition
cell defines the resulting state transition (i.e.  next state) and associated
actions, if any, that must be executed by the DLS provider tomaintain the
interface state.  Each cell may contain the following:

@image{dlpi_ta12}

The DL_INFO_REQ, DL_INFO_ACK, DL_TOKEN_REQ, and DL_TOKEN_ACK primitives
areexcluded from the state transition table because they can be issued from many
states and, when fully processed, do not cause a state transition to occur.
However, the DLS user may not issue a DL_INFO_REQ or DL_TOKEN_REQ if any local
acknowledgements are pending.  In other words, these two primitives may not be
issued until the DLS user receives the acknowledgement for any previouslyissued
primitive that is expecting local positive acknowledgement.  Thus, these
primitives may not be issued from the DL_ATTACH_PENDING, DL_DETACH_PENDING,
DL_BIND_PENDING, DL_SUBS_BIND_PND, DL_SUBS_UNBIND_PND, DL_UNBIND_PENDING,
DL_UDQOS_PENDING, DL_CONN_RES_PENDING, DL_RESET_RES_PENDING, DL_DISCON8_PENDING,
DL_DISCON9_PENDING, DL_DISCON11_PENDING, DL_DISCON12_PENDING, or
DL_DISCON13_PENDING states.  Failure to comply by this restrictionmay result in
loss of primitives at the stream head if the DLS user is a user process.  Once a
DL_INFO_REQ or DL_TOKEN_REQ has been issued, the DLS provider must respond with
theappropriate acknowledgement primitive.

The following rules apply to the maintenance of DLPI state:

@itemize @bullet
@item The DLS provider is responsible for keeping a record of the state of the
interface as viewed by the DLSuser, to be returned in the DL_INFO_ACK.

@item The DLS provider may never generate a primitive that places the interface
out of state (i.e.  wouldcorrespond to a "-" cell entry in the state transition
table below).

@item If the DLS provider generates a STREAMS M_ERROR message upstream, it
should free any furtherprimitives processed by it's write side put or service
procedure.

@item The close of a stream is considered an abortive action by the DLS user,
and may be executed from anystate.  The DLS provider must issue appropriate
indications to the remote DLS user when a close occurs.  For example, if the DLPI
state is DL_DATAXFER, a DL_DISCONNECT_IND should be sentto the remote DLS user.
The DLS provider should free any resources associated with that stream and reset
the stream to its unopened condition.  The following points clarify the state
transition table.

@item If the DLS provider supports connection-mode service, the value of the
outcnt state variable must beinitialized to zero for each stream when that
stream is first opened.

@item The initial and final state for a style 2 DLS provider is DL_UNATTACHED.
However, because a style 1 DLS provider implicitly attaches a PPA to a stream
when it is opened, the initial and final DLPI statefor a style 1 provider is
DL_UNBOUND.  The DLS user should not issue DL_ATTACH_REQ or DL_DETACH_REQ
primitives to a style 1 DLS provider.

@item A DLS provider may have multiple connect indications outstanding (i.e.  the
DLS user has notresponded to them) at one time (see section 4.2.1,
Multi-threaded Connection Establishment).  As the state transition table points
out, the stream on which those indications are outstanding will remain inthe
DL_INCON_PENDING state until the DLS provider receives a response for all
indications.

@item The DLPI state associated with a given stream may be transferred to
another stream only when the DL_CONNECT_RES primitive indicates this behavior.  In
this case, the responding stream (where the connection will be established) must
be in the DL_IDLE state.  This state transition is indicated by thePASS_CONN
event in table 9.

@item The labeling of the states DL_PROV_RESET_PENDING and DL_USER_RESET_PENDING
indicatethe party that started the local interaction, and does not necessarily
indicate the originator of the reset procedure.

@item A DL_DATA_REQ primitive received by the DLS provider in the
state DL_PROV_RESET_PENDING (i.e.  after a DL_RESET_IND has been passed to the DLS
user) or the state DL_IDLE (i.e.  after a data link connection has been released)
should be discarded by the DLSprovider.

@item A DL_DATA_IND primitive received by the DLS user after the user has issued
a DL_RESET_REQshould be discarded.  To ensure accurate processing of DLPI
primitives, the DLS provider must adhere to the following rulesconcerning the
receipt and generation of STREAMS M_FLUSH messages during various state
transitions.

@item The DLS provider must be ready to receive M_FLUSH messages from upstream
and flush it's queuesas specified in the message.

@item The DLS provider must issue an M_FLUSH message upstream to flush both the
read and write queuesafter receiving a successful DL_UNBIND_REQ primitive but
before issuing the DL_OK_ACK.

@item If an incoming disconnect occurs when the interface is in the
DL_DATAXFER, DL_USER_RESET_PENDING, or DL_PROV_RESET_PENDING state, the DLS
provider must send up an M_FLUSH message to flush both the read and write queues
before sending up a DL_DISCONNECT_IND.

@item If a DL_DISCONNECT_REQ is issued in the DL_DATAXFER,
DL_USER_RESET_PENDING, or DL_PROV_RESET_PENDING states, the DLS provider must
issue an M_FLUSH message upstream to flush both the read and write queues after
receiving the successful DL_DISCONNECT_REQ butbefore issuing the DL_OK_ACK.

@item If a reset occurs when the interface is in the DL_DATAXFER or
DL_USER_RESET_PENDING state,the DLS provider must send up an M_FLUSH message to
flush both the read and write queues before sending up a DL_RESET_IND or
DL_RESET_CON.

@end itemize

The following table presents the allowed sequence of DLPI primitives for the
common local management phase of communication.

@tabfigsized{dlpi_ta13,7,DLPI State Transition Table - Local Management Phase,5.5in}

The following table presents the allowed sequence of DLPI primitives for the
connectionless data transfer phase.

@tabfig{dlpi_ta14,8,DLPI State Transition Table - Connectionless-mode Data Transfer Phase}

@tabfig{dlpi_ta15,9,DLPI State Transition Table - Acknowledged Connectionless-mode Data Transfer Phase}

The following table presents the allowed sequence of DLPI primitives for the
connection establishment phase of connection mode service.

@tabfigsized{dlpi_ta16,10,DLPI State Transition Table - Connection Establishment Phase,5.5in}

The following table presents the allowed sequence of DLPI primitives for the connection mode datatransfer phase.

STATES IDLE DATA- USER PROV RESET_RES DISCON 11 DISCON 12 DISCON 13

XFER RESET RESET PEND PEND PEND PENDPEND PEND

EVENTS 6 11 12 13 14 17 18 19 DISCON_REQ - 17 18 19 - - - - DATA_REQ - 11 - - - - - -RESET_REQ - 12 - - - - - -

RESET_RES - - - 14 - - - - DISCON_IND1 - 6 6 6 - - - - (outcnt == 0)

DATA_IND - 11 - - - - - - RESET_IND - 13 - - - - - -RESET_CON - - 11 - - - - -

OK_ACK1 - - - - 11 6 6 6 (outcnt == 0) ERROR_ACK - - 11 - 13 11 12 13

TABLE 11.  DLPI State Transition Table - Connection-mode Data Transfer Phase

@node Precedence of DLPI Primitives
@appendix Precedence of DLPI Primitives

@menu
* Write Queue Precedence::
* Read Queue Precedence::
@end menu

This appendix presents the precedence of DLPI primitives relative to one
another.  Two queues are used todescribe DLPI precedence rules.  One queue
contains DLS user-originated primitives and corresponds to the STREAMS write
queue of the DLS provider.  The other queue contains DLS
provider-originatedprimitives and corresponds to the STREAMS read queue of the
DLS user.  The DLS provider is responsiblefor determining precedence on its write
queue and the DLS user is responsible for determining precedence on its read
queue as indicated in the precedence tables below.  For each precedence table,
the rows (labeled PRIM X) correspond to primitives that are on the givenqueue
and the columns (labeled PRIM Y) correspond to primitives that are about to be
placed on that queue.  Each pair of primitives (PRIM X, PRIM Y) may be
manipulated resulting in:

@itemize @bullet
@item Change of order, where the order of a pair of primitives is reversed if,
and only if, the second primitivein the pair (PRIM Y) is of a type defined to be
able to advance ahead of the first primitive in the pair (PRIM X).

@item Deletion, where a primitive (PRIM X) may be deleted if, and only if, the
primitive that follows it(PRIM Y) is defined to be destructive with respect to
that primitive.  Destructive primitives may always be added to the queue.  Some
primitives may cause both primitives in the pair to be destroyed.  The precedence
rules define the allowed manipulations of a pair of DLPI primitives.  Whether
theseactions are performed is the choice of the DLS provider for user-originated
primitives and the choice of the DLS user for provider-originated primitives.
@end itemize

@page
@node Write Queue Precedence
@appendixsec Write Queue Precedence
The following table presents the precedence rules for DLS user-originated
primitives on the DLSprovider's STREAMS write queue.  It assumes that only
non-local primitives (i.e.  those that generateprotocol data units to a peer DLS
user) are queued by the DLS provider.

For connection establishment primitives, this table represents the possible
pairs of DLPI primitives whenconnect indications/responses are single-threaded.
For the multi-threading scenario, the following rules apply:

@itemize @bullet
@item A DL_CONNECT_RES primitive has no precedence over either a DL_CONNECT_RES
or a DL_DISCONNECT_REQ primitive that is associated with another connection
correlation number (dl_correlation), and should therefore be placed on the queue
behind such primitives.

@item Similarly, a DL_DISCONNECT_REQ primitive has no precedence over either a
DL_CONNECT_RESor a DL_DISCONNECT_REQ primitive that is associated with another
connection correlation number, and should therefore be placed on the queue
behind such primitives.  Notice, however, that a DL_DISCONNECT_REQ does have
precedence over a DL_CONNECT_RES primitive that is associated with the same
correlation number (this is indicated in the table below).
@end itemize

PRIM Y P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15PRIM X (on queue) P1 DL_INFO_REQ P2 DL_ATTACH_REQ P3 DL_DETACH_REQ P4 DL_BIND_REQ P5 DL_UNBIND_REQ P6 DL_UNITDATA_REQ 1 P7 DL_UDQOS_REQ P8 DL_CONNECT_REQ 4 P9 DL_CONNECT_RES 3 1 1 P10 DL_TOKEN_REQ P11 DL_DISCONNECT_REQ 1 P12 DL_DATA_REQ 5 1 3 3 P13 DL_RESET_REQ 3 P14 DL_RESET_RES 3 1 1 P15 DL_SUBS_BIND_REQ

TABLE 12.  Write Queue Precedence

KEY: Code Interpretation

Empty box indicates a scenario which cannot take place." "

Y has no precedence over X and should be placed on queue behind X.1 Y has precedence over X and may advance ahead of X.2 Y has precedence over X and X must be removed.3 Y has precedence over X and both X and Y must be removed.4 Y may have precedence over X (DLS provider's choice), and if so then X must beremoved.5

@page
@node Read Queue Precedence
@appendixsec Read Queue Precedence
The following table presents the precedence rules for DLS provider-originated
primitives on the DLSuser's STREAMS read queue.

For connection establishment primitives, this table represents the possible
pairs of DLPI primitives whenconnect indications/responses are single-threaded.
For the multi-threading scenario, the following rules apply:

@enumerate
@item A DL_CONNECT_IND primitive has no precedence over either a DL_CONNECT_IND
or a DL_DISCONNECT_IND primitive that is associated with another connection
correlation number (dl_correlation), and should therefore be placed on the queue
behind such primitives.

@item Similarly, a DL_DISCONNECT_IND primitive has no precedence over either
a DL_CONNECT_IND or a DL_DISCONNECT_IND primitive that is associated with another
connection correlation number, and should therefore be placed on the queue
behind such primitives.

@item A DL_DISCONNECT_IND does have precedence over a DL_CONNECT_IND primitive
that isassociated with the same correlation number (this is indicated in the
table below).  If a DL_DISCONNECT_IND is about to be placed on the DLS user's
read queue, the user should scanthe read queue for a possible DL_CONNECT_IND
primitive with a matching correlation number.  If a match is found, both the
DL_DISCONNECT_IND and matching DL_CONNECT_IND should beremoved.
@end enumerate

If the DLS user is a user-level process, it's read queue is the stream head read
queue.  Because a userprocess has no control over the placement of DLS primitives
on the stream head read queue, a DLS user cannot straightforwardly initiate the
actions specified in the following precedence table.  Except for theconnection
establishment scenario, the DLS user can ignore the precedence rules defined in
the table below.  This is equivalent to saying the DLS user's read queue contains
at most one primitive.  The only exception to this rule is the processing of
connect indication/response primitives.  A problemarises if a user issues a
DL_CONNECT_RES primitive when a DL_DISCONNECT_IND is on the stream
head read queue.  The DLS provider will not be expecting the connect response
because it has forwardedthe disconnect indication to the DLS user and is in the
DL_IDLE state.  It will therefore generate an error upon seeing the
DL_CONNECT_RES.  To avoid this error, the DLS user should not respond to
a DL_CONNECT_IND primitive if the stream head read queue is not empty.  The
assumption here is a nonempty queue may be holding a disconnect indication that
is associated with the connect indication that isbeing processed.

When connect indications/responses are single-threaded, a non-empty read queue
can only contain a DL_DISCONNECT_IND, which must be associated with the
outstanding DL_CONNECT_IND.  This DL_DISCONNECT_IND primitive indicates to the
DLS user that the DL_CONNECT_IND is to beremoved.  The DLS user should not issue
a response to the DL_CONNECT_IND if a DL_DISCONNECT_IND is received.  The
multi-threaded scenario is slightly more complex, because multiple
DL_CONNECT_IND and DL_DISCONNECT_IND primitives may be interspersed on the stream
head read queue.  In this scenario, the DLS user should retrieve all indications
on the queue before responding to a given connect indication.If a queued
primitive is a DL_CONNECT_IND, it should be stored by the user process for
eventual response.  If a queued primitive is a DL_DISCONNECT_IND, it should be
matched (using the correlationnumber) against any stored connect indications.
The matched connect indication should then be removed, just as is done in the
single-threaded scenario.

PRIM Y P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14PRIM X (on queue) P1 DL_INFO_ACK 1 1 1 1 1 1 1 1 P2 DL_BIND_ACK 1 1 P3 DL_UNITDATA_IND 2 1 2 2 2 P4 DL_UDERROR_IND 2 1 1 2 2 P5 DL_CONNECT_IND 2 2 4 P6 DL_CONNECT_CON 2 2 3 1 1 P7 DL_TOKEN_ACK 1 1 1 1 1 1 P8 DL_DISCONNECT_IND 2 1 2 2 P9 DL_DATA_IND 2 2 5 1 3 3 2 P10 DL_RESET_IND 2 2 3 2 P11 DL_RESET_CON 2 2 3 1 1 2 P12 DL_OK_ACK 1 1 1 1 1 1 P13 DL_ERROR_ACK 1 1 1 1 1 1 1 P14 DL_SUBS_BIND_ACK 1 1

TABLE 13.  Read Queue Precedence

KEY: Code Interpretation

Empty box indicates a scenario which cannot take place." "

Y has no precedence over X and should be placed on queue behind X.1 Y has precedence over X and may advance ahead of X.2 Y has precedence over X and X must be removed.3 Y has precedence over X and both X and Y must be removed.4 Y may have precedence over X (DLS provider's choice), and if so then X must beremoved.5

@node Glossary of DLPI Terms and Acronyms
@appendix Glossary of DLPI Terms and Acronyms
The following acronyms apply to the Data Link Provider Interface:
@table @asis
@item DLPI
Data Link Provider Interface
@item DLS
Data Link Service
@item DLSAP
Data Link Service Access Point
@item DLSDU
Data Link Service Data Unit
@item ISO
International Organization for Standardization
@item OSI
Open Systems Interconnection
@item PPA
Physical Point of Attachment
@item QOS
Quality of Service
@end table

The following terms apply to the Data Link Provider Interface:
@table @asis
@item Called DLS user
The DLS user in connection mode that processes requests for connections from
other DLS users.

@item Calling DLS user
The DLS user in connection mode that initiates the establishment of a data link
connection.

@item Communication endpoint
The local communication channel between a DLS user and DLS provider.

@item Connection establishment
The phase in connection mode that enables two DLS users to create a data link
connection between them.

@item Connectionless mode
A mode of transfer in which data is passed from one user to another in
self-contained units with no logical relationship required among the units.

@item Connection management stream
A special stream that will receive all incoming connect indications destined for
DLSAP addresses that are not bound to any other streams associated with a
particular PPA.

@item Connection mode
A circuit-oriented mode of transfer in which data is passed from one user to
another over an established connection in a sequenced manner.

@item Connection release
The phase in connection mode that terminates a previously established data link
connection.

@item Data link service data unit
A grouping of DLS user data whose boundaries are preserved from one end of a
data link connection to the other.

@item Data transfer
The phase in connection and connectionless modes that supports the transfer of
data between two DLS users.

@item DLSAP
An point at a DLS user attaches itself to a DLS provider to access data link
services.

@item DLSAP address
An identifier used to differentiate and locate specific DLS user access points
to a DLS provider.

@item DLS provider
The data link layer protocol that provides the services of the Data Link
Provider Interface.

@item DLS user
The user-level application or user-level or kernel-level protocol that accesses
the services of the data link layer.

@item Local management
The phase in connection and connectionless modes in which a DLS user initializes
a stream and binds a DLSAP to the stream.  Primitives in this phase generate
local operations only.

@item PPA
The point at which a system attaches itself to a physical communications medium.

@item PPA identifier
An identifier of a particular physical medium over which communication
transpires.

@item Quality of service
Characteristics of transmission quality between two DLS users.

@end table

@node Guidelines for Protocol Independent DLS Users
@appendix Guidelines for Protocol Independent DLS Users
DLPI enables a DLS user to be implemented in a protocol-independent manner such
that the DLS user canoperate over many DLS providers without changing the DLS
user software.  DLS user implementors must adhere to the following guidelines,
however, to achieve this independence.

@itemize @bullet
@item The protocol-specific service limits returned in the DL_INFO_ACK primitive
(e.g.  dl_max_sdu) mustnot be exceeded.  The DLS user should access these limits
and adhere to them while interacting with the DLS provider.

@item Protocol-specific DLSAP address and PPA identifier formats should be
hidden from DLS usersoftware.  Hard-coded addresses and identifiers must be
avoided.  The DLS user should retrieve the necessary information from some other
entity (such as a management entity or a higher layer protocolentity) and insert
it without inspection into the appropriate primitives.

@item The DLS user should not be written to a specific style of DLS provider
(i.e.  style 1 vs.  style 2).  The DL_INFO_ACK returns sufficient information to
identify which style of provider has been accessed, and the DLS user should
perform (or not perform) a DL_ATTACH_REQ accordingly.

@item The names of devices should not be hard-coded into user-level programs
that access a DLS provider.

@item The DLS user should access the dl_service_mode field of the DL_INFO_ACK
primitive to determinewhether connection or connectionless services are
available on a given stream.

@end itemize

@node Required Information for DLS Provider-Specific Addenda
@appendix Required Information for DLS Provider-Specific Addenda
DLPI is a general interface to the services of any DLS provider.  However, areas
have been documented inthis specification where DLS provider-specific
information can be conveyed and interpreted.  This appendix summarizes all
provider-specific issues as an aid to developers of DLS providerimplementations.
As such, it forms a checklist of required information that should be documented
in some manner as part of the provider implementation.  The areas DLS
provider-specific addendumdocumentation must address are:

@itemize @bullet
@item DLSAP Address Space

@item PPA Access and Control

@item Quality of Service

@item DL_INFO_ACK Values

@item Supported Services
@end itemize

For each area listed, a brief description of the provider-specific item(s)
associated with it will bepresented, including references to the appropriate
section in this specification.

DLSAP Address Space (Sections 2.3.2 and 4.1.6) The format of a DLSAP address is
specific to each DLS provider, as is the management of that addressspace.  There
are no restriction on the format or style of a DLSAP address.  As such, a
specific implementation should document the format, size, and restrictions of a
DLSAP address, as well asinformation on how the address space is managed.  For
example, DLPI enables a DLS user to choose a specific DLSAP address to be bound
to a stream, but a given implementation may pre-associate addresseswith streams
based, for example, on the major/minor device number of the stream.  In this
case, the DLS user could only retrieve the address associated with a stream.  If
the DLS provider enables a user to select the DLSAP address for a stream, the
implementation mustdocument the contents of the dl_sap field in the DL_BIND_REQ.
This field must contain sufficientinformation to enable the DLS provider to
determine the chosen DLSAP address.  This may be the full DLSAP address (if it is
not larger than sizeof(ulong)), or some distinguishable part of that address.
Forexample, an implementation of a DLS provider conforming to the ISO 8802/2
address space might allow the DSAP or SSAP portion of the DLSAP address to be
specified here, where the MAC address portionremains constant over all DLSAP
addresses managed by that provider.

Another aspect of address management is whether the provider supports the
ability to dynamically allocate DLSAPs other than the requested DLSAP in a
DL_BIND_REQ.  Restrictions on DLSAPs might cover the range of supported DLSAP
values, services provided by a DLSAP, connection management, and multiplexing.  An
example of connection management restrictions is the number of connections
allowed per DLSAP.  Examples of multiplexing restrictions include thenumber of
DLSAPs per PPA, and requirements that certain DLSAPs are attached to specific
PPAs.

Subsequent DLSAP Addresses (Section 4.1.9) The IEEE 802.2 link layer standard
allows two ways of specifying a DLSAP value:

@itemize @bullet
@item Using an IEEE reserved DLSAP which corresponds to a well-defined protocol.

@item Using a privately defined DLSAP.  Previously, subnetworks used privately
defined DLSAP values.  As these subnetworks move into the OSIworld, they may
exist in environments with other vendors machines.  This presents a problem
because there are only 64 privately definable DLSAPS and any other vendor may
choose to use these same DLSAP values.
@end itemize

IEEE 802.1 has defined a third way of assigning DLSAP values that will allow for
unique private protocol demultiplexing.  The DL_SUBS_BIND_REQ may be used to
support this method.  The Subsequent binding of DLSAPs can be peer or
hierarchical.  When the User requests peer addressing,the DL_SUBS_BIND_REQ will
specify a DLSAP that may be used in lieu of the DLSAP that was bound in the
DL_BIND_REQ.  This will allow for a choice to be made between a number of DLSAPs
on a streamwhen determining traffic based on DLSAP values.  An example of this
would be to various ether_type values as DLSAPs.  The DL_BIND_REQ, for example,
could be issued with ether_type value of IP, and asubsequent bind could be
issued with ether type value of ARP.  The Provider may now multiplex off of the
ether_type field and allow for either IP or ARP traffic to be sent up this
stream.  When the DLS User requests hierarchical binding, the DL_SUBS_BIND_REQ
will specify a DLSAP thatwill be used in addition to the DLSAP bound using a
DL_BIND_REQ.  This will allow additional information to be specified, that will
be used in a header or used for demultiplexing.  An example of thiswould be to
use hierarchical bind to specify the OUI (organizationally unique identifier) to
be used by SNAP.  If a DLS Provider supports peer subsequent bind operations, the
first SAP that is bound is used as thesource SAP when there is ambiguity.

PPA Access and Control (Sections 2.3.1 and 4.1.1) A physical point of attachment
(PPA) is referenced in DLPI by a PPA identifier, which is of type 'ulong'.The
format of this identifier is provider-specific.  The DLS provider addendum
documentation should describe the format and generation of PPA identifiers for
all physical media it is expected to control.  Itshould also describe how a PPA
is controlled, the capabilities of the PPA, the number of PPAs supported, and
the administrative interface.  Multiplexing capabilities of a PPA should also be
described in the DLS provider addendumdocumentation.  This conveys information on
the number of DLSAPs that may be supported per PPA, and the number of PPAs
supported.  Another item that should be described is the manner in which a PPA is
initialized.  Section 4.1.1, PPA Initialization/De-initialization, presents the
alternative methods supported by DLPI for initializing a PPA.The interactions of
auto-initialization or pre-initialization with the Attach and Bind services
should be discussed, and the following items should be addressed.

@itemize @bullet
@item Is auto-initialization, pre-initialization, or both supported for a PPA?

@item Can the method of initialization be restricted on a PPA basis?
@end itemize

Quality of Service (Section 5) Support of QOS parameter negotiation and
selection is a provider-specific issue that must be described foreach
implementation.  The DLS provider addendum documentation should describe which,
if any, QOS parameters are supported by the provider.  For parameters that are
negotiated end-to-end, the addendumshould describe whether the provider supports
end-to-end negotiation, or whether these parameters are negotiated in a local
manner only.  Finally, default QOS parameter values should be documented.
DL_INFO_ACK Values (Section 4.1.3) The DL_INFO_ACK primitive specifies
information on a DLS provider's restrictions and capabilities.The DLS provider
addendum documentation should describe the values for all fields in the
DL_INFO_ACK, and how they are determined (static, tunable, dynamic).  At a
minimum, the addendummust describe the provider style and the service modes
supported by the DLS provider.

Supported Services (Section 3) The overall services that a specific DLS provider
supports should be described.  These include whether aprovider supports
connection-mode service, connectionless-mode service (acknowledged or
OSI Work Group unacknowledged), or both, and how a DLS user selects the
appropriate mode.  For example, the mode maybe mapped directly to a specific
major/minor device, and the user selects an appropriate mode by opening the
corresponding special file.  Alternatively, a DLS provider that supports both
modes may enable a DLSuser to select the service mode on the DL_BIND_REQ.

The file name(s) used to access a particular DLS provider and/or specific
service modes of that providermust also be documented.

@node DLPI Header File
@appendix DLPI Header File
This appendix contains a listing of the DLPI header file needed by
implementations of both DLS user and DLS provider software.

@smallexample
#ifndef _SYS_DLPI_H
#define _SYS_DLPI_H

/*
 * dlpi.h header for Data Link Provider Interface
 */

/*
 * This header file has encoded the values so an existing driver
 * or user which was written with the Logical Link Interface(LLI)
 * can migrate to the DLPI interface in a binary compatible manner.
 * Any fields which require a specific format or value are flagged
 * with a comment containing the message LLI compatibility.
 */

/*
 * DLPI revision definition history
 */
#define DL_CURRENT_VERSION 0x02 /* current version of dlpi */
#define DL_VERSION_2 0x02       /* version of dlpi March 12,1991 */

/*
 * Primitives for Local Management Services
 */
#define DL_INFO_REQ 0x00        /* Information Req, LLI compatibility */
#define DL_INFO_ACK 0x03        /* Information Ack, LLI compatibility */
#define DL_ATTACH_REQ 0x0b      /* Attach a PPA */
#define DL_DETACH_REQ 0x0c      /* Detach a PPA */

#define DL_BIND_REQ 0x01        /* Bind dlsap address, LLI compatibility */
#define DL_BIND_ACK 0x04        /* Dlsap address bound, LLI compatibility */
#define DL_UNBIND_REQ 0x02      /* Unbind dlsap address, LLI compatibility */
#define DL_OK_ACK 0x06          /* Success acknowledgment, LLI compatibility */
#define DL_ERROR_ACK 0x05       /* Error acknowledgment, LLI compatibility */
#define DL_SUBS_BIND_REQ 0x1b   /* Bind Subsequent DLSAP address */

#define DL_SUBS_BIND_ACK 0x1c   /* Subsequent DLSAP address bound */
#define DL_SUBS_UNBIND_REQ 0x15 /* Subsequent unbind */
#define DL_ENABMULTI_REQ 0x1d   /* Enable multicast addresses */
#define DL_DISABMULTI_REQ 0x1e  /* Disable multicast addresses */
#define DL_PROMISCON_REQ 0x1f   /* Turn on promiscuous mode */
#define DL_PROMISCOFF_REQ 0x20  /* Turn off promiscuous mode */

/*
 * Primitives used for Connectionless Service
 */
#define DL_UNITDATA_REQ 0x07    /* datagram send request, LLI compatibility */
#define DL_UNITDATA_IND 0x08    /* datagram receive indication, LLI
                                   compatibility */

#define DL_UDERROR_IND 0x09     /* datagram error indication, LLI compatibility 
                                 */
#define DL_UDQOS_REQ 0x0a       /* set QOS for subsequent datagram
                                   transmissions */

/*
 * Primitives used for Connection-Oriented Service
 */
#define DL_CONNECT_REQ 0x0d     /* Connect request */

#define DL_CONNECT_IND 0x0e     /* Incoming connect indication */
#define DL_CONNECT_RES 0x0f     /* Accept previous connect indication */
#define DL_CONNECT_CON 0x10     /* Connection established */

#define DL_TOKEN_REQ 0x11       /* Passoff token request */
#define DL_TOKEN_ACK 0x12       /* Passoff token ack */
#define DL_DISCONNECT_REQ 0x13  /* Disconnect request */
#define DL_DISCONNECT_IND 0x14  /* Disconnect indication */

#define DL_RESET_REQ 0x17       /* Reset service request */
#define DL_RESET_IND 0x18       /* Incoming reset indication */
#define DL_RESET_RES 0x19       /* Complete reset processing */
#define DL_RESET_CON 0x1a       /* Reset processing complete */

/*
 * Primitives used for Acknowledged Connectionless Service
 */
#define DL_DATA_ACK_REQ 0x21    /* data unit transmission request */
#define DL_DATA_ACK_IND 0x22    /* Arrival of a command PDU */
#define DL_DATA_ACK_STATUS_IND 0x23     /* Status indication of DATA_ACK_REQ */
#define DL_REPLY_REQ 0x24       /* Request a DLSDU from the remote */
#define DL_REPLY_IND 0x25       /* Arrival of a command PDU */
#define DL_REPLY_STATUS_IND 0x26        /* Status indication of REPLY_REQ */
#define DL_REPLY_UPDATE_REQ 0x27        /* Hold a DLSDU for transmission */
#define DL_REPLY_UPDATE_STATUS_IND 0x28 /* Status of REPLY_UPDATE req */

/*
 * Primitives used for XID and TEST operations
 */
#define DL_XID_REQ 0x29         /* Request to send an XID PDU */
#define DL_XID_IND 0x2a         /* Arrival of an XID PDU */
#define DL_XID_RES 0x2b         /* request to send a response XID PDU */
#define DL_XID_CON 0x2c         /* Arrival of a response XID PDU */
#define DL_TEST_REQ 0x2d        /* TEST command request */
#define DL_TEST_IND 0x2e        /* TEST response indication */
#define DL_TEST_RES 0x2f        /* TEST response */
#define DL_TEST_CON 0x30        /* TEST Confirmation */

/*
 * Primitives to get and set the physical address, and to get
 * Statistics
 */

#define DL_PHYS_ADDR_REQ 0x31   /* Request to get physical addr */
#define DL_PHYS_ADDR_ACK 0x32   /* Return physical addr */
#define DL_SET_PHYS_ADDR_REQ 0x33       /* set physical addr */
#define DL_GET_STATISTICS_REQ 0x34      /* Request to get statistics */
#define DL_GET_STATISTICS_ACK 0x35      /* Return statistics */

/*
 * DLPI interface states
 */
#define DL_UNATTACHED 0x04      /* PPA not attached */
#define DL_ATTACH_PENDING 0x05  /* Waiting ack of DL_ATTACH_REQ */
#define DL_DETACH_PENDING 0x06  /* Waiting ack of DL_DETACH_REQ */

#define DL_UNBOUND 0x00         /* PPA attached, LLI compatibility */
#define DL_BIND_PENDING 0x01    /* Waiting ack of DL_BIND_REQ, LLI
                                   compatibility */
#define DL_UNBIND_PENDING 0x02  /* Waiting ack of DL_UNBIND_REQ, LLI
                                   compatibility */
#define DL_IDLE 0x03            /* dlsap bound, awaiting use, LLI compatibility 
                                 */
#define DL_UDQOS_PENDING 0x07   /* Waiting ack of DL_UDQOS_REQ */
#define DL_OUTCON_PENDING 0x08  /* outgoing connection, awaiting DL_CONN_CON */

#define DL_INCON_PENDING 0x09   /* incoming connection, awaiting DL_CONN_RES */
#define DL_CONN_RES_PENDING 0x0a        /* Waiting ack of DL_CONNECT_RES */
#define DL_DATAXFER 0x0b        /* connection-oriented data transfer */
#define DL_USER_RESET_PENDING 0x0c      /* user initiated reset, awaiting
                                           DL_RESET_CON */
#define DL_PROV_RESET_PENDING 0x0d      /* provider initiated reset, awaiting
                                           DL_RESET_RES */
#define DL_RESET_RES_PENDING 0x0e       /* Waiting ack of DL_RESET_RES */

#define DL_DISCON8_PENDING 0x0f /* Waiting ack of DL_DISC_REQ when in
                                   DL_OUTCON_PENDING */

#define DL_DISCON9_PENDING 0x10 /* Waiting ack of DL_DISC_REQ when in
                                   DL_INCON_PENDING */
#define DL_DISCON11_PENDING 0x11        /* Waiting ack of DL_DISC_REQ when in
                                           DL_DATAXFER */
#define DL_DISCON12_PENDING 0x12        /* Waiting ack of DL_DISC_REQ when in
                                           DL_USER_RESET_PENDING */

#define DL_DISCON13_PENDING 0x13        /* Waiting ack of DL_DISC_REQ when in
                                           DL_DL_PROV_RESET_PENDING */
#define DL_SUBS_BIND_PND 0x14   /* Waiting ack of DL_SUBS_BIND_REQ */
#define DL_SUBS_UNBIND_PND 0x15 /* Waiting ack of DL_SUBS_UNBIND_REQ */

/*
 * DL_ERROR_ACK error return values
 *
 */
#define DL_ACCESS 0x02          /* Improper permissions for request, LLI
                                   compatibility */
#define DL_BADADDR 0x01         /* DLSAP address in improper format or invalid */
#define DL_BADCORR 0x05         /* Sequence number not from outstanding
                                   DL_CONN_IND */
#define DL_BADDATA 0x06         /* User data exceeded provider limit */
#define DL_BADPPA 0x08          /* Specified PPA was invalid */
#define DL_BADPRIM 0x09         /* Primitive received is not known by DLS
                                   provider */
#define DL_BADQOSPARAM 0x0a     /* QOS parameters contained invalid values */
#define DL_BADQOSTYPE 0x0b      /* QOS structure type is unknown or unsupported 
                                 */
#define DL_BADSAP 0x00          /* Bad LSAP selector, LLI compatibility */
#define DL_BADTOKEN 0x0c        /* Token used not associated with an active
                                   stream */

#define DL_BOUND 0x0d /* Attempted second bind with dl_max_conind or */

/* dl_conn_mgmt > 0 on same DLSAP or PPA */
#define DL_INITFAILED 0x0e      /* Physical Link initialization failed */
#define DL_NOADDR 0x0f          /* Provider couldn't allocate alternate address 
                                 */
#define DL_NOTINIT 0x10         /* Physical Link not initialized */
#define DL_OUTSTATE 0x03        /* Primitive issued in improper state, LLI
                                   compatibility */
#define DL_SYSERR 0x04          /* UNIX system error occurred, LLI
                                   compatibility */
#define DL_UNSUPPORTED 0x07     /* Requested service not supplied by provider */
#define DL_UNDELIVERABLE 0x11   /* Previous data unit could not be delivered */
#define DL_NOTSUPPORTED 0x12    /* Primitive is known but not supported by DLS
                                   provider */
#define DL_TOOMANY 0x13         /* limit exceeded */
#define DL_NOTENAB 0x14         /* Promiscuous mode not enabled */
#define DL_BUSY 0x15            /* Other streams for a particular PPA in the
                                   post-attached state */
#define DL_NOAUTO 0x16          /* Automatic handling of XID & TEST responses
                                   not supported */
#define DL_NOXIDAUTO 0x17       /* Automatic handling of XID not supported */
#define DL_NOTESTAUTO 0x18      /* Automatic handling of TEST not supported */
#define DL_XIDAUTO 0x19         /* Automatic handling of XID response */
#define DL_TESTAUTO 0x1a        /* AUtomatic handling of TEST response */
#define DL_PENDING 0x1b         /* pending outstanding connect indications */

/*
 * NOTE: The range of error codes, 0x80 - 0xff is reserved for
 * implementation specific error codes.  This reserved range of error
 * codes will be defined by the DLS Provider.
 */
/*
 * DLPI media types supported
 */
#define DL_CSMACD 0x0           /* IEEE 802.3 CSMA/CD network, LLI
                                   Compatibility */
#define DL_TPB 0x1              /* IEEE 802.4 Token Passing Bus, LLI
                                   Compatibility */
#define DL_TPR 0x2              /* IEEE 802.5 Token Passing Ring, LLI
                                   Compatibility */
#define DL_METRO 0x3            /* IEEE 802.6 Metro Net, LLI Compatibility */

#define DL_ETHER 0x4            /* Ethernet Bus, LLI Compatibility */
#define DL_HDLC 0x05            /* ISO HDLC protocol support, bit synchronous */
#define DL_CHAR 0x06            /* Character Synchronous protocol support, eg
                                   BISYNC */
#define DL_CTCA 0x07            /* IBM Channel-to-Channel Adapter */
#define DL_FDDI 0x08            /* Fiber Distributed data interface */
#define DL_OTHER 0x09           /* Any other medium not listed above */

/*
 * DLPI provider service supported.
 * These must be allowed to be bitwise-OR for dl_service_mode in
 * DL_INFO_ACK.
 */
#define DL_CODLS 0x01           /* support connection-oriented service */
#define DL_CLDLS 0x02           /* support connectionless data link service */
#define DL_ACLDLS 0x04          /* support acknowledged connectionless service */

/*
 * DLPI provider style.
 * The DLPI provider style which determines whether a provider
 * requires a DL_ATTACH_REQ to inform the provider which PPA
 * user messages should be sent/received on.
 */
#define DL_STYLE1 0x0500        /* PPA is implicitly bound by open(2) */
#define DL_STYLE2 0x0501        /* PPA must be explicitly bound via
                                   DL_ATTACH_REQ */

/*
 * DLPI Originator for Disconnect and Resets
 */
#define DL_PROVIDER 0x0700
#define DL_USER 0x0701

/*
 * DLPI Disconnect Reasons
 */
#define DL_CONREJ_DEST_UNKNOWN 0x0800
#define DL_CONREJ_DEST_UNREACH_PERMANENT 0x0801
#define DL_CONREJ_DEST_UNREACH_TRANSIENT 0x0802
#define DL_CONREJ_QOS_UNAVAIL_PERMANENT 0x0803
#define DL_CONREJ_QOS_UNAVAIL_TRANSIENT 0x0804

#define DL_CONREJ_PERMANENT_COND 0x0805
#define DL_CONREJ_TRANSIENT_COND 0x0806
#define DL_DISC_ABNORMAL_CONDITION 0x0807
#define DL_DISC_NORMAL_CONDITION 0x0808
#define DL_DISC_PERMANENT_CONDITION 0x0809
#define DL_DISC_TRANSIENT_CONDITION 0x080a

#define DL_DISC_UNSPECIFIED 0x080b

/*
 * DLPI Reset Reasons
 */
#define DL_RESET_FLOW_CONTROL 0x0900
#define DL_RESET_LINK_ERROR 0x0901
#define DL_RESET_RESYNCH 0x0902

/*
 * DLPI status values for acknowledged connectionless data transfer
 */
#define DL_CMD_MASK 0x0f        /* mask for command portion of status */

#define DL_CMD_OK 0x00          /* Command Accepted */
#define DL_CMD_RS 0x01          /* Unimplemented or inactivated service */
#define DL_CMD_UE 0x05          /* Data Link User interface error */
#define DL_CMD_PE 0x06          /* Protocol error */
#define DL_CMD_IP 0x07          /* Permanent implementation dependent error */
#define DL_CMD_UN 0x09          /* Resources temporarily unavailable */

#define DL_CMD_IT 0x0f          /* Temporary implementation dependent error */
#define DL_RSP_MASK 0xf0        /* mask for response portion of status */
#define DL_RSP_OK 0x00          /* Response DLSDU present */
#define DL_RSP_RS 0x10          /* Unimplemented or inactivated service */
#define DL_RSP_NE 0x30          /* Response DLSDU never submitted */
#define DL_RSP_NR 0x40          /* Response DLSDU not requested */

#define DL_RSP_UE 0x50 /* Data Link User interface error */

#define DL_RSP_IP 0x70 /* Permanent implementation dependent error */
#define DL_RSP_UN 0x90 /* Resources temporarily unavailable */
#define DL_RSP_IT 0xf0 /* Temporary implementation dependent error */

/*
 * Service Class values for acknowledged connectionless data transfer
 */
#define DL_RQST_RSP 0x01        /* Use acknowledge capability in MAC sublayer */
#define DL_RQST_NORSP 0x02      /* No acknowledgement service requested */

/*
 * DLPI address type definition
 */
#define DL_FACT_PHYS_ADDR 0x01  /* factory physical address */
#define DL_CURR_PHYS_ADDR 0x02  /* current physical address */

/*
 * DLPI flag definitions
 */
#define DL_POLL_FINAL 0x01      /* if set,indicates poll/final bit set */

/*
 * XID and TEST responses supported by the provider
 */
#define DL_AUTO_XID 0x01        /* provider will respond to XID */
#define DL_AUTO_TEST 0x02       /* provider will respond to TEST */

/*
 * Subsequent bind type
 */
#define DL_PEER_BIND 0x01       /* subsequent bind on a peer addr */
#define DL_HIERARCHICAL_BIND 0x02       /* subs_bind on a hierarchical addr */

/*
 * DLPI promiscuous mode definitions
 */
#define DL_PROMISC_PHYS 0x01    /* promiscuous mode at phys level */
#define DL_PROMISC_SAP 0x02     /* promiscous mode at sap level */
#define DL_PROMISC_MULTI 0x03   /* promiscuous mode for multicast */

/*
 * DLPI Quality Of Service definition for use in QOS structure definitions.
 * The QOS structures are used in connection establishment, DL_INFO_ACK,
 * and setting connectionless QOS values.
 */

/*
 * Throughput
 *
 * This parameter is specified for both directions.
 */
typedef struct @{
        long dl_target_value;           /* desired bits/second desired */
        long dl_accept_value;           /* min.  acceptable bits/second */
@} dl_through_t;
@tpindex dl_through_t

/*
 * transit delay specification
 *
 * This parameter is specified for both directions.
 * expressed in milliseconds assuming a DLSDU size of 128 octets.
 * The scaling of the value to the current DLSDU size is provider dependent.
 */
typedef struct @{
        long dl_target_value;           /* desired value of service */
        long dl_accept_value;           /* min.  acceptable value of service */
@} dl_transdelay_t;
@tpindex dl_transdelay_t

/*
 * priority specification
 * priority range is 0-100, with 0 being highest value.
 */
typedef struct @{
        long dl_min;
        long dl_max;
@} dl_priority_t;
@tpindex dl_priority_t

/*
 * protection specification
 *
 */
#define DL_NONE 0x0B01          /* no protection supplied */
#define DL_MONITOR 0x0B02       /* protection against passive monitoring */
#define DL_MAXIMUM 0x0B03       /* protection against modification, replay, */

/* addition, or deletion */

typedef struct @{
        long dl_min;
        long dl_max;
@} dl_protect_t;
@tpindex dl_protect_t

/*
 * Resilience specification
 * probabilities are scaled by a factor of 10,000 with a time interval
 * of 10,000 seconds.
 */
typedef struct @{
        long dl_disc_prob;              /* probability of provider init DISC */
        long dl_reset_prob;             /* probability of provider init RESET */
@} dl_resilience_t;
@tpindex dl_resilience_t

/*
 * QOS type definition to be used for negotiation with the
 * remote end of a connection, or a connectionless unitdata request.
 * There are two type definitions to handle the negotiation
 * process at connection establishment.  The typedef dl_qos_range_t
@tpindex dl_qos_range_t
 * is used to present a range for parameters.  This is used
 * in the DL_CONNECT_REQ and DL_CONNECT_IND messages.  The typedef
 * dl_qos_sel_t is used to select a specific value for the QOS
@tpindex dl_qos_sel_t
 * parameters.  This is used in the DL_CONNECT_RES, DL_CONNECT_CON,
 * and DL_INFO_ACK messages to define the selected QOS parameters
 * for a connection.
 *
 * NOTE
 * A DataLink provider which has unknown values for any of the fields
 * will use a value of DL_UNKNOWN for all values in the fields.
 *
 * NOTE
 * A QOS parameter value of DL_QOS_DONT_CARE informs the DLS
 * provider the user requesting this value doesn't care
 * what the QOS parameter is set to.  This value becomes the
 * least possible value in the range of QOS parameters.
 * The order of the QOS parameter range is then:
 *
 * DL_QOS_DONT_CARE < 0 < MAXIMUM QOS VALUE
 */
#define DL_UNKNOWN -1
#define DL_QOS_DONT_CARE -2

/*
 * Every QOS structure has the first 4 bytes containing a type
 * field, denoting the definition of the rest of the structure.
 * This is used in the same manner has the dl_primitive variable
 * is in messages.
 *
 * The following list is the defined QOS structure type values and structures.
 */
#define DL_QOS_CO_RANGE1 0x0101 /* QOS range struct.  for Connection modeservice 
                                 */

#define DL_QOS_CO_SEL1 0x0102 /* QOS selection structure */
#define DL_QOS_CL_RANGE1 0x0103 /* QOS range struct.  for connectionless*/
#define DL_QOS_CL_SEL1 0x0104 /* QOS selection for connectionless mode*/

typedef struct @{
        ulong dl_qos_type;
        dl_through_t dl_rcv_throughput; /* desired and acceptable */
        dl_transdelay_t dl_rcv_trans_delay;     /* desired and acceptable */
        dl_through_t dl_xmt_throughput;
        dl_transdelay_t dl_xmt_trans_delay;
        dl_priority_t dl_priority;      /* min and max values */
        dl_protect_t dl_protection;     /* min and max values */
        long dl_residual_error;
        dl_resilience_t dl_resilience;
@} dl_qos_co_range1_t;
@tpindex dl_qos_co_range1_t

typedef struct @{
        ulong dl_qos_type;
        long dl_rcv_throughput;
        long dl_rcv_trans_delay;
        long dl_xmt_throughput;
        long dl_xmt_trans_delay;
        long dl_priority;
        long dl_protection;
        long dl_residual_error;
        dl_resilience_t dl_resilience;
@} dl_qos_co_sel1_t;
@tpindex dl_qos_co_sel1_t

typedef struct @{
        ulong dl_qos_type;
        dl_transdelay_t dl_trans_delay;
        dl_priority_t dl_priority;
        dl_protect_t dl_protection;
        long dl_residual_error;
@} dl_qos_cl_range1_t;
@tpindex dl_qos_cl_range1_t

typedef struct @{
        ulong dl_qos_type;
        long dl_trans_delay;
        long dl_priority;
        long dl_protection;
        long dl_residual_error;
@} dl_qos_cl_sel1_t;
@tpindex dl_qos_cl_sel1_t

/*
 * DLPI interface primitive definitions.
 *
 * Each primitive is sent as a stream message.  It is possible that
 * the messages may be viewed as a sequence of bytes that have the
 * following form without any padding.  The structure definition
 * of the following messages may have to change depending on the
 * underlying hardware architecture and crossing of a hardware
 * boundary with a different hardware architecture.
 *
 * Fields in the primitives having a name of the form
 * dl_reserved cannot be used and have the value of
 * binary zero, no bits turned on.
 *
 * Each message has the name defined followed by the
 * stream message type (M_PROTO, M_PCPROTO, M_DATA)
 */

/*
 * LOCAL MANAGEMENT SERVICE PRIMITIVES
 */

/*
 * DL_INFO_REQ, M_PCPROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* set to DL_INFO_REQ */
@} dl_info_req_t;
@tpindex dl_info_req_t

/*
 * DL_INFO_ACK, M_PCPROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* set to DL_INFO_ACK */
        ulong dl_max_sdu;               /* Max bytes in a DLSDU */
        ulong dl_min_sdu;               /* Min bytes in a DLSDU */
        ulong dl_addr_length;           /* length of DLSAP address */
        ulong dl_mac_type;              /* type of medium supported */
        ulong dl_reserved;              /* value set to zero */
        ulong dl_current_state;         /* state of DLPI interface */
        long dl_sap_length;             /* current length of SAP part of dlsap
                                           address */
        ulong dl_service_mode;          /* CO, CL or ACL */
        ulong dl_qos_length;            /* length of qos values */
        ulong dl_qos_offset;            /* offset from beg.  of block */
        ulong dl_qos_range_length;      /* available range of qos */
        ulong dl_qos_range_offset;      /* offset from beg.  of block */
        ulong dl_provider_style;        /* style1 or style2 */
        ulong dl_addr_offset;           /* offset of the dlsap addr */
        ulong dl_version;               /* version number */
        ulong dl_brdcst_addr_length;    /* length of broadcast addr */
        ulong dl_brdcst_addr_offset;    /* offset from beg.  of block */
        ulong dl_growth;                /* set to zero */
@} dl_info_ack_t;
@tpindex dl_info_ack_t

/*
 * DL_ATTACH_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* set to DL_ATTACH_REQ */
        ulong dl_ppa;                   /* id of the PPA */
@} dl_attach_req_t;
@tpindex dl_attach_req_t

/*
 * DL_DETACH_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* set to DL_DETACH_REQ */
@} dl_detach_req_t;
@tpindex dl_detach_req_t

/*
 * DL_BIND_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* set to DL_BIND_REQ */
        ulong dl_sap;                   /* info to identify dlsap addr */
        ulong dl_max_conind;            /* max # of outstanding con_ind */
        ushort dl_service_mode;         /* CO, CL or ACL */
        ushort dl_conn_mgmt;            /* if non-zero, is con-mgmt stream */
        ulong dl_xidtest_flg;           /* if set to 1 indicates automatic
                                           initiation of test and xid frames */
@} dl_bind_req_t;
@tpindex dl_bind_req_t

/*
 * DL_BIND_ACK, M_PCPROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_BIND_ACK */
        ulong dl_sap;                   /* DLSAP addr info */
        ulong dl_addr_length;           /* length of complete DLSAP addr */
        ulong dl_addr_offset;           /* offset from beginning of M_PCPROTO */
        ulong dl_max_conind;            /* allowed max.  # of con-ind */
        ulong dl_xidtest_flg;           /* responses supported by provider */
@} dl_bind_ack_t;
@tpindex dl_bind_ack_t

/*
 * DL_SUBS_BIND_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_SUBS_BIND_REQ */
        ulong dl_subs_sap_offset;       /* offset of subs_sap */
        ulong dl_subs_sap_length;       /* length of subs_sap */
        ulong dl_subs_bind_class;       /* peer or hierarchical */
@} dl_subs_bind_req_t;
@tpindex dl_subs_bind_req_t

/*
 * DL_SUBS_BIND_ACK, M_PCPROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_SUBS_BIND_ACK */
        ulong dl_subs_sap_offset;       /* offset of subs_sap */
        ulong dl_subs_sap_length;       /* length of subs_sap */
@} dl_subs_bind_ack_t;
@tpindex dl_subs_bind_ack_t

/*
 * DL_UNBIND_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_UNBIND_REQ */
@} dl_unbind_req_t;
@tpindex dl_unbind_req_t

/*
 * DL_SUBS_UNBIND_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_SUBS_UNBIND_REQ */
        ulong dl_subs_sap_offset;       /* offset of subs_sap */
        ulong dl_subs_sap_length;       /* length of subs_sap */
@} dl_subs_unbind_req_t;
@tpindex dl_subs_unbind_req_t

/*
 * DL_OK_ACK, M_PCPROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_OK_ACK */
        ulong dl_correct_primitive;     /* primitive being acknowledged */
@} dl_ok_ack_t;
@tpindex dl_ok_ack_t

/*
 * DL_ERROR_ACK, M_PCPROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_ERROR_ACK */
        ulong dl_error_primitive;       /* primitive in error */
        ulong dl_errno;                 /* DLPI error code */
        ulong dl_unix_errno;            /* UNIX system error code */
@} dl_error_ack_t;
@tpindex dl_error_ack_t

/*
 * DL_ENABMULTI_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_ENABMULTI_REQ */
        ulong dl_addr_length;           /* length of multicast address */
        ulong dl_addr_offset;           /* offset from beg.  of M_PROTO block */
@} dl_enabmulti_req_t;
@tpindex dl_enabmulti_req_t

/*
 * DL_DISABMULTI_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_DISABMULTI_REQ */
        ulong dl_addr_length;           /* length of multicast address */
        ulong dl_addr_offset;           /* offset from beg.  of M_PROTO block */
@} dl_disabmulti_req_t;
@tpindex dl_disabmulti_req_t

/*
 * DL_PROMISCON_REQ, M_PROTO type
 */

typedef struct @{
        ulong dl_primitive;             /* DL_PROMISCON_REQ */
        ulong dl_level;                 /* physical,SAP level or ALL multicast */
@} dl_promiscon_req_t;
@tpindex dl_promiscon_req_t

/*
 * DL_PROMISCOFF_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_PROMISCOFF_REQ */
        ulong dl_level;                 /* Physical,SAP level or ALL multicast */
@} dl_promiscoff_req_t;
@tpindex dl_promiscoff_req_t

/*
 * Primitives to get and set the Physical address
 */

/*
 * DL_PHYS_ADDR_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_PHYS_ADDR_REQ */
        ulong dl_addr_type;             /* factory or current physical addr */
@} dl_phys_addr_req_t;
@tpindex dl_phys_addr_req_t

/*
 * DL_PHYS_ADDR_ACK, M_PCPROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_PHYS_ADDR_ACK */
        ulong dl_addr_length;           /* length of the physical addr */
        ulong dl_addr_offset;           /* offset from beg.  of block */
@} dl_phys_addr_ack_t;
@tpindex dl_phys_addr_ack_t

/*
 * DL_SET_PHYS_ADDR_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_SET_PHYS_ADDR_REQ */
        ulong dl_addr_length;           /* length of physical addr */
        ulong dl_addr_offset;           /* offset from beg.  of block */
@} dl_set_phys_addr_req_t;
@tpindex dl_set_phys_addr_req_t

/*
 * Primitives to get statistics
 */

/*
 * DL_GET_STATISTICS_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_GET_STATISTICS_REQ */
@} dl_get_statistics_req_t;
@tpindex dl_get_statistics_req_t

/*
 * DL_GET_STATISTICS_ACK, M_PCPROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_GET_STATISTICS_ACK */
        ulong dl_stat_length;           /* length of statistics structure */
        ulong dl_stat_offset;           /* offset from beg.  of block */
@} dl_get_statistics_ack_t;
@tpindex dl_get_statistics_ack_t

/*
 * CONNECTION-ORIENTED SERVICE PRIMITIVES
 */

/*
 * DL_CONNECT_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_CONNECT_REQ */
        ulong dl_dest_addr_length;      /* len.  of dlsap addr */
        ulong dl_dest_addr_offset;      /* offset */
        ulong dl_qos_length;            /* len.  of QOS parm val */
        ulong dl_qos_offset;            /* offset */
        ulong dl_growth;                /* set to zero */
@} dl_connect_req_t;
@tpindex dl_connect_req_t

/*
 * DL_CONNECT_IND, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_CONNECT_IND */
        ulong dl_correlation;           /* provider's correlation token */
        ulong dl_called_addr_length;    /* length of called address */
        ulong dl_called_addr_offset;    /* offset from beginning of block */
        ulong dl_calling_addr_length;   /* length of calling address */
        ulong dl_calling_addr_offset;   /* offset from beginning of block */
        ulong dl_qos_length;            /* length of qos structure */
        ulong dl_qos_offset;            /* offset from beginning of block */
        ulong dl_growth;                /* set to zero */
@} dl_connect_ind_t;
@tpindex dl_connect_ind_t

/*
 * DL_CONNECT_RES, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_CONNECT_RES */
        ulong dl_correlation;           /* provider's correlation token */
        ulong dl_resp_token;            /* token associated with responding
                                           stream */
        ulong dl_qos_length;            /* length of qos structure ulong
                                           dl_qos_offset; /* offset from
                                           beginning of block */
        ulong dl_growth;                /* set to zero */
@} dl_connect_res_t;
@tpindex dl_connect_res_t

/*
 * DL_CONNECT_CON, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_CONNECT_CON */
        ulong dl_resp_addr_length;      /* length of responder's address */
        ulong dl_resp_addr_offset;      /* offset from beginning of block */
        ulong dl_qos_length;            /* length of qos structure */
        ulong dl_qos_offset;            /* offset from beginning of block */
        ulong dl_growth;                /* set to zero */
@} dl_connect_con_t;
@tpindex dl_connect_con_t

/*
 * DL_TOKEN_REQ, M_PCPROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_TOKEN_REQ */
@} dl_token_req_t;
@tpindex dl_token_req_t

/*
 * DL_TOKEN_ACK, M_PCPROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_TOKEN_ACK */
        ulong dl_token;                 /* Connection response token associated 
                                           with the stream */
@} dl_token_ack_t;
@tpindex dl_token_ack_t

/*
 * DL_DISCONNECT_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_DISCONNECT_REQ */
        ulong dl_reason;                /* normal, abnormal, perm.  or transient 
                                         */
        ulong dl_correlation;           /* association with connect_ind */
@} dl_disconnect_req_t;
@tpindex dl_disconnect_req_t

/*
 * DL_DISCONNECT_IND, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_DISCONNECT_IND */
        ulong dl_originator;            /* USER or PROVIDER */
        ulong dl_reason;                /* permanent or transient */
        ulong dl_correlation;           /* association with connect_ind */
@} dl_disconnect_ind_t;
@tpindex dl_disconnect_ind_t

/*
 * DL_RESET_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_RESET_REQ */
@} dl_reset_req_t;
@tpindex dl_reset_req_t

/*
 * DL_RESET_IND, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_RESET_IND */
        ulong dl_originator;            /* Provider or User */
        ulong dl_reason;                /* flow control, link error or resynch */
@} dl_reset_ind_t;
@tpindex dl_reset_ind_t

/*
 * DL_RESET_RES, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_RESET_RES */
@} dl_reset_res_t;
@tpindex dl_reset_res_t

/*
 * DL_RESET_CON, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_RESET_CON */
@} dl_reset_con_t;
@tpindex dl_reset_con_t

/*
 * CONNECTIONLESS SERVICE PRIMITIVES
 */

/*
 * DL_UNITDATA_REQ, M_PROTO type, with M_DATA block(s)
 */
typedef struct @{
        ulong dl_primitive;             /* DL_UNITDATA_REQ */
        ulong dl_dest_addr_length;      /* DLSAP length of dest.  user */
        ulong dl_dest_addr_offset;      /* offset from beg.  of block */
        dl_priority_t dl_priority;      /* priority value */
@} dl_unitdata_req_t;
@tpindex dl_unitdata_req_t

/*
 * DL_UNITDATA_IND, M_PROTO type, with M_DATA block(s)
 */
typedef struct @{
        ulong dl_primitive;             /* DL_UNITDATA_IND */
        ulong dl_dest_addr_length;      /* DLSAP length of dest.  user */
        ulong dl_dest_addr_offset;      /* offset from beg.  of block */
        ulong dl_src_addr_length;       /* DLSAP addr length of sending user */
        ulong dl_src_addr_offset;       /* offset from beg.  of block */
        ulong dl_group_address;         /* set to one if multicast/broadcast */
@} dl_unitdata_ind_t;
@tpindex dl_unitdata_ind_t

/*
 * DL_UDERROR_IND, M_PROTO type
 * (or M_PCPROTO type if LLI-based provider)
 */
typedef struct @{
        ulong dl_primitive;             /* DL_UDERROR_IND */
        ulong dl_dest_addr_length;      /* Destination DLSAP */
        ulong dl_dest_addr_offset;      /* Offset from beg.  of block */
        ulong dl_unix_errno;            /* unix system error code */
        ulong dl_errno;                 /* DLPI error code */
@} dl_uderror_ind_t;
@tpindex dl_uderror_ind_t

/*
 * DL_UDQOS_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_UDQOS_REQ */
        ulong dl_qos_length;            /* length in bytes of requested qos */
        ulong dl_qos_offset;            /* offset from beg.  of block */
@} dl_udqos_req_t;
@tpindex dl_udqos_req_t

/*
 * Primitives to handle XID and TEST operations
 */

/*
 * DL_TEST_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_TEST_REQ */
        ulong dl_flag;                  /* poll/final */
        ulong dl_dest_addr_length;      /* DLSAP length of dest.  user */
        ulong dl_dest_addr_offset;      /* offset from beg.  of block */
@} dl_test_req_t;
@tpindex dl_test_req_t

/*
 * DL_TEST_IND, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_TEST_IND */
        ulong dl_flag;                  /* poll/final */
        ulong dl_dest_addr_length;      /* dlsap length of dest.  user */
        ulong dl_dest_addr_offset;      /* offset from beg.  of block */
        ulong dl_src_addr_length;       /* dlsap length of source user */
        ulong dl_src_addr_offset;       /* offset from beg.  of block */
@} dl_test_ind_t;
@tpindex dl_test_ind_t

/*
 * DL_TEST_RES, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_TEST_RES */
        ulong dl_flag;                  /* poll/final */
        ulong dl_dest_addr_length;      /* DLSAP length of dest.  user */
        ulong dl_dest_addr_offset;      /* offset from beg.  of block */
@} dl_test_res_t;
@tpindex dl_test_res_t

/*
 * DL_TEST_CON, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_TEST_CON */
        ulong dl_flag;                  /* poll/final */
        ulong dl_dest_addr_length;      /* dlsap length of dest.  user */
        ulong dl_dest_addr_offset;      /* offset from beg.  of block */
        ulong dl_src_addr_length;       /* dlsap length of source user */
        ulong dl_src_addr_offset;       /* offset from beg.  of block */
@} dl_test_con_t;
@tpindex dl_test_con_t

/*
 * DL_XID_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_XID_REQ */
        ulong dl_flag;                  /* poll/final */
        ulong dl_dest_addr_length;      /* dlsap length of dest.  user */
        ulong dl_dest_addr_offset;      /* offset from beg.  of block */
@} dl_xid_req_t;
@tpindex dl_xid_req_t

/*
 * DL_XID_IND, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_XID_IND */
        ulong dl_flag;                  /* poll/final */
        ulong dl_dest_addr_length;      /* dlsap length of dest.  user */
        ulong dl_dest_addr_offset;      /* offset from beg.  of block */
        ulong dl_src_addr_length;       /* dlsap length of source user */
        ulong dl_src_addr_offset;       /* offset from beg.  of block */
@} dl_xid_ind_t;
@tpindex dl_xid_ind_t

/*
 * DL_XID_RES, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_XID_RES */
        ulong dl_flag;                  /* poll/final */
        ulong dl_dest_addr_length;      /* DLSAP length of dest.  user */
        ulong dl_dest_addr_offset;      /* offset from beg.  of block */
@} dl_xid_res_t;
@tpindex dl_xid_res_t

/*
 * DL_XID_CON, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_XID_CON */
        ulong dl_flag;                  /* poll/final */
        ulong dl_dest_addr_length;      /* dlsap length of dest.  user */
        ulong dl_dest_addr_offset;      /* offset from beg.  of block */
        ulong dl_src_addr_length;       /* dlsap length of source user */
        ulong dl_src_addr_offset;       /* offset from beg.  of block */
@} dl_xid_con_t;
@tpindex dl_xid_con_t

/*
 * ACKNOWLEDGED CONNECTIONLESS SERVICE PRIMITIVES
 */

/*
 * DL_DATA_ACK_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_DATA_ACK_REQ */
        ulong dl_correlation;           /* User's correlation token */
        ulong dl_dest_addr_length;      /* length of destination addr */
        ulong dl_dest_addr_offset;      /* offset from beginning of block */
        ulong dl_src_addr_length;       /* length of source address */
        ulong dl_src_addr_offset;       /* offset from beginning of block */
        ulong dl_priority;              /* priority */
        ulong dl_service_class;         /* DL_RQST_RSP or DL_RQST_NORSP */
@} dl_data_ack_req_t;
@tpindex dl_data_ack_req_t

/*
 * DL_DATA_ACK_IND, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_DATA_ACK_IND */
        ulong dl_dest_addr_length;      /* length of destination addr */
        ulong dl_dest_addr_offset;      /* offset from beginning of block */
        ulong dl_src_addr_length;       /* length of source address */
        ulong dl_src_addr_offset;       /* offset from beginning of block */
        ulong dl_priority;              /* priority for data unit transm.  */
        ulong dl_service_class;         /* DL_RQST_RSP or DL_RQST_NORSP */
@} dl_data_ack_ind_t;
@tpindex dl_data_ack_ind_t

/*
 * DL_DATA_ACK_STATUS_IND, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_DATA_ACK_STATUS_IND */
        ulong dl_correlation;           /* User's correlation token */
        ulong dl_status;                /* success or failure of previous req */
@} dl_data_ack_status_ind_t;
@tpindex dl_data_ack_status_ind_t

/*
 * DL_REPLY_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_REPLY_REQ */
        ulong dl_correlation;           /* User's correlation token */
        ulong dl_dest_addr_length;      /* length of destination address */
        ulong dl_dest_addr_offset;      /* offset from beginning of block */
        ulong dl_src_addr_length;       /* source address length */
        ulong dl_src_addr_offset;       /* offset from beginning of block */
        ulong dl_priority;              /* priority for data unit transmission */
        ulong dl_service_class;
@} dl_reply_req_t;
@tpindex dl_reply_req_t

/*
 * DL_REPLY_IND, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_REPLY_IND */
        ulong dl_dest_addr_length;      /* length of destination address */
        ulong dl_dest_addr_offset;      /* offset from beginning of block */
        ulong dl_src_addr_length;       /* length of source address */
        ulong dl_src_addr_offset;       /* offset from beginning of block */
        ulong dl_priority;              /* priority for data unit transmission */
        ulong dl_service_class;         /* DL_RQST_RSP or DL_RQST_NORSP */
@} dl_reply_ind_t;
@tpindex dl_reply_ind_t

/*
 * DL_REPLY_STATUS_IND, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_REPLY_STATUS_IND */
        ulong dl_correlation;           /* User's correlation token */
        ulong dl_status;                /* success or failure of previous req */
@} dl_reply_status_ind_t;
@tpindex dl_reply_status_ind_t

/*
 * DL_REPLY_UPDATE_REQ, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_REPLY_UPDATE_REQ */
        ulong dl_correlation;           /* user's correlation token */
        ulong dl_src_addr_length;       /* length of source address */
        ulong dl_src_addr_offset;       /* offset from beginning of block */
@} dl_reply_update_req_t;
@tpindex dl_reply_update_req_t

/*
 * DL_REPLY_UPDATE_STATUS_IND, M_PROTO type
 */
typedef struct @{
        ulong dl_primitive;             /* DL_REPLY_UPDATE_STATUS_IND */
        ulong dl_correlation;           /* User's correlation token */
        ulong dl_status;                /* success or failure of previous req */
@} dl_reply_update_status_ind_t;
@tpindex dl_reply_update_status_ind_t

union DL_primitives @{
@tpindex DL_primitives
        ulong dl_primitive;
        dl_info_req_t info_req;
        dl_info_ack_t info_ack;
        dl_attach_req_t attach_req;
        dl_detach_req_t detach_req;
        dl_bind_req_t bind_req;
        dl_bind_ack_t bind_ack;
        dl_unbind_req_t unbind_req;
        dl_subs_bind_req_t subs_bind_req;
        dl_subs_bind_ack_t subs_bind_ack;
        dl_subs_unbind_req_t subs_unbind_req;
        dl_ok_ack_t ok_ack;
        dl_error_ack_t error_ack;
        dl_connect_req_t connect_req;
        dl_connect_ind_t connect_ind;
        dl_connect_res_t connect_res;
        dl_connect_con_t connect_con;
        dl_token_req_t token_req;
        dl_token_ack_t token_ack;
        dl_disconnect_req_t disconnect_req;
        dl_disconnect_ind_t disconnect_ind;
        dl_reset_req_t reset_req;
        dl_reset_ind_t reset_ind;
        dl_reset_res_t reset_res;
        dl_reset_con_t reset_con;
        dl_unitdata_req_t unitdata_req;
        dl_unitdata_ind_t unitdata_ind;
        dl_uderror_ind_t uderror_ind;
        dl_udqos_req_t udqos_req;
        dl_enabmulti_req_t enabmulti_req;
        dl_disabmulti_req_t disabmulti_req;
        dl_promiscon_req_t promiscon_req;
        dl_promiscoff_req_t promiscoff_req;
        dl_phys_addr_req_t physaddr_req;
        dl_phys_addr_ack_t physaddr_ack;
        dl_set_phys_addr_req_t set_physaddr_req;
        dl_get_statistics_req_t get_statistics_req;
        dl_get_statistics_ack_t get_statistics_ack;
        dl_test_req_t test_req;
        dl_test_ind_t test_ind;
        dl_test_res_t test_res;
        dl_test_con_t test_con;
        dl_xid_req_t xid_req;
        dl_xid_ind_t xid_ind;
        dl_xid_res_t xid_res;
        dl_xid_con_t xid_con;
        dl_data_ack_req_t data_ack_req;
        dl_data_ack_ind_t data_ack_ind;
        dl_data_ack_status_ind_t data_ack_status_ind;
        dl_reply_req_t reply_req;
        dl_reply_ind_t reply_ind;
        dl_reply_status_ind_t reply_status_ind;
        dl_reply_update_req_t reply_update_req;
        dl_reply_update_status_ind_t reply_update_status_ind;
@};

#define DL_INFO_REQ_SIZE sizeof(dl_info_req_t)
#define DL_INFO_ACK_SIZE sizeof(dl_info_ack_t)
#define DL_ATTACH_REQ_SIZE sizeof(dl_attach_req_t)
#define DL_DETACH_REQ_SIZE sizeof(dl_detach_req_t)
#define DL_BIND_REQ_SIZE sizeof(dl_bind_req_t)
#define DL_BIND_ACK_SIZE sizeof(dl_bind_ack_t)
#define DL_UNBIND_REQ_SIZE sizeof(dl_unbind_req_t)
#define DL_SUBS_BIND_REQ_SIZE sizeof(dl_subs_bind_req_t)

#define DL_SUBS_BIND_ACK_SIZE sizeof(dl_subs_bind_ack_t)
#define DL_SUBS_UNBIND_REQ_SIZE sizeof(dl_subs_unbind_req_t)
#define DL_OK_ACK_SIZE sizeof(dl_ok_ack_t)
#define DL_ERROR_ACK_SIZE sizeof(dl_error_ack_t)
#define DL_CONNECT_REQ_SIZE sizeof(dl_connect_req_t)
#define DL_CONNECT_IND_SIZE sizeof(dl_connect_ind_t)

#define DL_CONNECT_RES_SIZE sizeof(dl_connect_res_t)
#define DL_CONNECT_CON_SIZE sizeof(dl_connect_con_t)
#define DL_TOKEN_REQ_SIZE sizeof(dl_token_req_t)
#define DL_TOKEN_ACK_SIZE sizeof(dl_token_ack_t)
#define DL_DISCONNECT_REQ_SIZE sizeof(dl_disconnect_req_t)
#define DL_DISCONNECT_IND_SIZE sizeof(dl_disconnect_ind_t)

#define DL_RESET_REQ_SIZE sizeof(dl_reset_req_t)
#define DL_RESET_IND_SIZE sizeof(dl_reset_ind_t)
#define DL_RESET_RES_SIZE sizeof(dl_reset_res_t)
#define DL_RESET_CON_SIZE sizeof(dl_reset_con_t)
#define DL_UNITDATA_REQ_SIZE sizeof(dl_unitdata_req_t)
#define DL_UNITDATA_IND_SIZE sizeof(dl_unitdata_ind_t)

#define DL_UDERROR_IND_SIZE sizeof(dl_uderror_ind_t)

#define DL_UDQOS_REQ_SIZE sizeof(dl_udqos_req_t)
#define DL_ENABMULTI_REQ_SIZE sizeof(dl_enabmulti_req_t)
#define DL_DISABMULTI_REQ_SIZE sizeof(dl_disabmulti_req_t)

#define DL_PROMISCON_REQ_SIZE sizeof(dl_promiscon_req_t)
#define DL_PROMISCOFF_REQ_SIZE sizeof(dl_promiscoff_req_t)
#define DL_PHYS_ADDR_REQ_SIZE sizeof(dl_phys_addr_req_t)
#define DL_PHYS_ADDR_ACK_SIZE sizeof(dl_phys_addr_ack_t)
#define DL_SET_PHYS_ADDR_REQ_SIZE sizeof(dl_set_phys_addr_req_t)
#define DL_GET_STATISTICS_REQ_SIZE sizeof(dl_get_statistics_req_t)

#define DL_GET_STATISTICS_ACK_SIZE sizeof(dl_get_statistics_ack_t)
#define DL_XID_REQ_SIZE sizeof(dl_xid_req_t)
#define DL_XID_IND_SIZE sizeof(dl_xid_ind_t)
#define DL_XID_RES_SIZE sizeof(dl_xid_res_t)
#define DL_XID_CON_SIZE sizeof(dl_xid_con_t)
#define DL_TEST_REQ_SIZE sizeof(dl_test_req_t)

#define DL_TEST_IND_SIZE sizeof(dl_test_ind_t)
#define DL_TEST_RES_SIZE sizeof(dl_test_res_t)
#define DL_TEST_CON_SIZE sizeof(dl_test_con_t)
#define DL_DATA_ACK_REQ_SIZE sizeof(dl_data_ack_req_t)
#define DL_DATA_ACK_IND_SIZE sizeof(dl_data_ack_ind_t)
#define DL_DATA_ACK_STATUS_IND_SIZE sizeof(dl_data_ack_status_ind_t)
#define DL_REPLY_REQ_SIZE sizeof(dl_reply_req_t)

#define DL_REPLY_IND_SIZE sizeof(dl_reply_ind_t)
#define DL_REPLY_STATUS_IND_SIZE sizeof(dl_reply_status_ind_t)
#define DL_REPLY_UPDATE_REQ_SIZE sizeof(dl_reply_update_req_t)
#define DL_REPLY_UPDATE_STATUS_IND_SIZE sizeof(dl_reply_update_status_ind_t)

#endif                          /* _SYS_DLPI_H */
@end smallexample

@node Index
@unnumbered Index

@printindex cp

@c @section Primitive Index
@c @printindex pr

@c @section Primitive Structure and Type Index
@c @printindex tp

@c @section Primitive Structure Filed Index
@c @printindex vr

@page
@shortcontents
@page
@contents
@bye

@c ================================================================
@c ================================================================
@c ================================================================


The NPI allows the NS provider to be configured with any network layer user
(such as the OSI Transport Layer) that also conforms to the NPI.  A network layer
user can also be a user program that conforms to the NPI and accesses the NS
provider via ``putmsg'' and ``getmsg'' system calls.
@fnindex putmsg
@fnindex getmsg

@node NPI Services
@section NPI Services

@ifnotinfo
@menu
* CONS::
* CLNS::
* Local Management::
@end menu
@end ifnotinfo

The features of the NPI are defined in terms of the services provided by the NS
provider,and the individual primitives that may flow between the NS user and the
NS provider.

The services supported by the NPI are based on two distinct modes of
communication, connection (CONS) and connectionless (CLNS).  In addition, the NPI
supports services for local management.

@node CONS
@subsection CONS

The main features of the connection mode communication are:

@enumerate a

@item It is virtual circuit oriented;

@item It provides transfer of data via a pre-established path;

@item It provides reliable data transfer.

@end enumerate

There are three phases to each instance of communication: Connection
Establishment; Data Transfer; and Connection Termination.  Units of data arrive
at their destination in the same order as they departed their source and the
data is protected against duplication or loss of data units within some
specified quality of service.

@node CLNS
@subsection CLNS

The main features of the connectionless mode communication are:

@enumerate a

@item It is datagram oriented;

@item It provides transfer of data in self contained units;

@item There is no logical relationship between these units of data;

@item It is unreliable.

@end enumerate

Connectionless mode communication has no separate phases.  Each unit of data
is transmitted from source to destination independently, appropriate addressing
information is included with each unit of data.  As the units of data are
transmitted independently from source to destination, there are, in general, no
guarantees of proper sequence and completeness of the data stream.

@node Local Management
@subsection Local Management

The NPI specifications also define a set of local management functions that
apply to both CONS and CLNS modes of communication.  These services have local
significance only.

Tables 1 and 2 summarizes the NPI service primitives by their state and service.

@c @cartouche
@c @image{npi_tab1} @center @b{Table 1.  Service Primitives for Connection Mode Data Transfer}
@c @end cartouche

@c @cartouche
@c @image{npi_tab2} @center @b{Table 2.  Service Primitives for Connectionless Mode Data Transfer}
@c @end cartouche

@node NPI Services Definition
@chapter NPI Services Definition

@menu
* Local Management Services Definition::
* Connection-Mode Network Services Definition::
* Connectionless Network Services Definition::
@end menu

This section describes the services of the NPI primitives.  Time-sequence
diagrams that illustrate the sequence of primitives are included.  (Conventions
for the time-sequence diagrams are defined in CCITT X.210 [8].) The format of
the primitives will be defined later in this document.

@node Local Management Services Definition
@section Local Management Services Definition

@menu
* Network Information Reporting Service::
* NS User Bind Service::
* NS User Unbind Service::
* Receipt Acknowledgement Service::
* Options Management Service::
* Error Acknowledgement Service::
@end menu

The services defined in this section are outside the scope of the international
standards.  These services apply to both connection-mode as well as the
connection-less modes of communication.  They are invoked for the
initialization/de-initialization of a stream connected to the NS provider.  They
are also used to manage options supported by the NS provider and to report
information on the supported parameter values.

@node Network Information Reporting Service
@subsection Network Information Reporting Service

This service provides information on the options supported by the NS provider.

@itemize @bullet

@item N_INFO_REQ: This primitive requests that the NS provider return the
values of all the supported protocol parameters.  This request may be invoked
during any phase.

@item N_INFO_ACK: This primitive is in response to the N_INFO_REQ primitive
and returns the values of the supported protocol parameters to the NS user.

@end itemize

The sequence of primitives for network information management is shown in Figure 2.

@c @cartouche
@c @image{npi_fig2,4in} @center @b{Figure 2.  Sequence of Primitives; Network Information Reporting Service}
@c @end cartouche

@node NS User Bind Service
@subsection NS User Bind Service

This service allows a network address to be associated with a stream.  It allows
the NS user to negotiate the number of connect indications that can remain
unacknowledged for that NS user (a connect indication is considered
unacknowledged while it is awaiting a corresponding connect response or
disconnect request from the NS user).  This service also defines a mechanism that
allows a stream (bound to a network address of the NS user) to be reserved to
handle incoming calls only.  This stream is referred to as the listener stream.

@itemize @bullet

@item N_BIND_REQ: This primitive requests that the NS user be bound to a
particular network address, and negotiate the number of allowable outstanding
connect indications for that address.

@item N_BIND_ACK: This primitive is in response to the N_BIND_REQ primitive
and indicates to the user that the specified NS user has been bound to a network
address.

@end itemize

The sequence of primitives for NS user bind service is shown in Figure 3.

@c @cartouche
@c @image{npi_fig3,4in} @center @b{Figure 3.  Sequence of Primitives; NS User Bind Service}
@c @end cartouche

@node NS User Unbind Service
@subsection NS User Unbind Service

This service allows the NS user to be unbound from a network address.

@itemize @bullet

@item N_UNBIND_REQ: This primitive requests that the NS user be unbound from
the network address that it had previously been bound to.

@end itemize

The sequence of primitives for NS user unbind service is shown in Figure 4.

@c @cartouche
@c @image{npi_fig4,4in} @center @b{Figure 4.  Sequence of Primitives; NS User Unbind & Receipt Acknowledgement}
@c @end cartouche

@node Receipt Acknowledgement Service
@subsection Receipt Acknowledgement Service

@itemize @bullet

@item N_OK_ACK: This primitive indicates to the NS user that the previous NS
user originated primitive was received successfully by the NS provider.

@end itemize

An example showing the sequence of primitives for successful receipt
acknowledgement is depicted in Figure 4.

@node Options Management Service
@subsection Options Management Service

This service allows the NS user to manage the QOS parameter values associated
with the NS provider.

@itemize @bullet

@item N_OPTMGMT_REQ: This primitive allows the NS user to select default
values for QOS parameters within the range supported by the NS provider, and to
indicate the default selection of receipt confirmation.

@end itemize

Figure 5 shows the sequence of primitives for network options management.

@c @cartouche
@c @image{npi_fig5,4in} @center @b{Figure 5.  Sequence of Primitives; Options Management Service}
@c @end cartouche

@node Error Acknowledgement Service
@subsection Error Acknowledgement Service

@itemize @bullet

@item N_ERROR_ACK: This primitive indicates to the NS user that a non-fatal
error has occurred in the last NS user originated request or response primitive
(listed in Figure 6), on the stream.

@end itemize

Figure 6 shows the sequence of primitives for the error management primitive.

@c @cartouche
@c @image{npi_fig6,4in} @center @b{Figure 6.  Sequence of Primitives; Error Acknowledgement Service}
@c @end cartouche

@page
@node Connection-Mode Network Services Definition
@section Connection-Mode Network Services Definition

@menu
* Connection Establishment Phase::
* Data Transfer Phase::
* Reset Operation Primitives::
* Connection Termination Phase::
@end menu

This section describes the required network service primitives that define the
CONS interface.

The queue model for CONS is discussed in more detail in CCITT X.213 section 9.2.
The queue model represents the operation of a network connection in the abstract
by a pair of queues linking the two network addresses.  There is one queue for
each direction of information flow.  Each queue represents a flow control
function in one direction of transfer.  The ability of a user to add objects to a
queue will be determined by the behaviour of the user removing objects from that
queue, and the state of the queue.  The pair of queues is considered to be
available for each potential NC.  Objects that are entered or removed from the
queue are either as a result of interactions at the two network addresses, or as
the result of NS provider initiatives.

@itemize @bullet

@item A queue is empty until a connect object has been entered and can be
returned to this state, with loss of its contents, by the NS provider.

@item Objects may be entered into a queue as a result of the actions of the
source NS user, subject to control by the NS provider;

@item Objects may also be entered into a queue by the NS provider.

@item Objects are removed from the queue under the control of the receiving NS user.

@item Objects are normally removed under the control of the NS user in the same
order as they were entered except:

@itemize ---

@item if the object is of a type defined to be able to advance ahead of the
preceding object (however, no object is defined to be able to advance ahead of
another object of the same type), or

@item if the following object is defined to be destructive with respect to the
preceding object on the queue.  If necessary, the last object on the queue will
be deleted to allow a destructive object to be entered - they will therefore
always be added to the queue.  For example, ``disconnect'' objects are defined to be
destructive with respect to all other objects.  ``Reset'' objects are defined to be
destructive with respect to all other objects except ``connect'', ``disconnect'', and
other ``reset'' objects.

@end itemize

@end itemize

Table 3 shows the ordering relationships among the queue model objects.

@cartouche
@image{npi_tab3} @center @b{Table 3.  Ordering Relationships Between Queue Model Objects}
@end cartouche

@node Connection Establishment Phase
@subsection Connection Establishment Phase

A pair of queues is associated with an NC between two network addresses when the
NS provider receives an N_CONNECT_REQ primitive at one of the network addresses
resulting in a connect object being entered into the queue.  The queues will
remain associated with the NC until a N_DISCON_REQ primitive (resulting in a
disconnect object) is either entered or removed from a queue.  Similarly, in the
queue from the called NS user, objects can be entered into the queue only after
the connect object associated with the N_CONN_RES has been entered into the
queue.  Alternatively, the called NS user can enter a disconnect object into the
queue instead of the connect object to terminate the NC.  The NC establishment
procedure will fail if the NS provider is unable to establish an NC,or if the
destination NS user is unable to accept the N_CONN_IND (see NC Release
primitive definition).

@subsubsection User Primitives for Successful Network Connection Establishment

@ 

@itemize @bullet

@item N_CONN_REQ: This primitive requests that the NS provider make a
connection to the specified destination.

@item N_CONN_RES: This primitive requests that the NS provider accept a
previous connection indication.

@end itemize

@subsubsection Provider Primitives for Successful Network Connection Establishment

@ 

@itemize @bullet

@item N_CONN_IND: This primitive indicates to the NS user that a connect
request has been made by a user at the specified source address.

@item N_CONN_CON: This primitive indicates to the NS user that a connect
request has been confirmed on the specified responding address.

@end itemize

The sequence of primitives in a successful NC establishment is defined by the
time sequence diagram as shown in Figure 7.  The sequence of primitives for the
NC response token value determination is shown in Figure 8 (procedures for NC
response token value determination are discussed in sections 4.1.3 and 4.1.4.).

@cartouche
@image{npi_fig7,4in} @center @b{Figure 7.  Sequence of Primitives; Successful NC Establishment}
@end cartouche

@cartouche
@image{npi_fig8,4in} @center @b{Figure 8.  Sequence of Primitives; NC Response Token Value Determination}
@end cartouche

@node Data Transfer Phase
@subsection Data Transfer Phase

Flow control on the NC is done by management of the queue capacity, and by
allowing objects of certain types to be inserted to the queues, as shown in
Table 4.

@cartouche
@image{npi_tab4} @center @b{Table 4.  Flow Control Relationships Between Queue Model Objects}
@end cartouche

@subsubsection User Primitives for Data Transfer

@ 

@itemize @bullet

@item N_DATA_REQ: This primitive requests that the NS provider transfer the
specified data.

@item N_DATACK_REQ: This primitive requests that the NS provider acknowledge
the data that had previously been received with receipt confirmation requested.

@item N_EXDATA_REQ: This primitive requests that the NS provider transfer
the specified expedited network service data unit.

@end itemize

@subsubsection Provider Primitives for Data Transfer

@ 

@itemize @bullet

@item N_DATA_IND: This primitive indicates to the NS user that this message
contains data.

@item N_DATACK_IND: This primitive indicates to the NS user that the remote NS
user has acknowledged the data that had previously been sent with receipt
confirmation requested.

@item N_EXDATA_IND: This primitive indicates to the NS user that this message
unit contains expedited data.

@end itemize

Figure 9 shows the sequence of primitives for successful normal data transfer.
The sequence of primitives may remain incomplete if a N_RESET or N_DISCON
primitive occurs.

@cartouche
@image{npi_fig9,4in} @center @b{Figure 9.  Sequence of Primitives; Data Transfer}
@end cartouche

The sequence of primitives in a successful confirmation of receipt is defined in
the time sequence diagram as shown in Figure 10.

@cartouche
@image{npi_fi10,4in} @center @b{Figure 10.  Sequence of Primitives; Successful Confirmation of Receipt}
@end cartouche

The sequence of primitives as shown above may remain incomplete if an N_RESET
or an N_DISCON primitive occurs (see Table 3).  A NS user must not issue an
N_DATACK_REQ primitive if no N_DATA_IND with confirmation request set has
been received, or if all such N_DATA_IND have been previously acknowledged.
Following a reset procedure (N_RESET_REQ or N_RESET_IND), a NS user may not
issue aN_DATACK_REQ to acknowledge an outstanding N_DATA_IND received before the
reset procedure was signalled.

Note --- The withholding of confirmation of receipt by a NS user can have an
effect on the attainable throughput on the NC.

The sequence of primitives for expedited data transfer is shown in the time
sequence diagram in Figure 11.  This sequence of primitives may remain incomplete
if a N_RESET or N_DISCON primitive is issued.

@cartouche
@image{npi_fi11,4in} @center @b{Figure 11.  Sequence of Primitives; Expedited Data Transfer}
@end cartouche

@node Reset Operation Primitives
@subsection Reset Operation Primitives

The reset service is used by the NS user to resynchronize the use of the NC, or
by the NS provider to report detected loss of unrecoverable data.

The reset procedure involves the following interactions:

@enumerate A

@item a N_RESET_REQ from the NS user, followed by a N_RESET_CON from the
NS provider; or

@item a N_RESET_IND from the NS provider, followed by a N_RESET_RES from the NS
user.

@end enumerate

The complete sequence of primitives depends upon the origin/s of the reset
action.  The reset service may be:

@enumerate 1

@item invoked by one NS user, leading to interaction (A) with that NS user
and interaction (B) with the peer NS user;

@item invoked by both NS users, leading to interaction (A) with both NS users;

@item invoked by the NS provider, leading to interaction (B) with both NS users;

@item invoked by one NS user and the NS provider, leading to interaction (A)
with the originating NS user and (B) with the peer NS user.

@end enumerate

The N_RESET_REQ acts as a synchronization mark in the flow of N_DATA,N_EXDATA,
and N_DATACK primitives transmitted by the issuing NS user; the N_RESET_IND acts
as a synchronization mark in the flow of N_DATA, N_EXDATA,and N_DATACK
primitives received by the receiving NS user.  Similarly, N_RESET_RES acts as a
synchronization mark in the flow of N_DATA, N_EXDATA,and N_DATACK primitives
transmitted by the responding NS user, while the N_RESET_CON acts as a
synchronization mark in the flow of N_DATA, N_EXDATA, and N_DATACK primitives
received by the NS user that originally issued the reset.  The resynchronizing
properties of the reset service are the following:

@enumerate a

@item All N_DATA, N_EXDATA, and N_DATACK primitives issued before issuing
the N_RESET_REQ/N_RESET_RES that have not been delivered to the other NS user
before the N_RESET_IND/N_RESET_CON are issued by the NS provider,should be
discarded by the NS provider.

@item Any N_DATA, N_EXDATA, and N_DATACK primitives issued after
the synchronization mark will not be delivered to the other NS user before the
synchronization mark is received.

@end enumerate

@subsubsection User Primitives for Reset Operations

@ 

@itemize @bullet

@item N_RESET_REQ: This primitive requests that the NS provider reset the
network connection.

@item N_RESET_RES: This primitive indicates to the NS provider that the NS user
has accepted a reset indication.

@end itemize

@subsubsection Provider Primitives for Reset Operations

@ 

@itemize @bullet

@item N_RESET_IND: This primitive indicates to the NS user that the
network connection has been reset.

@item N_RESET_CON: This primitive indicates to the NS user that the reset
request has been confirmed.

@end itemize

The sequence of primitives as shown in Figures 12, 13, 14, and 15 may
remain in complete if a N_DISCON primitive occurs.

@cartouche
@image{npi_fi12,4in} @center @b{Figure 12.  Sequence of Primitives; NS User Invoked Reset}
@end cartouche

@cartouche
@image{npi_fi13,4in} @center @b{Figure 13.  Sequence of Primitives; Simultaneous NS User Invoked Reset}
@end cartouche

@cartouche
@image{npi_fi14,4in} @center @b{Figure 14.  Sequence of Primitives; NS Provider Invoked Reset}
@end cartouche

@cartouche
@image{npi_fi15,4in} @center @b{Figure 15.  Sequence of Primitives; Simultaneous NS User & NS Provider}
@end cartouche

@node Connection Termination Phase
@subsection Connection Termination Phase

The NC release procedure is initialized by the insertion of a disconnect
object (associated with a N_DISCON_REQ) into the queue.  As shown in Table 3, the
disconnect procedure is destructive with respect to other objects in the queue,
and eventually results in the emptying of queues and termination of the NC
connection.

The sequence of primitives depends on the origin of the release action.  The
sequence may be:

@enumerate 1

@item invoked by one NS user, with a request from that NS user leading to an
indication to the other;

@item invoked by both NS users, with a request from each of the NS users;

@item invoked by the NS provider, with an indication to each of the NS users;

@item invoked independently by one NS user and the NS provider, with a request
from the originating NS user and an indication to the other.

@end enumerate

@subsubsection User Primitives for Connection Termination

@ 

@itemize @bullet

@item N_DISCON_REQ: This primitive requests that the NS provider deny
an outstanding request for a connection or disconnect an existing connection.

@end itemize

@subsubsection Provider Primitives for Connection Termination

@ 

@itemize @bullet

@item N_DISCON_IND: This primitive indicates to the NS user that either a
request for connection has been denied or an existing connection has been
terminated.

@end itemize

The sequence of primitives are shown in the time sequence diagrams in Figures
16, 17, 18, and 19.

@cartouche
@image{npi_fi16,4in} @center @b{Figure 16.  Sequence of Primitives; NS User Invoked Release}
@end cartouche

@cartouche
@image{npi_fi17,4in} @center @b{Figure 17.  Sequence of Primitives; Simultaneous NS User Invoked Release}
@end cartouche

@cartouche
@image{npi_fi18,4in} @center @b{Figure 18.  Sequence of Primitives; NS Provider Invoked Release}
@end cartouche

@cartouche
@image{npi_fi19,4in} @center @b{Figure 19.  Sequence of Primitives; Simultaneous NS User & NS Provider}
@end cartouche

A NS user may reject an NC establishment attempt by issuing a N_DISCON_REQ.
The originator parameter in the N_DISCON primitives will indicate NS user invoked
release.  The sequence of events is shown in Figure 20.

@cartouche
@image{npi_fi20,4in} @center @b{Figure 20.  Sequence of Primitives; NS User Rejection of an NC}
@center @b{Establishment Attempt}
@end cartouche

If the NS provider is unable to establish an NC, it indicates this to the
requester by an N_DISCON_IND.  The originator in this primitive indicates an NS
provider invoked release.  This is shown in Figure 21.

@cartouche
@image{npi_fi21,4in} @center @b{Figure 21.  Sequence of Primitives; NS Provider Rejection of an NC}
@center @b{Establishment Attempt}
@end cartouche

@node Connectionless Network Services Definition
@section Connectionless Network Services Definition

The CLNS allows for the transfer of the NS user data in one or both directions
simultaneously without establishing a network connection.  A set of primitives
are defined that carry user data and control information between the NS user and
NS provider entities.  The primitives are modelled as requests initiated by the
NS user and indications initiated by the NS provider.  Indications may be
initiated by the NS provider independently from requests by the NS user.

The connectionless network service consists of one phase.

@subsection User Request Primitives

@ 

@itemize @bullet

@item N_UNITDATA_REQ: This primitive requests that the NS provider send the
data unit to the specified destination.

@end itemize

@subsection Provider Response Primitives

@ 

@itemize @bullet

@item N_UNITDATA_IND: This primitive indicates to the NS user that a data unit
has been received from the specified source address.

@end itemize

Figure 22 shows the sequence of primitives for the connectionless mode of data
transfer.

@cartouche
@image{npi_fi22,4in} @center @b{Figure 22.  Sequence of Primitives; Connectionless Data Transfer}
@end cartouche

@itemize @bullet

@item N_UDERROR_IND: This primitive indicates to the NS user that the data unit
with the specified destination address and QOS parameters produced an error.
This primitive is specific to CLNS.

@end itemize

Figure 23 shows the sequence of primitives for the CLNS error management
primitive.

@cartouche
@image{npi_fi23,4in} @center @b{Figure 23.  Sequence of Primitives; CLNS Error Indication Service}
@end cartouche

@node NPI Primitives
@chapter NPI Primitives

@menu
* Management Primitives::
* CONS Primitive Format and Rules::
* CLNS Primitive Format and Rules::
@end menu

This section describes the format and parameters of the NPI primitives (Appendix
A shows the mapping of the NPI primitives to the primitives defined in ISO 8348
and CCITT X.213).  In addition, it discusses the states the primitive is valid
in, the resulting state, and the acknowledgement that the primitive expects.
(The state/event tables for these primitives are shown in Appendix B.  The
precedence tables for the NPI primitives are shown in Appendix C.) Rules for OSI
conformance are described in Addendum 1 to this document.

Tables 5, 6, and 7 provide a summary of the NS primitives and their parameters.

@cartouche
@image{npi_tab5} @center @b{Table 5.  NC Establishment Network Service Primitives}
@end cartouche

@cartouche
@image{npi_tab6} @center @b{Table 6.  Data Transfer Network Service Primitives}
@end cartouche

@cartouche
@image{npi_tab7} @center @b{Table 7.  NC Release Network Service Primitives}
@end cartouche

@page
@node Management Primitives
@section Management Primitives

@menu
* N_INFO_REQ::
* N_INFO_ACK::
* N_BIND_REQ::
* N_BIND_ACK::
* N_UNBIND_REQ::
* N_OPTMGMT_REQ::
* N_ERROR_ACK::
* N_OK_ACK::
@end menu

These primitives apply both to CONS as well as CLNS.

@node N_INFO_REQ
@subsection Network Information Request

@subsubheading N_INFO_REQ
@prindex N_INFO_REQ

This primitive requests the NS provider to return the values of all supported
protocol parameters (see under N_INFO_ACK), and also the current state of the NS
provider (as defined in Appendix B).  This primitive does not affect the state of
the network provider and does not appear in the state tables.

@subsubheading Format

The format of the message is one M_PCPROTO message block and its structure is
as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_INFO_REQ */
@} N_info_req_t;
@tpindex N_info_req_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@end vtable

@subsubheading Valid States

This primitive is valid in any state where a local acknowledgement is not
pending.

@subsubheading New State

The new state remains unchanged.

@subsubheading Acknowledgements

This primitive requires the NS provider to generate one of the following
acknowledgements upon receipt of the primitive:

@itemize ---

@item Successful:
Acknowledgement of the primitive via the N_INFO_ACK primitive.

@item Non-fatal_errors:
There are no errors associated with the issuance of this primitive.

@end itemize

@page
@node N_INFO_ACK
@subsection Network Information Acknowledgement

@subsubheading N_INFO_ACK
@prindex N_INFO_ACK

This primitive indicates to the NS user any relevant protocol-dependent
parameters.
@footnote{In the future, this primitive will be modified such that it will allow
the NPI to accept either sub-network point of attachment addresses or network
addresses.}
It should be initiated in response to the N_INFO_REQ primitive described above.

@subsubheading Format

The format of this message is one M_PCPROTO message block and its structure is
as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_INFO_ACK */
        ulong NSDU_size;                /* maximum NSDU size */
        ulong ENSDU_size;               /* maximum ENSDU size */
        ulong CDATA_size;               /* connect data size */
        ulong DDATA_size;               /* discon data size */
        ulong ADDR_size;                /* address size */
        ulong ADDR_length;              /* address length */
        ulong ADDR_offset;              /* address offse t */
        ulong QOS_length;               /* length of default QOS values */
        ulong QOS_offset;               /* offset of default QOS values from
                                           the beginning of block */
        ulong QOS_range_length;         /* length of range of QOS values */
        ulong QOS_range_offset;         /* offset of range of QOS values from
                                           the beginning of block */
        ulong OPTIONS_flags;            /* bit masking for options supported */
        ulong NIDU_size;                /* network interface data unit size */
        long SERV_type;                 /* service type */
        ulong CURRENT_state;            /* current state */
        ulong PROVIDER_type;            /* type of provider */
        ulong NODU_size;                /* optimal NSDU size */
        ulong PROTOID_length;           /* length of bound protocol ids */
        ulong PROTOID_offset;           /* offset of bound protocol ids */
        ulong NPI_version;              /* version number of NPI that's
                                           supported */
@} N_info_ack_t;
@tpindex N_info_ack_t

/* Flags to indicate support of NS provider options */
#define REC_CONF_OPT    0x00000001L
#define EX_DATA_OPT     0x00000002L
#define DEFAULT_RC_SEL  0x00000004L

/* Service types supported by the NS provider */
#define N_CONS 1
#define N_CLNS 2

/* Valid provider types */
#define N_SNICFP 1
#define N_SUBNET 2
@end smallexample

@subsubheading Parameters

The above fields have the following meaning:

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item NSDU_size
Specifies the maximum size (in octets) of a Network Service Data Unit (NSDU)
supported by the NS provider.

@item ENSDU_size
Specifies the maximum size (in octets) of an Expedited Network Service Data Unit
(ENSDU) supported by the NS provider.

@item CDATA_size
Specifies the maximum number of octets of data that may be associated with
connection establishment primitives.

@item DDATA_size
Specifies the maximum number of octets of data that may be associated with the
disconnect primitives.

@item ADDR_size
Specifies the maximum size (in decimal digits) of a network address.

@item ADDR_length
Specifies the length in bytes of the network address bound on the STREAM on
which the N_INFO_REQ was issued (a network address is bound to a STREAM via a
N_BIND_REQ).

@item ADDR_offset
Specifies the offset of the bound network address from the beginning of the
M_PCPROTO message block (this field should be ignored if the ADDR_length field
is zero).

@item QOS_length
in an addendum to this document.  In the connection-mode environment, when this
primitive is invoked before the NC is established on the stream, the values
returned specify the the default values supported by the NS provider.  When this
primitive is invoked after a NC has been established on the stream, the values
returned indicate the negotiated values for the QOS parameters.  In the
connection-less environment, these values represent the default or the selected
QOS parameter values.  In case a QOS parameter is not supported by the NS
Provider, a value of QOS_UNKNOWN will be returned.  In the case where no QOS
parameters are supported by the NS provider, this field will be zero.

@item QOS_offset
Indicates the offset of the QOS parameters from the beginning of the M_PCPROTO
message block.

@item QOS_range_length
Indicates the length in bytes, of the available range of QOS parameters values
supported by the NS provider.  These ranges are used by the NS user to select QOS
parameter values that are valid with the NS provider.  QOS parameter values are
selected, or the default values altered via the N_OPTMGMT_REQ primitive.  In the
connection-mode environment, the values for end-to-end QOS parameters may be
specified with the N_CONN primitives for negotiation.  If the NS provider does
not support a certain QOS parameter, its value will be set to QOS_UNKNOWN.  In
the case where no QOS parameters are supported by the NS provider, the length
of this field will be zero.

@item QOS_range_offset
Indicates the offset of the range of QOS parameter values from the beginning of
the M_PCPROTO message block.

@item OPTIONS_flags
Defines flags that indicate whether the options described below are supported by
the NS provider.  The possible options are receipt confirmation, expedited data
and default selection for use of receipt confirmation.

@item NIDU_size
This indicates the amount of user data that may be present in a N_DATA primitive.
The NIDU_size should not be larger than the NSDU_size specification.

@item SERV_type
Specifies the service type supported by the NS provider.  The possible values can
be N_CONS, N_CLNS, (or both as indicated by using N_CONS|N_CLNS).

@item CURRENT_state
This indicates the current state of the NS provider.

@item PROVIDER_type
This indicates the type of NS provider.  The possible values can be N_SNICFP or
N_SUBNET.  The value N_SNICFP indicates that the provider is the Subnetwork
Independent Convergence Function/Protocol sub-layer of the network layer.  The
value N_SUBNET indicates that the provider is a subnetwork.

@item NODU_size
This specifies the optimal NSDU size (in octets) of an NSDU given the current
routing information.

@item PROTOID_length
This specifies the length of the protocol ids that were bound using the
N_BIND_REQ.

@item PROTOID_offset
This specifies the offset of the protocol ids that were bound using the
N_BIND_REQ.

@item NPI_version
This indicates the current version of NPI that is supported.

@end vtable

@subsubheading Flags

@vtable @var

@item REC_CONF_OPT
When set, it indicates that the NS provider supports receipt confirmation.

@emph{This flag is used only in the connection-mode environment.}

@item EX_DATA_OPT
When set, it indicates that the NS provider supports expedited data transfer.

@emph{This flag is used only in the connection-mode environment.}

@item DEFAULT_RC_SEL
When set, it indicates that the default selection is for the use of receipt
confirmation for every N_DATA_REQ primitive (This parameter is applicable only
when use of receipt confirmation is successfully negotiated via the N_CONN
primitives).

@emph{This flag is used only in the connection-mode environment.}

@item N_CONS
When set, it indicates that the NS provider supports connection-mode network
services.

@item N_CLNS
When set, it indicates that the NS provider supports connection-less network
services.

@end vtable

@subsubheading Valid States

This primitive is valid in any state in response to a N_INFO_REQ primitive.

@subsubheading New State

The state remains the same.

@page
@node N_BIND_REQ
@subsection Bind Protocol Address Request

@subsubheading N_BIND_REQ
@prindex N_BIND_REQ

This primitive requests that the NS provider bind a NS user entity to a network
address and negotiate the number of connect indications allowed to be outstanding
by the NS provider for the specified NS user entity being bound.

@subsubheading Format

The format of the message is one M_PROTO message block and its structure is as
follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_BIND_REQ */
        ulong ADDR_length;              /* length of address */
        ulong ADDR_offset;              /* offset of address */
        ulong CONIND_number;            /* req # of conn-indications to be
                                           queued */
        ulong BIND_flags;               /* flags associated with N_BIND_REQ */
        ulong PROTOID_length;           /* length of the protocol id */
        ulong PROTOID_offset;           /* offset of protocol id */
@} N_bind_req_t;
@tpindex N_bind_req_t

/* Flags associated with N_BIND_REQ */
#define DEFAULT_LISTENER    0x00000001L
#define TOKEN_REQUEST       0x00000002L
#define DEFAULT_DEST        0x00000004L
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Is the primitive type.

@item ADDR_length
Is the length in bytes of the network address to be bound to the stream.

@item ADDR_offset
Is the offset from the beginning of the M_PROTO block where the network address
begins.

@item CONIND_number
Is the requested number of connect indications allowed to be outstanding by the
NS provider for the specified protocol address.  (If the number of outstanding
connect indications equals CONIND_number, the NS provider need not discard
further incoming connect indications, but may choose to queue them internally
until the number of outstanding connect indications drops below the
CONIND_number.) Only one stream per network address is allowed to have a
CONIND_number value greater than zero.  This indicates to the network provider
that this stream is the listener stream for the NS user.  This stream will be
used by the NS provider for connect indications for that network address.

If a stream is bound as a listener stream, it will not be able to initiate
connect requests.  If the NS user attempts to send an N_CONN_REQ primitive down
this stream, an N_ERROR_ACK message will be sent to the NS user by the NS
provider with an error value of NACCESS.

@emph{This field should be ignored in CLNS.}

@item PROTOID_length
Is the length in bytes of the protocol ids to be bound to the stream.

@item PROTOID_offset
Is the offset from the beginning of the M_PROTO block where the protocol id
begins.

@end vtable

@subsubheading Flags

@vtable @var

@item DEFAULT_LISTENER

When set, this flag indicates that this stream is the ``default listener
stream''.  This stream is used to pass connect indications for all incoming calls
that contain protocol identifiers that are not bound to any other listener, or
when a listener stream with CONIND_number value of greater than zero is not
found.  Also, the default listener will receive all incoming call indications
that contain no user data.

Only one default listener stream is allowed per occurrence of NPI.  An attempt to
bind a default listener stream when one is already bound should result in an
error (of type NBOUND).

@emph{The DEFAULT_LISTENER flag is ignored in CLNS.}

@item TOKEN_REQUEST
When set, this flag indicates to the NS provider that the NS user has requested
that a ``token'' be assigned to the stream (to be used in the NC response
message), and the token value be returned to the NS user via the N_BIND_ACK
primitive.

The token assigned by the NS provider can then be used by the NS user in a
subsequent N_CONN_RES primitive to identify the stream on which the NC is to be
established.

@emph{The TOKEN_REQUEST flag is ignored in CLNS.}

@item DEFAULT_DEST
When set, this flag indicates that this stream is the ``default destination
stream.'' This stream will receive all packets destined for the NSAP specified
in the bind request.  If no NSAP is indicated in the bind request, then this
stream should receive all packets destined to an NSAP which is bound to no other
stream.

Only one default destination stream per NSAP is allowed per occurrence of NPI.  An
attempt to bind a default destination stream to an NSAP when one is already
bound should result in an error of type NBOUND.

@emph{The DEFAULT_DEST flag is ignored in the CONS.}

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_UNBND (see Appendix B).

@subsubheading New State

The new state is NE_WACK_BREQ.

@subsubheading Acknowledgements

The NS provider will generate one of the following acknowledgements upon receipt
of the N_BIND_REQ primitive:

@itemize ---

@item Successful:
Correct acknowledgement of the primitive is indicated using the N_BIND_ACK
primitive.

@item Non-fatal errors:
These errors will be indicated using the N_ERROR_ACK primitive.  The applicable
non-fatal errors are as follows:

@vtable @asis

@item NBADADDR
The network address was in an incorrect format or the address contained illegal
information.  It is not intended to indicate protocol errors.

@item NBOUND
The NS user attempted to bind a second stream to a network address with the
CONIND_number set to a non-zero value, or attempted to bind a second stream with
the DEFAULT_LISTENER flag value set to non-zero.

@item NNOADDR
The NS provider could not allocate an address.

@item NACCESS
The user did not have proper permissions for the use of the requested address.

@item NOUTSTATE
The primitive was issued from an invalid state.

@item NSYSERR
A system error has occurred and the UNIX system error is indicated in the
primitive.

@item NNOPROTOID
Protocol identifier could not be allocated.

@end vtable

@end itemize

@page
@node N_BIND_ACK
@subsection Bind Protocol Address Acknowledgement

@subsubheading N_BIND_ACK
@prindex N_BIND_ACK

This primitive indicates to the NS user that the specified network user entity
has been bound to the requested network address and that the specified number of
connect indications are allowed to be queued by the NS provider for the
specified network address.

@subsubheading Format

The format of the message is one M_PCPROTO message block, and its structure is
the following:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_BIND_ACK */
        ulong ADDR_length;              /* address length */
        ulong ADDR_offset;              /* offset of address */
        ulong CONIND_number;            /* connection indications */
        ulong TOKEN_value;              /* NC response token value */
        ulong PROTOID_length;           /* length of protocol id */
        ulong PROTOID_offset;           /* offset from beg.  of block */
@} N_bind_ack_t;
@tpindex N_bind_ack_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item ADDR_length
Is the length of the network address that was bound.

@item ADDR_offset
Is the offset from the beginning of the M_PCPROTO block where the network
address begins.

@item CONIND_number
Is the accepted number of connect indications allowed to be outstanding by the
NS provider for the specified network address.  If its value is zero, this stream
cannot acceptN_CONN_IND messages.  If its value is greater than zero, then the NS
user can accept N_CONN_IND messages up to the value specified in this parameter
before having to respond with a N_CONN_RES or a N_DISCON_REQ message.

@emph{This field should be ignored for CLNS.}

@item TOKEN_value
Conveys the value of the ``token'' assigned to this stream that can be used by
the NS user in a N_CONN_RES primitive to accept a NC on this stream.  It is a
non-zero value, and is unique to all streams bound to the NS provider.

@emph{This field should be ignored for CLNS.}

@item PROTOID_length
Conveys the length of the protocol ids that were bound.

@item PROTOID_offset
Conveys the offset of the protocol ids that were bound.

@end vtable

The proper alignment of the address in the M_PCPROTO message block is not guaranteed.

@subsubheading Bind Rules:

The following rules apply to the binding of the specified network address to the
stream:

@itemize ---

@item If the ADDR_length field in the N_BIND_REQ primitive is zero, then the NS
provider is to assign a network address to the user.

@item The NS provider is to bind the network address as specified in the
N_BIND_REQ primitive.  If the NS provider cannot bind the specified address, it
may assign another network address to the user.  It is the network user's
responsibility to check the network address returned in the N_BIND_ACK primitive
to see if it is the same as the one requested.

@end itemize

The following rules apply to negotiating CONIND_number argument:

@itemize ---

@item The CONIND_number in the N_BIND_ACK primitive must be less than or equal
to the corresponding requested number as indicated in the N_BIND_REQ primitive.

@item Only one stream that is bound to the indicated network address may have a
negotiated accepted number of maximum connect requests greater than zero.  If a
N_BIND_REQ primitive specifies a value greater than zero, but another stream has
already bound itself to the given network address with a value greater than
zero, the NS provider should assign another protocol address to the user.

@item If a stream with CONIND_number greater than zero is used to accept a
connection,the stream will be found busy during the duration of that connection
and no other streams may be bound to that network address with a CONIND_number
greater than zero.  This will prevent more than one stream bound to the identical
network address from accepting connect indications.

@item A stream requesting a CONIND_number of zero should always be legal.  This
indicates to the NS provider that the stream is to be used to request
connections only.

@item A stream with a negotiated CONIND_number greater than zero may generate
connect requests or accept connect indications.

@end itemize

@emph{If the above rules result in an error condition, then the NS provider must
issue anN_ERROR_ACK primitive to the NS user specifying the error as defined in
the description of the N_BIND_REQ primitive.}

@subsubheading Valid States

This primitive is in response to a N_BIND_REQ primitive and is valid in the
state NS_WACK_BREQ.

@subsubheading New State

The new state is NS_IDLE.

@page
@node N_UNBIND_REQ
@subsection Unbind Protocol Address Request

@subsubheading N_UNBIND_REQ
@prindex N_UNBIND_REQ

This primitive requests that the NS provider unbind the NS user entity that
was previously bound to the network address.

@subsubheading Format

The format of the message is one M_PROTO block, and its structure is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_UNBIND_REQ */
@} N_unbind_req_t;
@tpindex N_unbind_req_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@end vtable

@subsubheading Valid States

This primitive is valid in the NS_IDLE state.

@subsubheading New State

The new state is NS_WACK_UREQ.

@subsubheading Acknowledgements

This primitive requires the NS provider to generate the following
acknowledgements upon receipt of the primitive:

@itemize ---

@item Successful:
Correct acknowledgement of the primitive is indicated via the N_OK_ACK
primitive, @pxref{N_OK_ACK}.

@item Unsuccessful (Non-fatal errors):
These errors will be indicated via the N_ERROR_ACK primitive.  The applicable
non-fatal errors are as follows:

@vtable @asis

@item NOUTSTATE
The primitive was issued from an invalid state.

@item NSYSERR
A system error has occurred and the UNIX system error is indicated in the
primitive.

@end vtable

@end itemize

@page
@node N_OPTMGMT_REQ
@subsection Network Options Management Request

@subsubheading N_OPTMGMT_REQ
@prindex N_OPTMGMT_REQ

This primitive allows the NS user to manage the QOS parameter values associated
with the stream.

@subsubheading Format

The format of the message is one M_PROTO message block, and its structure is
as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_OPTMGMT_REQ */
        ulong QOS_length;               /* length of QOS values */
        ulong QOS_offset;               /* offset of QOS values */
        ulong OPTMGMT_flags;            /* default receipt conf.  selection */
@} N_optmgmt_req_t;
@prindex N_optmgmt_req_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item QOS_length
Indicates the length of the default values of the QOS parameters as selected by
the NS user.  In the connection-mode environment these values will be used in
subsequent N_CONN_REQprimitives on the stream that do not specify values for
these QOS parameters.  In the connection-less environment, these values represent
the selected QOS values that would apply to each unit data transmission.  If the
NS user cannot determine the value of a QOS parameter, its value should be set
to QOS_UNKNOWN.  If the NS user does not specify any QOS parameter values, the
length of this field should be set to zero.

@item QOS_offset
Indicates the offset of the QOS parameters from the beginning of the M_PROTO
message block.

@end vtable

@subsubheading Flags

@vtable @var

@item DEFAULT_RC_SEL
When set, it indicates to the NS provider that the NS user's default selection
is for the use of receipt confirmation with every N_DATA_REQ message (applicable
only when its use is successfully negotiated via the N_CONN primitives).  This
default indication is used only when the M_PROTO message block is not present in
the N_DATA_REQ primitive.

@emph{This flag should be ignored in the connection-less environment.}

@end vtable

@subsubheading Valid States

This primitive is valid in the NS_IDLE state.

@subsubheading New State

The new state is NS_WACK_OPTREQ.

@subsubheading Acknowledgements

The N_OPTMGMT_REQ primitive requires the NS provider to generate one of the
following acknowledgements upon receipt of the primitive:

@itemize ---

@item Successful:
Acknowledgement is via the N_OK_ACK primitive.  At successful completion, the
resulting state is NS_IDLE.

@item Non-fatal errors:
These errors are indicated in the N_ERROR_ACK primitive.  The resulting state
remains unchanged.  The applicable non-fatal errors are defined as follows:

@vtable @asis

@item NOUTSTATE
The primitive was issued from an invalid state.

@item NBADQOSPARAM
The QOS parameter values specified are outside the range supported by the NS provider.

@item NBADQOSTYPE
The QOS structure type is not supported by the NS provider.

@item NSYSERR
A system error has occurred and the UNIX system error is indicated in the primitive.

@end vtable

@end itemize


@page
@node N_ERROR_ACK
@subsection Error Acknowledgement

@subsubheading N_ERROR_ACK
@prindex N_ERROR_ACK

This primitive indicates to the NS user that a non-fatal error has occurred in
the last network-user-originated primitive.  This may only be initiated as an
acknowledgement for those primitives that require one.  It also indicates to the
user that no action was taken on the primitive that caused the error.

@subsubheading Format

The format of the message is one M_PCPROTO message block, and its structure is
asfollows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_ERROR_ACK */
        ulong ERROR_prim;               /* primitive in error */
        ulong NPI_error;                /* NPI error code */
        ulong UNIX_error;               /* UNIX system error code */
@} N_error_ack_t;
@tpindex N_error_ack_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Identifies the primitive type

@item ERROR_prim
Identifies the primitive type that caused the error.

@item NPI_error
Contains the Network Provider Interface error code.

@item UNIX_error
Contains the UNIX system error code.  This may only be non-zero if the NPI_error
is equal to NSYSERR.

@end vtable

@subsubheading Valid Error Codes

@emph{The following error codes are allowed to be returned:}

@vtable @asis

@item NBADADDR
The network address as specified in the primitive was in an incorrect format, or
the address contained illegal information.

@item NBADOPT
The options values as specified in the primitive were in an incorrect format, or
they contained illegal information.

@item NBADQOSPARAM
The QOS values specified are outside the range supported by the NS provider.
illegal.

@item NBADQOSTYPE
The QOS structure type is not supported by the NS provider.

@item NBADTOKEN
Token used is not associated with an open stream.

@item NNOADDR
The NS provider could not allocate an address.

@item NACCESS
The user did not have proper permissions.

@item NOUTSTATE
The primitive was issued from an invalid state.

@item NBADSEQ
The sequence number specified in the primitive was incorrect or illegal.

@item NBADFLAG
The flags specified in the primitive were incorrect or illegal.

@item NBADDATA
The amount of user data specified was outside the range supported by the NS
provider.

@item NSYSERR
A system error has occurred and the UNIX system error is indicated in the
primitive.

@item NNOTSUPPORT
Specified primitive type is not known to the NS provider.

@end vtable

@subsubheading Valid States

This primitive is valid in all states that have a pending acknowledgement or
confirmation.

@subsubheading New State

The new state is the same as the one from which the acknowledged request or
response was issued.

@page
@node N_OK_ACK
@subsection Successful Receipt Acknowledgement

@subsubheading N_OK_ACK
@prindex N_OK_ACK

This primitive indicates to the NS user that the previous network-
user-originated primitive was received successfully by the network provider.  It
does not indicate to the NS user any network protocol action taken due to the
issuance of the last primitive.  The N_OK_ACK primitive may only be initiated as
an acknowledgement for those user originated primitives that have no other means
of confirmation.

@subsubheading Format

The format of the message is one M_PCPROTO message block, and its structure is
as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_OK_ACK */
        ulong CORRECT_prim;             /* primitive being acknowledged */
@} N_ok_ack_t;
@tpindex N_ok_ack_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Identifies the primitive.

@item CORRECT_prim
Identifies the successfully received primitive type.

@end vtable

@subsubheading Valid States

This primitive is issued in states
@itemize @bullet
@item NS_WACK_UREQ,
@item NS_WACK_OPTREQ,
@item NS_WACK_RRES,
@item NS_WACK_CRES,
@item NS_WACK_DREQ6,
@item NS_WACK_DREQ7,
@item NS_WACK_DREQ9,
@item NS_WACK_DREQ10, and
@item NS_WACK_DREQ11,
@end itemize
in response to
@itemize @bullet
@item N_UNBIND_REQ,
@item N_RESET_RES,
@item N_CONN_RES, and
@item N_DISCON_REQ
@end itemize
primitives.

@subsubheading New State

The resulting state depends on the current state (see Appendix B, Tables B-7 and
B-8.)

@page
@node CONS Primitive Format and Rules
@section CONS Primitive Format and Rules

@menu
* Connection Establishment Primitives::
* Normal Data Transfer Phase::
* Receipt Confirmation Service Primitives::
* Expedited Data Transfer Service::
* Reset Service::
* Network Connection Release Phase::
@end menu

This section describes the format of the CONS primitives and the rules
associated with these primitives.  The default values of the QOS parameters
associated with a NC may be selected via the N_OPTMGMT_REQ primitive.

@node Connection Establishment Primitives
@subsection Connection Establishment Primitives

@menu
* N_CONN_REQ::
* N_CONN_IND::
* N_CONN_RES::
* N_CONN_CON::
@end menu

The following network service primitives pertain to the establishment of an NC,
provided the NS users exist, and are known to the NS provider.

@node N_CONN_REQ
@subsubsection Network Connection Request

@subsubheading N_CONN_REQ
@prindex N_CONN_REQ

This primitive requests that the NS provider make a network connection to the
specified destination.

@subsubheading Format

The format of the message is one M_PROTO message block followed by one or
more M_DATA blocks for the NS user data transfer.  The specification of the NS
user data is optional.  The NS user can send any integral number of octets of
data within the range supported by the NS provider (see N_INFO_ACK).  If the user
does not specify QOS parameter values, the default values (specified via
N_OPTMGMT_REQ) are used by the NS provider.

The structure of the M_PROTO message block is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_CONN_REQ */
        ulong DEST_length;              /* destination address length */
        ulong DEST_offset;              /* destination address offset */
        ulong CONN_flags;               /* bit masking for options flags */
        ulong QOS_length;               /* QOS parameters' length */
        ulong QOS_offset;               /* QOS parameters' offset */
@} N_conn_req_t;
@tpindex N_conn_req_t

/* Flags to indicate if options are requested */
#define REC_CONF_OPT    0x00000001L
#define EX_DATA_OPT     0x00000002L
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item DEST_length
Indicates the length of the destination address parameter that conveys an address
identifying the NS user to which the NC is to be established.  This field will
accommodate variable length addresses within a range supported by the NS
provider.

@item DEST_offset
Is the offset of the destination address from the beginning of the M_PROTO
message block.

@item QOS_length
Indicates the length of the QOS parameters values that apply to the NC being
requested.  If the NS user cannot determine the value of a QOS parameter, its
value should be set to QOS_UNKNOWN.  If the NS user does not specify any QOS
parameter values, the length of this field should be set to zero.

@item QOS_offset
Indicates the offset of the QOS parameters from the beginning of the M_PROTO
message block.

@end vtable

@subsubheading Flags

@vtable @var

@item REC_CONF_OPT
The receipt confirmation selection parameter indicates the use/availability of
the receipt confirmation service on the NC.  The receipt confirmation service
must be supported by the NS provider to be used on the NC.

@item EX_DATA_OPT
Indicates the use of the expedited data transfer service on the NC.  The
expedited data transfer service must be provided by the NS provider for it to be
used on the NC.

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_IDLE.

@subsubheading New State

The new state is NS_WCON_CREQ.

@subsubheading Acknowledgements

The following acknowledgements are valid for this primitive:

@itemize ---

@item Successful NC Establishment:
This is indicated via the N_CONN_CON primitive.  This results in the data transfer
state.

@item Unsuccessful NC Establishment:
This is indicated via the N_DISCON_IND primitive.  For example, a connection may
be rejected because either the called NS user cannot be reached, or the NS
provider and/or the called NS user did not agree with the specified QOS.  This
results in the idle state.

@item Non-fatal errors:
These are indicated via the N_ERROR_ACK primitive.  The applicable non-fatal
errors are defined as follows:

@vtable @asis

@item NACCESS
The user did not have proper permissions for the use of the requested address or
options.

@item NBADQOSPARAM
The QOS parameter values specified are outside the range supported by the NS
provider.

@item NBADQOSTYPE
The QOS structure type is not supported by the NS provider.

@item NBADADDR
The network address was in an incorrect format or contained illegal information.
It is not intended to indicate NC errors, such as an unreachable destination.
These errors types are indicated via the N_DISCON_IND primitive.

@item NBADOPT
The options were in an incorrect format, or they contained illegal information.

@item NOUTSTATE
The primitive was issued from an invalid state.

@item NBADDATA
The amount of user data specified was outside the range supported by the NS
provider.

@item NSYSERR
A system error has occurred and the UNIX system error is indicated in the
primitive.

@end vtable

@end itemize

@page
@node N_CONN_IND
@subsubsection Network Connection Indication

@subsubheading N_CONN_IND
@prindex N_CONN_IND

This primitive indicates to the destination NS user that a network connect
request has been made by the user at the specified source address.

@subsubheading Format

The format of this message is one M_PROTO message block followed by one or
more M_DATA blocks for NS user data.  The specification of NS user data is
optional.  The NS user can send any integral number of octets of data within the
range supported by the NS provider.  The NS user data will only be present if the
corresponding N_CONN_REQ had NS user data parameter specified, and their data
will be identical.

The structure of the M_PROTO message block is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_CONN_IND */
        ulong DEST_length;              /* destination address length */
        ulong DEST_offset;              /* destination address offset */
        ulong SRC_length;               /* source address length */
        ulong SRC_offset;               /* source address offset */
        ulong SEQ_number;               /* sequence number */
        ulong CONN_flags;               /* bit masking for options flags */
        ulong QOS_length;               /* QOS parameters' length */
        ulong QOS_offset;               /* QOS parameters' offset */
@} N_conn_ind_t;
@tpindex N_conn_ind_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item DEST_length
Indicates the length of the destination address parameter that conveys an address
identifying the NS user to which the NC is to be established.

@item DEST_offset
Is the offset of the destination address from the beginning of theM_PROTO
message block.

@item SRC_length
The source address parameter conveys the network address of the NS user from
which the NC has been requested.  The semantics of the value in the N_CONN_IND
primitive is identical to the value associated with the stream on which the
N_CONN_REQ was issued.

@item SRC_offset
Is the offset of the destination address from the beginning of theM_PROTO
message block.

@item SEQ_number
Identifies the sequence number that can be used by the NS user to associate this
message with the N_CONN_RES or N_DISCON_REQ primitive that is to follow.  This
value must be unique among the outstanding N_CONN_IND messages.  The use of this
field allows the NS user to issue the N_CONN_RES or the N_DISCON_REQ messages in
any order.

@item QOS_length
Indicates the length of the QOS parameters values that are negotiated during NC
establishment.  If the destination NS user does not agree to the range of QOS
values specified by the source NS user in the N_CONN_REQ primitive, it will
reject the NC establishment by invoking a N_DISCON_REQ primitive(the originator
parameter in the N_DISCON_REQ primitive will indicate NS user initiated
release).  If the NS user does not support or cannot determine the value of a QOS
parameter, its value will be set to QOS_UNKNOWN.  If the NS user does not specify
any QOS parameter values, the length of this field should be set to zero.

@item QOS_offset
Indicates the offset of the QOS parameters from the beginning of the M_PROTO
message block.

@end vtable

@subsubheading Flags

@vtable @var

@item REC_CONF_OPT
The receipt confirmation selection parameter indicates the use/availability of
the receipt confirmation service on the NC.  The receipt confirmation service must
be provided in the network service to be used on the NC.

@item EX_DATA_OPT
The expedited data selection parameter indicates the use/ availability of the
expedited data transfer service on the NC.  The expedited data transfer service
must be provided by the NS provider for it to be used on the NC.  Valid States
This primitive is valid in the states NS_IDLE and NS_WRES_CIND.  New State In
both cases the resulting state is NS_WRES_CIND (the number of connect
indications waiting for user response is incremented by one).

@end vtable


@page
@node N_CONN_RES
@subsubsection Network Connection Response

@subsubheading N_CONN_RES
@prindex N_CONN_RES

This primitive allows the destination NS user to request that the network
provider accept a previous connect request.

@subsubheading Format

The format of this message is one M_PROTO message block followed by one or
more M_DATA blocks (for NS user data).  The specification of the NS user data is
optional.

The NS user can send any integral number of octets of data within the range
supported by the NS provider.

The structure of the M_PROTO block is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_CONN_RES */
        ulong TOKEN_value;              /* NC response token value */
        ulong RES_length;               /* responding address length */
        ulong RES_offset;               /* responding address offset */
        ulong SEQ_number;               /* sequence number */
        ulong CONN_flags;               /* bit masking for options flags */
        ulong QOS_length;               /* QOS parameters' length */
        ulong QOS_offset;               /* QOS parameters' offset */
@} N_conn_res_t;
@tpindex N_conn_res_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item TOKEN_value
Is used to identify the stream that the NS user wants to establish the NC on.
(Its value is determined by the NS user by issuing a N_BIND_REQ primitive with
the TOKEN_REQUEST flag set.The token value is returned in the N_BIND_ACK).  The
value of this field should be non-zero when the NS user wants to establish the NC
on a stream other than the stream on which the N_CONN_IND arrived.  If the NS
user wants to establish a NC on the same stream that the N_CONN_IND arrived on,
then the value of this field should be zero.

@item RES_length
Indicates the length of the responding address parameter that conveys the network
address of the NS user to which the NC has been established.  Under certain
circumstances, such as call redirection, generic addressing, etc., the value of
this parameter may be different from the destination address
parameter specification in the corresponding N_CONN_REQ.

@item RES_offset
Indicates the offset of the responding address from the beginning of the M_PROTO
message block.

@item SEQ_number
Indicates the sequence number of the N_CONN_RES message.It is used by the NS
provider to associate the N_CONN_RES message with an outstanding N_CONN_IND
message.  An invalid sequence number should result in error with the message type
NBADSEQ.

@item QOS_length
Indicates the length of the QOS parameters values that are negotiated during NC
establishment.  If the NS user does not agree to the QOS values, it will reject
the NC establishment by invoking a N_DISCON_REQ primitive (the originator
parameter in the N_DISCON_REQ primitive will indicate NS user invoked release).
If the NS user cannot determine the value of a QOS parameter, its value should
be set to QOS_UNKNOWN.  If the NS user does not specify any QOS parameter values,
the length of this field should be set to zero.

@item QOS_offset
Indicates the offset of the QOS parameters from the beginning of the M_PROTO
message block.

@end vtable

@subsubheading Flags

@vtable @var

@item REC_CONF_OPT
The receipt confirmation selection parameter indicates the use/availability of
the receipt confirmation service on the NC.  The receipt confirmation service must
be provided in the network service to be used on the NC.

@item EX_DATA_OPT
The expedited data selection parameter indicates the use/availability of the
expedited data transfer service on the NC.  The expedited data transfer service
must be provided by the NS provider for it to be used on the NC.

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_WRES_CIND.

@subsubheading New State

The new state is NS_WACK_CRES.

@subsubheading Acknowledgements

The NS provider should generate one of the following acknowledgements upon
receipt of this primitive:

@itemize ---

@item Successful:
Successful completion is indicated via the N_OK_ACK primitive.

@item Unsuccessful (Non-fatal errors):
Errors are indicated via the N_ERROR_ACK primitive.  The applicable non-fatal
errors are defined as follows:

@vtable @asis

@item NBADOPT
The options were in an incorrect format, or they contained illegal information.

@item NBADQOSPARAM
The QOS parameter values specified are outside the range supported by the NS
provider.

@item NBADQOSTYPE
The QOS structure type is not supported by the NS provider.

@item NBADTOKEN
The token specified is not associated with an open stream.

@item NACCESS
The user did not have proper permissions for the use of the options of the
options or response id.

@item NOUTSTATE
The primitive was issued from an invalid state.

@item NBADDATA
The amount of user data specified was outside the range supported by the NS
provider.

@item NBADSEQ
The sequence number specified in the primitive was incorrect or illegal.

@item NSYSERR
A system error has occurred and the UNIX system error is indicated in the
primitive.

@end vtable

@end itemize


@page
@node N_CONN_CON
@subsubsection Network Connection Confirm

@subheading N_CONN_CON
@prindex N_CONN_CON

This primitive indicates to the source NS user that the network connect request
has been confirmed on the specified responding address.

@subsubheading Format

The format of this message is one M_PROTO message block followed by one or
more M_DATA blocks (for NS user data).  The specification of the NS user data is
optional.

The NS user can send any integral number of octets of NS user data within a
range supported by the NS provider (see N_INFO_ACK).  The NS user data will only
be present if the corresponding N_CONN_RES had NS user data specified with it,
and their data will always be identical.

The structure of the M_PROTO block is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_CONN_CON */
        ulong RES_length;               /* responding address length */
        ulong RES_offset;               /* responding address offset */
        ulong CONN_flags;               /* bit masking for options flags */
        ulong QOS_length;               /* QOS parameters' length */
        ulong QOS_offset;               /* QOS parameters' offset */
@} N_conn_con_t;
@tpindex N_conn_con_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item RES_length
Indicates the length of the responding address parameter that conveys the
network address of the NS user entity to which the NC has been established.  The
semantics of the values in the N_CONN_CON is identical to the values in
N_CONN_RES.  Under certain circumstances, such as call redirection,
generic addressing, etc., the value of this parameter may be different from the
destination address parameter specification in the corresponding N_CONN_REQ.

@item RES_offset
Indicates the offset of the responding address from the beginning of the M_PROTO
message block.

@item QOS_length
Indicates the length of the QOS parameters values selected by the responding NS
user.  If the NS provider does not support or cannot determine the selected value
of a QOS parameter, its value will be set to QOS_UNKNOWN.  If the NS provider does
not specify any QOS parameter values, the length of this field should be set to
zero.

@item QOS_offset
Indicates the offset of the QOS parameters from the beginning of the M_PROTO
message block.

@end vtable

@subsubheading Flags

@vtable @var

@item REC_CONF_OPT
The receipt confirmation selection parameter indicates the use/availability of
the receipt confirmation service on the NC.  The receipt confirmation service must
be provided in the network service to be used on the NC.

@item EX_DATA_OPT
The expedited data selection parameter indicates the use/ availability of the
expedited data transfer service on the NC.  The expedited data transfer service
must be provided by the NS provider for it to be used on the NC.  Valid States
This primitive is valid in state NS_WCON_CREQ.  New State The new state is
NS_DATA_XFER.

@end vtable

@page
@node Normal Data Transfer Phase
@subsection Normal Data Transfer Phase

@menu
* N_DATA_REQ::
* N_DATA_IND::
@end menu

The data transfer service primitives provide for an exchange of NS user data
known as NSDUs, in either direction or in both directions simultaneously on a
NC.  The network service preserves both the sequence and the boundaries of the
NSDUs (when the NS provider supports NSDUs).

@node N_DATA_REQ
@subsubsection Normal Data Transfer Request

@subsubheading N_DATA_REQ
@prindex N_DATA_REQ

This user-originated primitive indicates to the NS provider that this message
contains NS user data.  It allows the transfer of NS_user_data between NS users,
without modification by the NS provider.  The NS user must send any integral
number of octets of data greater than zero.  In a case where the size of the NSDU
exceeds the NIDU (as specified by the size of the NIDU_size parameter of the
N_INFO_ACK primitive), the NSDU may be broken up into more than one NIDU.  When
an NSDU is broken up into more than one NIDU, the N_MORE_DATA_FLAG will be set
on each NIDU except the last one.  The RC_flagmay only be set on the last NIDU.

@subsubheading Format

The format of the message is one or more M_DATA blocks.  Use of a M_PROTOmessage
block is optional.  The M_PROTO message block is used for two reasons:

@enumerate 1

@item to indicate that the NSDU is broken into more than one NIDUs, and that the
data carried in the following M_DATA message block constitutes one NIDU;

@item to indicate whether receipt confirmation is desired for the NSDU.

@end enumerate

@subsubheading Guidelines for use of M_PROTO:

The following guidelines must be followed with respect to the use of the M_PROTO
message block:

@enumerate 1

@item The M_PROTO message block need not be present when the NSDU size is
less than or equal to the NIDU size and one of the following is true:

@itemize ---

@item receipt confirmation has been negotiated for non-use (via the
N_CONNprimitives); or

@item receipt confirmation has been successfully negotiated for use or non-use
and the default selection as specified via the N_OPTMGMT primitive is to be used.

@end itemize

@item The M_PROTO message block must be present when:

@itemize ---

@item the NSDU size is greater than the NIDU size;

@item receipt confirmation has been successfully negotiated for use and the
default selection as specified via N_OPTMGMT_REQ primitive needs to be
overridden.

@end itemize

@end enumerate

The structure of the M_PROTO message block, if present, is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_DATA_REQ */
        ulong DATA_xfer_flags;          /* bit masking for data xfer flags */
@} N_data_req_t;
@tpindex N_data_req_t

/* Data Transfer Flags */
#define N_MORE_DATA_FLAG    0x00000001L
#define N_RC_FLAG           0x00000002L
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@end vtable

@subsubheading Flags

@vtable @var

@item N_MORE_DATA_FLAG
When set, the MORE_DATA_FLAG indicates that the next N_DATA_REQ message (NIDU) is
also part of this NSDU.

@item N_RC_FLAG
By setting this flag on the N_DATA_REQ, the originating NS user can request
confirmation of receipt of the N_DATA primitive.  The receipt is provided by the
N_DATACK primitives.  The parameter may only be present if use of Receipt
Confirmation was agreed by both NS users and the NS provider during NC
establishment.

@end vtable

@subsubheading Valid States

This primitive is valid in the NS_DATA_XFER state.

@subsubheading New State

The resulting state remains the same (NS_DATA_XFER).

@subsubheading Acknowledgements

This primitive does not require any acknowledgements, although it may generate
a fatal error.  This is indicated to the NS user via a M_ERROR STREAMS message
type (specifying an errno value of EPROTO) which results in the failure of
all system calls on that stream.  The applicable errors are defined as follows:

@vtable @asis

@item EPROTO
This indicates one of the following unrecoverable protocol conditions:

@itemize ---

@item The network interface was found to be in an incorrect state.

@item The amount of NS user data associated with the primitive is outside the range
supported by the NS provider (as specified by the NIDU_size parameter
ofN_INFO_ACK primitive).

@item The options requested are either not supported by the NS provider or its use
not specified with the N_CONN_REQ primitive.

@item The M_PROTO message block was not followed by one or more M_DATA message
blocks.

@item The amount of NS user data associated with the current NSDU is outside the
range supported by the NS provider (as specified by the NSDU_sizeparameter if
the N_INFO_ACK primitive.)

@item The N_RC_FLAG and N_MORE_DATA_FLAG were both set in the primitive, or the
flags field contained an unknown value.

@end itemize

@end vtable

NOTE: If the interface is in the NS_IDLE or NS_WRES_RIND states when the provider
receives the N_DATA_REQ primitive, then the NS provider should discard the
request without generating a fatal error.


@page
@node N_DATA_IND
@subsubsection Normal Data Transfer Indication

@subsubheading N_DATA_IND
@prindex N_DATA_IND

This network-provider-originated primitive indicates to the NS user that this
message contains NS user data.  As in the N_DATA_REQ primitive, the NSDU can be
segmented into more than one NIDUs.  The NIDUs are associated with the NSDU by
using theMORE_DATA_FLAG.  The RC_FLAG is allowed to be set only on the last NIDU.

@subsubheading Format

The format of the message is one or more M_DATA message blocks.  The value of the
NS user data field is always the same as that supplied in the corresponding
N_DATA_REQ primitive at the peer service access point.  Use of M_PROTO message
blocks is optional (see guidelines under N_DATA_REQ).

The structure of the M_PROTO message block, if present, is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_DATA_IND */
        ulong DATA_xfer_flags;          /* bit masking for data xfer flags */
@} N_data_ind_t;
@tpindex N_data_ind_t

/* Data Transfer Flags */
#define N_MORE_DATA_FLAG    0x00000001L
#define N_RC_FLAG           0x00000002L
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@end vtable

@subsubheading Flags

@vtable @var

@item MORE_DATA_FLAG
When set, indicates that the next N_DATA_IND message (NIDU) is part of this NSDU.

@item RC_FLAG
The value of the parameter may indicate either that confirmation is requested or
that it is not requested.  The parameter is allowed to be set only if use of
Receipt Confirmation was agreed to between both the NS users and the NS provider
during NC establishment.  The value of this parameter is always identical to that
supplied in the corresponding N_DATA_REQ primitive.

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_DATA_XFER.

@subsubheading New State

The resulting state remains the same (NS_DATA_XFER).

@page
@node Receipt Confirmation Service Primitives
@subsection Receipt Confirmation Service Primitives

@menu
* N_DATACK_REQ::
* N_DATACK_IND::
@end menu

The receipt confirmation service is requested by the confirmation request
parameter on the N_DATA_REQ primitive.  For each and every NSDU with the
confirmation request parameter set, the receiving NS user should return an
N_DATACK_REQ primitive.Such acknowledgements should be issued in the same
sequence as the corresponding N_DATA_IND primitives are received, and are to be
conveyed by the NS provider in such a way so as to preserve them distinct from
any previous or subsequent acknowledgements.  The NS user may thus correlate them
with the original requests by counting.  When an NSDU has been segmented into
more than one NIDUs, only the last NIDU is allowed to request receipt
confirmation.  N_DATACK_REQ primitives will not be subject to the flow control
affectingN_DATA_REQ primitives at the same NC endpoint.  N_DATACK_IND primitives
will not be subject to the flow control affecting N_DATA_IND primitives at the
same NC endpoint.

The use of the receipt confirmation service must be agreed to by the two NS
users of the NC and the NS provider during the NC establishment by using the
RC_selection parameter on the N_CONN primitives.

@node N_DATACK_REQ
@subsubsection Data Acknowledgement Request

@subsubheading N_DATACK_REQ
@prindex N_DATACK_REQ

This is a user-originated primitive that requests that the network provider
acknowledge the N_DATA_IND that had previously been received with the receipt
confirmation parameter set.

@subsubheading Format

The format of the message is one M_PROTO message block and its structure is
as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_DATACK_REQ */
@} N_datack_req_t;
@tpindex N_datack_req_t;
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_DATA_XFER.

@subsubheading New State

The resulting state remains the same (NS_DATA_XFER).

@subsubheading Acknowledgements

This primitive does not require any acknowledgements, although it may generate a
fatal (unrecoverable) error.  This is indicated via an M_ERROR STREAMS message
type (issued to the NS user specifying the errno value of EPROTO), which results
in the failure of all system calls on that stream.  The allowable errors are as
follows:

@vtable @asis

@item EPROTO
This indicates the following unrecoverable protocol condition:

@itemize ---

@item The network interface was found to be in an incorrect state.

@end itemize

@end vtable

NOTE: If the interface is in the NS_IDLE state when the provider receives
the N_DATACK_REQ primitive, then the NS provider should discard the request
without generating a fatal error.  If the NS provider had no knowledge of a
previous N_DATA_IND with the receipt confirmation flag set, then the NS provider
should just ignore the request without generating a fatal error.

@page
@node N_DATACK_IND
@subsubsection Data Acknowledgement Indication

@subsubheading N_DATACK_IND
@prindex N_DATACK_IND

This is a NS provider originated primitive that indicates to the network service
user that the remote network service user has acknowledged the data that had
previously been sent with the receipt confirmation set.

@subsubheading Format

The format of the message is one M_PROTO message block and its structure is as
follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_DATACK_IND */
@} N_datack_ind_t;
@tpindex N_datack_ind_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_DATA_XFER.

@subsubheading New State

The resulting state remains the same (NS_DATA_XFER).

@page
@node Expedited Data Transfer Service
@subsection Expedited Data Transfer Service

@menu
* N_EXDATA_REQ::
* N_EXDATA_IND::
@end menu

The expedited data transfer service provides a further means of information
exchange on an NC in both directions simultaneously.  The transfer of expedited
network service data unit (ENSDU) is subject to separate flow control from that
applying to NS user data (However, a separate STREAMS message type for expedited
data is not available with UNIX(R) System V Release 3.1.  Until a new STREAMS
message type is provided, expedited data will be implemented via queue
manipulation).  The NS provider should guarantee that an expedited-NSDU will not
be delivered after any subsequently issued NSDU or expedited-NSDU on that NC.
The relationship between normal and expedited data is shown in Table 2.
Expedited data can still be delivered when the receiving NS user is not accepting
normal data (however this cannot be guaranteed if there are blockages occurring
in the lower layers).  The expedited data transfer service is a NS provider
option, and its use must be agreed by the two NS users of the NC and the NS
provider during NC establishment by using the EX_DATA_OPT parameter on the
N_CONN primitives.

@node N_EXDATA_REQ
@subsubsection Expedited Data Transfer Request

@subsubheading N_EXDATA_REQ
@prindex N_EXDATA_REQ

This is a NS user originated primitive and is used to indicate to the network
provider that the message block contains an ENSDU.

@subsubheading Format

The format of the message is one M_PROTO message block, followed by one or
more M_DATA blocks.  The NS user must send an integral number of octets of data
within the range supported by the NS provider (see N_INFO_ACK).

The structure of the M_PROTO message block is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_EXDATA_REQ */
@} N_exdata_req_t;
@tpindex N_exdata_req_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_DATA_XFER.

@subsubheading New State

The resulting state remains the same (NS_DATA_XFER).

@subsubheading Acknowledgements

This primitive does not require any acknowledgements, although it may generate a
fatal (unrecoverable) error.  This is indicated via an M_ERROR STREAMS message
type (issued to the NS user with the errno value of EPROTO), which results in
the failure of all system calls on that stream.  The applicable errors are as
follows:

@vtable @asis

@item EPROTO
This indicates one of the following unrecoverable protocol conditions:

@itemize ---

@item The network interface was found to be in an incorrect state.

@item The amount of NS user data associated with the primitive defines an
expedited network service data unit of a size that is outside the range
supported by the NS provider.

@item Expedited data transfer is either not supported by the NS provider or not
requested with the N_CONN_REQ primitive.

@end itemize

@end vtable

NOTE: If the interface is in the NS_IDLE or NS_WRES_RIND states when the
provider receives the N_EXDATA_REQ primitive, then the NS provider should
discard the request without generating a fatal error.

@page
@node N_EXDATA_IND
@subsubsection Expedited Data Transfer Indication

@subsubheading N_EXDATA_IND
@prindex N_EXDATA_IND

This is a NS provider originated primitive and is used to indicate to the NS
user that this message contains an ENSDU.

@subsubheading Format

The format of the message is one M_PROTO message block, followed by one or
more M_DATA blocks.  The value of the data in the M_DATA blocks is identical to
that supplied with the corresponding N_EXDATA_REQ primitive.

The structure of the M_PROTO message block is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_EXDATA_IND */
@} N_exdata_ind_t;
@tpindex N_exdata_ind_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_DATA_XFER.

@subsubheading New State

The resulting state remains the same (NS_DATA_XFER).

@page
@node Reset Service
@subsection Reset Service

@menu
* N_RESET_REQ::
* N_RESET_IND::
* N_RESET_RES::
* N_RESET_CON::
@end menu

The reset service can be used by the NS user to resynchronize the use of the NC;
or by the NS provider to report detected loss of data unrecoverable within the
network service.

All loss of data which does not involve loss of the NC is reported in this way.
Invocation of the reset service will unblock the flow of NSDUs and ENSDUs in case
of congestion of the NC; it will cause the NS provider to discard NSDUs, ENSDUs,
or confirmations of receipt associated with the NC (See Table 1), and to notify
any NS user or users that did not invoke reset that a reset has occurred.  The
service will be completed in finite time,irrespective of the acceptance of the
NSDUs, ENSDUs, and confirmations of receipt by the NS users.

@node N_RESET_REQ
@subsubsection Reset Request

@subsubheading N_RESET_REQ
@prindex N_RESET_REQ

This user-originated primitive requests that the NS provider reset the
network connection.

@subsubheading Format

The format of the message is one M_PROTO message block, and its structure is
as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_RESET_REQ */
        ulong RESET_reason;             /* reason for reset */
@} N_reset_req_t;
@tpindex N_reset_req_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item RESET_reason
Gives information indicating the cause of the reset.

@end vtable

@subsubheading Valid States

This primitive is valid in the NS_DATA_XFER state.

@subsubheading New State

The resulting state is NS_WACK_RREQ.

@subsubheading Acknowledgements

@itemize ---

@item Successful:
This primitive does not require an immediate acknowledgement, although when the
resynchronization completes successfully, a N_RESET_CON primitive is issued to
the NS user that issued the N_RESET_REQ.

@item Unsuccessful:
A non-fatal error is acknowledged via the N_ERROR_ACK primitive.  In this case the
resulting state remains unchanged.  The following non-fatal error codes are
valid:

@vtable @asis

@item NOUTSTATE
The primitive was issued from an invalid state.

@item NSYSERR
A system error has occurred and the UNIX(R) system error is indicated with the
N_ERROR_ACK primitive.

@end vtable

@end itemize

NOTE: If the interface is in the NS_IDLE state when the provider receives
the N_RESET_REQ primitive, then the NS provider should discard the message
without generating an error.

@page
@node N_RESET_IND
@subsubsection Reset Indication

@subsubheading N_RESET_IND
@prindex N_RESET_IND

This network-provider-originated primitive indicates to the NS user that the
network connection has been reset.

@subsubheading Format

The format of the message is one M_PROTO message block, and its structure is
as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_RESET_IND */
        ulong RESET_orig;               /* reset originator */
        ulong RESET_reason;             /* reason for reset */
@} N_reset_ind_t;
@tpindex N_reset_ind_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item RESET_orig
This parameter indicates the source of the reset.

@item RESET_reason
Gives information indicating the cause of the reset.

@end vtable

@subsubheading Valid States

This primitive is valid in the NS_DATA_XFER state.

@subsubheading New State

The new state is NS_WRES_RIND.

@page
@node N_RESET_RES
@subsubsection Reset Response

@subsubheading N_RESET_RES
@prindex N_RESET_RES

This user-originated primitive indicates that the NS user has accepted a reset
request.

Format

The format of the message is one M_PROTO message block and its structure is
the following:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_RESET_RES */
@} N_reset_res_t;
@tpindex N_reset_res_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_WRES_RIND.

@subsubheading New State

The new state is NS_WACK_RRES.

@subsubheading Acknowledgements

@itemize ---

@item Successful:
The successful completion of this primitive is indicated via the N_OK_ACK
primitive.  This results in the data transfer state.

@item Unsuccessful:
An unsuccessful completion of this primitive is indicated by the N_ERROR_ACK
primitive.  The resulting state remains the same.  The following non-fatal
error-codes are valid:

@vtable @asis

@item NOUTSTATE
The primitive was issued from an invalid state.

@item NSYSERR
A system error has occurred and the UNIX system error
is indicated in the N_ERROR_ACK primitive.

@end vtable

@end itemize

NOTE: If the interface is in the NS_IDLE state when the provider receives
the N_RESET_RES primitive, then the NS provider should discard the message
without generating an error.

@page
@node N_RESET_CON
@subsubsection Reset Confirmation

@subsubheading N_RESET_CON
@prindex N_RESET_CON

This NS provider-originated primitive indicates to the network user that
initiated the reset, that the reset request has been confirmed.  The NS provider
is allowed to issue the N_RESET_CON primitive to the NS user that initiated the
reset even before receiving a N_RESET_RES.

@subsubheading Format

The format of the message is one M_PROTO message block and its structure is
the following:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_RESET_CON */
@} N_reset_con_t;
@tpindex N_reset_con_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_WCON_RREQ.

@subsubheading New State

The resulting state is NS_DATA_XFER.

@page
@node Network Connection Release Phase
@subsection Network Connection Release Phase

@menu
* N_DISCON_REQ::
* N_DISCON_IND::
@end menu

The NC release service primitives are used to release a NC.  The release may
be performed by:

@itemize ---

@item either or both of the NS users to release an established NC;

@item the NS provider to release an established NC (all failures to maintain an
NC are indicated in this manner);

@item the destination NS user to reject an N_CONN_IND;

@item by the NS provider to indicate its inability to establish a requested NC.

@end itemize

An NC release is permitted at any time regardless of the current phase of the
NC.  Once an NC release procedure has been invoked, the NC will be released; a
request for release cannot be rejected.  The network service does not guarantee
delivery of any data once the NC release phase is entered (see Table 1).

@node N_DISCON_REQ
@subsubsection Disconnect Request

@subsubheading N_DISCON_REQ
@prindex N_DISCON_REQ

This user-originated primitive requests that the NS provider deny a request for
a network connection, or disconnect an existing connection.

@subsubheading Format

The format of the message is one M_PROTO message block, followed by one or
more M_DATA message blocks (for NS user data).  The NS user data may be lost if
the NS provider initiates release before the N_DISCON_IND is delivered.
Therefore, the NS user data parameter is present only if the originator
parameter (as discussed in N_DISCON_IND definition) indicates that the release
was originated by an NS user.  The NS user may send any integral number of octets
of data within a range supported by the NS provider (see N_INFO_ACK).

The structure of the M_PROTO message block is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_DISCON_REQ */
        ulong DISCON_reason;            /* reason */
        ulong RES_length;               /* responding address length */
        ulong RES_offset;               /* responding address offset */
        ulong SEQ_number;               /* sequence number */
@} N_discon_req_t;
@tpindex N_discon_req_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item DISCON_reason
Gives information about the cause of the release.

@item RES_length
Indicates the length of the address of the responding address parameter.  The
responding address parameter is an optional parameter, and is present in the
primitive only in the case where the primitive is used to indicate rejection of
an NC establishment attempt by an NS user.  The responding address parameter
conveys the network address of the NS user entity from which the N_DISCON_REQ
was issued and under certain circumstances (e.g.  call redirection, generic
addressing, etc.) may be different from the ``destination address'' in
the corresponding N_CONN_REQ primitive.

@item RES_offset
Is the offset from the beginning of the M_PROTO message block where the network
address begins.

@item SEQ_number
When non-zero, it identifies the sequence number of the N_CONN_IND message being
rejected.  This number is used by the NS provider to associate the N_DISCON_REQ
with an unacknowledged N_CONN_IND that is to be rejected.  If the N_DISCON_REQ is
rejecting a NC that is already established(or rejecting a N_CONN_REQ that the NS
user had previously sent and has not yet been confirmed), then this field should
have a value of 0.

@end vtable

@subsubheading Valid States

This primitive is valid in states NS_WCON_CREQ, NS_WRES_CIND,NS_DATA_XFER, NS_WCON_RREQ, NS_WRES_RIND.

@subsubheading New State

The new state depends on the original state (see Appendix B, Table B-8).

@subsubheading Acknowledgements:

The NS provider should generate one of the following acknowledgements upon
receipt of this primitive:

@itemize ---

@item Successful:
Successful completion is indicated via the N_OK_ACK primitive.

@item Unsuccessful (Non-fatal errors):
Errors are indicated via the N_ERROR_ACK primitive.  The applicable non-fatal
errors are as follows:

@vtable @asis

@item NOUTSTATE
The primitive was issued from an invalid state.

@item NBADDATA
The amount of user data specified was outside the range supported by the NS
provider.

@item NSYSERR
A system error has occurred and the UNIX system error is indicated in the
primitive.

@item NBADSEQ
The specified sequence number referred to an invalid N_CONN_IND message, or the
N_DISCON_REQ is rejecting an NC that is already established (or rejecting
anN_CONN_REQ that the NS user had previously sent and has not yet been
confirmed) and the value of the sequence number is not 0.

@end vtable

@end itemize

@page
@node N_DISCON_IND
@subsubsection Disconnect Indication

@subsubheading N_DISCON_IND
@prindex N_DISCON_IND

This network-provider originated primitive indicates to the NS user that either
a request for connection has been denied or an existing connection has been
disconnected.

@subsubheading Format

The format of the message is one M_PROTO message block, followed by one or
more M_DATA blocks.  The value of the NS user data parameter is identical to the
value in the corresponding N_DISCON_REQ primitive.  The NS user data parameter is
present only if the originator parameter indicates that the release was
initiated by the NS user.

The structure of the M_PROTO message block is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_DISCON_IND */
        ulong DISCON_orig;              /* originator */
        ulong DISCON_reason;            /* reason */
        ulong RES_length;               /* responding address length */
        ulong RES_offset;               /* responding address offset */
        ulong SEQ_number;               /* sequence number */
@} N_discon_ind_t;
@tpindex N_discon_ind_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item DISCON_orig
Indicates the source of the NC release.

@item DISCON_reason
Gives information about the cause of the release.

@item RES_length
Indicates the length of the address of the responding address parameter.  The
responding address parameter is an optional parameter, and is present in the
primitive only in the case where the primitive is used to indicate rejection of
an NC establishment attempt by an NS user.  When not present, the value of this
parameter is zero.  When present, the value of the disconnect address parameter
is identical to that supplied with the corresponding N_DISCON_REQ primitive.

@item RES_offset
Is the offset from the beginning of the M_PROTO message block where the network
address begins.

@item SEQ_number
When its value is non-zero, it identifies the sequence number associated with the
N_CONN_IND that is being aborted.

The value of this parameter must be zero when:

@enumerate a

@item indicating the rejection of a previously issuedN_CONN_REQ primitive; or

@item indicating the release of a NC that is already successfully established.

@end enumerate

When this field is non-zero and its value is the same as the sequence number
assigned to an unacknowledged N_CONN_IND, it indicates that the NS provider is
canceling the unacknowledged N_CONN_IND.

@end vtable

@subsubheading Valid States

The valid states are as follows:

@itemize @bullet
@item NS_WCON_CREQ,
@item NS_WRES_CIND,
@item NS_DATA_XFER,
@item NS_WCON_RREQ, and
@item NS_WRES_RIND.
@end itemize

@subsubheading New State

The new state is NS_IDLE (except when number of outstanding connect indications
is greater than 1, in which case the resulting state is NS_WRES_CIND).

@page
@node CLNS Primitive Format and Rules
@section CLNS Primitive Format and Rules

@menu
* N_UNITDATA_REQ::
* N_UNITDATA_IND::
* N_UDERROR_IND::
@end menu

This section describes the format of the CLNS primitives and the rules
associated with these primitives.  The values of the QOS parameters associated
with each unit data transmission are selected via the N_OPTMGMT_REQ primitive.

@node N_UNITDATA_REQ
@subsection Unitdata Request

@subsubheading N_UNITDATA_REQ
@prindex N_UNITDATA_REQ

This primitive requests that the NS provider send the specified datagram to the
specified destination.

@subsubheading Format

The format of the message is one M_PROTO message block followed by one or
more M_DATA message blocks.

The structure of the M_PROTO is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_UNITDATA_REQ */
        ulong DEST_length;              /* destination address length */
        ulong DEST_offset;              /* destination address offset */
        ulong RESERVED_field[2];        /* reserved field for DLPI
                                           compatibility */
@} N_unitdata_req_t;
@tpindex N_unitdata_req_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item DEST_length
Indicates the length of the destination address.

@item DEST_offset
Indicates the offset of the destination address from the beginning of the M_PROTO message block.

@item RESERVED_field
This is a reserved field (for compatibility with DLPI) whose value must be set
to zero for both entries of the array.

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_IDLE.

@subsubheading New State

The resulting state remains unchanged.

@subsubheading Acknowledgements

@itemize ---

@item Successful:
There is no acknowledgement for the successful completion of this primitive.

@item Non-Fatal Error:
If a non-fatal error occurs, it is the responsibility of the NS provider to
report it via the N_UDERROR_IND primitive.  The following non-fatal error codes
are allowed:

@vtable @asis

@item NBADADDR
The network address as specified in the primitive was in an incorrect format, or
the address contained illegal information.

@item NBADDATA
The amount of user data specified was outside the range supported by the NS
provider.

@item NOUTSTATE
The primitive was issued from an invalid state.

@end vtable

@item Fatal Error:
Fatal errors are indicated via an M_ERROR STREAMS message type (issued to the NS
user with the errno value of EPROTO), which results in the failure of all UNIX
system calls on the stream.  The fatal errors are as follows:

@vtable @asis

@item EPROTO
This indicates one of the following unrecoverable protocol conditions:

@itemize ---

@item The network service interface was found to be in an incorrect state.

@item The amount of NS user data associated with the primitive defines a network
service data unit larger than that allowed by the NS provider.

@end itemize

@end vtable

@end itemize

@page
@node N_UNITDATA_IND
@subsection Unitdata Indication

@subsubheading N_UNITDATA_IND
@prindex N_UNITDATA_IND

This primitive indicates to the NS user that a datagram has been received from
the specified source address.

@subsubheading Format

The format of the message is one M_PROTO message block followed by one or
more M_DATA blocks containing at least one byte of data.  The format of the
M_PROTO is as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_UNITDATA_IND */
        ulong DEST_length;              /* destination address length */
        ulong DEST_offset;              /* destination address offset */
        ulong SRC_length;               /* source address length */
        ulong SRC_offset;               /* source address offset */
        ulong ERROR_type;               /* specifies the reason for the error */
@} N_unitdata_ind_t;
@tpindex N_unitdata_ind_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item DEST_length
Indicates the length of the destination address.  The address is the same as in
the corresponding N_UNITDATA_REQ primitive.

@item DEST_offset
Indicates the offset of the destination address from the beginning of the M_PROTO
message block.

@item SRC_length
Indicates the length of the source network address.  This address is the same as
the value associated with the stream on which the N_UNITDATA_REQ was issued.

@item SRC_offset
Indicates the offset of the source address from the beginning of the M_PROTO
message block.

@item ERROR_type
Specifies the reason for the error.  The possible values are:

@vtable @var

@item N_UD_CONGESTION
This packet experienced congestion during its delivery.

@end vtable

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_IDLE.

@subsubheading New State

The resulting state remains unchanged.

@page
@node N_UDERROR_IND
@subsection Unitdata Error Indication

@subsubheading N_UDERROR_IND
@prindex N_UDERROR_IND

This primitive indicates to the NS user that a datagram with the specified
destination address and QOS parameters has resulted in an error condition.

@subsubheading Format

The format of the message is one M_PROTO message block, and its structure is
as follows:

@smallexample
typedef struct @{
        ulong PRIM_type;                /* always N_UDERROR_IND */
        ulong DEST_length;              /* destination address length */
        ulong DEST_offset;              /* destination address offset */
        ulong RESERVED_field;           /* reserved field for DLPI
                                           compatibility */
        ulong ERROR_type;               /* error type */
@} N_uderror_ind_t;
@tpindex N_uderror_ind_t
@end smallexample

@subsubheading Parameters

@vtable @var

@item PRIM_type
Indicates the primitive type.

@item DEST_length
Indicates the length of the destination address.  The address is the same as in the corresponding N_UNITDATA_REQ
primitive.

@item DEST_offset
Indicates the offset of the destination address from the beginning of the M_PROTO message block.

@item RESERVED_field
This field is reserved whose value must be set to zero.

@item ERROR_type
Specifies the reason for the error.

@end vtable

@subsubheading Valid States

This primitive is valid in state NS_IDLE.

@subsubheading New State

The resulting state remains unchanged.

@node Diagnostics Requirements
@chapter Diagnostics Requirements

Two error handling facilities should be provided to the network service user:
one to handle non-fatal errors, and the other to handle fatal errors.

@section Non-Fatal Error Handling Facility

These are errors that do not change the state of the network service interface
as seen by the network service user, and provide the user the option of reissuing
the network service primitive with the corrected options specification.  The
non-fatal error handling is provided only to those primitives that require
acknowledgements, and uses the N_ERROR_ACK to report these errors.  These errors
retain the state of the network service interface the same as it was before the
network provider received the primitive that was in error.  Syntax errors and
rule violations are reported via the non-fatal error handling facility.

@section Fatal Error Handling Facility

These errors are issued by the NS provider when it detects errors that are not
correctable by the network service user, or if it is unable to report a
correctable error to the network service user.  Fatal errors are indicated via
the STREAMS message type M_ERRORwith the UNIX system error EPROTO.  The M_ERROR
STREAMS message type will result in the failure of all the UNIX system calls on
the stream.  The network service user can recover from a fatal error by having all
the processes close the files associated with the stream, and then reopening
them for processing.

@node References
@chapter References

@enumerate 1

@item CCITT X.213, (Geneva, 1986), ``Network Service Definition for Open Systems
Interconnection (OSI) for CCITT Applications'', (Grey Book)

@item ISO 8348 -- ``Information Processing Systems -- Data Communications --
Network Service Definition'', 4/15/87

@item ISO 8348/AD1 -- ``Information Processing Systems -- Data Communications --
Network Service Definition -- Addendum 1: Connectionless Mode Transmission'',
4/15/87

@item ISO 8473 -- ``Information Processing Systems -- Data Communications
Protocol for Providing the Connectionless Mode Network Service'', SC6 N4542

@item ISO 8208 -- ``Information Processing Systems -- X.25 Packet Level Protocol
for Data Terminal Equipment'', 9/15/87

@item ISO 8878 -- ``Information Processing Systems -- Data Communications -- Use
of X.25 to Provide the OSI Connection-Mode Network Service'', 9/1/87

@item System V Interface Definition, Issue 2 - Volume 3

@item CCITT X.210, (Geneva, 1984), ``Open Systems Interconnection (OSI)
Layer Service Definition Conventions'', (Red Book)

@end enumerate

@node Addendum for OSI Conformance
@chapter Addendum for OSI Conformance

This section describes the formats and rules that are specific to OSI.  The
addendum must be used along with the generic NPI as defined in the main document
when implementing a NS provider that will be configured with the OSI Transport
Layer.

@section Quality of Service: Model & Description
The ``Quality of Service'' characteristics apply to both CONS as well as CLNS.

@subsection QOS Overview
QOS (Quality of Service) is described in terms of QOS parameters.  There are two
types of QOS parameters:

@enumerate 1

@item Those that are ``negotiated'' on a per-connection basis during NC
establishment.(CLNS does not support end-to-end QOS parameter negotiation).

@item Those that are not negotiated and their values are selected/determined by
local management methods.

@end enumerate

Table 8 summarizes the supported parameters both for connection-mode
and connectionless network service.  For more details on the definition of the
QOS parameters, refer to CCITT X.213 [1] and ISO 8348 [2].

@cartouche
@image{npi_tab8} @center @b{Figure 8.  Supported QoS Parameters}
@end cartouche

@subsection QOS Parameter Formats

This section describes the formats of the QOS parameters for CONS and/or
CLNS services.  The requested QOS parameter values apply to complete NSDUs.

@subsubsection NC Establishment Delay

This parameter applies to CONS only.  It is defined as the maximum acceptable
delay between a N_CONN_REQ and the corresponding N_CONN_CON primitive.  NC
establishment delay is measured in milliseconds.

@subsubheading Format: 

@smallexample
long nc_estab_delay; /* maximum NC establishment delay */
@end smallexample

@vtable @var

@item nc_estab_delay
Is the maximum acceptable delay value for NC establishment.

@end vtable

@subsubsection NC Establishment Failure Probability

This parameter applies to CONS only.  NC Establishment Failure Probability is
the percent ratio (rounded to the nearest integer) of total NC establishment
failures to total NC establishment attempts in a measurement sample.  A
measurement sample consists of100 NC establishment attempts.

NC establishment failure occurs due to NS provider behaviour such as
mis-connection, NC refusal, and excessive delay.  NC establishment attempts that
fail due to NS user behaviour such as error, NC refusal, or excessive delay are
excluded in calculating NC establishment failure probability.

@subsubheading Format:

@smallexample
long nc_estab_fail_prob; /* maximum NC estab failure probability */
@end smallexample

@vtable @var

@item nc_estab_fail_prob
Is the maximum acceptable percent value (rounded to the nearest integer) for the
NC establishment failure probability.

@end vtable

@subsubsection Throughput

This parameter applies to CONS only, is specified separately for each direction
of transfer, and has end-to-end significance.  Throughput is defined in terms of
at least two successfully transferred NSDUs presented continuously to the NS
provider at the maximum rate the NS provider can continuously sustain, and
unconstrained by flow control applied by the receiving NS user.  Given a sequence
of ``n'' NSDUs (where is greater than or equal to two; suggested value is 100),
throughput is defined to be the smaller of:

@enumerate a

@item the number of NS user data octets contained in the last ``n-1'' NSDUs
divided bythe time between the first and the last N_DATA_REQs in the sequence;
and

@item the number of NS user data octets contained in the last ``n-1'' NSDUs
divided bythe time between the first and the last N_DATA_INDs in the sequence.

@end enumerate

Throughput should be measured and specified in bits per second.

@subsubheading Format:

@smallexample
typedef struct @{
        long thru_targ_value;
        long thru_min_value;
@} thru_values_t;
@tpindex thru_values_t
@end smallexample

@vtable @var

@item thru_targ_value
Specifies the requested QOS value for throughput for data transfer between the
two NS users.

@item thru_min_value
Specifies the requested lowest acceptable QOS value for throughput between the
two NS users.

@end vtable

@subsubsection Transit Delay

This parameter applies to CONS as well as CLNS.  Transit Delay is the elapsed
time between a N_DATA_REQ and the corresponding N_DATA_IND (calculated on
successfully transferred NSDUs only).  The pair of values specified for an NC
applies to both directions of transfer.  The specified values are averages (based
on 100 samples using a NSDU size of 128 bytes).  Transit Delay should be measured
in milliseconds.

@subsubheading Format:

@smallexample
typedef struct @{
        long td_targ_value;
        long td_max_value;
@} td_values_t;
@tpindex td_values_t
@end smallexample

@vtable @var

@item td_targ_value
Specifies the desired QOS value for transit delay between the two NS users.

@item td_max_value
Specifies the maximum QOS value that the source NS user will agree for transit
delay between the two NS users.

@end vtable

@subsubsection Residual Error Rate

This parameter applies to both CONS as well as CLNS.  Residual Error Rate is
the percent ratio (rounded to the nearest integer) of total incorrect, lost, and
duplicate NSDUs to total NSDUs transferred across the NS boundary during a
measurement period.  The measurement period will be 3600 seconds.

@subsubheading Format:

@smallexample
long residual_error_rate; /* maximum acceptable residual error rate */
@end smallexample

@vtable @var

@item residual_error_rate
Specifies the maximum acceptable percent value (rounded to the nearest integer)
of the residual error rate.

@end vtable

@subsubsection NC Resilience

This parameter applies to CONS only.  NC Resilience specifies the percent
probability (rounded to the nearest integer) of a NS provider invoked NC release
or a NS provider invoked reset during a specified time interval on an
established NC.  The time interval will be 3600 seconds.

@subsubheading Format:

@smallexample
long nc_resilience; /* maximum acceptable nc resilience */
@end smallexample

@vtable @var

@item nc_resilience
Specifies the maximum acceptable value for NC resilience.

@end vtable

@subsubsection Transfer Failure Probability

This parameter applies to CONS only.  It is the percent ratio (rounded to the
nearest integer) of total transfer failures to total transfer samples observed
during a performance measurement.  A transfer sample is a discrete observation of
NS provider performance in transferring NSDUs between specified sending and
receiving NS user.  A transfer sample will last for the duration of the NC.  A
transfer failure is a transfer sample in which the observed performance is worse
than the specified minimum acceptable level.  A transfer failure is identified by
comparing the measured values for the supported performance parameters with
specified transfer failure thresholds.  The three supported performance
parameters are throughput, transit delay, and residual error rate.

@subsubheading Format:

@smallexample
long xfer_fail_prob; /* maximum xfer failure prob */
@end smallexample

@vtable @var

@item xfer_fail_prob
Specifies the maximum acceptable percent value (rounded to the nearest integer)
for transfer failure probability.

@end vtable

@subsubsection NC Release Delay

This parameter applies to CONS only.  NC Release Delay is defined as the
maximum acceptable delay between a NS user invoked N_DISCON_REQ and the
successful release of the NC at the peer NS user.  NC Release Delay is specified
independently for each NS user.  It does not apply in cases where NC release is
invoked by the NS provider.  NC release delay should be measured in milliseconds.

@subsubheading Format:

@smallexample
long nc_rel_delay; /* maximum nc release delay */
@end smallexample

@vtable @var

@item nc_rel_delay
Is the maximum acceptable value for NC release delay.

@end vtable

@subsubsection NC Release Failure Probability

This parameter applies to CONS only.  It is the percent ratio (rounded to the
nearest integer) of total NC release requests resulting in release failure to
total NC release requests included in a measurement sample.  A measurement sample
consists of a 100NC release requests.  This parameter is specified independently
for each NS user.

A release failure is defined to occur for a particular NS user, if that user
does not receive a N_DISCON_IND within a specified maximum NC release delay of
the NS user issuing the N_DISCON_REQ (given that the former NS user has not
issued aN_DISCON_REQ).

@subsubheading Format:

@smallexample
long nc_rel_fail_prob; /* maximum nc rel fail probability */
@end smallexample

@vtable @var

@item nc_rel_fail_prob
Is the maximum acceptable percent value (rounded to the nearest integer) of NC
release failure probability.

@end vtable

@subsubsection Protection

This parameter applies to both CONS and CLNS.  It specifies the extent to which
the NS provider attempts to prevent unauthorized monitoring or manipulation of NS
user originated information.

@smallexample
/* Types of protection */
#define N_NO_PROT               0x00000000L     /* no protection */
#define N_PASSIVE_PROT          0x00000001L     /* protection against passive
                                                   monitoring */
#define N_ACTIVE_PROT           0x00000002L     /* protection against active
                                                   monitoring */
#define N_ACTIVE_PASSIVE_PROT   0x00000003L     /* maximum protection */
@end smallexample

Four protection options are provided:

@enumerate 1

@item No protection features;

@item Protection against passive monitoring;

@item Protection against modification, replay, addition, or deletion

@item Both 2 and 3.

@end enumerate

@subsubheading Format:

@smallexample
typedef struct @{
        long protect_targ_value;        /* target protection */
        long protect_min_value;         /* minimum protection */
@} protection_values_t;
@tpindex protection_values_t
@end smallexample

@vtable @var

@item protect_targ_value
Specifies the target protection of the NS user originated information.

@item protect_min_value
Specifies the lowest quality acceptable of protection of the NS user originated
information.

@end vtable

@subsubsection Priority

This parameter applies to both CONS and CLNS.

It specifies the target priority of:

@enumerate a

@item an NSDU in relation to any other NSDUs (for CLNS);

@item a NC (for CONS).  The number of priority levels is limited to 15 (where
level 1 is the highest priority and level 15 is the lowest priority).

@end enumerate

@subsubheading Format:

@smallexample
typedef struct @{
        long priority_targ_value;       /* target priority */
        long priority_min_value;        /* minimum priority */
@} priority_values_t;
@tpindex priority_values_t
@end smallexample

@vtable @var

@item priority_targ_value
Specifies the target NC priority level.

@item priority_min_value
Specifies the lowest quality acceptable of the NC priority level.

@end vtable

@subsubsection Maximum Acceptable Cost

This parameter applies to both CONS and CLNS.  It specifies the maximum
acceptable cost in local currency (composed of communications and end-system
resource costs), or indicates to the NS provider that it should choose the least
expensive means available to it.

@subsubheading Format

@smallexample
long max_accept_cost;                   /* acceptable cost maximum */

/* Choose least expensive means */
#define N_LEAST_EXPENSIVE 0x00000000L   /* choose least expensive means */
@end smallexample

@vtable @var

@item max_accept_cost
Specifies the maximum acceptable cost in local currency.

@end vtable

@subsection QOS Data Structures

The quality of services parameters are organized into six different structures
for simplicity:

@vtable @var

@item N_QOS_CO_RANGE1

Quality of service range requested for connection-mode service as used with the
N_CONN_REQ and N_CONN_IND primitives.

@item N_QOS_CO_SEL1

Quality of service values selected for the connection-mode service as used with
the N_CONN_RES and N_CONN_CON primitives.

@item N_QOS_CL_RANGE1

Range of quality of service values for connectionless-mode service as
specified with the QOS_@-range_@-length and QOS_@-range_@-offset parameters of
the N_@-INFO_@-ACK primitive.

@item N_QOS_CL_SEL1

Quality of service values supported/selected for connectionless-mode service as
specified with the QOS_length and QOS_offset parameters of the N_INFO_ACK and
the N_OPTMGMT_REQ primitives.

@item N_QOS_CO_OPT_RANGE1

Range of quality of service values for connection-mode service as specified with
the QOS_range_length and QOS_range_offset parameters of the N_INFO_ACK
primitive.

@item N_QOS_CO_OPT_SEL1

Default quality of service values supported/selected for connection-mode service
as specified with the QOS_length and QOS_offset parameters of the N_INFO_ACK and
the N_OPTMGMT_REQ primitives.

@end vtable

@subsubsection Structure N_QOS_CO_RANGE1
@vrindex N_QOS_CO_RANGE1

Structure N_qos_co_range1 defines the QOS parameters that are transferred
between the source and destination NS users for a NC.  The format of this
structure is as follows:

@smallexample
typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CO_RANGE */
        thru_values_t src_throughput_range;     /* source throughput range */
        thru_values_t dest_throughput_range;    /* dest throughput range */
        td_values_t transit_delay_range;        /* transit delay range */
        protection_values_t protection_range;   /* protection range */
        priority_values_t priority_range;       /* priority target */
@} N_qos_co_range1_t;
@tpindex N_qos_co_range1_t
@end smallexample

This structure should be used in the QOS_length and QOS_offset fields of the
following NPI primitives:

@itemize @bullet

@item N_CONN_REQ

@item N_CONN_IND

@end itemize

@subsubsection Structure N_QOS_CO_SEL1
@vrindex N_QOS_CO_SEL1

Structure N_qos_co_sel1 defines the QOS parameters that are transferred between
the destination and source NS users for a NC.  The format of this structure is as
follows:

@smallexample
typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CO_SEL */
        long src_throughput_sel;        /* source throughput selected */
        long dest_throughput_sel;       /* destination throughput selected */
        long transit_delay_sel;         /* transit delay selected */
        long protection_sel;            /* NC protection selected */
        long priority_sel;              /* NC priority selected */
@} N_qos_co_sel1_t;
@tpindex N_qos_co_sel1_t
@end smallexample

This structure should be used in the QOS_length and QOS_offset fields of the
following NPI primitives:

@itemize @bullet

@item N_CONN_RES

@item N_CONN_CON

@end itemize

@subsubsection Structure N_QOS_CL_RANGE1
@vrindex N_QOS_CL_RANGE1

Structure N_qos_cl_range1 defines the range of QOS parameter values that
are supported by the NS provider.  The format of the structure is as follows:

@smallexample
typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CL_RANGE */
        td_values_t transit_delay_max;  /* maximum transit delay */
        long residual_error_rate;       /* residual error rate */
        protection_values_t protection_range;   /* target protection */
        priority_values_t priority_range;       /* target priority */
        long max_accept_cost;           /* maximum acceptable cost */
@} N_qos_cl_range1_t;
@tpindex N_qos_cl_range1_t
@end smallexample

This structure should be used in the:

@itemize @bullet

@item QOS_range_length and QOS_range_offset fields of the N_INFO_ACK primitive;

@end itemize

@subsubsection Structure N_QOS_CL_SEL1
@vrindex N_QOS_CL_SEL1

Structure N_qos_cl_sel1 defines the QOS parameters values that will apply to
each unitdata transmission between the CLNS users.  The format of the structure
is as follows:

@smallexample
typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CL_sel */
        long transit_delay_max;         /* maximum transit delay */
        long residual_error_rate;       /* residual error rate */
        long protection_sel;            /* protection selected */
        long priority_sel;              /* priority selected */
        long max_accept_cost;           /* maximum acceptable cost */
@} N_qos_cl_sel1_t;
@tpindex N_qos_cl_sel1_t
@end smallexample

This structure should be used in the:

@itemize @bullet

@item QOS_length and QOS_offset fields of the N_INFO_ACK primitive;

@item QOS_length and QOS_offset fields of the N_OPTMGMT_REQ primitive.

@end itemize

@subsubsection Structure N_QOS_CO_OPT_RANGE1
@vrindex N_QOS_CO_OPT_RANGE1

Structure N_qos_opt_range1 defines the range of the default QOS parameter values
that are supported by the NS provider.  This allows the NS user to select values
within the range supported by the NS provider.  The format of the structure is as
follows:

@smallexample
typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CO_OPT_RANGE */
        thru_values_t src_throughput;   /* source throughput values */
        thru_values_t dest_throughput;  /* dest throughput values */
        td_values_t transit_delay;      /* transit delay values */
        long nc_estab_delay;            /* NC establishment delay */
        long nc_estab_fail_prob;        /* NC estab failure probability */
        long residual_error_rate;       /* residual error rate */
        long xfer_fail_prob;            /* transfer failure probability */
        long nc_resilience;             /* NC resilience */
        long nc_rel_delay;              /* NC release delay */
        long nc_rel_fail_prob;          /* NC release fail probability */
        protection_values_t protection_range;   /* protection range */
        priority_values_t priority_range;       /* priority range */
        long max_accept_cost;           /* maximum acceptable cost */
@} N_qos_co_opt_range1_t;
@tpindex N_qos_co_opt_range1_t
@end smallexample

This structure should be used in the:

@itemize @bullet

@item QOS_range_length and QOS_range_offset fields of the N_INFO_ACK primitive;

@end itemize

@subsubsection Structure N_QOS_CO_OPT_SEL1
@vrindex N_QOS_CO_OPT_SEL1

Structure N_qos_opt_sel1 defines the selected QOS parameter values.  The format
of the structure is as follows:

@smallexample
typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CO_OPT_SEL */
        thru_values_t src_throughput;   /* source throughput values */
        thru_values_t dest_throughput;  /* dest throughput values */
        td_values_t transit_delay;      /* transit delay values */
        long nc_estab_delay;            /* NC establishment delay */
        long nc_estab_fail_prob;        /* NC estab failure probability */
        long residual_error_rate;       /* residual error rate */
        long xfer_fail_prob;            /* transfer failure probability */
        long nc_resilience;             /* NC resilience */
        long nc_rel_delay;              /* NC release delay */
        long nc_rel_fail_prob;          /* NC release failure probability */
        long protection_sel;            /* protection selected */
        long priority_sel;              /* priority selected */
        long max_accept_cost;           /* maximum acceptable cost */
@} N_qos_co_opt_sel1_t;
@tpindex N_qos_co_opt_sel1_t;
@end smallexample

This structure should be used in the:

@itemize @bullet

@item QOS_length and QOS_offset fields of the N_INFO_ACK primitive;

@item QOS_length and QOS_offset fields of the N_OPTMGMT_REQ primitive.

@end itemize

@page
@section NPI Primitives Rules for OSI Conformance

The following are the rules that apply to the NPI primitives for OSI
compatibility.

@subsection Local Management Primitives

@subsubsection N_INFO_ACK
@prindex N_INFO_ACK

@subsubheading Parameters

@vtable @var

@item NSDU_size
A value greater than zero specifies the maximum size of a Network Service Data
Unit (NSDU); a value of 0 specifies that the transfer of normal data is not
supported by the NS provider,and a value of -1 specifies that there is no limit
on the size of a NSDU.

@item ENSDU_size
A value between 1 and 32 inclusive specifies the maximum size of an Expedited
Network Service Data Unit (ENSDU); a value of 0 specifies that the transfer of
expedited data is not supported by the NS provider.

@item CDATA_size
A value between 1 and 128 inclusive specifies the maximum number of octets of
data that may be associated with connection establishment primitives.  A value of
0 specifies that the NS provider does not allow data to be sent with connection
establishment primitives.  When used in an OSI conforming environment, CDATA_size
shall always equal 128.

@item DDATA_size
A value between 1 and 128 inclusive specifies the maximum number of octets of
data that may be associated with the disconnect primitives; a value of 0
specifies that the NS provider does not allow data to be sent with the
disconnect primitives.  When used in an OSI conforming environment, DDATA_size
shall always equal 128.

@item ADDR_size
A value between 1 and 40 indicates the maximum size of a network address in
decimal digits.  When used in an OSI conforming environment, ADDR_size
shall always equal 40 in order to accommodate a full NSAP address.

@item QOS_length
Indicates the length in bytes of the default/negotiated/selected values of the
QOS parameters.  The applicable QOS parameters are defined in the following
structures:

@enumerate a

@item N_QOS_CO_OPT_SEL1 for CONS; and

@item N_QOS_CL_SEL1 for CLNS.

@end enumerate

In the connection-mode environment, when this primitive is invoked before the NC
is established on the stream, the values returned specify the the default values
supported by the NS provider.  When this primitive is invoked after a NC has been
established on the stream, the values returned indicate the negotiated values
for the QOS parameters.  In the connectionless environment, these values
represent the default or the selected QOS parameter values.

In case a QOS parameter is not supported by the NS Provider, a value of
QOS_UNKNOWN will be returned.  In the case where no QOS parameters are supported
by the NS provider, the length of this field will be zero.

@item QOS_range_length
Indicates the length in bytes, of the available range of QOS parameters values
supported by the NS provider.  These ranges are used by the NS user to select QOS
parameter values that are valid with the NS provider.

The applicable QOS parameters are defined in the following structures:

@enumerate a

@item N_QOS_CO_OPT_RANGE1 for CONS; and

@item N_QOS_CL_RANGE1 for CLNS.

@end enumerate

QOS parameter values are selected, or the default values altered via the
N_OPTMGMT_REQ primitive.  In the connection-mode environment, the values for
end-to-end QOS parameters may be specified with the N_CONN primitives for
negotiation.  If the NS provider does not support a certain QOS parameter, its
value will be set to QOS_UNKNOWN.  In the case where no QOS parameters are
supported by the NS provider, the length of this field will be zero.

@item NIDU_size
This indicates the amount of user data that may be present in aN_DATA primitive.
The NIDU_size should not be larger than the NSDU_size specification.

@item SERV_type
Specifies the service type supported by the NS provider.  The possible values can
be N_CONS, N_CLNS, (or both by using N_CONS|N_CLNS).  If the SERV_type is N_CLNS,
the following rules will apply:

@itemize ---

@item The ENSDU_size, CDATA_size, DDATA_size, and DEFAULT_rc_sel fields are not
used and their values should be set to 0;

@item The NSDU_size should be the same as the NIDU_size.

@end itemize

@item NODU_size
The NODU_size specifies the optimal NSDU size in octets of an NSDU given the
current routing information.

@item PROTOID_length
The length of the protocol identifiers to be bound.

@item PROTOID_offset
The offset of the protocol identifiers to be bound, from the beginning of the
block.

@end vtable

@subsubsection N_OPTMGMT_REQ
@prindex N_OPTMGMT_REQ

@subsubheading Parameters

@vtable @var

@item QOS_length
Indicates the length of the default values of the QOS parameters as selected by
the NS user.  In the connection-mode environment these values will be used in
subsequent N_CONN_REQ primitives on the stream that do not specify values for
these QOS parameters.  In the connection-less environment, these values represent
the selected QOS values that would apply to each unit data transmission.  The
applicable QOS parameters are defined in the following structures:

@enumerate a

@item N_QOS_CO_OPT_SEL1 for CONS; and

@item N_QOS_CL_SEL1 for CLNS.

@end enumerate

If the NS user cannot determine the value of a QOS parameter,its value should be
set to QOS_UNKNOWN.  If the NS user does not specify any QOS parameter values,
the length of this field should be set to zero.

@end vtable

@subsection CONS Connection Establishment Phase Rules for QOS Parameter Negotiation

The negotiation for NC throughput and NC transit-delay QOS parameters
are conducted as follows:

@enumerate a

@item in the N_CONN_REQ primitive, the source NS user specifies two values
for each negotiable QOS parameter:

@enumerate 1

@item a ``target'' which is the QOS value desired; and

@item a ``lowest acceptable'' QOS value to which the source NS user will agree;

@end enumerate

The value of each of these parameters must be within the limit of the allowable
values defined for the network service.  ``Default'' values for these parameters
are supported by the NS provider.  The default values may be selected by the NS
user via the N_OPTMGMT_REQ primitive.

@item if the NS provider agrees to provide a value of QOS which is in the
range between the ``target'' and the ``lowest acceptable'' QOS values, inclusive,
of the N_CONN_REQ, then the NS provider specifies two parameters in
the N_CONN_IND issued to the destination NS user:

@enumerate 1

@item an ``available'' value which is the QOS value the NS provider is willing
to provide; and

@item a ``lowest acceptable'' QOS value which is identical to the
``lowest acceptable'' value specified in the N_CONN_REQ; (if the NS provider
does not agree to provide QOS in the given range, then the NC establishment
request is rejected);

@end enumerate

@item if the destination NS user agrees to a QOS value which is in the range
between the ``available'' and the ``lowest acceptable'' QOS values, inclusive,
of the N_CONN_IND, then the destination NS user specifies a single parameter,
``selected'' in the N_CONN_RES; this parameter is the QOS value the destination
NS user agrees to; (if the destination NS user does not agree to a QOS in the
given range, then the NC establishment request is rejected);

@item the NS provider adopts the QOS value for the NC which was specified by
the destination NS user and supplies this as a single parameter, ``selected'', in
the N_CONN_CON primitive.

@end enumerate

@itemize @bullet

@item The negotiation for the NC protection parameter is conducted as follows:

@enumerate a

@item In the N_CONN_REQ primitive, the calling NS user specifies values for
the ``Target'' and ``Lowest Quality Acceptable'' sub-parameters; permitted value
assignments are:

@table @asis

@item Case1:
both the ``Target'' and ``Lowest Quality Acceptable'' are ``unspecified'';

@item Case2:
values other than ``unspecified'' are specified for both ``Target'' and ``Lowest
Quality Acceptable'';

@item Case3:
a value other than ``unspecified'' is specified for ``Target'' and the ``Lowest
Quality Acceptable'' is ``unspecified''.

@end table

NOTE: In case where ``Target'' is ``unspecified'', the ``Lowest Quality
Acceptable'' must also be ``unspecified''.

@item If the NS provider does not support a choice of NC protection levels, the
value of the ``Target'' parameter is conveyed by the NS provider and passed to
the called NS user unchanged as the ``Available'' sub-parameter in the N_CONN_IND
primitive;

@item If the NS provider does support a choice of NC protection levels, then:

@enumerate 1

@item In Case1, the NS provider determines the QOS value to be offered on the NC
and specifies it in the ``Available'' sub-parameter in the N_CONN_IND primitive;

@item In Case2 and Case3, if the NS provider does not agree to provide a QOS in
the requested range, then the NC establishment attempt is rejected as described
in clause 13.5 of ISO 8348.  If the NS provider does agree to provide a QOS in
the requested range, then in the N_CONN_IND primitive, the ``Available''
sub-parameter specifies the highest QOS value within the range which the NS
provider is willing to provide.

@end enumerate

@item The value of the ``Lowest Quality Acceptable'' sub-parameter in
the N_CONN_IND primitive is identical to that in the N_CONN_REQ primitive;

@item If the value of the ``Available'' sub-parameter of the N_CONN_IND primitive
is ``unspecified'' then:

@enumerate 1

@item if the called NS user does not agree to accept establishment of a NC
with this unspecified quality, the NS user rejects the NC establishment attempt
as described in clause 13.4 of ISO 8348;

@item if the called NS user does agree, then the NS user specifies the
value ``unspecified'' in the ``Selected'' sub-parameter of the N_CONN_RES
primitive.

@end enumerate

@item If the value of the ``Available'' sub-parameter in the N_CONN_IND primitive
is not ``unspecified'' then:

@enumerate 1

@item if the called NS user does not agree to a QOS in the range identified
by the ``Available'' and ``Lowest Quality Acceptable'' sub-parameters of the
N_CONN_IND primitive, then the NS user rejects the NC establishment attempt as
described in clause 13.4 of ISO 8348;

@item if the called NS user does agree to a QOS in the identified range, then
the NS user specifies the agreed value in the ``Selected'' sub-parameter of the
N_CONN_RES primitive.

@end enumerate

@item In the N_CONN_CON primitive, the ``Selected'' sub-parameter has a
value identical to that of ``Selected'' in the N_CONN_RES primitive.

@end enumerate

@item The negotiation of the NC priority parameter is conducted as follows:

@enumerate a

@item In the N_CONN_REQ primitive, the calling NS user specifies values for
the ``Target'' and ``Lowest Quality Acceptable'' sub-parameters; permitted value
assignments are:

@table @asis

@item Case1:
both the ``Target'' and ``Lowest Quality Acceptable'' are ``unspecified'';

@item Case2:
values other than ``unspecified'' are specified for both ``Target'' and ``Lowest
Quality Acceptable'';

@item Case3:
a value other than ``unspecified'' is specified for ``Target'' and the ``Lowest
Quality Acceptable'' is ``unspecified''.

@end table

NOTE: In case where ``Target'' is ``unspecified'', the ``Lowest Quality
Acceptable'' must also be ``unspecified''.

@item If the NS provider does not support a choice of NC priority levels, the
value of the ``Target'' parameter is conveyed by the NS provider and passed to
the called NS user unchanged as the ``Available'' sub-parameter in the
N_CONN_IND primitive;

@item If the NS provider does support a choice of NC priority levels, then:

@enumerate 1

@item In Case1, the NS provider determines the QOS value to be offered on the NC and
specifies it in the ``Available'' sub-parameter in the N_CONN_IND primitive;

@item In Case2 and Case3, if the NS provider does not agree to provide a QOS in the
requested range, then the NC establishment attempt is rejected as described in
clause 13.5 of ISO 8348.  If the NS provider does agree to provide a QOS in the
requested range, then in the N_CONN_IND primitive, the ``Available''
sub-parameter specifies the highest QOS value within the range which the NS
provider is willing to provide.

@end enumerate

@item The value of the ``Lowest Quality Acceptable'' sub-parameter in
the N_CONN_IND primitive is identical to that in the N_CONN_REQ primitive;

@item If the value of the ``Available'' sub-parameter of the N_CONN_IND primitive
is ``unspecified'' then:

@enumerate 1

@item if the called NS user does not agree to accept establishment of a NC with this
unspecified quality, the NS user rejects the NC establishment attempt as
described in clause 13.4 of ISO 8348;

@item if the called NS user does agree, then the NS user specifies the
value ``unspecified'' in the ``Selected'' sub-parameter of the N_CONN_RES
primitive.

@end enumerate

@item If the value of the ``Available'' sub-parameter in the N_CONN_IND primitive
is not ``unspecified'' then:

@enumerate 1

@item if the called NS user does not agree to a QOS in the range identified by
the ``Available'' and ``Lowest Quality Acceptable'' sub-parameters of the
N_CONN_IND primitive, then the NS user rejects the NC establishment attempt as
described in clause 13.4 of ISO 8348;

@item if the called NS user does agree to a QOS in the identified range, then
the NS user specifies the agreed value in the ``Selected'' sub-parameter of the
N_CONN_RES primitive.

@end enumerate

@item In the N_CONN_CON primitive, the ``Selected'' sub-parameter has a
value identical to that of ``Selected'' in the N_CONN_RES primitive.

@end enumerate

@end itemize

@subsubheading Rules for QOS Parameter Selection

When a NS user/provider cannot determine the value of a QOS field, it should
return a value of QOS_UNKNOWN.

@smallexample
#define QOS_UNKNOWN -1
@end smallexample

@subsubheading Rules for Receipt Confirmation Selection

@itemize @bullet

@item The receipt confirmation selection parameter values on the various
primitives are related such that:

@enumerate 1

@item on the N_CONN_REQ, either of the defined values may occur (namely, ``use of
receipt confirmation'', or ``no use of receipt confirmation'').

@item on the N_CONN_IND, the value is either equal to the value on the
request primitive, or is ``no use of receipt confirmation''.

@item on the N_CONN_RES, the value is either equal to the value on the indication
primitive or is ``no use of receipt confirmation''.

@item on the N_CONN_CON, the value is equal to the value on the response primitive.

@end enumerate

@item Since the NS users and the NS provider must agree to the use of receipt
confirmation selection, there are four possible cases of negotiation of receipt
confirmation on an NC:

@enumerate 1

@item if the source NS user does not request it --- it is not used;

@item if the source NS user requests it but the NS provider does not provide it ---
it is not used;

@item if the source NS user requests it and the NS provider agrees to provide
it,but the destination NS user does not agree to its use -- it is not used;

@item if the source NS user requests it, the NS provider agrees to provide it,
and the destination NS user agrees to its use -- it can be used.  Rules for
Expedited Data Selection

@end enumerate

@item The expedited data selection parameter values on the various primitives
are related such that:

@enumerate 1

@item on the N_CONN_REQ, either of the defined values may occur, (namely ``use of
expedited data'' or ``no use of expedited data'');

@item on the N_CONN_IND, the value is either equal to the value on the
request primitive, or is ``no use of expedited data'';

@item on the N_CONN_RES, the value is either equal to the value on the
indication primitive, or is ``no use of expedited data'';

@item on the N_CONN_CON, the value is equal to the value on the response
primitive.

@end enumerate

@item Since the NS users and the NS provider must agree to the use of expedited
data selection, there are four possible cases of negotiation of expedited data on
an NC:

@enumerate 1

@item if the source NS user does not request it --- it is not used;

@item if the source NS user requests it but the NS provider does not provide it
--- it is not used;

@item if the source NS user requests it and the NS provider agrees to provide
it, but the destination NS user does not agree to its use --- it is not used;

@item if the source NS user requests it, the NS provider agrees to provide it,
and the destination NS user agrees to its use --- it can be used.

@end enumerate

@end itemize

@subsubsection N_CONN_REQ
@prindex N_CONN_REQ

@subsubheading Parameters

@vtable @var

@item QOS_length
Indicates the length of the QOS parameters values that apply to the NC being requested.

The applicable QOS parameters are defined in the following structure:

@enumerate a

@item N_QOS_CO_RANGE1

@end enumerate

If the NS user cannot determine the value of a QOS parameter, its value should
be set to QOS_UNKNOWN.  If the NS user does not specify any QOS parameter values,
the length of this field should be set to zero.

@end vtable

@subsubheading Flags

@vtable @var

@item REC_CONF_OPT
The receipt confirmation selection parameter indicates whether receipt
confirmation service is desired by the calling NS user on the NC.  The receipt
confirmation service must be provided in the network service to be used on the
NC.  When set, it indicates ``use of receipt confirmation'', and when not set it
indicates ``no use of receipt confirmation''.

@item EX_DATA_OPT
The expedited data selection parameter indicates whether the expedited data
service is desired by the calling NS user on the NC.  The expedited data transfer
service must be provided by the NS provider for it to be used on the NC.  When
set, it indicates ``use of expedited data'', and when not set it indicates ``no
use of expedited data''.

@end vtable

@subsubsection N_CONN_IND
@prindex N_CONN_IND

@subsubheading Parameters

@vtable @var

@item QOS_length
Indicates the length of the QOS parameters values that are negotiated during NC
establishment.

The applicable QOS parameters are defined in the following structure:

@enumerate a

@item N_QOS_CO_RANGE1

@end enumerate

If the NS provider does not support or cannot determine the value of a QOS
parameter, its value will be set to QOS_UNKNOWN.  If the NS provider does not
specify any QOS parameter values, the length of this field should be set to
zero.

@item QOS_offset
Indicates the offset of the QOS parameters from the beginning of the M_PROTO
message block.

@end vtable

@subsubheading Flags

@vtable @var

@item REC_CONF_OPT
The receipt confirmation selection parameter indicates whether the receipt
confirmation service is available on the NC and the calling NS user desires its
use.  The receipt confirmation service must be provided in the network service to
be used on the NC.  When set, it indicates ``use of receipt confirmation'', and
when not set, it indicates ``no use of receipt confirmation''.  The value on the
N_CONN_IND is either equal to the value on the request primitive or is ``no use
of receipt confirmation''.

@item EX_DATA_OPT
The expedited data selection parameter indicates whether the expedited data
transfer service is available on the NC and the calling NS user desires its use.
The expedited data transfer service must be provided by the NS provider for it
to be used on the NC.  When set, it indicates ``use of expedited data'' or ``no
use of expedited data''.  The value on the N_CONN_IND is either equal to the value
on the request primitive or is ``no use of expedited data''.

@end vtable

@subsubsection N_CONN_RES
@prindex N_CONN_RES

@subsubheading Parameters

@vtable @var

@item QOS_length
Indicates the length of the QOS parameters values that are negotiated during NC
establishment.  The applicable QOS parameters are defined in the following
structure:

@enumerate a

@item N_QOS_CO_SEL1

@end enumerate

If the NS user does not agree to the QOS values, it will reject the NC
establishment by invoking a N_DISCON_REQ primitive (the originator parameter in
the N_DISCON_REQ primitive will indicate NS user invoked release).  If the NS user
cannot determine the value of a QOS parameter, its value should be set to
QOS_UNKNOWN.  If the NS user does not specify any QOS parameter values, the
length of this field should be set to zero.

@end vtable

@subsubheading Flags

@vtable @var

@item REC_CONF_OPT
The receipt confirmation selection parameter indicates whether the receipt
confirmation service can be used on the NC.  The receipt confirmation service
must be provided in the network service to be used on the NC.  When set, it
indicates ``use of receipt confirmation'', and when not set it indicates ``no
use of receipt confirmation''.  The value on the N_CONN_RES is either equal to
the value on the indication primitive or is ``no use of receipt confirmation''.

@item EX_DATA_OPT
The expedited data selection parameter indicates whether the expedited data
transfer service can be used on the NC.  The expedited data transfer service must
be provided by the NS provider for it to be used on the NC.  When set, it
indicates ``use of expedited data'', and when not set, it indicates ``no use of
expedited data''.  The value on the N_CONN_RES is either equal to the value on the
indication primitive or is ``no use of expedited data''.

@end vtable

@subsubsection N_CONN_CON
@prindex N_CONN_CON

@subsubheading Parameters

@vtable @var

@item QOS_length
Indicates the length of the QOS parameters values selected by the responding NS
user.  The applicable QOS parameters are defined in the following structure:

@enumerate a

@item N_QOS_CO_SEL1

@end enumerate

If the NS provider does not support or cannot determine the selected value of a
QOS parameter, its value will be set to QOS_UNKNOWN.  If the NS provider does not
specify any QOS parameter values, the length of this field should be set to
zero.

@end vtable

@subsubheading Flags

@vtable @var

@item REC_CONF_OPT
The receipt confirmation selection parameter indicates whether the receipt
confirmation service can be used on the NC.  The receipt confirmation service
must be provided in the network service to be used on the NC.  When set, it
indicates ``use of receipt confirmation'', and when not set it indicates ``no
use of receipt confirmation''.  The value on the N_CONN_CON is equal to the value
on the response primitive.

@item EX_DATA_OPT
The expedited data selection parameter indicates whether the expedited data
transfer service can be used on the NC.  The expedited data transfer service must
be provided by the NS provider for it to be used on the NC.  When set, it
indicates ``use of expedited data'', and when not set, it indicates ``no use of
expedited data''.  The value on the N_CONN_CON is equal to the value on the
response primitive.

@end vtable

@subsection CONS Reset Service

@subsubsection N_RESET_REQ
@prindex N_RESET_REQ

@subsubheading Parameters

@vtable @var

@item RESET_reason

Gives information indicating the cause of the reset.  Rules governing the value
of the RESET_reason parameter For an N_RESET_REQ, the reason shall always
indicate N_USER_RESYNC.

@end vtable

@subsubsection N_RESET_IND
@prindex N_RESET_IND

@subsubheading Parameters

@vtable @var

@item RESET_orig
This parameter indicates the source of the reset.

Reset Originator

@vtable @var

@item N_PROVIDER
NS provider originated reset

@item N_USER
NS user originated reset

@item N_UNDEFINED
reset originator undefined

@end vtable

@item RESET_reason
Gives information indicating the cause of the reset.

@end vtable

@subsubheading Rules governing the value of the RESET_reason parameter

The value conveyed in this parameter will be as follows:

@enumerate a

@item when the originator parameter indicates an NS provider invoked reset;
the parameter is one of:

@vtable @var

@item N_CONGESTION
reset due to congestion;

@item N_RESET_UNSPECIFIED
reset-reason unspecified.

@end vtable

@item when the originator parameter indicates an NS user invoked reset, the value is:

@vtable @var

@item N_USER_RESYNC
user resynchronization.

@end vtable

@item when the originator parameter has the value ``undefined'', then the value of the reason parameter is:

@vtable @var

@item N_REASON_UNDEFINED
reset reason undefined

@end vtable

@end enumerate

@subsection CONS NC Release Phase

@subsubsection N_DISCON_REQ
@prindex N_DISCON_REQ

@subsubheading Parameters:

@vtable @var

@item DISCON_reason
Gives information about the cause of the release.

@end vtable

@subsubheading Rules governing the value of the DISCON_reason parameter

The value conveyed in the parameter will be as follows:

@vtable @var

@item N_DISC_NORMAL
``disconnection-normal condition''

@item N_DISC_ABNORMAL
``disconnection-abnormal condition''

@item N_REJ_P
``connection rejection-permanent condition''

@item N_REJ_T
``connection rejection-transient condition''

@item N_REJ_QOS_UNAVAIL_P
``connection rejection-QOS not available/permanent condition''

@item N_REJ_QOS_UNAVAIL_T
``connection rejection-QOS not available/transient condition''

@item N_REJ_INCOMPAT_INFO
``connection rejection-incompatible information in NS user data''

@item N_REJ_UNSPECIFIED
``connection rejection-reason unspecified''

@end vtable

@subsubsection N_DISCON_IND
@prindex N_DISCON_IND

@subsubheading Parameters

@vtable @var

@item DISCON_orig
Indicates the source of the NC release.  Its value are as follows:

@vtable @var

@item N_PROVIDER
NS provider originated disconnect N_USER: NS user originated disconnect

@item N_UNDEFINED
disconnect originator undefined

@end vtable

The value ``undefined'' is not permitted when an N_DISCON_IND is issued by an NS
user or the NS provider in order to reject an NC establishment attempt.

@item DISCON_reason
Gives information about the cause of the release.

@end vtable

@subsubheading Rules governing the value of the DISCON_reason parameter

The value conveyed in the parameter will be as follows:

@enumerate a

@item When the originator parameter indicates an NS provider invoked release,
the value is one of:

@vtable @var

@item N_DISC_P
``disconnection-permanent condition''

@item N_DISC_T
``disconnection-transient condition''

@item N_REJ_NSAP_UNKNOWN
``connection rejection-NSAP address unknown (permanent condition)''

@item N_REJ_NSAP_UNREACH_P
``connection rejection-NSAP unreachable(permanent condition)''

@item N_REJ_NSAP_UNREACH_T
``connection rejection-NSAP unreachable(transient condition)''

@item N_REJ_QOS_UNAVAIL_P
``connection rejection-QOS not available/permanent condition''

@item N_REJ_QOS_UNAVAIL_T
``connection rejection-QOS not available/transient condition''

@item N_REJ_UNSPECIFIED
``connection rejection-reason unspecified''

@end vtable

@item When the originator parameter indicates an NS user invoked release, the
value is one of:

@vtable @var

@item N_DISC_NORMAL
``disconnection-normal condition''

@item N_DISC_ABNORMAL
``disconnection-abnormal condition''

@item N_REJ_P
``connection rejection-permanent condition''

@item N_REJ_T
``connection rejection-transient condition''

@item N_REJ_QOS_UNAVAIL_P
``connection rejection-QOS not available/permanent condition''

@item N_REJ_QOS_UNAVAIL_T
``connection rejection-QOS not available/transient condition''

@item N_REJ_INCOMPAT_INFO
``connection rejection-incompatible information in NS user data''

@item N_REJ_UNSPECIFIED
``connection rejection-reason unspecified''

@end vtable

@item When the originator parameter value is undefined, then the value of the
reason parameter shall be:

@vtable @var

@item N_REASON_UNDEFINED
disconnect reason undefined

@end vtable

@end enumerate

@subsection CLNS

@subsubsection N_UDERROR_IND
@prindex N_UDERROR_IND

@subsubheading Parameters

@vtable @var

@item ERROR_type
Specifies the reason for the error.  The possible values are:

@vtable @var

@item N_UD_UNDEFINED
no reason specified;

@item N_UD_TD_EXCEEDED
transit delay exceeded;

@item N_UD_CONGESTION
NS provider congestion;

@item N_UD_QOS_UNAVAIL
other requested QOS/service characteristic unavailable;

@item N_UD_LIFE_EXCEEDED
NSDU lifetime exceeded;

@item N_UD_ROUTE_UNAVAIL
suitable route unavailable.

@end vtable

@end vtable

@node Mapping NPI to ISO 8348 and CCITT X.213
@appendix Mapping NPI to ISO 8348 and CCITT X.213

Table A-1 shows a mapping of the NPI primitives to the OSI network service
definition primitives.

@cartouche
@image{npi_taba1} @center @b{Table A-1.  Mapping NPI Primitives to OSI NS}
@end cartouche

@node State/Event Tables
@appendix State/Event Tables

This appendix contains tables showing the network-user's view of the possible
states that the NPI may enter due to an event, and the possible events that may
occur on the interface.  The N_INFO_REQ, N_INFO_ACK, N_TOKEN_REQ, and N_TOKEN_ACK
primitives are excluded from the state transition table because they can be
issued from several states, and secondly, they do not cause a state transition
to occur.  However, the N_INFO_REQ and the N_TOKEN_REQ primitives may not be
issued by the NS user when a local acknowledgement to a previously issued
primitive is pending.

@cartouche
@image{npi_tabb1} @center @b{Table B-1.  Kernel Level NPI States}
@end cartouche

Tables B-2 and B-3 describe the variables and outputs used in the state tables.

@cartouche
@image{npi_tabb2} @center @b{Table B-2.  State Table Variables}
@end cartouche

@cartouche
@image{npi_tabb3} @center @b{Table B-3.  State Table Outputs}
@end cartouche

Table B-4 shows outgoing events that are initiated by the network-user entity.
These events are either requests to the network provider or responses to an
event of the network provider.

@cartouche
@image{npi_tabb4} @center @b{Table B-4.  Kernel Level NPI Outgoing Events}
@end cartouche

Table B-5 shows incoming events that are initiated by the network provider.
These events are either confirmations of a request, or are indications to the NS
user entity that an event has occurred.

@cartouche
@image{npi_tabb5} @center @b{Table B-5.  Kernel Level NPI Incoming Events}
@end cartouche

Tables B-6 and B-7 describe the possible events the NPI may enter given a
current state and event.  The contents of each box represent the next state given
the current state (column) and the current incoming or outgoing event (row).  An
empty box represents a state/event combination that is invalid.  Along with the
next state, each box may include an action.  The network provider must take
specific actions in the order specified in the state table.

@cartouche
@image{npi_tabb6} @center @b{Table B-6.  Data Transfer State Table for CLNS}
@end cartouche

@cartouche
@image{npi_tabb7} @center @b{Table B-7.  Initialization State Table for CONS}
@end cartouche

@cartouche
@image{npi_tabb8} @center @b{Table B-8.  State Table for CONS for Connection/Release/Data Transfer States}
@end cartouche

@node Primitive Precedence Tables
@appendix Primitive Precedence Tables

Tables C-1 and C-2 describe the precedence of the NPI primitives for both the
stream write and read queues.  In both these tables, primitive Y is already on the
queue and primitive X is about to be put on the queue.  The stream write queue
contains network user initiated primitives and the stream read queue contains
network provider initiated primitives.  The column headings are a shorthand
notation for the row headings.

@cartouche
@image{npi_tabc1} @center @b{Table C-1.  STREAM Write Queue Precedence Table}
@end cartouche

@cartouche
@image{npi_tabc2} @center @b{Table C-2.  STREAM Read Queue Precedence Table}
@end cartouche

@node NPI Header File Listing
@appendix NPI Header File Listing

This appendix contains a listing of the NPI header file needed by
implementations.

@smallexample
/*
 * npi.h header for the Network Provider Interface (OSI Conforming)
 */
#define N_CURRENT_VERSION   0x02        /* current version of NPI */
#define N_VERSION_2         0x02        /* version of npi, December 16, 1991 */

/*
 * Primitives that are initiated by the network user.
 */
#define N_CONN_REQ      0       /* NC request */
#define N_CONN_RES      1       /* Accept previous connection indication */
#define N_DISCON_REQ    2       /* NC disconnection request */
#define N_DATA_REQ      3       /* Connection-Mode data transfer request */
#define N_EXDATA_REQ    4       /* Expedited data request */
#define N_INFO_REQ      5       /* Information Request */
#define N_BIND_REQ      6       /* Bind a NS user to network address */
#define N_UNBIND_REQ    7       /* Unbind NS user from network address */
#define N_UNITDATA_REQ  8       /* Connection-less data send request */
#define N_OPTMGMT_REQ   9       /* Options Management request */

/*
 * Primitives that are initiated by the network provider.
 */
#define N_CONN_IND     11       /* Incoming connection indication */
#define N_CONN_CON     12       /* Connection established */
#define N_DISCON_IND   13       /* NC disconnected */
#define N_DATA_IND     14       /* Incoming connection-mode data indication */
#define N_EXDATA_IND   15       /* Incoming expedited data indication */
#define N_INFO_ACK     16       /* Information Acknowledgement */
#define N_BIND_ACK     17       /* NS User bound to network address */
#define N_ERROR_ACK    18       /* Error Acknowledgement */
#define N_OK_ACK       19       /* Success Acknowledgement */
#define N_UNITDATA_IND 20       /* Connection-less data receive indication */
#define N_UDERROR_IND  21       /* UNITDATA Error Indication */

/*
 * Additional NPI Primitivies
 */
#define N_DATACK_REQ   23       /* Data acknowledgement request */
#define N_DATACK_IND   24       /* Data acknowledgement indication */
#define N_RESET_REQ    25       /* NC reset request */
#define N_RESET_IND    26       /* Incoming NC reset request indication */
#define N_RESET_RES    27       /* Reset processing accepted */
#define N_RESET_CON    28       /* Reset processing complete */

/*
 * The following are the events that drive the state machine
 */

/*
 * Initialization events
 */
#define NE_BIND_REQ      0      /* bind request */
#define NE_UNBIND_REQ    1      /* unbind request */
#define NE_OPTMGMT_REQ   2      /* manage options request */
#define NE_BIND_ACK      3      /* bind acknowledgement */
#define NE_ERROR_ACK     5      /* error acknowledgement */
#define NE_OK_ACK1       6      /* ok ack, outcnt == 0 */
#define NE_OK_ACK2       7      /* ok ack, outcnt == 1, q == rq */
#define NE_OK_ACK3       8      /* ok ack, outcnt == 1, q! == rq */
#define NE_OK_ACK4       9      /* ok ack, outcnt > 1 */

/*
 * Connection-Mode events
 */
#define NE_CONN_REQ     10      /* connect request */
#define NE_CONN_RES     11      /* connect response */
#define NE_DISCON_REQ   12      /* disconnect request */
#define NE_DATA_REQ     13      /* data request */
#define NE_EXDATA_REQ   14      /* expedited data request */
#define NE_CONN_IND     16      /* connect indication */
#define NE_CONN_CON     17      /* connect confirm */
#define NE_DATA_IND     18      /* data indication */
#define NE_EXDATA_IND   19      /* expedited data indication */
#define NE_DISCON_IND1  21      /* disconnect indication, outcnt == 0 */
#define NE_DISCON_IND2  22      /* disconnect indication, outcnt == 1 */
#define NE_DISCON_IND3  23      /* disconnect indication, outcnt > 1 */
#define NE_PASS_CON     24      /* pass connection */
#define NE_RESET_REQ    28      /* reset request */
#define NE_RESET_RES    29      /* reset response */
#define NE_DATACK_REQ   30      /* data acknowledgement request */
#define NE_DATACK_IND   31      /* data acknowledgement indication */
#define NE_RESET_IND    32      /* reset indication */
#define NE_RESET_CON    33      /* reset confirm */

/*
 * Connection-less events
 */
#define NE_UNITDATA_REQ 25      /* unitdata request */
#define NE_UNITDATA_IND 26      /* unitdata indication */
#define NE_UDERROR_IND  27      /* unitdata error indication */

#define NE_NOEVENTS     36      /* no events */

/*
 * NPI interface states
 */
#define NS_UNBND        0       /* NS user not bound to network address */
#define NS_WACK_BREQ    1       /* Awaiting acknowledgement of N_BIND_REQ */
#define NS_WACK_UREQ    2       /* Pending acknowledgement for N_UNBIND_REQ */
#define NS_IDLE         3       /* Idle, no connection */
#define NS_WACK_OPTREQ  4       /* Pending acknowledgement of N_OPTMGMT_REQ */
#define NS_WACK_RRES    5       /* Pending acknowledgement of N_RESET_RES */
#define NS_WCON_CREQ    6       /* Pending confirmation of N_CONN_REQ */
#define NS_WRES_CIND    7       /* Pending response of N_CONN_REQ */
#define NS_WACK_CRES    8       /* Pending acknowledgement of N_CONN_RES */
#define NS_DATA_XFER    9       /* Connection-mode data transfer */
#define NS_WCON_RREQ   10       /* Pending confirmation of N_RESET_REQ */
#define NS_WRES_RIND   11       /* Pending response of N_RESET_IND */
#define NS_WACK_DREQ6  12       /* Waiting ack of N_DISCON_REQ */
#define NS_WACK_DREQ7  13       /* Waiting ack of N_DISCON_REQ */
#define NS_WACK_DREQ9  14       /* Waiting ack of N_DISCON_REQ */
#define NS_WACK_DREQ10 15       /* Waiting ack of N_DISCON_REQ */
#define NS_WACK_DREQ11 16       /* Waiting ack of N_DISCON_REQ */

#define NS_NOSTATES 18          /* No states */

/*
 * N_ERROR_ACK error return code values
 */
#define NBADADDR       1        /* Incorrect address format/illegal address *
                                   information */
#define NBADOPT        2        /* Options in incorrect format or contain
                                   illegal * information */
#define NACCESS        3        /* User did not have proper permissions */
#define NNOADDR        5        /* NS Provider could not allocate address */
#define NOUTSTATE      6        /* Primitive was issues in wrong sequence */
#define NBADSEQ        7        /* Sequence number in primitive was
                                   incorrect/illegal */
#define NSYSERR        8        /* UNIX system error occurred */
#define NBADDATA      10        /* User data spec.  outside range supported by
                                   NS provider */
#define NBADFLAG      16        /* Flags specified in primitive were
                                   illegal/incorrect */
#define NNOTSUPPORT   18        /* Primitive type not supported by the NS
                                   provider */
#define NBOUND        19        /* Illegal second attempt to bind listener or
                                   default listener */
#define NBADQOSPARAM  20        /* QOS values specified are outside the range
                                   supported by the NS provider */
#define NBADQOSTYPE   21        /* QOS structure type specified is not
                                   supported by the NS provider */
#define NBADTOKEN     22        /* Token used is not associated with an open
                                   stream */
#define NNOPROTOID    23        /* Protocol id could not be allocated */

/* 
 * N_UDERROR_IND reason codes
 */
#define N_UD_UNDEFINED     10   /* no reason specified */
#define N_UD_TD_EXCEEDED   11   /* Transit delay exceeded */
#define N_UD_CONGESTION    12   /* NS Provider congestion */
#define N_UD_QOS_UNAVAIL   13   /* Requested QOS/service characteristic
                                   unavailable */
#define N_UD_LIFE_EXCEEDED 14   /* NSDU Lifetime exceeded */
#define N_UD_ROUTE_UNAVAIL 15   /* Suitable route unavailable */
#define N_UD_SEG_REQUIRED  16   /* Segmentation reqd where none permitted */

/*
 * NPI Originator for Resets and Disconnects
 */
#define N_PROVIDER           0x0100     /* provider originated reset/disconnect 
                                         */
#define N_USER               0x0101     /* user originated reset/disconnect */
#define N_UNDEFINED          0x0102     /* reset/disconnect originator
                                           undefined */

/*
 * NPI Disconnect & Reset reasons when the originator is the N_UNDEFINED
 */
#define N_REASON_UNDEFINED  0x0200

/*
 * NPI Disconnect reasons when the originator is the N_PROVIDER
 */
#define N_DISC_P             0x0300     /* Disconnection-permanent condition */
#define N_DISC_T             0x0301     /* Disconnection-transient condition */
#define N_REJ_NSAP_UNKNOWN   0x0302     /* Connection rejection-NSAP address
                                           unknown (permanent condition) */
#define N_REJ_NSAP_UNREACH_P 0x0303     /* Connection rejection-NSAP
                                           unreachable (permanent condition) */
#define N_REJ_NSAP_UNREACH_T 0x0304     /* Connection rejection-NSAP
                                           unreachable (transient condition) */

/*
 * NPI Disconnect reasons when the originator is the N_USER
 */
#define N_DISC_NORMAL        0x0400     /* Disconnection-normal condition */
#define N_DISC_ABNORMAL      0x0401     /* Disconnection-abnormal condition */
#define N_REJ_P              0x0402     /* Connection rejection-permanent
                                           condition */
#define N_REJ_T              0x0403     /* Connection rejection-transient
                                           condition */
#define N_REJ_INCOMPAT_INFO  0x0406     /* Connection rejection-incompatible
                                           information in NS-user-data */

/*
 * NPI Disconnect reasons when the originator is the N_USER or N_PROVIDER
 */
#define N_REJ_QOS_UNAVAIL_P  0x0305     /* Connection rejection-QOS unavailable 
                                           (permanent condition) */
#define N_REJ_QOS_UNAVAIL_T  0x0306     /* Connection rejection-QOS unavailable 
                                           (transient condition) */
#define N_REJ_UNSPECIFIED    0x0307     /* Connection rejection-reason
                                           unspecified */

/*
 * NPI Reset reasons when originator is N_PROVIDER
 */
#define N_CONGESTION         0x0500     /* Reset due to congestion */
#define N_RESET_UNSPECIFIED  0x0501     /* Reset-reason "unspecified" */

/*
 * NPI Reset reasons when originator is N_USER
 */
#define N_USER_RESYNC        0x0600     /* Reset due to user resynchronization */

/*
 * CONN_flags definition; (used in N_conn_req, N_conn_ind, N_conn_res, and
 * N_conn_con primitives)
 *
 * Flags to indicate support of network provider options; (used with the
 * OPTIONS_flags field of N_info_ack primitive)
 */
#define REC_CONF_OPT        0x00000001L /* Receipt Confirmation Selection and
                                           Support */
#define EX_DATA_OPT         0x00000002L /* Expedited Data Selection and Support 
                                         */

/*
 * This flag is used with the OPTIONS_flags field of N_info_ack as well as the
 * OPTMGMT_flags field of the N_optmgmt_req primitive
 */
#define DEFAULT_RC_SEL      0x00000003L /* Indicates if default receipt
                                           confirmation is selected */

/*
 * BIND_flags; (used with N_bind_req primitive)
 */
#define DEFAULT_LISTENER    0x00000001L /* indicates if this stream is the
                                           default listener */
#define TOKEN_REQUEST       0x00000002L /* indicates if "token" should be
                                           assigned to the stream */
#define DEFAULT_DEST        0x00000004L /* indicates if default dest.  stream */

/*
 * QOS Parameter Definitions
 */
/*
 * Throughput
 *
 * This parameter is specified for both directions.
 */
typedef struct @{
        long thru_targ_value;           /* target throughput values */
        long thru_min_value;            /* minimum acceptable throughput value */
@} thru_values_t;
@tpindex thru_values_t

/*
 * Transit Delay
 */
typedef struct @{
        long td_targ_value;             /* target transit delay */
        long td_max_value;              /* maximum acceptable transit delay */
@} td_values_t;
@tpindex td_values_t

/*
 * Protection Values
 */
typedef struct @{
        long protect_targ_value;        /* target protection value */
        long protect_min_value;         /* minimum or available protection */
@} protection_values_t;
@tpindex protection_values_t

/*
 * Priority Values
 */
typedef struct @{
        long priority_targ_value;       /* target priority */
        long priority_min_value;        /* minimum acceptable priority */
@} priority_values_t;
@tpindex priority_values_t

/*
 * Types of protection specifications
 */
#define N_NO_PROT               0x00000000L     /* no protection */
#define N_PASSIVE_PROT          0x00000001L     /* protection against passive
                                                   monitoring */
#define N_ACTIVE_PROT           0x00000002L     /* protection against active
                                                   monitoring */
#define N_ACTIVE_PASSIVE_PROT   0x00000003L     /* protection against active
                                                   and passive monitoring */

/*
 * Cost Selection
 */
#define N_LEAST_EXPENSIVE       0x00000000L     /* choose least expensive means 
                                                 */

/*
 * QOS STRUCTURE TYPES AND DEFINED VALUES
 */
#define N_QOS_CO_RANGE1         0x0101
#define N_QOS_CO_SEL1           0x0102
#define N_QOS_CL_RANGE1         0x0103
#define N_QOS_CL_SEL1           0x0104
#define N_QOS_CO_OPT_RANGE1     0x0105
#define N_QOS_CO_OPT_SEL1       0x0106

/*
 * When a NS user/provider cannot determine the value of a QOS field, it should
 * return a value of QOS_UNKNOWN.
 */
#define QOS_UNKNOWN -1

/*
 * QOS range for CONS.  (Used with N_CONN_REQ and N_CONN_IND.)
 */
typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CO_RANGE */
        thru_values_t src_throughput_range;     /* source throughput range */
        thru_values_t dest_throughput_range;    /* destination throughput range 
                                                 */
        td_values_t transit_delay_range;        /* transit delay range */
        protection_values_t protection_range;   /* protection range */
        priority_values_t priority_range;       /* priority range */
@} N_qos_co_range_t;
@tpindex N_qos_co_range_t

/*
 * QOS selected for CONS.  (Used with N_CONN_RES and N_CONN_CON.)
 */
typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CO_SEL */
        long src_throughput_sel;        /* source throughput selected */
        long dest_throughput_sel;       /* destination throughput selected */
        long transit_delay_sel;         /* transit delay selected */
        long protection_sel;            /* NC protection selected */
        long priority_sel;              /* NC priority selected */
@} N_qos_co_sel_t;
@tpindex N_qos_co_sel_t

/*
 * QOS range for CLNS options management.  (Used with N_INFO_ACK.)
*/
typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CL_RANGE */
        td_values_t transit_delay_max;  /* maximum transit delay */
        ulong residual_error_rate;      /* residual error rate */
        protection_values_t protection_range;   /* protection range */
        priority_values_t priority_range;       /* priority range */
        long max_accept_cost;           /* maximum acceptable cost */
@} N_qos_cl_range_t;
@tpindex N_qos_cl_range_t

/*
 * QOS selection for CLNS options management.  (Used with N_OPTMGMT_REQ and *
 * N_INFO_ACK.)
 */
typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CL_sel */
        long transit_delay_max;         /* maximum transit delay */
        ulong residual_error_rate;      /* residual error rate */
        long protection_sel;            /* protection selected */
        long priority_sel;              /* priority selected */
        long max_accept_cost;           /* maximum acceptable cost */
@} N_qos_cl_sel_t;
@tpindex N_qos_cl_sel_t

/*
 * QOS range for CONS options management.  (Used with N_OPTMGMT_REQ.)
 */
typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CO_OPT_RANGE */
        thru_values_t src_throughput;   /* source throughput values */
        thru_values_t dest_throughput;  /* dest throughput values */
        td_values_t transit_delay_t;    /* transit delay values */
        long nc_estab_delay;            /* NC establishment delay */
        ulong nc_estab_fail_prob;       /* NC estab failure probability */
        ulong residual_error_rate;      /* residual error rate */
        ulong xfer_fail_prob;           /* transfer failure probability */
        ulong nc_resilience;            /* NC resilience */
        long nc_rel_delay;              /* NC release delay */
        ulong nc_rel_fail_prob;         /* NC release failure probability */
        protection_values_t protection_range;   /* protection range */
        priority_values_t priority_range;       /* priority range */
        long max_accept_cost;           /* maximum acceptable cost */
@} N_qos_co_opt_range_t;
@tpindex N_qos_co_opt_range_t

/*
 * QOS values selected for CONS options management.  (Used with N_OPTMGMT_REQ *
 * and N_INFO_ACK.)
 */

typedef struct @{
        ulong n_qos_type;               /* always N_QOS_CO_OPT_SEL */
        thru_values_t src_throughput;   /* source throughput values */
        thru_values_t dest_throughput;  /* dest throughput values */
        td_values_t transit_delay_t;    /* transit delay values */
        long nc_estab_delay;            /* NC establishment delay */
        ulong nc_estab_fail_prob;       /* NC estab failure probability */
        ulong residual_error_rate;      /* residual error rate */
        ulong xfer_fail_prob;           /* transfer failure probability */
        ulong nc_resilience;            /* NC resilience */
        long nc_rel_delay;              /* NC release delay */
        ulong nc_rel_fail_prob;         /* NC release failure probability */
        long protection_sel;            /* protection selected */
        long priority_sel;              /* priority selected */
        long max_accept_cost;           /* maximum acceptable cost */
@} N_qos_co_opt_sel_t;
@tpindex N_qos_co_opt_sel_t

/*
 * NPI Primitive Definitions
 */

/*
 * Local management service primitives
 */

/*
 * Information request
 */
typedef struct @{
        ulong PRIM_type;                /* always N_INFO_REQ */
@} N_info_req_t;
@tpindex N_info_req_t

/*
 * Information acknowledgement
 */
typedef struct @{
        ulong PRIM_type;                /* always N_INFO_ACK */
        ulong NSDU_size;                /* maximum NSDU size */
        ulong ENSDU_size;               /* maximum ENSDU size */
        ulong CDATA_size;               /* connect data size */
        ulong DDATA_size;               /* discon data size */
        ulong ADDR_size;                /* address size */
        ulong ADDR_length;              /* address length */
        ulong ADDR_offset;              /* address offset */
        ulong QOS_length;               /* QOS values length */
        ulong QOS_offset;               /* QOS values offset */
        ulong QOS_range_length;         /* length of QOS values' range */
        ulong QOS_range_offset;         /* offset of QOS values' range */
        ulong OPTIONS_flags;            /* bit masking for options supported */
        ulong NIDU_size;                /* network i/f data unit size */
        long SERV_type;                 /* service type */
        ulong CURRENT_state;            /* current state */
        ulong PROVIDER_type;            /* type of NS provider */
        ulong NODU_size;                /* optimal NSDU size */
        ulong PROTOID_length;           /* length of bound protocol ids */
        ulong PROTOID_offset;           /* offset of bound protocol ids */
        ulong NPI_version;              /* version # of npi that is supported */
@} N_info_ack_t;
@tpindex N_info_ack_t

/*
 * Service types supported by NS provider
 */
#define N_CONS  1               /* Connection-mode network service supported */
#define N_CLNS  2               /* Connection-less network service supported */

/*
 * Valid provider types
 */
#define N_SNICFP    1
#define N_SUBNET    2

/*
 * Bind request
 */
typedef struct @{
        ulong PRIM_type;                /* always N_BIND_REQ */
        ulong ADDR_length;              /* length of address */
        ulong ADDR_offset;              /* offset of address */
        ulong CONIND_number;            /* requested # of connect-indications
                                           to be queued */
        ulong BIND_flags;               /* bind flags */
        ulong PROTOID_length;           /* length of bound protocol ids */
        ulong PROTOID_offset;           /* offset of bound protocol ids */
@} N_bind_req_t;
@tpindex N_bind_req_t

/*
 * Bind acknowledgement
 */
typedef struct @{
        ulong PRIM_type;                /* always N_BIND_ACK */
        ulong ADDR_length;              /* address length */
        ulong ADDR_offset;              /* offset of address */
        ulong CONIND_number;            /* connection indications */
        ulong TOKEN_value;              /* value of ``token'' assigned to
                                           stream */
        ulong PROTOID_length;           /* length of bound protocol ids */
        ulong PROTOID_offset;           /* offset of bound protocol ids */
@} N_bind_ack_t;
@tpindex N_bind_ack_t

/*
 * Unbind request
 */
typedef struct @{
        ulong PRIM_type;                /* always N_UNBIND_REQ */
@} N_unbind_req_t;
@tpindex N_unbind_req_t

/*
 * Options management request
 */
typedef struct @{
        ulong PRIM_type;                /* always N_OPTMGMT_REQ */
        ulong QOS_length;               /* length of QOS parameter values */
        ulong QOS_offset;               /* offset of QOS parameter values */
        ulong OPTMGMT_flags;            /* options management flags */
@} N_optmgmt_req_t;
@tpindex N_optmgmt_req_t

/*
 * Error acknowledgement for CONS services
 */
typedef struct @{
        ulong PRIM_type;                /* always N_ERROR_ACK */
        ulong ERROR_prim;               /* primitive in error */
        ulong NPI_error;                /* NPI error code */
        ulong UNIX_error;               /* UNIX error code */
@} N_error_ack_t;
@tpindex N_error_ack_t

/*
 * Successful completion acknowledgement
 */
typedef struct @{
        ulong PRIM_type;                /* always N_OK_ACK */
        ulong CORRECT_prim;             /* primitive being acknowledged */
@} N_ok_ack_t;
@tpindex N_ok_ack_t

/*
 * CONS PRIMITIVES
 */

/*
 * Network connection request
 */
typedef struct @{
        ulong PRIM_type;                /* always N_CONN_REQ */
        ulong DEST_length;              /* destination address length */
        ulong DEST_offset;              /* destination address offset */
        ulong CONN_flags;               /* bit masking for options flags */
        ulong QOS_length;               /* length of QOS parameter values */
        ulong QOS_offset;               /* offset of QOS parameter values */
@} N_conn_req_t;
@tpindex N_conn_req_t

/*
 * Connection indication
 */
typedef struct @{
        ulong PRIM_type;                /* always N_CONN_IND */
        ulong DEST_length;              /* destination address length */
        ulong DEST_offset;              /* destination address offset */
        ulong SRC_length;               /* source address length */
        ulong SRC_offset;               /* source address offset */
        ulong SEQ_number;               /* sequence number */
        ulong CONN_flags;               /* bit masking for options flags */
        ulong QOS_length;               /* length of QOS parameter values */
        ulong QOS_offset;               /* offset of QOS parameter values */
@} N_conn_ind_t;
@tpindex N_conn_ind_t

/*
 * Connection response
 */
typedef struct @{
        ulong PRIM_type;                /* always N_CONN_RES */
        ulong TOKEN_value;              /* NC response token value */
        ulong RES_length;               /* responding address length */
        ulong RES_offset;               /* responding address offset */
        ulong SEQ_number;               /* sequence number */
        ulong CONN_flags;               /* bit masking for options flags */
        ulong QOS_length;               /* length of QOS parameter values */
        ulong QOS_offset;               /* offset of QOS parameter values */
@} N_conn_res_t;
@tpindex N_conn_res_t

/*
 * Connection confirmation
 */
typedef struct @{
        ulong PRIM_type;                /* always N_CONN_CON */
        ulong RES_length;               /* responding address length */
        ulong RES_offset;               /* responding address offset */
        ulong CONN_flags;               /* bit masking for options flags */
        ulong QOS_length;               /* length of QOS parameter values */
        ulong QOS_offset;               /* offset of QOS parameter values */
@} N_conn_con_t;
@tpindex N_conn_con_t

/*
 * Connection mode data transfer request
 */
typedef struct @{
        ulong PRIM_type;                /* always N_DATA_REQ */
        ulong DATA_xfer_flags;          /* data transfer flags */
@} N_data_req_t;
@tpindex N_data_req_t

/*
 * NPI MORE_DATA_FLAG for segmenting NSDU into more than 1 NIDUs
 */
#define N_MORE_DATA_FLAG    0x00000001L /* Indicates that the next NIDU is part 
                                           of this NSDU */

/* 
 * NPI Receipt confirmation request set flag
 */
#define N_RC_FLAG           0x00000002L /* Indicates if receipt confirmation is 
                                           required */

/*
 * Incoming data indication for an NC
 */
typedef struct @{
        ulong PRIM_type;                /* always N_DATA_IND */
        ulong DATA_xfer_flags;          /* data transfer flags */
@} N_data_ind_t;
@tpindex N_data_ind_t

/*
 * Data acknowledgement request
 */
typedef struct @{
        ulong PRIM_type;                /* always N_DATACK_REQ */
@} N_datack_req_t;
@tpindex N_datack_req_t

/*
 * Data acknowledgement indication
 */
typedef struct @{
        ulong PRIM_type;                /* always N_DATACK_IND */
@} N_datack_ind_t;
@tpindex N_datack_ind_t

/*
 * Expedited data transfer request
 */
typedef struct @{
        ulong PRIM_type;                /* always N_EXDATA_REQ */
@} N_exdata_req_t;
@tpindex N_exdata_req_t

/*
 * Expedited data transfer indication
 */
typedef struct @{
        ulong PRIM_type;                /* always N_EXDATA_IND */
@} N_exdata_ind_t;
@tpindex N_exdata_ind_t

/*
 * NC reset request
 */
typedef struct @{
        ulong PRIM_type;                /* always N_RESET_REQ */
        ulong RESET_reason;             /* reason for reset */
@} N_reset_req_t;
@tpindex N_reset_req_t

/*
 * NC reset indication
 */
typedef struct @{
        ulong PRIM_type;                /* always N_RESET_IND */
        ulong RESET_orig;               /* reset originator */
        ulong RESET_reason;             /* reason for reset */
@} N_reset_ind_t;
@tpindex N_reset_ind_t

/*
 * NC reset response
 */
typedef struct @{
        ulong PRIM_type;                /* always N_RESET_RES */
@} N_reset_res_t;
@tpindex N_reset_res_t

/*
 * NC reset confirmed
 */
typedef struct @{
        ulong PRIM_type;                /* always N_RESET_CON */
@} N_reset_con_t;
@tpindex N_reset_con_t

/*
 * NC disconnection request
 */
typedef struct @{
        ulong PRIM_type;                /* always N_DISCON_REQ */
        ulong DISCON_reason;            /* reason */
        ulong RES_length;               /* responding address length */
        ulong RES_offset;               /* responding address offset */
        ulong SEQ_number;               /* sequence number */
@} N_discon_req_t;
@tpindex N_discon_req_t

/*
 * NC disconnection indication
 */
typedef struct @{
        ulong PRIM_type;                /* always N_DISCON_IND */
        ulong DISCON_orig;              /* originator */
        ulong DISCON_reason;            /* reason */
        ulong RES_length;               /* address length */
        ulong RES_offset;               /* address offset */
        ulong SEQ_number;               /* sequence number */
@} N_discon_ind_t;
@tpindex N_discon_ind_t

/*
 * CLNS PRIMITIVES
 */

/*
 * Unitdata transfer request
 */
typedef struct @{
        ulong PRIM_type;                /* always N_UNITDATA_REQ */
        ulong DEST_length;              /* destination address length */
        ulong DEST_offset;              /* destination address offset */
        ulong RESERVED_field[2];        /* reserved field for DLPI
                                           compatibility */
@} N_unitdata_req_t;
@tpindex N_unitdata_req_t

/*
 * Unitdata transfer indication
 */
typedef struct @{
        ulong PRIM_type;                /* always N_UNITDATA_IND */
        ulong SRC_length;               /* source address length */
        ulong SRC_offset;               /* source address offset */
        ulong DEST_length;              /* source address length */
        ulong DEST_offset;              /* source address offset */
        ulong ERROR_type;               /* reserved field for DLPI
                                           compatibility */
@} N_unitdata_ind_t;
@tpindex N_unitdata_ind_t

/*
 * Unitdata error indication for CLNS services
 */
typedef struct @{
        ulong PRIM_type;                /* always N_UDERROR_IND */
        ulong DEST_length;              /* destination address length */
        ulong DEST_offset;              /* destination address offset */
        ulong RESERVED_field;           /* reserved field for DLPI
                                           compatibility */
        ulong ERROR_type;               /* error type */
@} N_uderror_ind_t;
@tpindex N_uderror_ind_t

/*
 * The following represents a union of all the NPI primitives
 */
union N_primitives @{
        ulong type;
        N_info_req_t info_req;          /* information request */
        N_info_ack_t info_ack;          /* information acknowledgement */
        N_bind_req_t bind_req;          /* bind request */
        N_bind_ack_t bind_ack;          /* bind acknowledgement */
        N_unbind_req_t unbind_req;      /* unbind request */
        N_optmgmt_req_t optmgmt_req;    /* options management request */
        N_error_ack_t error_ack;        /* error acknowledgement */
        N_uderror_ind_t uderror_ind;    /* unitdata error indication */
        N_ok_ack_t ok_ack;              /* ok acknowledgement */
        N_conn_req_t conn_req;          /* connect request */
        N_conn_ind_t conn_ind;          /* connect indication */
        N_conn_res_t conn_res;          /* connect response */
        N_conn_con_t conn_con;          /* connect confirm */
        N_data_req_t data_req;          /* data request */
        N_data_ind_t data_ind;          /* data indication */
        N_datack_req_t datack_req;      /* data acknowledgement request */
        N_datack_ind_t datack_ind;      /* data acknowledgement indication */
        N_exdata_req_t exdata_req;      /* expedited data request */
        N_exdata_ind_t exdata_ind;      /* expedited data indication */
        N_reset_req_t reset_req;        /* reset request */
        N_reset_ind_t reset_ind;        /* reset indication */
        N_reset_res_t reset_res;        /* reset response */
        N_reset_con_t reset_con;        /* reset confirm */
        N_discon_req_t discon_req;      /* disconnect request */
        N_discon_ind_t discon_ind;      /* disconnect indication */
        N_unitdata_req_t unitdata_req;  /* unitdata request */
        N_unitdata_ind_t unitdata_ind;  /* unitdata indication */
@};
@tpindex N_primitives
@end smallexample

@node Glossary
@unnumbered Glossary

@table @emph
@item Signalling Data Link Service Data Unit
A grouping of SDL user data whose boundaries are preserved from one end of the
signalling data link connection to the other.
@item Data transfer
The phase in connection and connectionless modes that supports the transfer of
data between to signalling data link users.
@item SDL provider
The signalling data link layer protocol that provides the services of the
signalling data link interface.
@item SDL user
The user-level application or user-level or kernel-level protocol that accesses
the services of the signalling data link layer.
@item Local management
The phase in connection and connectionless modes in which a SDL user initializes
a stream and attaches a PPA address to the stream.  Primitives in this phase
generate local operations only.
@item PPA
The point at which a system attaches itself to a physical communications medium.
@item PPA identifier
An identifier of a particular physical medium over which communication
transpires.
@end table

@node Acronyms
@unnumbered Acronyms

@multitable {SDL SDU}{International Telecommunications Union}
@item SDLI @tab Signalling Data Link Interface
@item SDL @tab Signalling Data Link
@item SDL SDU @tab Signalling Data Link Service Data Unit
@item ITU-T @tab International Telecommunications Union - Telecom Sector
@item PPA @tab Physical Point of Attachment
@end multitable

@node Bibliography
@unnumbered Bibliography
@enumerate
@item ITU-T Recommendation X.210, (Geneva, 1993), ``Information Technology --- Open Systems Interconnection --- Basic reference model: Conventions for the definition of OSI services,'' ISO/IEC 10731:1994.
@item ITU-T Recommendation X.217, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Service definition for the Association Control Service Element,'' ISO/IEC 8649:1996.
@item ITU-T Recommendation X.227, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Connection-oriented protocol for the Association Control Service Element: Protocol Specification,'' ISO/IEC 8650-1.
@item ITU-T Recommendation X.237, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Connectionless protocol for the Association Control Service Element: Protocol Specification,'' ISO/IEC 10035-1 : 1995.
@item ITU-T Recommendation X.216, (Geneva, 1994), ``Information Technology --- Open Systems Interconnection --- Presentation service definition,'' ISO/IEC 8822:1994.
@item ITU-T Recommendation X.226, (Geneva, 1994), ``Information Technology --- Open Systems Interconnection --- Connection-oriented presentation protocol: Protocol specification,'' ISO/IEC 8823-1:1994.
@item ITU-T Recommendation X.236, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Connectionless presentation protocol: Protocol specification,'' ISO/IEC 9576-1:1995.
@item ITU-T Recommendation X.215, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Session service definition,'' ISO/IEC 8326:1996.
@item ITU-T Recommendation X.225, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Connection-oriented session protocol: Protocol specification,'' ISO/IEC 8327-1:1996.
@item ITU-T Recommendation X.235, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Connectionless session protocol: Protocol specification,'' ISO/IEC 9548-1:1995.
@item ITU-T Recommendation X.214, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Transport service definition,'' ISO/IEC 8072:1996.
@item ITU-T Recommendation X.224
@item ITU-T Recommendation Q.700
@item ITU-T Recommendation Q.701
@item ITU-T Recommendation Q.702
@item ITU-T Recommendation Q.703
@item ITU-T Recommendation Q.704
@item Geoffrey Gerrien, ``CDI - Application Program Interface Guide,'' Gcom, Inc., March 1999.
@item ITU-T Recommendation Q.771, (Geneva, 1993), ``Signalling System No.  7 --- Functional description of transaction capabilities,'' (White Book).
@end enumerate

@node Index
@unnumbered Index

@printindex cp

@c @section Primitive Index

@c @printindex pr

@c @section Primitive Structure and Type Index
@c @printindex tp

@c @section Primitive Structure Field Index

@c @printindex vr

@page
@shortcontents
@page
@contents
@bye
