/*****************************************************************************

 @(#) $RCSfile$ $Name$($Revision$) $Date$

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2009  Monavacom Limited <http://www.monavacom.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date$ by $Author$

 -----------------------------------------------------------------------------

 $Log$
 *****************************************************************************/

#ident "@(#) $RCSfile$ $Name$($Revision$) $Date$"

static char const ident[] = "$RCSfile$ $Name$($Revision$) $Date$";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "dlMIB_openss7.h"
const char sa_program[] = "dlmib";

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
int sa_nomead = 1;			/* default daemon mode */
int sa_output = 1;			/* default normal output */
int sa_agentx = 1;			/* default agentx mode */
int sa_alarms = 1;			/* default application alarms */
int sa_fclose = 1;			/* default close files between requests */
int sa_logaddr = 0;			/* log addresses */
int sa_logfillog = 0;			/* log to sa_logfile */
int sa_logstderr = 0;			/* log to standard error */
int sa_logstdout = 0;			/* log to standard output */
int sa_logsyslog = 0;			/* log to system logs */
int sa_logcallog = 0;			/* log to callback logs */
int sa_appendlog = 0;			/* append to log file without truncating */
char sa_logfile[256] = "/var/log/dlmib.log";
char sa_pidfile[256] = "/var/run/dlmib.pid";
char sa_sysctlf[256] = "/etc/dlmib.conf";
int allow_severity = LOG_ERR;
int deny_severity = LOG_ERR;

/* file stream for log file */
FILE *stdlog = NULL;

/* file descriptor for MIB use */
int sa_fd = 0;

/* indication to reread MIB configuration */
int sa_changed = 1;

/* indications that statistics, the mib or its tables need to be refreshed */
int sa_stats_refresh = 1;
#endif				/* !defined MODULE */
/* request number for per-request actions */
int sa_request = 1;
volatile int dlMIB_refresh = 1;
volatile int communicationsEntityTable_refresh = 1;
volatile int sap1Table_refresh = 1;
volatile int sap2Table_refresh = 1;
volatile int clProtocolMachineTable_refresh = 1;
volatile int coProtocolMachineTable_refresh = 1;
volatile int singlePeerConnectionTable_refresh = 1;
volatile int physicalEntityTable_refresh = 1;
volatile int physicalSAPTable_refresh = 1;
volatile int dataCircuitTable_refresh = 1;
volatile int physicalConnectionTable_refresh = 1;
volatile int datalinkEntityTable_refresh = 1;
volatile int dLSAPTable_refresh = 1;
volatile int lAPBDLETable_refresh = 1;
volatile int sLPPMTable_refresh = 1;
volatile int sLPConnectionTable_refresh = 1;
volatile int sLPConnectionIVMOTable_refresh = 1;
volatile int mACDLETable_refresh = 1;
volatile int mACTable_refresh = 1;
volatile int lLCDLETable_refresh = 1;
volatile int lLCCLPMTable_refresh = 1;
volatile int lLCCOPMTable_refresh = 1;
volatile int resourceTypeIdTable_refresh = 1;
volatile int lLCStationTable_refresh = 1;
volatile int lLCSAPTable_refresh = 1;
volatile int rDESetupTable_refresh = 1;
volatile int rDEPairTable_refresh = 1;
volatile int lLCConnectionLessTable_refresh = 1;
volatile int lLCConnection2Table_refresh = 1;
volatile int lLCConnection2IVMOTable_refresh = 1;
volatile int lLCConnectionlessAckTable_refresh = 1;
volatile int lLCConnectionlessAckIVMOTable_refresh = 1;
volatile int networkEntityTable_refresh = 1;
volatile int nSAPTable_refresh = 1;
volatile int cLNSTable_refresh = 1;
volatile int cLNSISISTable_refresh = 1;
volatile int cLNSISISLevel2Table_refresh = 1;
volatile int linkageTable_refresh = 1;
volatile int cONSTable_refresh = 1;
volatile int networkConnectionTable_refresh = 1;
volatile int x25PLETable_refresh = 1;
volatile int x25PLE_DTETable_refresh = 1;
volatile int x25PLE_DCETable_refresh = 1;
volatile int x25PLEIVMOTable_refresh = 1;
volatile int x25PLEIVMO_DTETable_refresh = 1;
volatile int x25PLEIVMO_DCETable_refresh = 1;
volatile int virtualCallTable_refresh = 1;
volatile int virtualCircuitTable_refresh = 1;
volatile int virtualCircuit_DTETable_refresh = 1;
volatile int virtualCircuit_DCETable_refresh = 1;
volatile int permanentVirtualCircuitTable_refresh = 1;
volatile int permanentVirtualCircuit_DTETable_refresh = 1;
volatile int permanentVirtualCircuit_DCETable_refresh = 1;
volatile int virtualCallIVMOTable_refresh = 1;
volatile int switchedVirtualCallTable_refresh = 1;
volatile int virtualCall_DTETable_refresh = 1;
volatile int virtualCall_DCETable_refresh = 1;
volatile int dSeriesCountsTable_refresh = 1;
volatile int adjacencyTable_refresh = 1;
volatile int virtualAdjacencyTable_refresh = 1;
volatile int destinationTable_refresh = 1;
volatile int destinationSystemTable_refresh = 1;
volatile int destinationAreaTable_refresh = 1;
volatile int reachableAddressTable_refresh = 1;

/*
 * dlMIB_variables_oid: object identifier for dlMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid dlMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212 };
oid physicalSAPTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 8, 1, 1 };
oid dataCircuitTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 9, 1, 1 };
oid physicalConnectionTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 10, 1, 1 };
oid datalinkEntityTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 11, 1, 1 };
oid dLSAPTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 12, 1, 1 };
oid lAPBDLETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 13, 1, 1 };
oid sLPPMTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 14, 1, 1 };
oid sLPConnectionTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 15, 1, 1 };
oid sLPConnectionIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 16, 1, 1 };
oid mACDLETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 17, 1, 1 };
oid mACTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 18, 1, 1 };
oid lLCDLETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 19, 1, 1 };
oid lLCCLPMTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 20, 1, 1 };
oid lLCCOPMTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 21, 1, 1 };
oid lLCConnectionlessAckIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 31, 1, 1 };
oid networkEntityTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 32, 1, 1 };
oid nSAPTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 33, 1, 1 };
oid cLNSTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 34, 1, 1 };
oid cLNSISISTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 35, 1, 1 };
oid cLNSISISLevel2Table_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 36, 1, 1 };
oid linkageTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 37, 1, 1 };
oid cONSTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 38, 1, 1 };
oid networkConnectionTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 39, 1, 1 };
oid x25PLETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 40, 1, 1 };
oid x25PLEIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 43, 1, 1 };
oid x25PLEIVMO_DTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 44, 1, 1 };
oid x25PLEIVMO_DCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 45, 1, 1 };
oid permanentVirtualCircuitTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 50, 1, 1 };
oid permanentVirtualCircuit_DTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 51, 1, 1 };
oid permanentVirtualCircuit_DCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 52, 1, 1 };
oid virtualCallIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 53, 1, 1 };
oid switchedVirtualCallTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 54, 1, 1 };
oid virtualCall_DTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 55, 1, 1 };
oid virtualCall_DCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 56, 1, 1 };
oid dSeriesCountsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 57, 1, 1 };
oid adjacencyTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 58, 1, 1 };
oid reachableAddressTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 63, 1, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid lLCConnection2Event_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 0 };
oid lLCClessACKEvent_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 0 };
oid lLCStationEvent_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 0 };

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid physicalBitErrorThresholdReached_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid physicalConnectionError_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid phsyicalConnectionEstablished_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid physicalLossOfSignal_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid physicalLossOfSynchronization_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid fRMR_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid pdusDiscarded1_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid pdusDiscarded2_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid pduRetransmissions_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid acknowledgeTimeout_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid busyStateTimeout_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid rejectTimeout_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid pBitTimeout_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid type2Violation_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid retranmissions_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid type3Violation_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid noResponse_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid pdusDiscarded_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid bufferProblems_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationPDUHeader_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid reachabilityChange_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationData_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid constraintViolation_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationReceivingAdjacency_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationIDLength_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationAreaAddress_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationAreaAddresses_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationSourceId_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationMaximumAreaAddresses_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationVirtualLinkChange_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationVirtualLinkAddress_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationSystemId_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationVersion_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationDesignatedIntermediateSystemChange_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationOverloadStateChange_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid reservedName_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };
oid notificationLSPHeader_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3 };

/*
 * Other oids defined in this MIB.
 */
oid osiObjectGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 2, 1 };
oid osiNotificationGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 2, 1 };
oid osiTotalCompliance_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 2, 2 };

/*
 * variable7 dlMIB_variables: tree for dlMIB
 * This variable defines function callbacks and type return information for the dlMIB mib section
 */
struct variable7 dlMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   COMMUNICATIONSENTITYLOCALSAPNAMES  (4 % 256)
	{COMMUNICATIONSENTITYLOCALSAPNAMES, ASN_OBJECT_ID, RONLY, var_communicationsEntityTable, 6, {1, 1, 1, 1, 1, 2}},
#define   COMMUNICATIONSENTITYOPERATIONALSTATE  (5 % 256)
	{COMMUNICATIONSENTITYOPERATIONALSTATE, ASN_INTEGER, RONLY, var_communicationsEntityTable, 6, {1, 1, 1, 1, 1, 3}},
#define   SAP1ADDRESS           (10 % 256)
	{SAP1ADDRESS, ASN_UNSIGNED, RONLY, var_sap1Table, 6, {1, 1, 2, 1, 1, 2}},
#define   SAP1USERENTITYNAMES   (11 % 256)
	{SAP1USERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap1Table, 6, {1, 1, 2, 1, 1, 3}},
#define   SAP2ADDRESS           (15 % 256)
	{SAP2ADDRESS, ASN_OCTET_STR, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 1}},
#define   SAP2USERENTITYNAMES   (16 % 256)
	{SAP2USERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 2}},
#define   SAP2PROVIDERENTITYNAMES  (17 % 256)
	{SAP2PROVIDERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 3}},
#define   CLPROTOCOLMACHINEOPERATIONALSTATE  (22 % 256)
	{CLPROTOCOLMACHINEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_clProtocolMachineTable, 6, {1, 1, 4, 1, 1, 2}},
#define   CLPROTOCOLMACHINETOTALREMOTESAPS  (23 % 256)
	{CLPROTOCOLMACHINETOTALREMOTESAPS, ASN_COUNTER, RONLY, var_clProtocolMachineTable, 6, {1, 1, 4, 1, 1, 3}},
#define   COPROTOCOLMACHINEOPERATIONALSTATE  (28 % 256)
	{COPROTOCOLMACHINEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_coProtocolMachineTable, 6, {1, 1, 5, 1, 1, 2}},
#define   UNDERLYINGCONNECTIONNAMES  (34 % 256)
	{UNDERLYINGCONNECTIONNAMES, ASN_OBJECT_ID, RONLY, var_singlePeerConnectionTable, 6, {1, 1, 6, 1, 1, 2}},
#define   SUPPPORTEDCONNECTIONNAMES  (35 % 256)
	{SUPPPORTEDCONNECTIONNAMES, ASN_OBJECT_ID, RONLY, var_singlePeerConnectionTable, 6, {1, 1, 6, 1, 1, 3}},
#define   PHYSICALENTITYPHYSICALENTITYTITLES  (39 % 256)
	{PHYSICALENTITYPHYSICALENTITYTITLES, ASN_OBJECT_ID, RWRITE, var_physicalEntityTable, 6, {1, 1, 7, 1, 1, 1}},
#define   DATACIRCUITBITERRORSRECEIVED  (49 % 256)
	{DATACIRCUITBITERRORSRECEIVED, ASN_COUNTER, RONLY, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 1}},
#define   DATACIRCUITBITERRORSTRANSMITTED  (50 % 256)
	{DATACIRCUITBITERRORSTRANSMITTED, ASN_COUNTER, RONLY, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 2}},
#define   DATACIRCUITBITERRORSTHRESHOLD  (51 % 256)
	{DATACIRCUITBITERRORSTHRESHOLD, ASN_OPAQUE, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 3}},
#define   DATACIRCUITTYPE       (52 % 256)
	{DATACIRCUITTYPE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 4}},
#define   DATACIRCUITPHYSICALMEDIANAMES  (53 % 256)
	{DATACIRCUITPHYSICALMEDIANAMES, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 5}},
#define   DATACIRCUITPHYSICALINTERFACETYPE  (54 % 256)
	{DATACIRCUITPHYSICALINTERFACETYPE, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 6}},
#define   DATACIRCUITPHYSICALINTERFACESTANDARD  (55 % 256)
	{DATACIRCUITPHYSICALINTERFACESTANDARD, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 7}},
#define   DATACIRCUITSYNCHRONIZATIONMODE  (56 % 256)
	{DATACIRCUITSYNCHRONIZATIONMODE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 8}},
#define   DATACIRCUITTRANSMISSIONCODING  (57 % 256)
	{DATACIRCUITTRANSMISSIONCODING, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 9}},
#define   DATACIRCUITTRANSMISSIONMODE  (58 % 256)
	{DATACIRCUITTRANSMISSIONMODE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 10}},
#define   DATACIRCUITTRANSMISSIONRATE  (59 % 256)
	{DATACIRCUITTRANSMISSIONRATE, ASN_OPAQUE, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 11}},
#define   DATACIRCUITROWSTATUS  (60 % 256)
	{DATACIRCUITROWSTATUS, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 12}},
#define   PHYSICALCONNECTIONENDPOINTIDENTIFIER  (66 % 256)
	{PHYSICALCONNECTIONENDPOINTIDENTIFIER, ASN_OCTET_STR, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 1}},
#define   PHYSICALCONNECTIONPORTNUMBER  (67 % 256)
	{PHYSICALCONNECTIONPORTNUMBER, ASN_INTEGER, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 2}},
#define   PHYSICALCONNECTIONROWSTATUS  (68 % 256)
	{PHYSICALCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 3}},
#define   DATALINKENTITYPROVIDERENTITYNAMES  (72 % 256)
	{DATALINKENTITYPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_datalinkEntityTable, 6, {1, 1, 11, 1, 1, 1}},
#define   DATALINKENTITYROWSTATUS  (73 % 256)
	{DATALINKENTITYROWSTATUS, ASN_INTEGER, RWRITE, var_datalinkEntityTable, 6, {1, 1, 11, 1, 1, 2}},
#define   DLSAPROWSTATUS        (78 % 256)
	{DLSAPROWSTATUS, ASN_INTEGER, RWRITE, var_dLSAPTable, 6, {1, 1, 12, 1, 1, 1}},
#define   LAPBDLEMT1TIMER       (82 % 256)
	{LAPBDLEMT1TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 1}},
#define   LAPBDLEMT3TIMER       (83 % 256)
	{LAPBDLEMT3TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 2}},
#define   LAPBDLEMW             (84 % 256)
	{LAPBDLEMW, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 3}},
#define   LAPBDLEMXSEND         (85 % 256)
	{LAPBDLEMXSEND, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 4}},
#define   LAPBDLEMXRECEIVE      (86 % 256)
	{LAPBDLEMXRECEIVE, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 5}},
#define   LAPBDLEMT2TIMER       (87 % 256)
	{LAPBDLEMT2TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 6}},
#define   LAPBDLERECEIVEDMLPRESETS  (88 % 256)
	{LAPBDLERECEIVEDMLPRESETS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 7}},
#define   LAPBDLETIMESMT1EXPIRED  (89 % 256)
	{LAPBDLETIMESMT1EXPIRED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 8}},
#define   LAPBDLEIFRAMESREASSIGNMENTS  (90 % 256)
	{LAPBDLEIFRAMESREASSIGNMENTS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 9}},
#define   LAPBDLEMLPFRAMESRECEIVED  (91 % 256)
	{LAPBDLEMLPFRAMESRECEIVED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 10}},
#define   LAPBDLEMLPFRAMESSENT  (92 % 256)
	{LAPBDLEMLPFRAMESSENT, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 11}},
#define   LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD  (93 % 256)
	{LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 12}},
#define   LAPBDLERECEIVEDMLPFRAMESINGUARDREGION  (94 % 256)
	{LAPBDLERECEIVEDMLPFRAMESINGUARDREGION, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 13}},
#define   LAPBDLEROWSTATUS      (95 % 256)
	{LAPBDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 14}},
#define   SLPPMADMINISTRATIVESTATE  (100 % 256)
	{SLPPMADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 14, 1, 1, 3}},
#define   SLPPMROWSTATUS        (101 % 256)
	{SLPPMROWSTATUS, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 14, 1, 1, 4}},
#define   SLPCONNECTIONINTERFACETYPE  (107 % 256)
	{SLPCONNECTIONINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 1}},
#define   SLPCONNECTIONK        (108 % 256)
	{SLPCONNECTIONK, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 2}},
#define   SLPCONNECTIONN1       (109 % 256)
	{SLPCONNECTIONN1, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 3}},
#define   SLPCONNECTIONN2       (110 % 256)
	{SLPCONNECTIONN2, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 4}},
#define   SLPCONNECTIONSEQUENCEMODULUS  (111 % 256)
	{SLPCONNECTIONSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 5}},
#define   SLPCONNECTIONT1TIMER  (112 % 256)
	{SLPCONNECTIONT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 6}},
#define   SLPCONNECTIONT2TIMER  (113 % 256)
	{SLPCONNECTIONT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 7}},
#define   SLPCONNECTIONFCSERRORSRECEIVED  (114 % 256)
	{SLPCONNECTIONFCSERRORSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 8}},
#define   SLPCONNECTIONFRMRSRECEIVED  (115 % 256)
	{SLPCONNECTIONFRMRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 9}},
#define   SLPCONNECTIONFRMRSSENT  (116 % 256)
	{SLPCONNECTIONFRMRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 10}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED  (117 % 256)
	{SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 11}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSSENT  (118 % 256)
	{SLPCONNECTIONIFRAMEDATAOCTETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 12}},
#define   SLPCONNECTIONIFRAMESRECEIVED  (119 % 256)
	{SLPCONNECTIONIFRAMESRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 13}},
#define   SLPCONNECTIONIFRAMESSENT  (120 % 256)
	{SLPCONNECTIONIFRAMESSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 14}},
#define   SLPCONNECTIONPOLLSRECEIVED  (121 % 256)
	{SLPCONNECTIONPOLLSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 15}},
#define   SLPCONNECTIONREJSRECEIVED  (122 % 256)
	{SLPCONNECTIONREJSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 16}},
#define   SLPCONNECTIONREJSSENT  (123 % 256)
	{SLPCONNECTIONREJSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 17}},
#define   SLPCONNECTIONRNRSRECEIVED  (124 % 256)
	{SLPCONNECTIONRNRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 18}},
#define   SLPCONNECTIONRNRSSENT  (125 % 256)
	{SLPCONNECTIONRNRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 19}},
#define   SLPCONNECTIONSABMSRECEIVED  (126 % 256)
	{SLPCONNECTIONSABMSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 20}},
#define   SLPCONNECTIONSABMSSENT  (127 % 256)
	{SLPCONNECTIONSABMSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 21}},
#define   SLPCONNECTIONPROTOCOLSTATE  (128 % 256)
	{SLPCONNECTIONPROTOCOLSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 22}},
#define   SLPCONNECTIONTIMEST1EXPIRED  (129 % 256)
	{SLPCONNECTIONTIMEST1EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 23}},
#define   SLPCONNECTIONT3TIMER  (130 % 256)
	{SLPCONNECTIONT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 24}},
#define   SLPCONNECTIONTIMEST3EXPIRED  (131 % 256)
	{SLPCONNECTIONTIMEST3EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 25}},
#define   SLPCONNECTIONT4TIMER  (132 % 256)
	{SLPCONNECTIONT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 26}},
#define   SLPCONNECTIONTIMEST4EXPIRED  (133 % 256)
	{SLPCONNECTIONTIMEST4EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 27}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED  (134 % 256)
	{SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 28}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSSENT  (135 % 256)
	{SLPCONNECTIONABNORMALLINKDISCONNECTSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 29}},
#define   SLPCONNECTIONLINKRESETSRECEIVED  (136 % 256)
	{SLPCONNECTIONLINKRESETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 30}},
#define   SLPCONNECTIONLINKRESETSSENT  (137 % 256)
	{SLPCONNECTIONLINKRESETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 31}},
#define   SLPCONNECTIONTIMESN2REACHED  (138 % 256)
	{SLPCONNECTIONTIMESN2REACHED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 32}},
#define   SLPCONNECTIONADMINISTRATIVESTATE  (139 % 256)
	{SLPCONNECTIONADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 33}},
#define   SLPCONNECTIONOPERATIONALSTATE  (140 % 256)
	{SLPCONNECTIONOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 34}},
#define   SLPCONNECTIONUSAGESTATE  (141 % 256)
	{SLPCONNECTIONUSAGESTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 35}},
#define   SLPCONNECTIONPROCEDURALSTATUS  (142 % 256)
	{SLPCONNECTIONPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 36}},
#define   SLPCONNECTIONALARMSTATUS  (143 % 256)
	{SLPCONNECTIONALARMSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 37}},
#define   SLPCONNECTIONROWSTATUS  (144 % 256)
	{SLPCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 38}},
#define   SLPCONNECTIONIVMOID   (150 % 256)
	{SLPCONNECTIONIVMOID, ASN_OCTET_STR, RONLY, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 1}},
#define   SLPCONNECTIONIVMOINTERFACETYPE  (151 % 256)
	{SLPCONNECTIONIVMOINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 2}},
#define   SLPCONNECTIONIVMOK    (152 % 256)
	{SLPCONNECTIONIVMOK, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 3}},
#define   SLPCONNECTIONIVMON1   (153 % 256)
	{SLPCONNECTIONIVMON1, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 4}},
#define   SLPCONNECTIONIVMON2   (154 % 256)
	{SLPCONNECTIONIVMON2, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 5}},
#define   SLPCONNECTIONIVMOSEQUENCEMODULUS  (155 % 256)
	{SLPCONNECTIONIVMOSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 6}},
#define   SLPCONNECTIONIVMOT1TIMER  (156 % 256)
	{SLPCONNECTIONIVMOT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 7}},
#define   SLPCONNECTIONIVMOT2TIMER  (157 % 256)
	{SLPCONNECTIONIVMOT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 8}},
#define   SLPCONNECTIONIVMOT3TIMER  (158 % 256)
	{SLPCONNECTIONIVMOT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 9}},
#define   SLPCONNECTIONIVMOT4TIMER  (159 % 256)
	{SLPCONNECTIONIVMOT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 10}},
#define   SLPCONNECTIONIVMOROWSTATUS  (160 % 256)
	{SLPCONNECTIONIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 11}},
#define   MACDLEROWSTATUS       (164 % 256)
	{MACDLEROWSTATUS, ASN_INTEGER, RWRITE, var_mACDLETable, 6, {1, 1, 17, 1, 1, 1}},
#define   MACOPERATIONALSTATE   (168 % 256)
	{MACOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mACTable, 6, {1, 1, 18, 1, 1, 1}},
#define   MACROWSTATUS          (170 % 256)
	{MACROWSTATUS, ASN_INTEGER, RWRITE, var_mACTable, 6, {1, 1, 18, 1, 1, 3}},
#define   LLCDLEROWSTATUS       (174 % 256)
	{LLCDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lLCDLETable, 6, {1, 1, 19, 1, 1, 1}},
#define   LLCCLPMROWSTATUS      (179 % 256)
	{LLCCLPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCLPMTable, 6, {1, 1, 20, 1, 1, 1}},
#define   LLCCOPMROWSTATUS      (184 % 256)
	{LLCCOPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCOPMTable, 6, {1, 1, 21, 1, 1, 1}},
#define   RESOURCETYPEIDNAME    (188 % 256)
	{RESOURCETYPEIDNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 1}},
#define   RESOURCEINFOMANUFACTUREROUI  (189 % 256)
	{RESOURCEINFOMANUFACTUREROUI, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 2}},
#define   RESOURCEINFOMANUFACTURERNAME  (190 % 256)
	{RESOURCEINFOMANUFACTURERNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 3}},
#define   RESOURCEINFOMANUFACTURERPRODUCTNAME  (191 % 256)
	{RESOURCEINFOMANUFACTURERPRODUCTNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 4}},
#define   RESOURCEINFOMANUFACTURERPRODUCTVERSION  (192 % 256)
	{RESOURCEINFOMANUFACTURERPRODUCTVERSION, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 5}},
#define   LLCSTATIONLLCNAME     (197 % 256)
	{LLCSTATIONLLCNAME, ASN_OCTET_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 1}},
#define   LLCSTATIONMAXIMUMLSAPSCONFIGURED  (198 % 256)
	{LLCSTATIONMAXIMUMLSAPSCONFIGURED, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 2}},
#define   LLCSTATIONNUMBEROFACTIVELSAPS  (199 % 256)
	{LLCSTATIONNUMBEROFACTIVELSAPS, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 3}},
#define   LLCSTATIONSUPPORTEDSERVICESTYPES  (200 % 256)
	{LLCSTATIONSUPPORTEDSERVICESTYPES, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 4}},
#define   LLCSTATIONSTATUS      (201 % 256)
	{LLCSTATIONSTATUS, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 5}},
#define   LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE  (202 % 256)
	{LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 6}},
#define   LLCSTATIONTYPE1MAXIMUMRETRYCOUNT  (203 % 256)
	{LLCSTATIONTYPE1MAXIMUMRETRYCOUNT, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 7}},
#define   LLCSTATIONMAXIMUMPDUN3  (204 % 256)
	{LLCSTATIONMAXIMUMPDUN3, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 8}},
#define   LLCSTATIONMAXIMUMRETRANSMISSIONS4  (205 % 256)
	{LLCSTATIONMAXIMUMRETRANSMISSIONS4, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 9}},
#define   LLCSTATIONRECEIVEVARIABLELIFETIME  (206 % 256)
	{LLCSTATIONRECEIVEVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 10}},
#define   LLCSTATIONTRANSMITVARIABLELIFETIME  (207 % 256)
	{LLCSTATIONTRANSMITVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 11}},
#define   LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE  (208 % 256)
	{LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 12}},
#define   LLCSTATIONTYPE3RETRANSMISSIONS  (209 % 256)
	{LLCSTATIONTYPE3RETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 13}},
#define   LLCSTATIONAVGBUFFERUSESIZE  (210 % 256)
	{LLCSTATIONAVGBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 14}},
#define   LLCSTATIONBUFFERPROBLEMS  (211 % 256)
	{LLCSTATIONBUFFERPROBLEMS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 15}},
#define   LLCSTATIONBUFFERSIZE  (212 % 256)
	{LLCSTATIONBUFFERSIZE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 16}},
#define   LLCSTATIONMAXBUFFERUSESIZE  (213 % 256)
	{LLCSTATIONMAXBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 17}},
#define   LLCSTATIONINACTIVELSAP  (214 % 256)
	{LLCSTATIONINACTIVELSAP, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 18}},
#define   LLCSTATIONPDUSDISCARD  (215 % 256)
	{LLCSTATIONPDUSDISCARD, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 19}},
#define   LLCSTATIONSTRINDICATOR  (216 % 256)
	{LLCSTATIONSTRINDICATOR, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 20}},
#define   LLCSTATIONVERSIONNUMBER  (217 % 256)
	{LLCSTATIONVERSIONNUMBER, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 21}},
#define   LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS  (218 % 256)
	{LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 22}},
#define   LLCSAPADDRESS         (224 % 256)
	{LLCSAPADDRESS, ASN_OCTET_STR, RONLY, var_lLCSAPTable, 6, {1, 1, 24, 1, 1, 2}},
#define   LLCSAPRDE             (225 % 256)
	{LLCSAPRDE, ASN_INTEGER, RONLY, var_lLCSAPTable, 6, {1, 1, 24, 1, 1, 3}},
#define   RDESETUPAGINGENABLED  (230 % 256)
	{RDESETUPAGINGENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 1}},
#define   RDESETUPAGINGVALUE    (231 % 256)
	{RDESETUPAGINGVALUE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 2}},
#define   RDESETUPENABLETYPE2RESET  (232 % 256)
	{RDESETUPENABLETYPE2RESET, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 3}},
#define   RDESETUPMAXIMUMROUTEDESCRIPTORS  (233 % 256)
	{RDESETUPMAXIMUMROUTEDESCRIPTORS, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 4}},
#define   RDESETUPMAXIMUMRESPONSETIME  (234 % 256)
	{RDESETUPMAXIMUMRESPONSETIME, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 5}},
#define   RDESETUPMINIMUMPDUSIZE  (235 % 256)
	{RDESETUPMINIMUMPDUSIZE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 6}},
#define   RDESETUPRDEHOLD       (236 % 256)
	{RDESETUPRDEHOLD, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 7}},
#define   RDESETUPRDEREPLACE    (237 % 256)
	{RDESETUPRDEREPLACE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 8}},
#define   RDESETUPNAME          (238 % 256)
	{RDESETUPNAME, ASN_INTEGER, RONLY, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 9}},
#define   RDESETUPRESETONTESTENABLED  (239 % 256)
	{RDESETUPRESETONTESTENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 10}},
#define   RDEPAIRDISCARDCOUNTER  (245 % 256)
	{RDEPAIRDISCARDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 2}},
#define   RDEPAIRNSRPDUCOUNTER  (246 % 256)
	{RDEPAIRNSRPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 3}},
#define   RDEPAIRNSRSELECTEDCOUNTER  (247 % 256)
	{RDEPAIRNSRSELECTEDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 4}},
#define   RDEPAIRRIF            (248 % 256)
	{RDEPAIRRIF, ASN_OCTET_STR, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 5}},
#define   RDEPAIRSRFPDUCOUNTER  (249 % 256)
	{RDEPAIRSRFPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 6}},
#define   RDEPAIRQUERYCOUNTER   (250 % 256)
	{RDEPAIRQUERYCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 7}},
#define   LLCCONNECTIONLESSNAME  (256 % 256)
	{LLCCONNECTIONLESSNAME, ASN_OCTET_STR, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 1}},
#define   LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE  (257 % 256)
	{LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 2}},
#define   LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE  (258 % 256)
	{LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 3}},
#define   LLCCONNECTIONLESSTESTRECEIVEDCOMMAND  (259 % 256)
	{LLCCONNECTIONLESSTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 4}},
#define   LLCCONNECTIONLESSTESTRECEIVEDRESPONSE  (260 % 256)
	{LLCCONNECTIONLESSTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 5}},
#define   LLCCONNECTIONLESSTESTSENTABBRESPONSE  (261 % 256)
	{LLCCONNECTIONLESSTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 6}},
#define   LLCCONNECTIONLESSTESTSENTCOMMAND  (262 % 256)
	{LLCCONNECTIONLESSTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 7}},
#define   LLCCONNECTIONLESSTESTSENTRESPONSE  (263 % 256)
	{LLCCONNECTIONLESSTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 8}},
#define   LLCCONNECTIONLESSUIRECEIVED  (264 % 256)
	{LLCCONNECTIONLESSUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 9}},
#define   LLCCONNECTIONLESSUISENT  (265 % 256)
	{LLCCONNECTIONLESSUISENT, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 10}},
#define   LLCCONNECTIONLESSXIDRECEIVEDCOMMAND  (266 % 256)
	{LLCCONNECTIONLESSXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 11}},
#define   LLCCONNECTIONLESSXIDRECEIVEDRESPONSE  (267 % 256)
	{LLCCONNECTIONLESSXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 12}},
#define   LLCCONNECTIONLESSXIDSENTCOMMAND  (268 % 256)
	{LLCCONNECTIONLESSXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 13}},
#define   LLCCONNECTIONLESSXIDSENTRESPONSE  (269 % 256)
	{LLCCONNECTIONLESSXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 14}},
#define   LLCCONNECTION2NAME    (275 % 256)
	{LLCCONNECTION2NAME, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 1}},
#define   LLCCONNECTION2MAXIMUMRETRANSMISSIONS  (276 % 256)
	{LLCCONNECTION2MAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 2}},
#define   LLCCONNECTION2RECEIVEDWINDOWSIZE  (277 % 256)
	{LLCCONNECTION2RECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 3}},
#define   LLCCONNECTION2SENDWINDOWSIZE  (278 % 256)
	{LLCCONNECTION2SENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 4}},
#define   LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE  (279 % 256)
	{LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 5}},
#define   LLCCONNECTION2BUSYSTATETIMEOUTVALUE  (280 % 256)
	{LLCCONNECTION2BUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 6}},
#define   LLCCONNECTION2PBITTIMEOUTVALUE  (281 % 256)
	{LLCCONNECTION2PBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 7}},
#define   LLCCONNECTION2REJECTTIMEOUTVALUE  (282 % 256)
	{LLCCONNECTION2REJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 8}},
#define   LLCCONNECTION2LOCALBUSY  (283 % 256)
	{LLCCONNECTION2LOCALBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 9}},
#define   LLCCONNECTION2REMOTEBUSY  (284 % 256)
	{LLCCONNECTION2REMOTEBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 10}},
#define   LLCCONNECTION2REMOTERESET  (285 % 256)
	{LLCCONNECTION2REMOTERESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 11}},
#define   LLCCONNECTION2LOCALRESET  (286 % 256)
	{LLCCONNECTION2LOCALRESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 12}},
#define   LLCCONNECTION2PROVIDERRESET  (287 % 256)
	{LLCCONNECTION2PROVIDERRESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 13}},
#define   LLCCONNECTION2ROUTE   (288 % 256)
	{LLCCONNECTION2ROUTE, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 14}},
#define   LLCCONNECTION2KSTEP   (289 % 256)
	{LLCCONNECTION2KSTEP, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 15}},
#define   LLCCONNECTION2MAXSENDWINDOWSIZE  (290 % 256)
	{LLCCONNECTION2MAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 16}},
#define   LLCCONNECTION2RECEIVEDI  (291 % 256)
	{LLCCONNECTION2RECEIVEDI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 17}},
#define   LLCCONNECTION2SENTI   (292 % 256)
	{LLCCONNECTION2SENTI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 18}},
#define   LLCCONNECTION2SENTACKS  (293 % 256)
	{LLCCONNECTION2SENTACKS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 19}},
#define   LLCCONNECTION2RECEIVEDACKS  (294 % 256)
	{LLCCONNECTION2RECEIVEDACKS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 20}},
#define   LLCCONNECTION2RECEIVEDFRMR  (295 % 256)
	{LLCCONNECTION2RECEIVEDFRMR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 21}},
#define   LLCCONNECTION2SENTFRMR  (296 % 256)
	{LLCCONNECTION2SENTFRMR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 22}},
#define   LLCCONNECTION2RECEIVEDRR  (297 % 256)
	{LLCCONNECTION2RECEIVEDRR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 23}},
#define   LLCCONNECTION2SENTRR  (298 % 256)
	{LLCCONNECTION2SENTRR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 24}},
#define   LLCCONNECTION2RECEIVEDRNR  (299 % 256)
	{LLCCONNECTION2RECEIVEDRNR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 25}},
#define   LLCCONNECTION2SENTRNR  (300 % 256)
	{LLCCONNECTION2SENTRNR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 26}},
#define   LLCCONNECTION2RECEIVEDREJ  (301 % 256)
	{LLCCONNECTION2RECEIVEDREJ, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 27}},
#define   LLCCONNECTION2SENTREJ  (302 % 256)
	{LLCCONNECTION2SENTREJ, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 28}},
#define   LLCCONNECTION2RECEIVEDSABME  (303 % 256)
	{LLCCONNECTION2RECEIVEDSABME, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 29}},
#define   LLCCONNECTION2SENTSABME  (304 % 256)
	{LLCCONNECTION2SENTSABME, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 30}},
#define   LLCCONNECTION2RECEIVEDUA  (305 % 256)
	{LLCCONNECTION2RECEIVEDUA, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 31}},
#define   LLCCONNECTION2SENTUA  (306 % 256)
	{LLCCONNECTION2SENTUA, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 32}},
#define   LLCCONNECTION2RECEIVEDDISC  (307 % 256)
	{LLCCONNECTION2RECEIVEDDISC, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 33}},
#define   LLCCONNECTION2SENTDISC  (308 % 256)
	{LLCCONNECTION2SENTDISC, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 34}},
#define   LLCCONNECTION2RECEIVEDDM  (309 % 256)
	{LLCCONNECTION2RECEIVEDDM, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 35}},
#define   LLCCONNECTION2SENTDM  (310 % 256)
	{LLCCONNECTION2SENTDM, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 36}},
#define   LLCCONNECTION2PDUSDISCARDED1  (311 % 256)
	{LLCCONNECTION2PDUSDISCARDED1, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 37}},
#define   LLCCONNECTION2PDUSDISCARDED2  (312 % 256)
	{LLCCONNECTION2PDUSDISCARDED2, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 38}},
#define   LLCCONNECTION2PDURETRANSMISSIONS  (313 % 256)
	{LLCCONNECTION2PDURETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 39}},
#define   LLCCONNECTION2OPTIONALTOLERATIONIPDUS  (314 % 256)
	{LLCCONNECTION2OPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 40}},
#define   LLCCONNECTION2DUPLICATEIPDUSRECEIVED  (315 % 256)
	{LLCCONNECTION2DUPLICATEIPDUSRECEIVED, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 41}},
#define   LLCCONNECTION2VIOLATION  (316 % 256)
	{LLCCONNECTION2VIOLATION, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 42}},
#define   LLCCONNECTION2PROTOCOLSTATE  (317 % 256)
	{LLCCONNECTION2PROTOCOLSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 43}},
#define   LLCCONNECTION2ADMINISTRATIVESTATE  (318 % 256)
	{LLCCONNECTION2ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 44}},
#define   LLCCONNECTION2OPERATIONALSTATE  (319 % 256)
	{LLCCONNECTION2OPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 45}},
#define   LLCCONNECTION2USAGESTATE  (320 % 256)
	{LLCCONNECTION2USAGESTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 46}},
#define   LLCCONNECTION2PROCEDURALSTATUS  (321 % 256)
	{LLCCONNECTION2PROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 47}},
#define   LLCCONNECTION2ALARMSTATUS  (322 % 256)
	{LLCCONNECTION2ALARMSTATUS, ASN_BIT_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 48}},
#define   LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS  (329 % 256)
	{LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 2}},
#define   LLCCONNECTION2IVMORECEIVEDWINDOWSIZE  (330 % 256)
	{LLCCONNECTION2IVMORECEIVEDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 3}},
#define   LLCCONNECTION2IVMOSENDWINDOWSIZE  (331 % 256)
	{LLCCONNECTION2IVMOSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 4}},
#define   LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE  (332 % 256)
	{LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 5}},
#define   LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE  (333 % 256)
	{LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 6}},
#define   LLCCONNECTION2IVMOBITTIMEOUTVALUE  (334 % 256)
	{LLCCONNECTION2IVMOBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 7}},
#define   LLCCONNECTION2IVMOREJECTTIMEOUTVALUE  (335 % 256)
	{LLCCONNECTION2IVMOREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 8}},
#define   LLCCONNECTION2IVMOROUTE  (336 % 256)
	{LLCCONNECTION2IVMOROUTE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 9}},
#define   LLCCONNECTION2IVMOKSTEP  (337 % 256)
	{LLCCONNECTION2IVMOKSTEP, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 10}},
#define   LLCCONNECTION2IVMOMAXSENDWINDOWSIZE  (338 % 256)
	{LLCCONNECTION2IVMOMAXSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 11}},
#define   LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS  (339 % 256)
	{LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE  (346 % 256)
	{LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS  (347 % 256)
	{LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE  (348 % 256)
	{LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 4}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND  (349 % 256)
	{LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 5}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE  (350 % 256)
	{LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 6}},
#define   LLCCONNECTIONLESSACKTESTSENTABBRESPONSE  (351 % 256)
	{LLCCONNECTIONLESSACKTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 7}},
#define   LLCCONNECTIONLESSACKTESTSENTCOMMAND  (352 % 256)
	{LLCCONNECTIONLESSACKTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 8}},
#define   LLCCONNECTIONLESSACKTESTSENTRESPONSE  (353 % 256)
	{LLCCONNECTIONLESSACKTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 9}},
#define   LLCCONNECTIONLESSACKRECEIVERESOURCES  (354 % 256)
	{LLCCONNECTIONLESSACKRECEIVERESOURCES, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 10}},
#define   LLCCONNECTIONLESSACKUIRECEIVED  (355 % 256)
	{LLCCONNECTIONLESSACKUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 11}},
#define   LLCCONNECTIONLESSACKUISENT  (356 % 256)
	{LLCCONNECTIONLESSACKUISENT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND  (357 % 256)
	{LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 13}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE  (358 % 256)
	{LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 14}},
#define   LLCCONNECTIONLESSACKXIDSENTCOMMAND  (359 % 256)
	{LLCCONNECTIONLESSACKXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 15}},
#define   LLCCONNECTIONLESSACKXIDSENTRESPONSE  (360 % 256)
	{LLCCONNECTIONLESSACKXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 16}},
#define   LLCCONNECTIONLESSACKRETRANSMISSIONS  (361 % 256)
	{LLCCONNECTIONLESSACKRETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 17}},
#define   LLCCONNECTIONLESSACKNORESPONSE  (362 % 256)
	{LLCCONNECTIONLESSACKNORESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 18}},
#define   LLCCONNECTIONLESSACKCOMMANDIP  (363 % 256)
	{LLCCONNECTIONLESSACKCOMMANDIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 19}},
#define   LLCCONNECTIONLESSACKCOMMANDIT  (364 % 256)
	{LLCCONNECTIONLESSACKCOMMANDIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 20}},
#define   LLCCONNECTIONLESSACKCOMMANDOK  (365 % 256)
	{LLCCONNECTIONLESSACKCOMMANDOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 21}},
#define   LLCCONNECTIONLESSACKCOMMANDPE  (366 % 256)
	{LLCCONNECTIONLESSACKCOMMANDPE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 22}},
#define   LLCCONNECTIONLESSACKCOMMANDRS  (367 % 256)
	{LLCCONNECTIONLESSACKCOMMANDRS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 23}},
#define   LLCCONNECTIONLESSACKCOMMANDUE  (368 % 256)
	{LLCCONNECTIONLESSACKCOMMANDUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 24}},
#define   LLCCONNECTIONLESSACKCOMMANDUN  (369 % 256)
	{LLCCONNECTIONLESSACKCOMMANDUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 25}},
#define   LLCCONNECTIONLESSACKRECEIVEDACCOMMAND  (370 % 256)
	{LLCCONNECTIONLESSACKRECEIVEDACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 26}},
#define   LLCCONNECTIONLESSACKSENTACCOMMAND  (371 % 256)
	{LLCCONNECTIONLESSACKSENTACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 27}},
#define   LLCCONNECTIONLESSACKRESPONSEIP  (372 % 256)
	{LLCCONNECTIONLESSACKRESPONSEIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 28}},
#define   LLCCONNECTIONLESSACKRESPONSEIT  (373 % 256)
	{LLCCONNECTIONLESSACKRESPONSEIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 29}},
#define   LLCCONNECTIONLESSACKRESPONSENE  (374 % 256)
	{LLCCONNECTIONLESSACKRESPONSENE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 30}},
#define   LLCCONNECTIONLESSACKRESPONSENR  (375 % 256)
	{LLCCONNECTIONLESSACKRESPONSENR, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 31}},
#define   LLCCONNECTIONLESSACKRESPONSEOK  (376 % 256)
	{LLCCONNECTIONLESSACKRESPONSEOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 32}},
#define   LLCCONNECTIONLESSACKRESPONSERS  (377 % 256)
	{LLCCONNECTIONLESSACKRESPONSERS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 33}},
#define   LLCCONNECTIONLESSACKRESPONSEUE  (378 % 256)
	{LLCCONNECTIONLESSACKRESPONSEUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 34}},
#define   LLCCONNECTIONLESSACKRESPONSEUN  (379 % 256)
	{LLCCONNECTIONLESSACKRESPONSEUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 35}},
#define   LLCCONNECTIONLESSACKVIOLATION  (380 % 256)
	{LLCCONNECTIONLESSACKVIOLATION, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 36}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE  (386 % 256)
	{LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS  (387 % 256)
	{LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKIVMOROWSTATUS  (388 % 256)
	{LLCCONNECTIONLESSACKIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 4}},
#define   NETWORKENTITYTITLES   (392 % 256)
	{NETWORKENTITYTITLES, ASN_OCTET_STR, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 1}},
#define   NETWORKENTITYSYSTEMTYPES  (393 % 256)
	{NETWORKENTITYSYSTEMTYPES, ASN_BIT_STR, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 2}},
#define   NETWORKENTITYROWSTATUS  (394 % 256)
	{NETWORKENTITYROWSTATUS, ASN_INTEGER, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 3}},
#define   NSAPROWSTATUS         (398 % 256)
	{NSAPROWSTATUS, ASN_INTEGER, RWRITE, var_nSAPTable, 6, {1, 1, 33, 1, 1, 1}},
#define   CLNSADMINISTRATIVESTATE  (403 % 256)
	{CLNSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 1}},
#define   CLNSSUPPORTEDPROTOCOLS  (404 % 256)
	{CLNSSUPPORTEDPROTOCOLS, ASN_OCTET_STR, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 2}},
#define   CLNSOPERATIONALSYSTEMTYPE  (405 % 256)
	{CLNSOPERATIONALSYSTEMTYPE, ASN_BIT_STR, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 3}},
#define   CLNSOCTETSSENTCOUNTER  (406 % 256)
	{CLNSOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 4}},
#define   CLNSOCTETSRECEIVEDCOUNTER  (407 % 256)
	{CLNSOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 5}},
#define   CLNSSEGMENTSRECEIVED  (408 % 256)
	{CLNSSEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 6}},
#define   CLNSSEGMENTSDISCARDED  (409 % 256)
	{CLNSSEGMENTSDISCARDED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 7}},
#define   CLNSASSEMBLINGSEGMENTSDISCARDED  (410 % 256)
	{CLNSASSEMBLINGSEGMENTSDISCARDED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 8}},
#define   CLNSERRORREPORTSRECEIVED  (411 % 256)
	{CLNSERRORREPORTSRECEIVED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 9}},
#define   CLNSPDUDISCARDS       (412 % 256)
	{CLNSPDUDISCARDS, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 10}},
#define   CLNSCONGESTIONDISCARDS  (413 % 256)
	{CLNSCONGESTIONDISCARDS, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 11}},
#define   CLNSMAXIMUMLIFETIME   (414 % 256)
	{CLNSMAXIMUMLIFETIME, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 12}},
#define   CLNSENABLECHECKSUM    (415 % 256)
	{CLNSENABLECHECKSUM, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 13}},
#define   CLNSROWSTATUS         (416 % 256)
	{CLNSROWSTATUS, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 14}},
#define   CLNSISISVERSION       (421 % 256)
	{CLNSISISVERSION, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 1}},
#define   CLNSISISISTYPE        (422 % 256)
	{CLNSISISISTYPE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 2}},
#define   CLNSISISSYSTEMID      (423 % 256)
	{CLNSISISSYSTEMID, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 3}},
#define   CLNSISISMAXIMUMPATHSPLITS  (424 % 256)
	{CLNSISISMAXIMUMPATHSPLITS, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 4}},
#define   CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL  (425 % 256)
	{CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 5}},
#define   CLNSISISMAXIMUMLSPGENERATIONINTERVAL  (426 % 256)
	{CLNSISISMAXIMUMLSPGENERATIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 6}},
#define   CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL  (427 % 256)
	{CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 7}},
#define   CLNSISISCOMPLETESNPINTERVAL  (428 % 256)
	{CLNSISISCOMPLETESNPINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 8}},
#define   CLNSISISORIGINATINGL1LSPBUFFERSIZE  (429 % 256)
	{CLNSISISORIGINATINGL1LSPBUFFERSIZE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 9}},
#define   CLNSISISMANUALAREAADDRESSES  (430 % 256)
	{CLNSISISMANUALAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 10}},
#define   CLNSISISMAXIMUMAREAADDRESSES  (431 % 256)
	{CLNSISISMAXIMUMAREAADDRESSES, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 11}},
#define   CLNSISISMINIMUMLSPGENERATIONINTERVAL  (432 % 256)
	{CLNSISISMINIMUMLSPGENERATIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 12}},
#define   CLNSISISPOLLESHELLORATE  (433 % 256)
	{CLNSISISPOLLESHELLORATE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 13}},
#define   CLNSISISPARTIALSNPINTERVAL  (434 % 256)
	{CLNSISISPARTIALSNPINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 14}},
#define   CLNSISISWAITINGTIME   (435 % 256)
	{CLNSISISWAITINGTIME, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 15}},
#define   CLNSISISDRISISHELLOTIMER  (436 % 256)
	{CLNSISISDRISISHELLOTIMER, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 16}},
#define   CLNSISISL1STATE       (437 % 256)
	{CLNSISISL1STATE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 17}},
#define   CLNSISISAREAADDRESSES  (438 % 256)
	{CLNSISISAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 18}},
#define   CLNSISISCORRUPTEDLSPSDETECTED  (439 % 256)
	{CLNSISISCORRUPTEDLSPSDETECTED, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 19}},
#define   CLNSISISLSPL1DATABASEOVERLOADS  (440 % 256)
	{CLNSISISLSPL1DATABASEOVERLOADS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 20}},
#define   CLNSISISMANUALADDRESSESDROPPEDFROMAREAS  (441 % 256)
	{CLNSISISMANUALADDRESSESDROPPEDFROMAREAS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 21}},
#define   CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER  (442 % 256)
	{CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 22}},
#define   CLNSISISSEQUENCENUMBERSKIPS  (443 % 256)
	{CLNSISISSEQUENCENUMBERSKIPS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 23}},
#define   CLNSISISOWNLSPPURGES  (444 % 256)
	{CLNSISISOWNLSPPURGES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 24}},
#define   CLNSISISIDFIELDLENGTHMISMATCHES  (445 % 256)
	{CLNSISISIDFIELDLENGTHMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 25}},
#define   CLNSISISMAXIMUMAREAADDRESSESMISMATCHES  (446 % 256)
	{CLNSISISMAXIMUMAREAADDRESSESMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 26}},
#define   CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES  (447 % 256)
	{CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 27}},
#define   CLNSISISLSPTOOLARGETOPROPAGATE  (448 % 256)
	{CLNSISISLSPTOOLARGETOPROPAGATE, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 28}},
#define   CLNSISISAREATRANSMITPASSWORD  (449 % 256)
	{CLNSISISAREATRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 29}},
#define   CLNSISISAREARECEIVEPASSWORDS  (450 % 256)
	{CLNSISISAREARECEIVEPASSWORDS, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 30}},
#define   CLNSISISAUTHENTICATIONFAILURES  (451 % 256)
	{CLNSISISAUTHENTICATIONFAILURES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 31}},
#define   CLNSISISROWSTATUS     (452 % 256)
	{CLNSISISROWSTATUS, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 32}},
#define   CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES  (456 % 256)
	{CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 1}},
#define   CLNSISISLEVEL2PARTITIONAREAADDRESSES  (457 % 256)
	{CLNSISISLEVEL2PARTITIONAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 2}},
#define   CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM  (458 % 256)
	{CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 3}},
#define   CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES  (459 % 256)
	{CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES, ASN_COUNTER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 4}},
#define   CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE  (460 % 256)
	{CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 5}},
#define   CLNSISISLEVEL2L2STATE  (461 % 256)
	{CLNSISISLEVEL2L2STATE, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 6}},
#define   CLNSISISLEVEL2LSPL2DATABASEOVERLOADS  (462 % 256)
	{CLNSISISLEVEL2LSPL2DATABASEOVERLOADS, ASN_COUNTER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 7}},
#define   CLNSISISLEVEL2DOMAINTRANSMITPASSWORD  (463 % 256)
	{CLNSISISLEVEL2DOMAINTRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 8}},
#define   CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS  (464 % 256)
	{CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 9}},
#define   CLNSISISLEVEL2ROWSTATUS  (465 % 256)
	{CLNSISISLEVEL2ROWSTATUS, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 10}},
#define   LINKAGEOPERATIONALSTATE  (471 % 256)
	{LINKAGEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 3}},
#define   LINKAGEADMINISTRATIVESTATE  (472 % 256)
	{LINKAGEADMINISTRATIVESTATE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 4}},
#define   LINKAGESNSERVICEPROVIDER  (473 % 256)
	{LINKAGESNSERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 5}},
#define   LINKAGESNSAP          (474 % 256)
	{LINKAGESNSAP, ASN_OBJECT_ID, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 6}},
#define   LINKAGEOPERATIONALPROTOCOLS  (475 % 256)
	{LINKAGEOPERATIONALPROTOCOLS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 7}},
#define   LINKAGEISISO9542OPERATIONALSUBSETS  (476 % 256)
	{LINKAGEISISO9542OPERATIONALSUBSETS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 8}},
#define   LINKAGEISHOLDINGTIMERMULTIPLIER  (477 % 256)
	{LINKAGEISHOLDINGTIMERMULTIPLIER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 9}},
#define   LINKAGEISISCONFIGURATIONTIMER  (478 % 256)
	{LINKAGEISISCONFIGURATIONTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 10}},
#define   LINKAGEISSUGGESTEDESCONFIGURATIONTIMER  (479 % 256)
	{LINKAGEISSUGGESTEDESCONFIGURATIONTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 11}},
#define   LINKAGEISREDIRECTHOLDINGTIME  (480 % 256)
	{LINKAGEISREDIRECTHOLDINGTIME, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 12}},
#define   LINKAGEISESREACHABILITYCHANGES  (481 % 256)
	{LINKAGEISESREACHABILITYCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 13}},
#define   LINKAGEISINVALID9542PDUS  (482 % 256)
	{LINKAGEISINVALID9542PDUS, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 14}},
#define   LINKAGEESISO9542OPERATIONALSUBSETS  (483 % 256)
	{LINKAGEESISO9542OPERATIONALSUBSETS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 15}},
#define   LINKAGEESHOLDINGTIMERMULTIPLIER  (484 % 256)
	{LINKAGEESHOLDINGTIMERMULTIPLIER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 16}},
#define   LINKAGEESMANUALISSNPAADDRESS  (485 % 256)
	{LINKAGEESMANUALISSNPAADDRESS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 17}},
#define   LINKAGEESDEFAULTESCONFIGTIMER  (486 % 256)
	{LINKAGEESDEFAULTESCONFIGTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 18}},
#define   LINKAGEESACTIVEESCONFIGTIMER  (487 % 256)
	{LINKAGEESACTIVEESCONFIGTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 19}},
#define   LINKAGEESISREACHABILITYCHANGES  (488 % 256)
	{LINKAGEESISREACHABILITYCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 20}},
#define   LINKAGEESINVALID9542PDUS  (489 % 256)
	{LINKAGEESINVALID9542PDUS, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 21}},
#define   LINKAGEENABLECHECKSUM  (490 % 256)
	{LINKAGEENABLECHECKSUM, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 22}},
#define   LINKAGEINITIALMINIMUMTIMER  (491 % 256)
	{LINKAGEINITIALMINIMUMTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 23}},
#define   LINKAGERESERVETIMER   (492 % 256)
	{LINKAGERESERVETIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 24}},
#define   LINKAGEIDLETIMER      (493 % 256)
	{LINKAGEIDLETIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 25}},
#define   LINKAGESNDCFCALLSPLACED  (494 % 256)
	{LINKAGESNDCFCALLSPLACED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 26}},
#define   LINKAGESNDCFCALLSFAILED  (495 % 256)
	{LINKAGESNDCFCALLSFAILED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 27}},
#define   LINKAGECODLCALLSPLACED  (496 % 256)
	{LINKAGECODLCALLSPLACED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 28}},
#define   LINKAGECODLCALLSFAILED  (497 % 256)
	{LINKAGECODLCALLSFAILED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 29}},
#define   LINKAGEISISTYPE       (498 % 256)
	{LINKAGEISISTYPE, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 30}},
#define   LINKAGEISISISISHELLOTIMER  (499 % 256)
	{LINKAGEISISISISHELLOTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 31}},
#define   LINKAGEISISL1DEFAULTMETRIC  (500 % 256)
	{LINKAGEISISL1DEFAULTMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 32}},
#define   LINKAGEISISL1DELAYMETRIC  (501 % 256)
	{LINKAGEISISL1DELAYMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 33}},
#define   LINKAGEISISL1EXPENSEMETRIC  (502 % 256)
	{LINKAGEISISL1EXPENSEMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 34}},
#define   LINKAGEISISL1ERRORMETRIC  (503 % 256)
	{LINKAGEISISL1ERRORMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 35}},
#define   LINKAGEISISEXTERNALDOMAIN  (504 % 256)
	{LINKAGEISISEXTERNALDOMAIN, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 36}},
#define   LINKAGEISISCHANGEDINADJACENCYSTATE  (505 % 256)
	{LINKAGEISISCHANGEDINADJACENCYSTATE, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 37}},
#define   LINKAGEISISINITIALISATIONFAILURES  (506 % 256)
	{LINKAGEISISINITIALISATIONFAILURES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 38}},
#define   LINKAGEISISREJECTEDADJACENCIES  (507 % 256)
	{LINKAGEISISREJECTEDADJACENCIES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 39}},
#define   LINKAGEISISISISCONTROLPDUSSENT  (508 % 256)
	{LINKAGEISISISISCONTROLPDUSSENT, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 40}},
#define   LINKAGEISISISISCONTROLPDUSRECEIVED  (509 % 256)
	{LINKAGEISISISISCONTROLPDUSRECEIVED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 41}},
#define   LINKAGEISISIDFIELDLENTHMISMATCHES  (510 % 256)
	{LINKAGEISISIDFIELDLENTHMISMATCHES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 42}},
#define   LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES  (511 % 256)
	{LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 43}},
#define   LINKAGEISISCIRCUITTRANSMITPASSWORD  (512 % 256)
	{LINKAGEISISCIRCUITTRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 44}},
#define   LINKAGEISISCIRCUITRECEIVEDPASSWORDS  (513 % 256)
	{LINKAGEISISCIRCUITRECEIVEDPASSWORDS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 45}},
#define   LINKAGEISISAUTHENTICATIONFAILURES  (514 % 256)
	{LINKAGEISISAUTHENTICATIONFAILURES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 46}},
#define   LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY  (515 % 256)
	{LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 47}},
#define   LINKAGEISISL1CIRCUITID  (516 % 256)
	{LINKAGEISISL1CIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 48}},
#define   LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM  (517 % 256)
	{LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 49}},
#define   LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES  (518 % 256)
	{LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 50}},
#define   LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT  (519 % 256)
	{LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 51}},
#define   LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT  (520 % 256)
	{LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 52}},
#define   LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT  (521 % 256)
	{LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 53}},
#define   LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT  (522 % 256)
	{LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 54}},
#define   LINKAGEISISPTPTCIRCUITID  (523 % 256)
	{LINKAGEISISPTPTCIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 55}},
#define   LINKAGEISISOUTGOINGCALLIVMO  (524 % 256)
	{LINKAGEISISOUTGOINGCALLIVMO, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 56}},
#define   LINKAGEISISNEIGHBORSNPAADDRESS  (525 % 256)
	{LINKAGEISISNEIGHBORSNPAADDRESS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 57}},
#define   LINKAGEISISL2DEFAULTMETRIC  (526 % 256)
	{LINKAGEISISL2DEFAULTMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 58}},
#define   LINKAGEISISL2DELAYMETRIC  (527 % 256)
	{LINKAGEISISL2DELAYMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 59}},
#define   LINKAGEISISL2EXPENSEMETRIC  (528 % 256)
	{LINKAGEISISL2EXPENSEMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 60}},
#define   LINKAGEISISL2ERRORMETRIC  (529 % 256)
	{LINKAGEISISL2ERRORMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 61}},
#define   LINKAGEISISMANUALL2ONLYMODE  (530 % 256)
	{LINKAGEISISMANUALL2ONLYMODE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 62}},
#define   LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY  (531 % 256)
	{LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 63}},
#define   LINKAGEISISL2CIRCUITID  (532 % 256)
	{LINKAGEISISL2CIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 64}},
#define   LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM  (533 % 256)
	{LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 65}},
#define   LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES  (534 % 256)
	{LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 66}},
#define   LINKAGEROWSTATUS      (535 % 256)
	{LINKAGEROWSTATUS, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 67}},
#define   CONSADMINISTRATIVESTATE  (540 % 256)
	{CONSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 1}},
#define   CONSOPERATIONALSYSTEMTYPE  (541 % 256)
	{CONSOPERATIONALSYSTEMTYPE, ASN_BIT_STR, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 2}},
#define   CONSROWSTATUS         (542 % 256)
	{CONSROWSTATUS, ASN_INTEGER, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 3}},
#define   NETWORKCONNECTIONLOCALNSAPMO  (548 % 256)
	{NETWORKCONNECTIONLOCALNSAPMO, ASN_OCTET_STR, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 1}},
#define   NETWORKCONNECTIONREMOTENSAPADDRESS  (549 % 256)
	{NETWORKCONNECTIONREMOTENSAPADDRESS, ASN_OCTET_STR, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 2}},
#define   NETWORKCONNECTIONROWSTATUS  (550 % 256)
	{NETWORKCONNECTIONROWSTATUS, ASN_INTEGER, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 3}},
#define   X25PLEOPERATIONALSTATE  (554 % 256)
	{X25PLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 2}},
#define   X25PLEADMINISTRATIVESTATE  (555 % 256)
	{X25PLEADMINISTRATIVESTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 3}},
#define   X25PLEPROTOCOLVERSIONSUPPORTED  (556 % 256)
	{X25PLEPROTOCOLVERSIONSUPPORTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 4}},
#define   X25PLELOCALDTEADDRESS  (557 % 256)
	{X25PLELOCALDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 5}},
#define   X25PLEMODE            (558 % 256)
	{X25PLEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 6}},
#define   X25PLEDEFAULTTHROUGHPUTCLASSES  (559 % 256)
	{X25PLEDEFAULTTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 7}},
#define   X25PLEFLOWCONTROLPARAMETERNEGOTIATION  (560 % 256)
	{X25PLEFLOWCONTROLPARAMETERNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 8}},
#define   X25PLEDEFAULTPACKAGESIZES  (561 % 256)
	{X25PLEDEFAULTPACKAGESIZES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 9}},
#define   X25PLETHROUGHPUTCLASSNEGOTIATION  (562 % 256)
	{X25PLETHROUGHPUTCLASSNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 10}},
#define   X25PLESNSERVICEPROVIDER  (563 % 256)
	{X25PLESNSERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 11}},
#define   X25PLESNSAP           (564 % 256)
	{X25PLESNSAP, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 12}},
#define   X25PELOGICALCHANNELASSIGNMENTS  (565 % 256)
	{X25PELOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 13}},
#define   X25PLEINTERFACEMODE   (566 % 256)
	{X25PLEINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 14}},
#define   X25PLEDEFAULTTHROUGHPUTCLASS  (567 % 256)
	{X25PLEDEFAULTTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 15}},
#define   X25PLEFLOWCONTROLNEGOTIATIONPERMITTED  (568 % 256)
	{X25PLEFLOWCONTROLNEGOTIATIONPERMITTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 16}},
#define   X25PLECALLDEFLECTIONSUBSCRIPTION  (569 % 256)
	{X25PLECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 17}},
#define   X25PLEMAXACTIVECIRCUITS  (570 % 256)
	{X25PLEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 18}},
#define   X25PLERESTARTTIME     (571 % 256)
	{X25PLERESTARTTIME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 19}},
#define   X25PLEDEFAULTPACKETSIZE  (572 % 256)
	{X25PLEDEFAULTPACKETSIZE, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 20}},
#define   X25PLEDEFAULTWINDOWSIZE  (573 % 256)
	{X25PLEDEFAULTWINDOWSIZE, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 21}},
#define   X25PLEMINIMUMRECALLTIMER  (574 % 256)
	{X25PLEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 22}},
#define   X25PLERESTARTCOUNT    (575 % 256)
	{X25PLERESTARTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 23}},
#define   X25PLESN_SERVICEPROVIDER  (576 % 256)
	{X25PLESN_SERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 24}},
#define   X25PLESN_SA_P         (577 % 256)
	{X25PLESN_SA_P, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 25}},
#define   X25PLELOGICALCHANNELASSIGNMENTS  (578 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 26}},
#define   X25PLEPACKETSEQUENCING  (579 % 256)
	{X25PLEPACKETSEQUENCING, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 27}},
#define   X25PLEOCTETSSENTCOUNTER  (580 % 256)
	{X25PLEOCTETSSENTCOUNTER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 28}},
#define   X25PLEOCTETSRECEIVEDCOUNTER  (581 % 256)
	{X25PLEOCTETSRECEIVEDCOUNTER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 29}},
#define   X25PLEDATAPACKETSSENT  (582 % 256)
	{X25PLEDATAPACKETSSENT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 30}},
#define   X25PLEDATAPACKETSRECEIVED  (583 % 256)
	{X25PLEDATAPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 31}},
#define   X25PLECALLATTEMPTS    (584 % 256)
	{X25PLECALLATTEMPTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 32}},
#define   X25PLECALLSCONNECTED  (585 % 256)
	{X25PLECALLSCONNECTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 33}},
#define   X25PLEPROVIDERINITIATEDDISCONNECTS  (586 % 256)
	{X25PLEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 34}},
#define   X25PLECALLTIMEOUTS    (587 % 256)
	{X25PLECALLTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 35}},
#define   X25PLECLEARTIMEOUTS   (588 % 256)
	{X25PLECLEARTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 36}},
#define   X25PLEREMOTELYINITIATEDRESETS  (589 % 256)
	{X25PLEREMOTELYINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 37}},
#define   X25PLEDATARETRANSMISSIONTIMEREXPIRIES  (590 % 256)
	{X25PLEDATARETRANSMISSIONTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 38}},
#define   X25PLEPROVIDERINITIATEDRESETS  (591 % 256)
	{X25PLEPROVIDERINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 39}},
#define   X25PLERESETTIMEOUTS   (592 % 256)
	{X25PLERESETTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 40}},
#define   X25PLEREMOTELYINITIATEDRESTARTS  (593 % 256)
	{X25PLEREMOTELYINITIATEDRESTARTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 41}},
#define   X25PLERESTARTCOUNTSEXCEEDED  (594 % 256)
	{X25PLERESTARTCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 42}},
#define   X25PLEPROTOCOLERRORSDETECTEDLOCALLY  (595 % 256)
	{X25PLEPROTOCOLERRORSDETECTEDLOCALLY, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 43}},
#define   X25PLEPROTOCOLERRORSACCUSEDOF  (596 % 256)
	{X25PLEPROTOCOLERRORSACCUSEDOF, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 44}},
#define   X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  (597 % 256)
	{X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 45}},
#define   X25PLECLEARCOUNTSEXCEEDED  (598 % 256)
	{X25PLECLEARCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 46}},
#define   X25PLEPLECLIENTMONAME  (599 % 256)
	{X25PLEPLECLIENTMONAME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 47}},
#define   X25PLEREGISTRATIONREQUESTTIME  (600 % 256)
	{X25PLEREGISTRATIONREQUESTTIME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 48}},
#define   X25PLEREGISTRATIONREQUESTCOUNT  (601 % 256)
	{X25PLEREGISTRATIONREQUESTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 49}},
#define   X25PLEREGISTRATIONPERMITTED  (602 % 256)
	{X25PLEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 50}},
#define   X25PLEROWSTATUS       (603 % 256)
	{X25PLEROWSTATUS, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 51}},
#define   X25PLE_DTECALLDEFLECTIONSUBSCRIPTION  (607 % 256)
	{X25PLE_DTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 1}},
#define   X25PLE_DTECALLREQUESTRESPONSETIMER  (608 % 256)
	{X25PLE_DTECALLREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 2}},
#define   X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING  (609 % 256)
	{X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 3}},
#define   X25PLE_DTEMAXACTIVECIRCUITS  (610 % 256)
	{X25PLE_DTEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 4}},
#define   X25PLE_DTEMINIMUMRECALLTIMER  (611 % 256)
	{X25PLE_DTEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 5}},
#define   X25PLE_DTERESETREQUESTRESPONSETIMER  (612 % 256)
	{X25PLE_DTERESETREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 6}},
#define   X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT  (613 % 256)
	{X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 7}},
#define   X25PLE_DTERESTARTREQUESTRESPONSETIMER  (614 % 256)
	{X25PLE_DTERESTARTREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 8}},
#define   X25PLE_DTECLEARREQUESTRESPONSETIMER  (615 % 256)
	{X25PLE_DTECLEARREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 9}},
#define   X25PLE_DTEINTERRUPTRESPONSETIMER  (616 % 256)
	{X25PLE_DTEINTERRUPTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 10}},
#define   X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT  (617 % 256)
	{X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 11}},
#define   X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT  (618 % 256)
	{X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 12}},
#define   X25PLE_DTECALLATTEMPTS  (619 % 256)
	{X25PLE_DTECALLATTEMPTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 13}},
#define   X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY  (620 % 256)
	{X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 14}},
#define   X25PLE_DTEPROTOCOLERRORSACCUSEDOF  (621 % 256)
	{X25PLE_DTEPROTOCOLERRORSACCUSEDOF, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 15}},
#define   X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  (622 % 256)
	{X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 16}},
#define   X25PLE_DTEOCTETSRECEIVEDCOUNTER  (623 % 256)
	{X25PLE_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 17}},
#define   X25PLE_DTEOCTETSSENTCOUNTER  (624 % 256)
	{X25PLE_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 18}},
#define   X25PLE_DTECALLTIMEOUTS  (625 % 256)
	{X25PLE_DTECALLTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 19}},
#define   X25PLE_DTECALLSCONNECTED  (626 % 256)
	{X25PLE_DTECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 20}},
#define   X25PLE_DTECLEARCOUNTSEXCEEDED  (627 % 256)
	{X25PLE_DTECLEARCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 21}},
#define   X25PLE_DTECLEARTIMEOUTS  (628 % 256)
	{X25PLE_DTECLEARTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 22}},
#define   X25PLE_DTEDATAPACKETSRECEIVED  (629 % 256)
	{X25PLE_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 23}},
#define   X25PLE_DTEDATAPACKETSSENT  (630 % 256)
	{X25PLE_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 24}},
#define   X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES  (631 % 256)
	{X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 25}},
#define   X25PLE_DTEPROVIDERINITIATEDRESETS  (632 % 256)
	{X25PLE_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 26}},
#define   X25PLE_DTEPROVIDERINITIATEDDISCONNECTS  (633 % 256)
	{X25PLE_DTEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 27}},
#define   X25PLE_DTEREMOTELYINITIATEDRESETS  (634 % 256)
	{X25PLE_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 28}},
#define   X25PLE_DTEREMOTELYINITIATEDRESTARTS  (635 % 256)
	{X25PLE_DTEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 29}},
#define   X25PLE_DTERESETTIMEOUTS  (636 % 256)
	{X25PLE_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 30}},
#define   X25PLE_DTERESTARTCOUNTSEXCEEDED  (637 % 256)
	{X25PLE_DTERESTARTCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 31}},
#define   X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER  (638 % 256)
	{X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 32}},
#define   X25PLE_DTEWINDOWROTATIONTIMER  (639 % 256)
	{X25PLE_DTEWINDOWROTATIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 33}},
#define   X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT  (640 % 256)
	{X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 34}},
#define   X25PLE_DTEREJECTRESPONSETIMER  (641 % 256)
	{X25PLE_DTEREJECTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 35}},
#define   X25PLE_DTEREJECTRETRANSMISSIONCOUNT  (642 % 256)
	{X25PLE_DTEREJECTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 36}},
#define   X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER  (643 % 256)
	{X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 37}},
#define   X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT  (644 % 256)
	{X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 38}},
#define   X25PLE_DTEREGISTRATIONPERMITTED  (645 % 256)
	{X25PLE_DTEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 39}},
#define   X25PLE_DCECALLATTEMPTS  (649 % 256)
	{X25PLE_DCECALLATTEMPTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 1}},
#define   X25PLE_DCECALLSCONNECTED  (650 % 256)
	{X25PLE_DCECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 2}},
#define   X25PLE_DCECUG         (651 % 256)
	{X25PLE_DCECUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 3}},
#define   X25PLE_DCEFASTSELECTACCEPTANCE  (652 % 256)
	{X25PLE_DCEFASTSELECTACCEPTANCE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 4}},
#define   X25PLE_DCEINCOMINGCALLSBARRED  (653 % 256)
	{X25PLE_DCEINCOMINGCALLSBARRED, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 5}},
#define   X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING  (654 % 256)
	{X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 6}},
#define   X25PLE_DCEOUTGOINGCALLSBARRED  (655 % 256)
	{X25PLE_DCEOUTGOINGCALLSBARRED, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 7}},
#define   X25PLE_DCEDATAPACKETSRECEIVED  (656 % 256)
	{X25PLE_DCEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 8}},
#define   X25PLE_DCEDATAPACKETSSENT  (657 % 256)
	{X25PLE_DCEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 9}},
#define   X25PLE_DCEINTERRUPTPACKETSRECEIVED  (658 % 256)
	{X25PLE_DCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 10}},
#define   X25PLE_DCEINTERRUPTPACKETSSENT  (659 % 256)
	{X25PLE_DCEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 11}},
#define   X25PLE_DCEINTERRUPTTIMEREXPIRIES  (660 % 256)
	{X25PLE_DCEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 12}},
#define   X25PLE_DCEOCTETSRECEIVEDCOUNTER  (661 % 256)
	{X25PLE_DCEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 13}},
#define   X25PLE_DCEOCTETSSENTCOUNTER  (662 % 256)
	{X25PLE_DCEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 14}},
#define   X25PLE_DCEPROVIDERINITIATEDDISCONNECTS  (663 % 256)
	{X25PLE_DCEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 15}},
#define   X25PLE_DCEPROVIDERINITIATEDRESETS  (664 % 256)
	{X25PLE_DCEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 16}},
#define   X25PLE_DCEREMOTELYINITIATEDRESTARTS  (665 % 256)
	{X25PLE_DCEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 17}},
#define   X25PLE_DCEREMOTELYINITIATEDRESETS  (666 % 256)
	{X25PLE_DCEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 18}},
#define   X25PLE_DCERESETTIMEOUTS  (667 % 256)
	{X25PLE_DCERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 19}},
#define   X25PLE_DCEX25SEGMENTSRECEIVED  (668 % 256)
	{X25PLE_DCEX25SEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 20}},
#define   X25PLE_DCEX25SEGMENTSSENT  (669 % 256)
	{X25PLE_DCEX25SEGMENTSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 21}},
#define   X25PLE_DCEBILATERALCUG  (670 % 256)
	{X25PLE_DCEBILATERALCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 22}},
#define   X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS  (671 % 256)
	{X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 23}},
#define   X25PLE_DCECALLDEFLECTIONSUBSCRIPTION  (672 % 256)
	{X25PLE_DCECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 24}},
#define   X25PLE_DCECALLREDIRECTION  (673 % 256)
	{X25PLE_DCECALLREDIRECTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 25}},
#define   X25PLE_DCECHARGINGINFORMATION  (674 % 256)
	{X25PLE_DCECHARGINGINFORMATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 26}},
#define   X25PLE_DCECUGWITHINCOMINGACCESS  (675 % 256)
	{X25PLE_DCECUGWITHINCOMINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 27}},
#define   X25PLE_DCECUGWITHOUTGOINGACCESS  (676 % 256)
	{X25PLE_DCECUGWITHOUTGOINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 28}},
#define   X25PLE_DCEDBITMODIFICATION  (677 % 256)
	{X25PLE_DCEDBITMODIFICATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 29}},
#define   X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT  (678 % 256)
	{X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 30}},
#define   X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING  (679 % 256)
	{X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 31}},
#define   X25PLE_DCEHUNTGROUP   (680 % 256)
	{X25PLE_DCEHUNTGROUP, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 32}},
#define   X25PLE_DCEINCOMINGCALLBARREDWITHINCUG  (681 % 256)
	{X25PLE_DCEINCOMINGCALLBARREDWITHINCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 33}},
#define   X25PLE_DCELOCALCHARGINGPREVENTION  (682 % 256)
	{X25PLE_DCELOCALCHARGINGPREVENTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 34}},
#define   X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES  (683 % 256)
	{X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 35}},
#define   X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES  (684 % 256)
	{X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 36}},
#define   X25PLE_DCENUIOVERRIDE  (685 % 256)
	{X25PLE_DCENUIOVERRIDE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 37}},
#define   X25PLE_DCENUISUBSCRIPTION  (686 % 256)
	{X25PLE_DCENUISUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 38}},
#define   X25PLE_DCEONEWAYLOGICALCHANNELINCOMING  (687 % 256)
	{X25PLE_DCEONEWAYLOGICALCHANNELINCOMING, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 39}},
#define   X25PLE_DCEONLINEFACILITYREGISTRATION  (688 % 256)
	{X25PLE_DCEONLINEFACILITYREGISTRATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 40}},
#define   X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG  (689 % 256)
	{X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 41}},
#define   X25PLE_DCEPACKETRETRANSMISSION  (690 % 256)
	{X25PLE_DCEPACKETRETRANSMISSION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 42}},
#define   X25PLE_DCEREVERSECHARGINGACCEPTANCE  (691 % 256)
	{X25PLE_DCEREVERSECHARGINGACCEPTANCE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 43}},
#define   X25PLE_DCEROASUBSCRIPTION  (692 % 256)
	{X25PLE_DCEROASUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 44}},
#define   X25PLE_DCECLEARINDICATION  (693 % 256)
	{X25PLE_DCECLEARINDICATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 45}},
#define   X25PLE_DCEINCOMINGCALL  (694 % 256)
	{X25PLE_DCEINCOMINGCALL, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 46}},
#define   X25PLE_DCERESETINDICATION  (695 % 256)
	{X25PLE_DCERESETINDICATION, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 47}},
#define   X25PLE_DCERESTARTINDICATION  (696 % 256)
	{X25PLE_DCERESTARTINDICATION, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 48}},
#define   X25PLEIVMOLOCALDTEADDRESS  (700 % 256)
	{X25PLEIVMOLOCALDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 2}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTS  (701 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 3}},
#define   X25PLEIVMOSN_SERVICEPROVIDER  (702 % 256)
	{X25PLEIVMOSN_SERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 4}},
#define   X25PLEIVMODEFAULTPACKETSIZES  (703 % 256)
	{X25PLEIVMODEFAULTPACKETSIZES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 5}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASSES  (704 % 256)
	{X25PLEIVMODEFAULTTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 6}},
#define   X25PLEIVMODEFAULTWINDOWSIZES  (705 % 256)
	{X25PLEIVMODEFAULTWINDOWSIZES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 7}},
#define   X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION  (706 % 256)
	{X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 8}},
#define   X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION  (707 % 256)
	{X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 9}},
#define   X25PLEIVMOX25PLEMODE  (708 % 256)
	{X25PLEIVMOX25PLEMODE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 10}},
#define   X25PLEIVMOINTERFACEMODE  (709 % 256)
	{X25PLEIVMOINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 11}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASS  (710 % 256)
	{X25PLEIVMODEFAULTTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 12}},
#define   X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED  (711 % 256)
	{X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 13}},
#define   X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION  (712 % 256)
	{X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 14}},
#define   X25PLEIVMOMAXACTIVECIRCUITS  (713 % 256)
	{X25PLEIVMOMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 15}},
#define   X25PLEIVMORESTARTTIME  (714 % 256)
	{X25PLEIVMORESTARTTIME, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 16}},
#define   X25PLEIVMODEFAULTPACKETSIZE  (715 % 256)
	{X25PLEIVMODEFAULTPACKETSIZE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 17}},
#define   X25PLEIVMODEFAULTWINDOWSIZE  (716 % 256)
	{X25PLEIVMODEFAULTWINDOWSIZE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 18}},
#define   X25PLEIVMOMINIMUMRECALLTIMER  (717 % 256)
	{X25PLEIVMOMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 19}},
#define   X25PLEIVMORESTARTCOUNT  (718 % 256)
	{X25PLEIVMORESTARTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 20}},
#define   X25PLEIVMOPACKETSEQUENCING  (719 % 256)
	{X25PLEIVMOPACKETSEQUENCING, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 21}},
#define   X25PLEIVMOREGISTRATIONREQUESTTIME  (720 % 256)
	{X25PLEIVMOREGISTRATIONREQUESTTIME, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 22}},
#define   X25PLEIVMOREGISTRATIONREQUESTCOUNT  (721 % 256)
	{X25PLEIVMOREGISTRATIONREQUESTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 23}},
#define   X25PLEIVMOREGISTRATIONPERMITTED  (722 % 256)
	{X25PLEIVMOREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 24}},
#define   X25PLEIVMOROWSTATUS   (723 % 256)
	{X25PLEIVMOROWSTATUS, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 25}},
#define   X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION  (727 % 256)
	{X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 1}},
#define   X25PLEIVMO_DTECALLREQUESTRESPONSETIMER  (728 % 256)
	{X25PLEIVMO_DTECALLREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 2}},
#define   X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING  (729 % 256)
	{X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 3}},
#define   X25PLEIVMO_DTEMAXACTIVECIRCUITS  (730 % 256)
	{X25PLEIVMO_DTEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 4}},
#define   X25PLEIVMO_DTEMINIMUMRECALLTIMER  (731 % 256)
	{X25PLEIVMO_DTEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 5}},
#define   X25PLEIVMO_DTERESETREQUESTRESPONSETIMER  (732 % 256)
	{X25PLEIVMO_DTERESETREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 6}},
#define   X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT  (733 % 256)
	{X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 7}},
#define   X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER  (734 % 256)
	{X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 8}},
#define   X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER  (735 % 256)
	{X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 9}},
#define   X25PLEIVMO_DTEINTERRUPTRESPONSETIMER  (736 % 256)
	{X25PLEIVMO_DTEINTERRUPTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 10}},
#define   X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT  (737 % 256)
	{X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 11}},
#define   X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT  (738 % 256)
	{X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 12}},
#define   X25PLEIVMO_DTECALLATTEMPTS  (739 % 256)
	{X25PLEIVMO_DTECALLATTEMPTS, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 13}},
#define   X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY  (740 % 256)
	{X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 14}},
#define   X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF  (741 % 256)
	{X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 15}},
#define   X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  (742 % 256)
	{X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 16}},
#define   X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER  (743 % 256)
	{X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 17}},
#define   X25PLEIVMO_DTEOCTETSSENTCOUNTER  (744 % 256)
	{X25PLEIVMO_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 18}},
#define   X25PLEIVMO_DTECALLTIMEOUTS  (745 % 256)
	{X25PLEIVMO_DTECALLTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 19}},
#define   X25PLEIVMO_DTECALLSCONNECTED  (746 % 256)
	{X25PLEIVMO_DTECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 20}},
#define   X25PLEIVMO_DTECLEARCOUNTSEXCEEDED  (747 % 256)
	{X25PLEIVMO_DTECLEARCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 21}},
#define   X25PLEIVMO_DTECLEARTIMEOUTS  (748 % 256)
	{X25PLEIVMO_DTECLEARTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 22}},
#define   X25PLEIVMO_DTEDATAPACKETSRECEIVED  (749 % 256)
	{X25PLEIVMO_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 23}},
#define   X25PLEIVMO_DTEDATAPACKETSSENT  (750 % 256)
	{X25PLEIVMO_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 24}},
#define   X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES  (751 % 256)
	{X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 25}},
#define   X25PLEIVMO_DTEPROVIDERINITIATEDRESETS  (752 % 256)
	{X25PLEIVMO_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 26}},
#define   X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS  (753 % 256)
	{X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 27}},
#define   X25PLEIVMO_DTEREMOTELYINITIATEDRESETS  (754 % 256)
	{X25PLEIVMO_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 28}},
#define   X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS  (755 % 256)
	{X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 29}},
#define   X25PLEIVMO_DTERESETTIMEOUTS  (756 % 256)
	{X25PLEIVMO_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 30}},
#define   X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED  (757 % 256)
	{X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 31}},
#define   X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER  (758 % 256)
	{X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 32}},
#define   X25PLEIVMO_DTEWINDOWROTATIONTIMER  (759 % 256)
	{X25PLEIVMO_DTEWINDOWROTATIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 33}},
#define   X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT  (760 % 256)
	{X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 34}},
#define   X25PLEIVMO_DTEREJECTRESPONSETIMER  (761 % 256)
	{X25PLEIVMO_DTEREJECTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 35}},
#define   X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT  (762 % 256)
	{X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 36}},
#define   X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER  (763 % 256)
	{X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 37}},
#define   X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT  (764 % 256)
	{X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 38}},
#define   X25PLEIVMO_DTEREGISTRATIONPERMITTED  (765 % 256)
	{X25PLEIVMO_DTEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 39}},
#define   X25PLEIVMO_DTEROWSTATUS  (766 % 256)
	{X25PLEIVMO_DTEROWSTATUS, ASN_INTEGER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 40}},
#define   X25PLEIVMO_DCEROWSTATUS  (770 % 256)
	{X25PLEIVMO_DCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMO_DCETable, 6, {1, 1, 45, 1, 1, 1}},
#define   VIRTUALCALLCHANNEL    (774 % 256)
	{VIRTUALCALLCHANNEL, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 2}},
#define   VIRTUALCALLPACKETSIZE  (775 % 256)
	{VIRTUALCALLPACKETSIZE, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 3}},
#define   VIRTUALCALLWINDOWSIZE  (776 % 256)
	{VIRTUALCALLWINDOWSIZE, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 4}},
#define   VIRTUALCALLOCTETSSENTCOUNTER  (777 % 256)
	{VIRTUALCALLOCTETSSENTCOUNTER, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 5}},
#define   VIRTUALCALLOCTETSRECEIVEDCOUNTER  (778 % 256)
	{VIRTUALCALLOCTETSRECEIVEDCOUNTER, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 6}},
#define   VIRTUALCALLDATAPACKETSSENT  (779 % 256)
	{VIRTUALCALLDATAPACKETSSENT, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 7}},
#define   VIRTUALCALLDATAPACKETSRECEIVED  (780 % 256)
	{VIRTUALCALLDATAPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 8}},
#define   VIRTUALCALLREMOTELYINITIATEDRESETS  (781 % 256)
	{VIRTUALCALLREMOTELYINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 9}},
#define   VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES  (782 % 256)
	{VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 10}},
#define   VIRTUALCALLPROVIDERINITIATEDRESETS  (783 % 256)
	{VIRTUALCALLPROVIDERINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 11}},
#define   VIRTUALCALLRESETTIMEOUTS  (784 % 256)
	{VIRTUALCALLRESETTIMEOUTS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 12}},
#define   VIRTUALCALLINTERRUPTPACKETSSENT  (785 % 256)
	{VIRTUALCALLINTERRUPTPACKETSSENT, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 13}},
#define   VIRTUALCALLINTERRUPTPACKETSRECEIVED  (786 % 256)
	{VIRTUALCALLINTERRUPTPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 14}},
#define   VIRTUALCALLINTERRUPTTIMEREXPIRIES  (787 % 256)
	{VIRTUALCALLINTERRUPTTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 15}},
#define   VIRTUALCIRCUITLOGICALCHANNEL  (791 % 256)
	{VIRTUALCIRCUITLOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 2}},
#define   VIRTUALCIRCUITPACKETSIZES  (792 % 256)
	{VIRTUALCIRCUITPACKETSIZES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 3}},
#define   VIRTUALCIRCUITTHROUGHPUTCLASSES  (793 % 256)
	{VIRTUALCIRCUITTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 4}},
#define   VIRTUALCIRCUITWINDOWSIZES  (794 % 256)
	{VIRTUALCIRCUITWINDOWSIZES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER  (798 % 256)
	{VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 1}},
#define   VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER  (799 % 256)
	{VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 2}},
#define   VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED  (800 % 256)
	{VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 3}},
#define   VIRTUALCIRCUIT_DTEDATAPACKETSSENT  (801 % 256)
	{VIRTUALCIRCUIT_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 4}},
#define   VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES  (802 % 256)
	{VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED  (803 % 256)
	{VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 6}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT  (804 % 256)
	{VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 7}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES  (805 % 256)
	{VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 8}},
#define   VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS  (806 % 256)
	{VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 9}},
#define   VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS  (807 % 256)
	{VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 10}},
#define   VIRTUALCIRCUIT_DTERESETTIMEOUTS  (808 % 256)
	{VIRTUALCIRCUIT_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 11}},
#define   VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED  (812 % 256)
	{VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 1}},
#define   VIRTUALCIRCUIT_DCEDATAPACKETSSENT  (813 % 256)
	{VIRTUALCIRCUIT_DCEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 2}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED  (814 % 256)
	{VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 3}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT  (815 % 256)
	{VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 4}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES  (816 % 256)
	{VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER  (817 % 256)
	{VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 6}},
#define   VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER  (818 % 256)
	{VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 7}},
#define   VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS  (819 % 256)
	{VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 8}},
#define   VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS  (820 % 256)
	{VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 9}},
#define   VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS  (821 % 256)
	{VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 10}},
#define   VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS  (822 % 256)
	{VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 11}},
#define   VIRTUALCIRCUIT_DCERESETTIMEOUTS  (823 % 256)
	{VIRTUALCIRCUIT_DCERESETTIMEOUTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 12}},
#define   VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED  (824 % 256)
	{VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 13}},
#define   VIRTUALCIRCUIT_DCEX25SEGMENTSSENT  (825 % 256)
	{VIRTUALCIRCUIT_DCEX25SEGMENTSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 14}},
#define   PERMANENTVIRTUALCIRCUITCHANNEL  (830 % 256)
	{PERMANENTVIRTUALCIRCUITCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuitTable, 6, {1, 1, 50, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUITROWSTATUS  (831 % 256)
	{PERMANENTVIRTUALCIRCUITROWSTATUS, ASN_INTEGER, RWRITE, var_permanentVirtualCircuitTable, 6, {1, 1, 50, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL  (836 % 256)
	{PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES  (837 % 256)
	{PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES  (838 % 256)
	{PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 3}},
#define   PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES  (839 % 256)
	{PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 4}},
#define   PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS  (840 % 256)
	{PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS, ASN_INTEGER, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 5}},
#define   PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION  (845 % 256)
	{PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL  (846 % 256)
	{PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES  (847 % 256)
	{PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 3}},
#define   PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES  (848 % 256)
	{PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 4}},
#define   PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES  (849 % 256)
	{PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 5}},
#define   PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE  (850 % 256)
	{PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 6}},
#define   PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS  (851 % 256)
	{PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 7}},
#define   PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL  (852 % 256)
	{PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 8}},
#define   PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS  (853 % 256)
	{PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS, ASN_INTEGER, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 9}},
#define   VIRTUALCALLIVMOFASTSELECT  (858 % 256)
	{VIRTUALCALLIVMOFASTSELECT, ASN_INTEGER, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 2}},
#define   VIRTUALCALLIVMOPACKETSIZES  (859 % 256)
	{VIRTUALCALLIVMOPACKETSIZES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 3}},
#define   VIRTUALCALLIVMOREVERSECHARGING  (860 % 256)
	{VIRTUALCALLIVMOREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 4}},
#define   VIRTUALCALLIVMOTHROUGHPUTCLASSES  (861 % 256)
	{VIRTUALCALLIVMOTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 5}},
#define   VIRTUALCALLIVMOWINDOWSIZES  (862 % 256)
	{VIRTUALCALLIVMOWINDOWSIZES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 6}},
#define   VIRTUALCALLIVMOPROPOSEDPACKETSIZE  (863 % 256)
	{VIRTUALCALLIVMOPROPOSEDPACKETSIZE, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 7}},
#define   VIRTUALCALLIVMOPROPOSEDWINDOWSIZE  (864 % 256)
	{VIRTUALCALLIVMOPROPOSEDWINDOWSIZE, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 8}},
#define   VIRTUALCALLIVMOACCEPTREVERSECHARGING  (865 % 256)
	{VIRTUALCALLIVMOACCEPTREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 9}},
#define   VIRTUALCALLIVMOPROPOSEREVERSECHARGING  (866 % 256)
	{VIRTUALCALLIVMOPROPOSEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 10}},
#define   VIRTUALCALLIVMOCALLTIME  (867 % 256)
	{VIRTUALCALLIVMOCALLTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 11}},
#define   VIRTUALCALLIVMORESETTIME  (868 % 256)
	{VIRTUALCALLIVMORESETTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 12}},
#define   VIRTUALCALLIVMOCLEARTIME  (869 % 256)
	{VIRTUALCALLIVMOCLEARTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 13}},
#define   VIRTUALCALLIVMOINTERRUPTTIME  (870 % 256)
	{VIRTUALCALLIVMOINTERRUPTTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 14}},
#define   VIRTUALCALLIVMORESETCOUNT  (871 % 256)
	{VIRTUALCALLIVMORESETCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 15}},
#define   VIRTUALCALLIVMOCLEARCOUNT  (872 % 256)
	{VIRTUALCALLIVMOCLEARCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 16}},
#define   VIRTUALCALLIVMOWINDOWTIME  (873 % 256)
	{VIRTUALCALLIVMOWINDOWTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 17}},
#define   VIRTUALCALLIVMODATARETRANSMISSIONTIME  (874 % 256)
	{VIRTUALCALLIVMODATARETRANSMISSIONTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 18}},
#define   VIRTUALCALLIVMODATARETRANSMISSIONCOUNT  (875 % 256)
	{VIRTUALCALLIVMODATARETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 19}},
#define   VIRTUALCALLIVMOREJECTTIME  (876 % 256)
	{VIRTUALCALLIVMOREJECTTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 20}},
#define   VIRTUALCALLIVMOREJECTCOUNT  (877 % 256)
	{VIRTUALCALLIVMOREJECTCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 21}},
#define   VIRTUALCALLIVMOROWSTATUS  (878 % 256)
	{VIRTUALCALLIVMOROWSTATUS, ASN_INTEGER, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 22}},
#define   SWITCHEDVIRTUALCALLDIRECTION  (883 % 256)
	{SWITCHEDVIRTUALCALLDIRECTION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 1}},
#define   SWITCHEDVIRTUALCALLREMOTEDTEADDRESS  (884 % 256)
	{SWITCHEDVIRTUALCALLREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 2}},
#define   SWITCHEDVIRTUALCALLTHROUGHPUTCLASS  (885 % 256)
	{SWITCHEDVIRTUALCALLTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 3}},
#define   SWITCHEDVIRTUALCALLREDIRECTREASON  (886 % 256)
	{SWITCHEDVIRTUALCALLREDIRECTREASON, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 4}},
#define   SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS  (887 % 256)
	{SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 5}},
#define   SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION  (888 % 256)
	{SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 6}},
#define   SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION  (889 % 256)
	{SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 7}},
#define   SWITCHEDVIRTUALCALLROWSTATUS  (890 % 256)
	{SWITCHEDVIRTUALCALLROWSTATUS, ASN_INTEGER, RWRITE, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 8}},
#define   VIRTUALCALL_DTECALLINGADDRESSEXTENSION  (895 % 256)
	{VIRTUALCALL_DTECALLINGADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 1}},
#define   VIRTUALCALL_DTECALLEDADDRESSEXTENSION  (896 % 256)
	{VIRTUALCALL_DTECALLEDADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 2}},
#define   VIRTUALCALL_DTEDIRECTION  (897 % 256)
	{VIRTUALCALL_DTEDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 3}},
#define   VIRTUALCALL_DTEFASTSELECT  (898 % 256)
	{VIRTUALCALL_DTEFASTSELECT, ASN_INTEGER, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 4}},
#define   VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS  (899 % 256)
	{VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 5}},
#define   VIRTUALCALL_DTEREDIRECTREASON  (900 % 256)
	{VIRTUALCALL_DTEREDIRECTREASON, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 6}},
#define   VIRTUALCALL_DTEREMOTEDTEADDRESS  (901 % 256)
	{VIRTUALCALL_DTEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 7}},
#define   VIRTUALCALL_DTEREVERSECHARGING  (902 % 256)
	{VIRTUALCALL_DTEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 8}},
#define   VIRTUALCALL_DTEROWSTATUS  (903 % 256)
	{VIRTUALCALL_DTEROWSTATUS, ASN_INTEGER, RWRITE, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 9}},
#define   VIRTUALCALL_DCECHARGINGDIRECTION  (908 % 256)
	{VIRTUALCALL_DCECHARGINGDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 1}},
#define   VIRTUALCALL_DCECUGSELECTION  (909 % 256)
	{VIRTUALCALL_DCECUGSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 2}},
#define   VIRTUALCALL_DCEDIRECTION  (910 % 256)
	{VIRTUALCALL_DCEDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 3}},
#define   VIRTUALCALL_DCEFASTSELECT  (911 % 256)
	{VIRTUALCALL_DCEFASTSELECT, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 4}},
#define   VIRTUALCALL_DCEREMOTEDTEADDRESS  (912 % 256)
	{VIRTUALCALL_DCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 5}},
#define   VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION  (913 % 256)
	{VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 6}},
#define   VIRTUALCALL_DCEBILATERALCUGSELECTION  (914 % 256)
	{VIRTUALCALL_DCEBILATERALCUGSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 7}},
#define   VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION  (915 % 256)
	{VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 8}},
#define   VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION  (916 % 256)
	{VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 9}},
#define   VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION  (917 % 256)
	{VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 10}},
#define   VIRTUALCALL_DCENUISELECTION  (918 % 256)
	{VIRTUALCALL_DCENUISELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 11}},
#define   VIRTUALCALL_DCEREVERSECHARGING  (919 % 256)
	{VIRTUALCALL_DCEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 12}},
#define   VIRTUALCALL_DCEROASELECTION  (920 % 256)
	{VIRTUALCALL_DCEROASELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 13}},
#define   VIRTUALCALL_DCEROWSTATUS  (921 % 256)
	{VIRTUALCALL_DCEROWSTATUS, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 14}},
#define   DSERIESRESETREQUESTINDICATIONPACKETS  (927 % 256)
	{DSERIESRESETREQUESTINDICATIONPACKETS, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 2}},
#define   DSERIESSEGMENTSSENT   (928 % 256)
	{DSERIESSEGMENTSSENT, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 3}},
#define   DSERIESSEGMENTSRECEIVED  (929 % 256)
	{DSERIESSEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 4}},
#define   DSERIESROWSTATUS      (930 % 256)
	{DSERIESROWSTATUS, ASN_INTEGER, RWRITE, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 5}},
#define   ADJACENCYSTATE        (937 % 256)
	{ADJACENCYSTATE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 2}},
#define   NEIGHBOURSNPAADDRESS  (938 % 256)
	{NEIGHBOURSNPAADDRESS, ASN_OCTET_STR, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 3}},
#define   NEIGHBOURSYSTEMTYPE   (939 % 256)
	{NEIGHBOURSYSTEMTYPE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 4}},
#define   NEIGHBOURSYSTEMIDS    (940 % 256)
	{NEIGHBOURSYSTEMIDS, ASN_OCTET_STR, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 5}},
#define   ADJACENCYUSAGE        (941 % 256)
	{ADJACENCYUSAGE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 6}},
#define   AREAADDRESSESOFNEIGHBOUR  (942 % 256)
	{AREAADDRESSESOFNEIGHBOUR, ASN_OCTET_STR, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 7}},
#define   HOLDINGTIMER          (943 % 256)
	{HOLDINGTIMER, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 8}},
#define   PRIORITYOFNEIGHBOUR   (944 % 256)
	{PRIORITYOFNEIGHBOUR, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 9}},
#define   ADJACENCYROWSTATUS    (945 % 256)
	{ADJACENCYROWSTATUS, ASN_INTEGER, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 10}},
#define   VIRTUALADJACENCYMETRIC  (951 % 256)
	{VIRTUALADJACENCYMETRIC, ASN_INTEGER, RONLY, var_virtualAdjacencyTable, 6, {1, 1, 59, 1, 1, 2}},
#define   DESTINATIONDEFAULTMETRICPATHCOST  (957 % 256)
	{DESTINATIONDEFAULTMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 2}},
#define   DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES  (958 % 256)
	{DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 3}},
#define   DESTINATIONDELAYMETRICPATHCOST  (959 % 256)
	{DESTINATIONDELAYMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 4}},
#define   DESTINATIONDELAYMETRICOUTPUTADJACENCIES  (960 % 256)
	{DESTINATIONDELAYMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 5}},
#define   DESTINATIONEXPENSEMETRICPATHCOST  (961 % 256)
	{DESTINATIONEXPENSEMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 6}},
#define   DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES  (962 % 256)
	{DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 7}},
#define   DESTINATIONERRORMETRICPATHCOST  (963 % 256)
	{DESTINATIONERRORMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 8}},
#define   DESTINATIONERRORMETRICOUTPUTADJACENCIES  (964 % 256)
	{DESTINATIONERRORMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 9}},
#define   DESINTATIONSYSTEMMETRIC  (971 % 256)
	{DESINTATIONSYSTEMMETRIC, ASN_INTEGER, RONLY, var_destinationSystemTable, 6, {1, 1, 61, 1, 1, 3}},
#define   DESTINATIONAREAID     (975 % 256)
	{DESTINATIONAREAID, ASN_OCTET_STR, RONLY, var_destinationAreaTable, 6, {1, 1, 62, 1, 1, 1}},
#define   REACHABLEADDRESSPREFIX  (979 % 256)
	{REACHABLEADDRESSPREFIX, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 2}},
#define   REACHABLEADDRESSMAPPINGTYPE  (980 % 256)
	{REACHABLEADDRESSMAPPINGTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 3}},
#define   REACHABLEADDRESSDEFAULTMETRIC  (981 % 256)
	{REACHABLEADDRESSDEFAULTMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 4}},
#define   REACHABLEADDRESSDELAYMETRIC  (982 % 256)
	{REACHABLEADDRESSDELAYMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 5}},
#define   REACHABLEADDRESSEXPENSEMETRIC  (983 % 256)
	{REACHABLEADDRESSEXPENSEMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 6}},
#define   REACHABLEADDRESSERRORMETRIC  (984 % 256)
	{REACHABLEADDRESSERRORMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 7}},
#define   REACHABLEADDRESSDEFAULTMETRICTYPE  (985 % 256)
	{REACHABLEADDRESSDEFAULTMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 8}},
#define   REACHABLEADDRESSDELAYMETRICTYPE  (986 % 256)
	{REACHABLEADDRESSDELAYMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 9}},
#define   REACHABLEADDRESSEXPENSEMETRICTYPE  (987 % 256)
	{REACHABLEADDRESSEXPENSEMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 10}},
#define   REACHABLEADDRESSERRORMETRICTYPE  (988 % 256)
	{REACHABLEADDRESSERRORMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 11}},
#define   REACHABLEADDRESSOPERATIONALSTATE  (989 % 256)
	{REACHABLEADDRESSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 12}},
#define   REACHABLEADDRESSADMINISTRATIVESTATE  (990 % 256)
	{REACHABLEADDRESSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 13}},
#define   REACHABLEADDRESSSNPAADDRESSES  (991 % 256)
	{REACHABLEADDRESSSNPAADDRESSES, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 14}},
#define   REACHABLEADDRESSSNPAMASK  (992 % 256)
	{REACHABLEADDRESSSNPAMASK, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 15}},
#define   REACHABLEADDRESSSNPAPREFIX  (993 % 256)
	{REACHABLEADDRESSSNPAPREFIX, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 16}},
#define   REACHABLEADDRESSROWSTATUS  (994 % 256)
	{REACHABLEADDRESSROWSTATUS, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 17}},
#define   LLCDISCONTINUITYTIME  (995 % 256)
	{LLCDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_dlMIB, 4, {1, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTINTERFACETYPE  (996 % 256)
	{SLPCONNECTIONDEFAULTINTERFACETYPE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTK  (997 % 256)
	{SLPCONNECTIONDEFAULTK, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 2}},
#define   SLPCONNECTIONDEFAULTN1  (998 % 256)
	{SLPCONNECTIONDEFAULTN1, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 3}},
#define   SLPCONNECTIONDEFAULTN2  (999 % 256)
	{SLPCONNECTIONDEFAULTN2, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 4}},
#define   SLPCONNECTIONDEFAULTSEQUENCEMODULUS  (1000 % 256)
	{SLPCONNECTIONDEFAULTSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 5}},
#define   SLPCONNECTIONDEFAULTT1TIMER  (1001 % 256)
	{SLPCONNECTIONDEFAULTT1TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 6}},
#define   SLPCONNECTIONDEFAULTT2TIMER  (1002 % 256)
	{SLPCONNECTIONDEFAULTT2TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 7}},
#define   SLPCONNECTIONDEFAULTT3TIMER  (1003 % 256)
	{SLPCONNECTIONDEFAULTT3TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 8}},
#define   SLPCONNECTIONDEFAULTT4TIMER  (1004 % 256)
	{SLPCONNECTIONDEFAULTT4TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 9}},
#define   LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS  (1005 % 256)
	{LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 1}},
#define   LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE  (1006 % 256)
	{LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 2}},
#define   LLCCONNECTION2DEFAULTSENDWINDOWSIZE  (1007 % 256)
	{LLCCONNECTION2DEFAULTSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 3}},
#define   LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE  (1008 % 256)
	{LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 4}},
#define   LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE  (1009 % 256)
	{LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 5}},
#define   LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE  (1010 % 256)
	{LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 6}},
#define   LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE  (1011 % 256)
	{LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 7}},
#define   LLCCONNECTION2DEFAULTROUTE  (1012 % 256)
	{LLCCONNECTION2DEFAULTROUTE, ASN_OCTET_STR, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 8}},
#define   LLCCONNECTION2DEFAULTKSTEP  (1013 % 256)
	{LLCCONNECTION2DEFAULTKSTEP, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 9}},
#define   LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE  (1014 % 256)
	{LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 10}},
#define   LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS  (1015 % 256)
	{LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 11}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE  (1016 % 256)
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 3, 1}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS  (1017 % 256)
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 3, 2}},
};

/* (L = length of the oidsuffix) */
struct dlMIB_data *dlMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *communicationsEntityTableStorage = NULL;
struct header_complex_index *sap1TableStorage = NULL;
struct header_complex_index *sap2TableStorage = NULL;
struct header_complex_index *clProtocolMachineTableStorage = NULL;
struct header_complex_index *coProtocolMachineTableStorage = NULL;
struct header_complex_index *singlePeerConnectionTableStorage = NULL;
struct header_complex_index *physicalEntityTableStorage = NULL;
struct header_complex_index *physicalSAPTableStorage = NULL;
struct header_complex_index *dataCircuitTableStorage = NULL;
struct header_complex_index *physicalConnectionTableStorage = NULL;
struct header_complex_index *datalinkEntityTableStorage = NULL;
struct header_complex_index *dLSAPTableStorage = NULL;
struct header_complex_index *lAPBDLETableStorage = NULL;
struct header_complex_index *sLPPMTableStorage = NULL;
struct header_complex_index *sLPConnectionTableStorage = NULL;
struct header_complex_index *sLPConnectionIVMOTableStorage = NULL;
struct header_complex_index *mACDLETableStorage = NULL;
struct header_complex_index *mACTableStorage = NULL;
struct header_complex_index *lLCDLETableStorage = NULL;
struct header_complex_index *lLCCLPMTableStorage = NULL;
struct header_complex_index *lLCCOPMTableStorage = NULL;
struct header_complex_index *resourceTypeIdTableStorage = NULL;
struct header_complex_index *lLCStationTableStorage = NULL;
struct header_complex_index *lLCSAPTableStorage = NULL;
struct header_complex_index *rDESetupTableStorage = NULL;
struct header_complex_index *rDEPairTableStorage = NULL;
struct header_complex_index *lLCConnectionLessTableStorage = NULL;
struct header_complex_index *lLCConnection2TableStorage = NULL;
struct header_complex_index *lLCConnection2IVMOTableStorage = NULL;
struct header_complex_index *lLCConnectionlessAckTableStorage = NULL;
struct header_complex_index *lLCConnectionlessAckIVMOTableStorage = NULL;
struct header_complex_index *networkEntityTableStorage = NULL;
struct header_complex_index *nSAPTableStorage = NULL;
struct header_complex_index *cLNSTableStorage = NULL;
struct header_complex_index *cLNSISISTableStorage = NULL;
struct header_complex_index *cLNSISISLevel2TableStorage = NULL;
struct header_complex_index *linkageTableStorage = NULL;
struct header_complex_index *cONSTableStorage = NULL;
struct header_complex_index *networkConnectionTableStorage = NULL;
struct header_complex_index *x25PLETableStorage = NULL;
struct header_complex_index *x25PLE_DTETableStorage = NULL;
struct header_complex_index *x25PLE_DCETableStorage = NULL;
struct header_complex_index *x25PLEIVMOTableStorage = NULL;
struct header_complex_index *x25PLEIVMO_DTETableStorage = NULL;
struct header_complex_index *x25PLEIVMO_DCETableStorage = NULL;
struct header_complex_index *virtualCallTableStorage = NULL;
struct header_complex_index *virtualCircuitTableStorage = NULL;
struct header_complex_index *virtualCircuit_DTETableStorage = NULL;
struct header_complex_index *virtualCircuit_DCETableStorage = NULL;
struct header_complex_index *permanentVirtualCircuitTableStorage = NULL;
struct header_complex_index *permanentVirtualCircuit_DTETableStorage = NULL;
struct header_complex_index *permanentVirtualCircuit_DCETableStorage = NULL;
struct header_complex_index *virtualCallIVMOTableStorage = NULL;
struct header_complex_index *switchedVirtualCallTableStorage = NULL;
struct header_complex_index *virtualCall_DTETableStorage = NULL;
struct header_complex_index *virtualCall_DCETableStorage = NULL;
struct header_complex_index *dSeriesCountsTableStorage = NULL;
struct header_complex_index *adjacencyTableStorage = NULL;
struct header_complex_index *virtualAdjacencyTableStorage = NULL;
struct header_complex_index *destinationTableStorage = NULL;
struct header_complex_index *destinationSystemTableStorage = NULL;
struct header_complex_index *destinationAreaTableStorage = NULL;
struct header_complex_index *reachableAddressTableStorage = NULL;

/*
 * init_dlMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_dlMIB(void)
{
	DEBUGMSGTL(("dlMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("dlMIB", dlMIB_variables, variable7, dlMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_dlMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("dlMIB", parse_dlMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("communicationsEntityTable", parse_communicationsEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sap1Table", parse_sap1Table, NULL, "HELP STRING");
	snmpd_register_config_handler("sap2Table", parse_sap2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("clProtocolMachineTable", parse_clProtocolMachineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("coProtocolMachineTable", parse_coProtocolMachineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("singlePeerConnectionTable", parse_singlePeerConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("physicalEntityTable", parse_physicalEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("physicalSAPTable", parse_physicalSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dataCircuitTable", parse_dataCircuitTable, NULL, "HELP STRING");
	snmpd_register_config_handler("physicalConnectionTable", parse_physicalConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("datalinkEntityTable", parse_datalinkEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dLSAPTable", parse_dLSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lAPBDLETable", parse_lAPBDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("sLPPMTable", parse_sLPPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sLPConnectionTable", parse_sLPConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sLPConnectionIVMOTable", parse_sLPConnectionIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mACDLETable", parse_mACDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("mACTable", parse_mACTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCDLETable", parse_lLCDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCCLPMTable", parse_lLCCLPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCCOPMTable", parse_lLCCOPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("resourceTypeIdTable", parse_resourceTypeIdTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCStationTable", parse_lLCStationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCSAPTable", parse_lLCSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("rDESetupTable", parse_rDESetupTable, NULL, "HELP STRING");
	snmpd_register_config_handler("rDEPairTable", parse_rDEPairTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionLessTable", parse_lLCConnectionLessTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnection2Table", parse_lLCConnection2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnection2IVMOTable", parse_lLCConnection2IVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionlessAckTable", parse_lLCConnectionlessAckTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionlessAckIVMOTable", parse_lLCConnectionlessAckIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("networkEntityTable", parse_networkEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("nSAPTable", parse_nSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cLNSTable", parse_cLNSTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cLNSISISTable", parse_cLNSISISTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cLNSISISLevel2Table", parse_cLNSISISLevel2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("linkageTable", parse_linkageTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cONSTable", parse_cONSTable, NULL, "HELP STRING");
	snmpd_register_config_handler("networkConnectionTable", parse_networkConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLETable", parse_x25PLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLE_DTETable", parse_x25PLE_DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLE_DCETable", parse_x25PLE_DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMOTable", parse_x25PLEIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMO_DTETable", parse_x25PLEIVMO_DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMO_DCETable", parse_x25PLEIVMO_DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCallTable", parse_virtualCallTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCircuitTable", parse_virtualCircuitTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCircuit_DTETable", parse_virtualCircuit_DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCircuit_DCETable", parse_virtualCircuit_DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("permanentVirtualCircuitTable", parse_permanentVirtualCircuitTable, NULL, "HELP STRING");
	snmpd_register_config_handler("permanentVirtualCircuit_DTETable", parse_permanentVirtualCircuit_DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("permanentVirtualCircuit_DCETable", parse_permanentVirtualCircuit_DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCallIVMOTable", parse_virtualCallIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("switchedVirtualCallTable", parse_switchedVirtualCallTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCall_DTETable", parse_virtualCall_DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCall_DCETable", parse_virtualCall_DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("dSeriesCountsTable", parse_dSeriesCountsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("adjacencyTable", parse_adjacencyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualAdjacencyTable", parse_virtualAdjacencyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("destinationTable", parse_destinationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("destinationSystemTable", parse_destinationSystemTable, NULL, "HELP STRING");
	snmpd_register_config_handler("destinationAreaTable", parse_destinationAreaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("reachableAddressTable", parse_reachableAddressTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dlMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_communicationsEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sap1Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sap2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_clProtocolMachineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_coProtocolMachineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_singlePeerConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_physicalEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_physicalSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dataCircuitTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_physicalConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_datalinkEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dLSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lAPBDLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sLPPMTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sLPConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sLPConnectionIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mACDLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mACTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCDLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCCLPMTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCCOPMTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_resourceTypeIdTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCStationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_rDESetupTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_rDEPairTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionLessTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnection2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnection2IVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionlessAckTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionlessAckIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_networkEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_nSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cLNSTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cLNSISISTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cLNSISISLevel2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_linkageTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cONSTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_networkConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLE_DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLE_DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLEIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLEIVMO_DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLEIVMO_DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCallTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCircuitTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCircuit_DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCircuit_DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_permanentVirtualCircuitTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_permanentVirtualCircuit_DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_permanentVirtualCircuit_DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCallIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_switchedVirtualCallTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCall_DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCall_DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dSeriesCountsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_adjacencyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualAdjacencyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_destinationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_destinationSystemTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_destinationAreaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_reachableAddressTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * deinit_dlMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_dlMIB(void)
{
	DEBUGMSGTL(("dlMIB", "deinitializating...  "));
	unregister_mib(dlMIB_variables_oid, sizeof(dlMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("dlMIB");
	snmpd_unregister_config_handler("communicationsEntityTable");
	snmpd_unregister_config_handler("sap1Table");
	snmpd_unregister_config_handler("sap2Table");
	snmpd_unregister_config_handler("clProtocolMachineTable");
	snmpd_unregister_config_handler("coProtocolMachineTable");
	snmpd_unregister_config_handler("singlePeerConnectionTable");
	snmpd_unregister_config_handler("physicalEntityTable");
	snmpd_unregister_config_handler("physicalSAPTable");
	snmpd_unregister_config_handler("dataCircuitTable");
	snmpd_unregister_config_handler("physicalConnectionTable");
	snmpd_unregister_config_handler("datalinkEntityTable");
	snmpd_unregister_config_handler("dLSAPTable");
	snmpd_unregister_config_handler("lAPBDLETable");
	snmpd_unregister_config_handler("sLPPMTable");
	snmpd_unregister_config_handler("sLPConnectionTable");
	snmpd_unregister_config_handler("sLPConnectionIVMOTable");
	snmpd_unregister_config_handler("mACDLETable");
	snmpd_unregister_config_handler("mACTable");
	snmpd_unregister_config_handler("lLCDLETable");
	snmpd_unregister_config_handler("lLCCLPMTable");
	snmpd_unregister_config_handler("lLCCOPMTable");
	snmpd_unregister_config_handler("resourceTypeIdTable");
	snmpd_unregister_config_handler("lLCStationTable");
	snmpd_unregister_config_handler("lLCSAPTable");
	snmpd_unregister_config_handler("rDESetupTable");
	snmpd_unregister_config_handler("rDEPairTable");
	snmpd_unregister_config_handler("lLCConnectionLessTable");
	snmpd_unregister_config_handler("lLCConnection2Table");
	snmpd_unregister_config_handler("lLCConnection2IVMOTable");
	snmpd_unregister_config_handler("lLCConnectionlessAckTable");
	snmpd_unregister_config_handler("lLCConnectionlessAckIVMOTable");
	snmpd_unregister_config_handler("networkEntityTable");
	snmpd_unregister_config_handler("nSAPTable");
	snmpd_unregister_config_handler("cLNSTable");
	snmpd_unregister_config_handler("cLNSISISTable");
	snmpd_unregister_config_handler("cLNSISISLevel2Table");
	snmpd_unregister_config_handler("linkageTable");
	snmpd_unregister_config_handler("cONSTable");
	snmpd_unregister_config_handler("networkConnectionTable");
	snmpd_unregister_config_handler("x25PLETable");
	snmpd_unregister_config_handler("x25PLE_DTETable");
	snmpd_unregister_config_handler("x25PLE_DCETable");
	snmpd_unregister_config_handler("x25PLEIVMOTable");
	snmpd_unregister_config_handler("x25PLEIVMO_DTETable");
	snmpd_unregister_config_handler("x25PLEIVMO_DCETable");
	snmpd_unregister_config_handler("virtualCallTable");
	snmpd_unregister_config_handler("virtualCircuitTable");
	snmpd_unregister_config_handler("virtualCircuit_DTETable");
	snmpd_unregister_config_handler("virtualCircuit_DCETable");
	snmpd_unregister_config_handler("permanentVirtualCircuitTable");
	snmpd_unregister_config_handler("permanentVirtualCircuit_DTETable");
	snmpd_unregister_config_handler("permanentVirtualCircuit_DCETable");
	snmpd_unregister_config_handler("virtualCallIVMOTable");
	snmpd_unregister_config_handler("switchedVirtualCallTable");
	snmpd_unregister_config_handler("virtualCall_DTETable");
	snmpd_unregister_config_handler("virtualCall_DCETable");
	snmpd_unregister_config_handler("dSeriesCountsTable");
	snmpd_unregister_config_handler("adjacencyTable");
	snmpd_unregister_config_handler("virtualAdjacencyTable");
	snmpd_unregister_config_handler("destinationTable");
	snmpd_unregister_config_handler("destinationSystemTable");
	snmpd_unregister_config_handler("destinationAreaTable");
	snmpd_unregister_config_handler("reachableAddressTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

int
term_dlMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_dlMIB();
	return 0;
}

/**
 * @fn struct dlMIB_data *dlMIB_create(void)
 * @brief create a fresh data structure representing scalars in dlMIB.
 * Creates a new dlMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in dlMIB.
 */
struct dlMIB_data *
dlMIB_create(void)
{
	struct dlMIB_data *StorageNew = SNMP_MALLOC_STRUCT(dlMIB_data);

	DBUGMSGTL(("dlMIB", "creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		StorageNew->sLPConnectionDefaultInterfaceType = dTE;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int dlMIB_destroy(struct dlMIB_data **thedata)
 * @brief delete a scalars structure from dlMIB.
 * @param thedata pointer to the data structure in dlMIB.
 * Frees scalars that were previously removed from dlMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
dlMIB_destroy(struct dlMIB_data **thedata)
{
	struct dlMIB_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCConnection2DefaultRoute);
		StorageDel->lLCConnection2DefaultRouteLen = 0;
		SNMP_FREE(StorageDel->physicalBitErrorThresholdReached);
		StorageDel->physicalBitErrorThresholdReachedLen = 0;
		SNMP_FREE(StorageDel->physicalConnectionError);
		StorageDel->physicalConnectionErrorLen = 0;
		SNMP_FREE(StorageDel->phsyicalConnectionEstablished);
		StorageDel->phsyicalConnectionEstablishedLen = 0;
		SNMP_FREE(StorageDel->physicalLossOfSignal);
		StorageDel->physicalLossOfSignalLen = 0;
		SNMP_FREE(StorageDel->physicalLossOfSynchronization);
		StorageDel->physicalLossOfSynchronizationLen = 0;
		SNMP_FREE(StorageDel->fRMR);
		StorageDel->fRMRLen = 0;
		SNMP_FREE(StorageDel->notificationPDUHeader);
		StorageDel->notificationPDUHeaderLen = 0;
		SNMP_FREE(StorageDel->reachabilityChange);
		StorageDel->reachabilityChangeLen = 0;
		SNMP_FREE(StorageDel->notificationData);
		StorageDel->notificationDataLen = 0;
		SNMP_FREE(StorageDel->notificationReceivingAdjacency);
		StorageDel->notificationReceivingAdjacencyLen = 0;
		SNMP_FREE(StorageDel->notificationAreaAddress);
		StorageDel->notificationAreaAddressLen = 0;
		SNMP_FREE(StorageDel->notificationAreaAddresses);
		StorageDel->notificationAreaAddressesLen = 0;
		SNMP_FREE(StorageDel->notificationSourceId);
		StorageDel->notificationSourceIdLen = 0;
		SNMP_FREE(StorageDel->notificationVirtualLinkAddress);
		StorageDel->notificationVirtualLinkAddressLen = 0;
		SNMP_FREE(StorageDel->notificationSystemId);
		StorageDel->notificationSystemIdLen = 0;
		SNMP_FREE(StorageDel->notificationVersion);
		StorageDel->notificationVersionLen = 0;
		SNMP_FREE(StorageDel->notificationLSPHeader);
		StorageDel->notificationLSPHeaderLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dlMIB_add(struct dlMIB_data *thedata)
 * @param thedata the structure representing dlMIB scalars.
 * @brief adds node to the dlMIB scalar data set.
 * Adds a scalar structure to the dlMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
dlMIB_add(struct dlMIB_data *thedata)
{
	DEBUGMSGTL(("dlMIB", "adding data...  "));
	dlMIBStorage = thedata;
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dlMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dlMIB entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case dlMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_dlMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct dlMIB_data *StorageTmp = dlMIB_create();

	DEBUGMSGTL(("dlMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->llcDiscontinuityTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultInterfaceType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultK, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultN2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultSequenceModulus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT2Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT3Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT4Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultPBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultRejectTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2DefaultRoute, &StorageTmp->lLCConnection2DefaultRouteLen);
	if (StorageTmp->lLCConnection2DefaultRoute == NULL) {
		config_perror("invalid specification for lLCConnection2DefaultRoute");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultKStep, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultMaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions, &tmpsize);
	dlMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_dlMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_dlMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dlMIB_data *StorageTmp;

	DEBUGMSGTL(("dlMIB", "storing data...  "));
	refresh_dlMIB();
	if ((StorageTmp = dlMIBStorage) == NULL) {
		DEBUGMSGTL(("dlMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "dlMIB ");
		cptr = line + strlen(line);
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->llcDiscontinuityTime, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultInterfaceType, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultK, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultN1, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultN2, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultSequenceModulus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT1Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT2Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT3Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT4Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultMaximumRetransmissions, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultReceivedWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultSendWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultPBitTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultRejectTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2DefaultRoute, &StorageTmp->lLCConnection2DefaultRouteLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultKStep, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultMaxSendWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_dlMIB(void)
 * @brief refresh the scalar values of dlMIB.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_dlMIB(void)
{
	if (dlMIBStorage == NULL) {
		struct dlMIB_data *StorageNew;

		if ((StorageNew = dlMIB_create()) == NULL)
			return;
		dlMIBStorage = StorageNew;
		dlMIB_refresh = 1;
	}
	if (dlMIB_refresh == 0)
		return;
	dlMIB_refresh = 0;
	/* XXX: Update scalars as required here... */
}

/**
* @fn u_char * var_dlMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
* @param vp a pointer to the entry in the variables table for the requested variable.
* @param name the object identifier for which to find.
* @param length the length of the object identifier.
* @param exact whether the name is exact.
* @param var_len a pointer to the length of the representation of the object.
* @param write_method a pointer to a write method for the object.
* @brief locate variables in dlMIB.
* This function returns a pointer to a memory area that is static across the request that contains
* the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
* GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
* telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
* overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
* writing.  Write-only objects can be effected in this way.
*/
u_char *
var_dlMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dlMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_dlMIB();
	if ((StorageTmp = dlMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCDISCONTINUITYTIME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->llcDiscontinuityTime);
		return (u_char *) &StorageTmp->llcDiscontinuityTime;
	case SLPCONNECTIONDEFAULTINTERFACETYPE:
		*write_method = write_sLPConnectionDefaultInterfaceType;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultInterfaceType);
		return (u_char *) &StorageTmp->sLPConnectionDefaultInterfaceType;
	case SLPCONNECTIONDEFAULTK:
		*write_method = write_sLPConnectionDefaultK;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultK);
		return (u_char *) &StorageTmp->sLPConnectionDefaultK;
	case SLPCONNECTIONDEFAULTN1:
		*write_method = write_sLPConnectionDefaultN1;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultN1);
		return (u_char *) &StorageTmp->sLPConnectionDefaultN1;
	case SLPCONNECTIONDEFAULTN2:
		*write_method = write_sLPConnectionDefaultN2;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultN2);
		return (u_char *) &StorageTmp->sLPConnectionDefaultN2;
	case SLPCONNECTIONDEFAULTSEQUENCEMODULUS:
		*write_method = write_sLPConnectionDefaultSequenceModulus;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultSequenceModulus);
		return (u_char *) &StorageTmp->sLPConnectionDefaultSequenceModulus;
	case SLPCONNECTIONDEFAULTT1TIMER:
		*write_method = write_sLPConnectionDefaultT1Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT1Timer);
		return (u_char *) &StorageTmp->sLPConnectionDefaultT1Timer;
	case SLPCONNECTIONDEFAULTT2TIMER:
		*write_method = write_sLPConnectionDefaultT2Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT2Timer);
		return (u_char *) &StorageTmp->sLPConnectionDefaultT2Timer;
	case SLPCONNECTIONDEFAULTT3TIMER:
		*write_method = write_sLPConnectionDefaultT3Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT3Timer);
		return (u_char *) &StorageTmp->sLPConnectionDefaultT3Timer;
	case SLPCONNECTIONDEFAULTT4TIMER:
		*write_method = write_sLPConnectionDefaultT4Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT4Timer);
		return (u_char *) &StorageTmp->sLPConnectionDefaultT4Timer;
	case LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2DefaultMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2DefaultMaximumRetransmissions;
	case LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2DefaultReceivedWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultReceivedWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2DefaultReceivedWindowSize;
	case LLCCONNECTION2DEFAULTSENDWINDOWSIZE:
		*write_method = write_lLCConnection2DefaultSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2DefaultSendWindowSize;
	case LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultAcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue;
	case LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultBusyStateTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue;
	case LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultPBitTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultPBitTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultPBitTimeoutValue;
	case LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultRejectTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultRejectTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultRejectTimeoutValue;
	case LLCCONNECTION2DEFAULTROUTE:
		*write_method = write_lLCConnection2DefaultRoute;
		*var_len = StorageTmp->lLCConnection2DefaultRouteLen;
		return (u_char *) StorageTmp->lLCConnection2DefaultRoute;
	case LLCCONNECTION2DEFAULTKSTEP:
		*write_method = write_lLCConnection2DefaultKStep;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultKStep);
		return (u_char *) &StorageTmp->lLCConnection2DefaultKStep;
	case LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2DefaultMaxSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultMaxSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2DefaultMaxSendWindowSize;
	case LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2DefaultOptionalTolerationIPDUs;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs);
		return (u_char *) &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs;
	case LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckDefaultMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn struct communicationsEntityTable_data *communicationsEntityTable_create(void)
 * @brief create a fresh data structure representing a new row in the communicationsEntityTable table.
 * Creates a new communicationsEntityTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct communicationsEntityTable_data *
communicationsEntityTable_create(void)
{
	struct communicationsEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(communicationsEntityTable_data);

	DBUGMSGTL(("communicationsEntityTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("communicationsEntityTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int communicationsEntityTable_destroy(struct communicationsEntityTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
communicationsEntityTable_destroy(struct communicationsEntityTable_data **thedata)
{
	struct communicationsEntityTable_data *StorageDel;

	DEBUGMSGTL(("communicationsEntityTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->communicationsEntityLocalSapNames);
		StorageDel->communicationsEntityLocalSapNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("communicationsEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int communicationsEntityTable_add(struct communicationsEntityTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the communicationsEntityTable table data set.
 * Adds a table row structure to the communicationsEntityTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
communicationsEntityTable_add(struct communicationsEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("communicationsEntityTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&communicationsEntityTableStorage, vars, thedata);
	DEBUGMSGTL(("communicationsEntityTable", "registered an entry\n"));
	DEBUGMSGTL(("communicationsEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int communicationsEntityTable_del(struct communicationsEntityTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the communicationsEntityTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
communicationsEntityTable_del(struct communicationsEntityTable_data *thedata)
{
	struct communicationsEntityTable_data *StorageDel;

	DEBUGMSGTL(("communicationsEntityTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(communicationsEntityTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&communicationsEntityTableStorage, hciptr);
	}
	DEBUGMSGTL(("communicationsEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_communicationsEntityTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for communicationsEntityTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case communicationsEntityTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_communicationsEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct communicationsEntityTable_data *StorageTmp = communicationsEntityTable_create();

	DEBUGMSGTL(("communicationsEntityTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->communicationsEntityLocalSapNames, &StorageTmp->communicationsEntityLocalSapNamesLen);
	if (StorageTmp->communicationsEntityLocalSapNames == NULL) {
		config_perror("invalid specification for communicationsEntityLocalSapNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->communicationsEntityOperationalState, &tmpsize);
	communicationsEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("communicationsEntityTable", "done.\n"));
}

/*
 * store_communicationsEntityTable(): store configuraiton file for communicationsEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_communicationsEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct communicationsEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("communicationsEntityTable", "storing data...  "));
	refresh_communicationsEntityTable();
	(void) tmpsize;
	for (hcindex = communicationsEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct communicationsEntityTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "communicationsEntityTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->communicationsEntityLocalSapNames, &StorageTmp->communicationsEntityLocalSapNamesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->communicationsEntityOperationalState, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("communicationsEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sap1Table_data *sap1Table_create(void)
 * @brief create a fresh data structure representing a new row in the sap1Table table.
 * Creates a new sap1Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sap1Table_data *
sap1Table_create(void)
{
	struct sap1Table_data *StorageNew = SNMP_MALLOC_STRUCT(sap1Table_data);

	DBUGMSGTL(("sap1Table", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("sap1Table", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int sap1Table_destroy(struct sap1Table_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
sap1Table_destroy(struct sap1Table_data **thedata)
{
	struct sap1Table_data *StorageDel;

	DEBUGMSGTL(("sap1Table", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->sap1UserEntityNames);
		StorageDel->sap1UserEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sap1Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sap1Table_add(struct sap1Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sap1Table table data set.
 * Adds a table row structure to the sap1Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sap1Table_add(struct sap1Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sap1Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&sap1TableStorage, vars, thedata);
	DEBUGMSGTL(("sap1Table", "registered an entry\n"));
	DEBUGMSGTL(("sap1Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sap1Table_del(struct sap1Table_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sap1Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sap1Table_del(struct sap1Table_data *thedata)
{
	struct sap1Table_data *StorageDel;

	DEBUGMSGTL(("sap1Table", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sap1TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sap1TableStorage, hciptr);
	}
	DEBUGMSGTL(("sap1Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sap1Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sap1Table entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sap1Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sap1Table(const char *token, char *line)
{
	size_t tmpsize;
	struct sap1Table_data *StorageTmp = sap1Table_create();

	DEBUGMSGTL(("sap1Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sap1Address, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sap1UserEntityNames, &StorageTmp->sap1UserEntityNamesLen);
	if (StorageTmp->sap1UserEntityNames == NULL) {
		config_perror("invalid specification for sap1UserEntityNames");
		return;
	}
	sap1Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sap1Table", "done.\n"));
}

/*
 * store_sap1Table(): store configuraiton file for sap1Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_sap1Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sap1Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sap1Table", "storing data...  "));
	refresh_sap1Table();
	(void) tmpsize;
	for (hcindex = sap1TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sap1Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sap1Table ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sap1Address, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sap1UserEntityNames, &StorageTmp->sap1UserEntityNamesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sap1Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sap2Table_data *sap2Table_create(void)
 * @brief create a fresh data structure representing a new row in the sap2Table table.
 * Creates a new sap2Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sap2Table_data *
sap2Table_create(void)
{
	struct sap2Table_data *StorageNew = SNMP_MALLOC_STRUCT(sap2Table_data);

	DBUGMSGTL(("sap2Table", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("sap2Table", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int sap2Table_destroy(struct sap2Table_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
sap2Table_destroy(struct sap2Table_data **thedata)
{
	struct sap2Table_data *StorageDel;

	DEBUGMSGTL(("sap2Table", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->sap2Address);
		StorageDel->sap2AddressLen = 0;
		SNMP_FREE(StorageDel->sap2UserEntityNames);
		StorageDel->sap2UserEntityNamesLen = 0;
		SNMP_FREE(StorageDel->sap2ProviderEntityNames);
		StorageDel->sap2ProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sap2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sap2Table_add(struct sap2Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sap2Table table data set.
 * Adds a table row structure to the sap2Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sap2Table_add(struct sap2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sap2Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&sap2TableStorage, vars, thedata);
	DEBUGMSGTL(("sap2Table", "registered an entry\n"));
	DEBUGMSGTL(("sap2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sap2Table_del(struct sap2Table_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sap2Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sap2Table_del(struct sap2Table_data *thedata)
{
	struct sap2Table_data *StorageDel;

	DEBUGMSGTL(("sap2Table", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sap2TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sap2TableStorage, hciptr);
	}
	DEBUGMSGTL(("sap2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sap2Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sap2Table entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sap2Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sap2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct sap2Table_data *StorageTmp = sap2Table_create();

	DEBUGMSGTL(("sap2Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sap2Address, &StorageTmp->sap2AddressLen);
	if (StorageTmp->sap2Address == NULL) {
		config_perror("invalid specification for sap2Address");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sap2UserEntityNames, &StorageTmp->sap2UserEntityNamesLen);
	if (StorageTmp->sap2UserEntityNames == NULL) {
		config_perror("invalid specification for sap2UserEntityNames");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sap2ProviderEntityNames, &StorageTmp->sap2ProviderEntityNamesLen);
	if (StorageTmp->sap2ProviderEntityNames == NULL) {
		config_perror("invalid specification for sap2ProviderEntityNames");
		return;
	}
	sap2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sap2Table", "done.\n"));
}

/*
 * store_sap2Table(): store configuraiton file for sap2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_sap2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sap2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sap2Table", "storing data...  "));
	refresh_sap2Table();
	(void) tmpsize;
	for (hcindex = sap2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sap2Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sap2Table ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sap2Address, &StorageTmp->sap2AddressLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sap2UserEntityNames, &StorageTmp->sap2UserEntityNamesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sap2ProviderEntityNames, &StorageTmp->sap2ProviderEntityNamesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sap2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct clProtocolMachineTable_data *clProtocolMachineTable_create(void)
 * @brief create a fresh data structure representing a new row in the clProtocolMachineTable table.
 * Creates a new clProtocolMachineTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct clProtocolMachineTable_data *
clProtocolMachineTable_create(void)
{
	struct clProtocolMachineTable_data *StorageNew = SNMP_MALLOC_STRUCT(clProtocolMachineTable_data);

	DBUGMSGTL(("clProtocolMachineTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("clProtocolMachineTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int clProtocolMachineTable_destroy(struct clProtocolMachineTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
clProtocolMachineTable_destroy(struct clProtocolMachineTable_data **thedata)
{
	struct clProtocolMachineTable_data *StorageDel;

	DEBUGMSGTL(("clProtocolMachineTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("clProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int clProtocolMachineTable_add(struct clProtocolMachineTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the clProtocolMachineTable table data set.
 * Adds a table row structure to the clProtocolMachineTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
clProtocolMachineTable_add(struct clProtocolMachineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("clProtocolMachineTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	header_complex_add_data(&clProtocolMachineTableStorage, vars, thedata);
	DEBUGMSGTL(("clProtocolMachineTable", "registered an entry\n"));
	DEBUGMSGTL(("clProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int clProtocolMachineTable_del(struct clProtocolMachineTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the clProtocolMachineTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
clProtocolMachineTable_del(struct clProtocolMachineTable_data *thedata)
{
	struct clProtocolMachineTable_data *StorageDel;

	DEBUGMSGTL(("clProtocolMachineTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(clProtocolMachineTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&clProtocolMachineTableStorage, hciptr);
	}
	DEBUGMSGTL(("clProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_clProtocolMachineTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for clProtocolMachineTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case clProtocolMachineTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_clProtocolMachineTable(const char *token, char *line)
{
	size_t tmpsize;
	struct clProtocolMachineTable_data *StorageTmp = clProtocolMachineTable_create();

	DEBUGMSGTL(("clProtocolMachineTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->clProtocolMachineOperationalState, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->clProtocolMachineTotalRemoteSAPs, &tmpsize);
	clProtocolMachineTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("clProtocolMachineTable", "done.\n"));
}

/*
 * store_clProtocolMachineTable(): store configuraiton file for clProtocolMachineTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_clProtocolMachineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct clProtocolMachineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("clProtocolMachineTable", "storing data...  "));
	refresh_clProtocolMachineTable();
	(void) tmpsize;
	for (hcindex = clProtocolMachineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct clProtocolMachineTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "clProtocolMachineTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->clProtocolMachineOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->clProtocolMachineTotalRemoteSAPs, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("clProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct coProtocolMachineTable_data *coProtocolMachineTable_create(void)
 * @brief create a fresh data structure representing a new row in the coProtocolMachineTable table.
 * Creates a new coProtocolMachineTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct coProtocolMachineTable_data *
coProtocolMachineTable_create(void)
{
	struct coProtocolMachineTable_data *StorageNew = SNMP_MALLOC_STRUCT(coProtocolMachineTable_data);

	DBUGMSGTL(("coProtocolMachineTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("coProtocolMachineTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int coProtocolMachineTable_destroy(struct coProtocolMachineTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
coProtocolMachineTable_destroy(struct coProtocolMachineTable_data **thedata)
{
	struct coProtocolMachineTable_data *StorageDel;

	DEBUGMSGTL(("coProtocolMachineTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("coProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int coProtocolMachineTable_add(struct coProtocolMachineTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the coProtocolMachineTable table data set.
 * Adds a table row structure to the coProtocolMachineTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
coProtocolMachineTable_add(struct coProtocolMachineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("coProtocolMachineTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&coProtocolMachineTableStorage, vars, thedata);
	DEBUGMSGTL(("coProtocolMachineTable", "registered an entry\n"));
	DEBUGMSGTL(("coProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int coProtocolMachineTable_del(struct coProtocolMachineTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the coProtocolMachineTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
coProtocolMachineTable_del(struct coProtocolMachineTable_data *thedata)
{
	struct coProtocolMachineTable_data *StorageDel;

	DEBUGMSGTL(("coProtocolMachineTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(coProtocolMachineTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&coProtocolMachineTableStorage, hciptr);
	}
	DEBUGMSGTL(("coProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_coProtocolMachineTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for coProtocolMachineTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case coProtocolMachineTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_coProtocolMachineTable(const char *token, char *line)
{
	size_t tmpsize;
	struct coProtocolMachineTable_data *StorageTmp = coProtocolMachineTable_create();

	DEBUGMSGTL(("coProtocolMachineTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->coProtocolMachineOperationalState, &tmpsize);
	coProtocolMachineTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("coProtocolMachineTable", "done.\n"));
}

/*
 * store_coProtocolMachineTable(): store configuraiton file for coProtocolMachineTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_coProtocolMachineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct coProtocolMachineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("coProtocolMachineTable", "storing data...  "));
	refresh_coProtocolMachineTable();
	(void) tmpsize;
	for (hcindex = coProtocolMachineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct coProtocolMachineTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "coProtocolMachineTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->coProtocolMachineOperationalState, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("coProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct singlePeerConnectionTable_data *singlePeerConnectionTable_create(void)
 * @brief create a fresh data structure representing a new row in the singlePeerConnectionTable table.
 * Creates a new singlePeerConnectionTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct singlePeerConnectionTable_data *
singlePeerConnectionTable_create(void)
{
	struct singlePeerConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(singlePeerConnectionTable_data);

	DBUGMSGTL(("singlePeerConnectionTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("singlePeerConnectionTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int singlePeerConnectionTable_destroy(struct singlePeerConnectionTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
singlePeerConnectionTable_destroy(struct singlePeerConnectionTable_data **thedata)
{
	struct singlePeerConnectionTable_data *StorageDel;

	DEBUGMSGTL(("singlePeerConnectionTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->underlyingConnectionNames);
		StorageDel->underlyingConnectionNamesLen = 0;
		SNMP_FREE(StorageDel->suppportedConnectionNames);
		StorageDel->suppportedConnectionNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("singlePeerConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int singlePeerConnectionTable_add(struct singlePeerConnectionTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the singlePeerConnectionTable table data set.
 * Adds a table row structure to the singlePeerConnectionTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
singlePeerConnectionTable_add(struct singlePeerConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("singlePeerConnectionTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&singlePeerConnectionTableStorage, vars, thedata);
	DEBUGMSGTL(("singlePeerConnectionTable", "registered an entry\n"));
	DEBUGMSGTL(("singlePeerConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int singlePeerConnectionTable_del(struct singlePeerConnectionTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the singlePeerConnectionTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
singlePeerConnectionTable_del(struct singlePeerConnectionTable_data *thedata)
{
	struct singlePeerConnectionTable_data *StorageDel;

	DEBUGMSGTL(("singlePeerConnectionTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(singlePeerConnectionTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&singlePeerConnectionTableStorage, hciptr);
	}
	DEBUGMSGTL(("singlePeerConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_singlePeerConnectionTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for singlePeerConnectionTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case singlePeerConnectionTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_singlePeerConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct singlePeerConnectionTable_data *StorageTmp = singlePeerConnectionTable_create();

	DEBUGMSGTL(("singlePeerConnectionTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->underlyingConnectionNames, &StorageTmp->underlyingConnectionNamesLen);
	if (StorageTmp->underlyingConnectionNames == NULL) {
		config_perror("invalid specification for underlyingConnectionNames");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->suppportedConnectionNames, &StorageTmp->suppportedConnectionNamesLen);
	if (StorageTmp->suppportedConnectionNames == NULL) {
		config_perror("invalid specification for suppportedConnectionNames");
		return;
	}
	singlePeerConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("singlePeerConnectionTable", "done.\n"));
}

/*
 * store_singlePeerConnectionTable(): store configuraiton file for singlePeerConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_singlePeerConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct singlePeerConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("singlePeerConnectionTable", "storing data...  "));
	refresh_singlePeerConnectionTable();
	(void) tmpsize;
	for (hcindex = singlePeerConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct singlePeerConnectionTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "singlePeerConnectionTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->underlyingConnectionNames, &StorageTmp->underlyingConnectionNamesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->suppportedConnectionNames, &StorageTmp->suppportedConnectionNamesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("singlePeerConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct physicalEntityTable_data *physicalEntityTable_create(void)
 * @brief create a fresh data structure representing a new row in the physicalEntityTable table.
 * Creates a new physicalEntityTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct physicalEntityTable_data *
physicalEntityTable_create(void)
{
	struct physicalEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(physicalEntityTable_data);

	DBUGMSGTL(("physicalEntityTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("physicalEntityTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int physicalEntityTable_destroy(struct physicalEntityTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
physicalEntityTable_destroy(struct physicalEntityTable_data **thedata)
{
	struct physicalEntityTable_data *StorageDel;

	DEBUGMSGTL(("physicalEntityTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->physicalEntityPhysicalEntityTitles);
		StorageDel->physicalEntityPhysicalEntityTitlesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("physicalEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalEntityTable_add(struct physicalEntityTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the physicalEntityTable table data set.
 * Adds a table row structure to the physicalEntityTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
physicalEntityTable_add(struct physicalEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("physicalEntityTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&physicalEntityTableStorage, vars, thedata);
	DEBUGMSGTL(("physicalEntityTable", "registered an entry\n"));
	DEBUGMSGTL(("physicalEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalEntityTable_del(struct physicalEntityTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the physicalEntityTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
physicalEntityTable_del(struct physicalEntityTable_data *thedata)
{
	struct physicalEntityTable_data *StorageDel;

	DEBUGMSGTL(("physicalEntityTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(physicalEntityTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&physicalEntityTableStorage, hciptr);
	}
	DEBUGMSGTL(("physicalEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_physicalEntityTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for physicalEntityTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case physicalEntityTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_physicalEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct physicalEntityTable_data *StorageTmp = physicalEntityTable_create();

	DEBUGMSGTL(("physicalEntityTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->physicalEntityPhysicalEntityTitles, &StorageTmp->physicalEntityPhysicalEntityTitlesLen);
	if (StorageTmp->physicalEntityPhysicalEntityTitles == NULL) {
		config_perror("invalid specification for physicalEntityPhysicalEntityTitles");
		return;
	}
	physicalEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("physicalEntityTable", "done.\n"));
}

/*
 * store_physicalEntityTable(): store configuraiton file for physicalEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_physicalEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct physicalEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("physicalEntityTable", "storing data...  "));
	refresh_physicalEntityTable();
	(void) tmpsize;
	for (hcindex = physicalEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct physicalEntityTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "physicalEntityTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->physicalEntityPhysicalEntityTitles, &StorageTmp->physicalEntityPhysicalEntityTitlesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("physicalEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct physicalSAPTable_data *physicalSAPTable_create(void)
 * @brief create a fresh data structure representing a new row in the physicalSAPTable table.
 * Creates a new physicalSAPTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct physicalSAPTable_data *
physicalSAPTable_create(void)
{
	struct physicalSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(physicalSAPTable_data);

	DBUGMSGTL(("physicalSAPTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->physicalSAPRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("physicalSAPTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int physicalSAPTable_destroy(struct physicalSAPTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
physicalSAPTable_destroy(struct physicalSAPTable_data **thedata)
{
	struct physicalSAPTable_data *StorageDel;

	DEBUGMSGTL(("physicalSAPTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("physicalSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalSAPTable_add(struct physicalSAPTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the physicalSAPTable table data set.
 * Adds a table row structure to the physicalSAPTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
physicalSAPTable_add(struct physicalSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("physicalSAPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&physicalSAPTableStorage, vars, thedata);
	DEBUGMSGTL(("physicalSAPTable", "registered an entry\n"));
	DEBUGMSGTL(("physicalSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalSAPTable_del(struct physicalSAPTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the physicalSAPTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
physicalSAPTable_del(struct physicalSAPTable_data *thedata)
{
	struct physicalSAPTable_data *StorageDel;

	DEBUGMSGTL(("physicalSAPTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(physicalSAPTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&physicalSAPTableStorage, hciptr);
	}
	DEBUGMSGTL(("physicalSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_physicalSAPTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for physicalSAPTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case physicalSAPTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_physicalSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct physicalSAPTable_data *StorageTmp = physicalSAPTable_create();

	DEBUGMSGTL(("physicalSAPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->physicalSAPRowStatus, &tmpsize);
	physicalSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("physicalSAPTable", "done.\n"));
}

/*
 * store_physicalSAPTable(): store configuraiton file for physicalSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_physicalSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct physicalSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("physicalSAPTable", "storing data...  "));
	refresh_physicalSAPTable();
	(void) tmpsize;
	for (hcindex = physicalSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct physicalSAPTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "physicalSAPTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->physicalSAPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("physicalSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dataCircuitTable_data *dataCircuitTable_create(void)
 * @brief create a fresh data structure representing a new row in the dataCircuitTable table.
 * Creates a new dataCircuitTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dataCircuitTable_data *
dataCircuitTable_create(void)
{
	struct dataCircuitTable_data *StorageNew = SNMP_MALLOC_STRUCT(dataCircuitTable_data);

	DBUGMSGTL(("dataCircuitTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dataCircuitRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dataCircuitTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int dataCircuitTable_destroy(struct dataCircuitTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
dataCircuitTable_destroy(struct dataCircuitTable_data **thedata)
{
	struct dataCircuitTable_data *StorageDel;

	DEBUGMSGTL(("dataCircuitTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->dataCircuitPhysicalMediaNames);
		StorageDel->dataCircuitPhysicalMediaNamesLen = 0;
		SNMP_FREE(StorageDel->dataCircuitPhysicalInterfaceType);
		StorageDel->dataCircuitPhysicalInterfaceTypeLen = 0;
		SNMP_FREE(StorageDel->dataCircuitPhysicalInterfaceStandard);
		StorageDel->dataCircuitPhysicalInterfaceStandardLen = 0;
		SNMP_FREE(StorageDel->dataCircuitTransmissionCoding);
		StorageDel->dataCircuitTransmissionCodingLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dataCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dataCircuitTable_add(struct dataCircuitTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dataCircuitTable table data set.
 * Adds a table row structure to the dataCircuitTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dataCircuitTable_add(struct dataCircuitTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dataCircuitTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&dataCircuitTableStorage, vars, thedata);
	DEBUGMSGTL(("dataCircuitTable", "registered an entry\n"));
	DEBUGMSGTL(("dataCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dataCircuitTable_del(struct dataCircuitTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the dataCircuitTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dataCircuitTable_del(struct dataCircuitTable_data *thedata)
{
	struct dataCircuitTable_data *StorageDel;

	DEBUGMSGTL(("dataCircuitTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dataCircuitTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dataCircuitTableStorage, hciptr);
	}
	DEBUGMSGTL(("dataCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dataCircuitTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dataCircuitTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case dataCircuitTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dataCircuitTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dataCircuitTable_data *StorageTmp = dataCircuitTable_create();

	DEBUGMSGTL(("dataCircuitTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dataCircuitBitErrorsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dataCircuitBitErrorsTransmitted, &tmpsize);
	line = read_config_read_data(ASN_OPAQUE, line, &StorageTmp->dataCircuitBitErrorsThreshold, &StorageTmp->dataCircuitBitErrorsThresholdLen);
	if (StorageTmp->dataCircuitBitErrorsThreshold == NULL) {
		config_perror("invalid specification for dataCircuitBitErrorsThreshold");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitType, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitPhysicalMediaNames, &StorageTmp->dataCircuitPhysicalMediaNamesLen);
	if (StorageTmp->dataCircuitPhysicalMediaNames == NULL) {
		config_perror("invalid specification for dataCircuitPhysicalMediaNames");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitPhysicalInterfaceType, &StorageTmp->dataCircuitPhysicalInterfaceTypeLen);
	if (StorageTmp->dataCircuitPhysicalInterfaceType == NULL) {
		config_perror("invalid specification for dataCircuitPhysicalInterfaceType");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitPhysicalInterfaceStandard, &StorageTmp->dataCircuitPhysicalInterfaceStandardLen);
	if (StorageTmp->dataCircuitPhysicalInterfaceStandard == NULL) {
		config_perror("invalid specification for dataCircuitPhysicalInterfaceStandard");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitSynchronizationMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitTransmissionCoding, &StorageTmp->dataCircuitTransmissionCodingLen);
	if (StorageTmp->dataCircuitTransmissionCoding == NULL) {
		config_perror("invalid specification for dataCircuitTransmissionCoding");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitTransmissionMode, &tmpsize);
	line = read_config_read_data(ASN_OPAQUE, line, &StorageTmp->dataCircuitTransmissionRate, &StorageTmp->dataCircuitTransmissionRateLen);
	if (StorageTmp->dataCircuitTransmissionRate == NULL) {
		config_perror("invalid specification for dataCircuitTransmissionRate");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitRowStatus, &tmpsize);
	dataCircuitTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dataCircuitTable", "done.\n"));
}

/*
 * store_dataCircuitTable(): store configuraiton file for dataCircuitTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dataCircuitTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dataCircuitTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dataCircuitTable", "storing data...  "));
	refresh_dataCircuitTable();
	(void) tmpsize;
	for (hcindex = dataCircuitTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dataCircuitTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dataCircuitTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dataCircuitBitErrorsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dataCircuitBitErrorsTransmitted, &tmpsize);
			cptr = read_config_store_data(ASN_OPAQUE, cptr, &StorageTmp->dataCircuitBitErrorsThreshold, &StorageTmp->dataCircuitBitErrorsThresholdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitPhysicalMediaNames, &StorageTmp->dataCircuitPhysicalMediaNamesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitPhysicalInterfaceType, &StorageTmp->dataCircuitPhysicalInterfaceTypeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitPhysicalInterfaceStandard, &StorageTmp->dataCircuitPhysicalInterfaceStandardLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitSynchronizationMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitTransmissionCoding, &StorageTmp->dataCircuitTransmissionCodingLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitTransmissionMode, &tmpsize);
			cptr = read_config_store_data(ASN_OPAQUE, cptr, &StorageTmp->dataCircuitTransmissionRate, &StorageTmp->dataCircuitTransmissionRateLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dataCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct physicalConnectionTable_data *physicalConnectionTable_create(void)
 * @brief create a fresh data structure representing a new row in the physicalConnectionTable table.
 * Creates a new physicalConnectionTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct physicalConnectionTable_data *
physicalConnectionTable_create(void)
{
	struct physicalConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(physicalConnectionTable_data);

	DBUGMSGTL(("physicalConnectionTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->physicalConnectionRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("physicalConnectionTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int physicalConnectionTable_destroy(struct physicalConnectionTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
physicalConnectionTable_destroy(struct physicalConnectionTable_data **thedata)
{
	struct physicalConnectionTable_data *StorageDel;

	DEBUGMSGTL(("physicalConnectionTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->physicalConnectionEndpointIdentifier);
		StorageDel->physicalConnectionEndpointIdentifierLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("physicalConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalConnectionTable_add(struct physicalConnectionTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the physicalConnectionTable table data set.
 * Adds a table row structure to the physicalConnectionTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
physicalConnectionTable_add(struct physicalConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("physicalConnectionTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&physicalConnectionTableStorage, vars, thedata);
	DEBUGMSGTL(("physicalConnectionTable", "registered an entry\n"));
	DEBUGMSGTL(("physicalConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalConnectionTable_del(struct physicalConnectionTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the physicalConnectionTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
physicalConnectionTable_del(struct physicalConnectionTable_data *thedata)
{
	struct physicalConnectionTable_data *StorageDel;

	DEBUGMSGTL(("physicalConnectionTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(physicalConnectionTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&physicalConnectionTableStorage, hciptr);
	}
	DEBUGMSGTL(("physicalConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_physicalConnectionTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for physicalConnectionTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case physicalConnectionTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_physicalConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct physicalConnectionTable_data *StorageTmp = physicalConnectionTable_create();

	DEBUGMSGTL(("physicalConnectionTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->physicalConnectionEndpointIdentifier, &StorageTmp->physicalConnectionEndpointIdentifierLen);
	if (StorageTmp->physicalConnectionEndpointIdentifier == NULL) {
		config_perror("invalid specification for physicalConnectionEndpointIdentifier");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->physicalConnectionPortNumber, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->physicalConnectionRowStatus, &tmpsize);
	physicalConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("physicalConnectionTable", "done.\n"));
}

/*
 * store_physicalConnectionTable(): store configuraiton file for physicalConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_physicalConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct physicalConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("physicalConnectionTable", "storing data...  "));
	refresh_physicalConnectionTable();
	(void) tmpsize;
	for (hcindex = physicalConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct physicalConnectionTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "physicalConnectionTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->physicalConnectionEndpointIdentifier, &StorageTmp->physicalConnectionEndpointIdentifierLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->physicalConnectionPortNumber, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->physicalConnectionRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("physicalConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct datalinkEntityTable_data *datalinkEntityTable_create(void)
 * @brief create a fresh data structure representing a new row in the datalinkEntityTable table.
 * Creates a new datalinkEntityTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct datalinkEntityTable_data *
datalinkEntityTable_create(void)
{
	struct datalinkEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(datalinkEntityTable_data);

	DBUGMSGTL(("datalinkEntityTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->datalinkEntityRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("datalinkEntityTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int datalinkEntityTable_destroy(struct datalinkEntityTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
datalinkEntityTable_destroy(struct datalinkEntityTable_data **thedata)
{
	struct datalinkEntityTable_data *StorageDel;

	DEBUGMSGTL(("datalinkEntityTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->datalinkEntityProviderEntityNames);
		StorageDel->datalinkEntityProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("datalinkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int datalinkEntityTable_add(struct datalinkEntityTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the datalinkEntityTable table data set.
 * Adds a table row structure to the datalinkEntityTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
datalinkEntityTable_add(struct datalinkEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("datalinkEntityTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&datalinkEntityTableStorage, vars, thedata);
	DEBUGMSGTL(("datalinkEntityTable", "registered an entry\n"));
	DEBUGMSGTL(("datalinkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int datalinkEntityTable_del(struct datalinkEntityTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the datalinkEntityTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
datalinkEntityTable_del(struct datalinkEntityTable_data *thedata)
{
	struct datalinkEntityTable_data *StorageDel;

	DEBUGMSGTL(("datalinkEntityTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(datalinkEntityTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&datalinkEntityTableStorage, hciptr);
	}
	DEBUGMSGTL(("datalinkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_datalinkEntityTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for datalinkEntityTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case datalinkEntityTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_datalinkEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct datalinkEntityTable_data *StorageTmp = datalinkEntityTable_create();

	DEBUGMSGTL(("datalinkEntityTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->datalinkEntityProviderEntityNames, &StorageTmp->datalinkEntityProviderEntityNamesLen);
	if (StorageTmp->datalinkEntityProviderEntityNames == NULL) {
		config_perror("invalid specification for datalinkEntityProviderEntityNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->datalinkEntityRowStatus, &tmpsize);
	datalinkEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("datalinkEntityTable", "done.\n"));
}

/*
 * store_datalinkEntityTable(): store configuraiton file for datalinkEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_datalinkEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct datalinkEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("datalinkEntityTable", "storing data...  "));
	refresh_datalinkEntityTable();
	(void) tmpsize;
	for (hcindex = datalinkEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct datalinkEntityTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "datalinkEntityTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->datalinkEntityProviderEntityNames, &StorageTmp->datalinkEntityProviderEntityNamesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->datalinkEntityRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("datalinkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dLSAPTable_data *dLSAPTable_create(void)
 * @brief create a fresh data structure representing a new row in the dLSAPTable table.
 * Creates a new dLSAPTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dLSAPTable_data *
dLSAPTable_create(void)
{
	struct dLSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(dLSAPTable_data);

	DBUGMSGTL(("dLSAPTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dLSAPRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int dLSAPTable_destroy(struct dLSAPTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
dLSAPTable_destroy(struct dLSAPTable_data **thedata)
{
	struct dLSAPTable_data *StorageDel;

	DEBUGMSGTL(("dLSAPTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dLSAPTable_add(struct dLSAPTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dLSAPTable table data set.
 * Adds a table row structure to the dLSAPTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dLSAPTable_add(struct dLSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dLSAPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&dLSAPTableStorage, vars, thedata);
	DEBUGMSGTL(("dLSAPTable", "registered an entry\n"));
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dLSAPTable_del(struct dLSAPTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the dLSAPTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dLSAPTable_del(struct dLSAPTable_data *thedata)
{
	struct dLSAPTable_data *StorageDel;

	DEBUGMSGTL(("dLSAPTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dLSAPTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dLSAPTableStorage, hciptr);
	}
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dLSAPTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dLSAPTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case dLSAPTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dLSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dLSAPTable_data *StorageTmp = dLSAPTable_create();

	DEBUGMSGTL(("dLSAPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dLSAPRowStatus, &tmpsize);
	dLSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
}

/*
 * store_dLSAPTable(): store configuraiton file for dLSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dLSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dLSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dLSAPTable", "storing data...  "));
	refresh_dLSAPTable();
	(void) tmpsize;
	for (hcindex = dLSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dLSAPTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dLSAPTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dLSAPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lAPBDLETable_data *lAPBDLETable_create(void)
 * @brief create a fresh data structure representing a new row in the lAPBDLETable table.
 * Creates a new lAPBDLETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lAPBDLETable_data *
lAPBDLETable_create(void)
{
	struct lAPBDLETable_data *StorageNew = SNMP_MALLOC_STRUCT(lAPBDLETable_data);

	DBUGMSGTL(("lAPBDLETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lAPBDLERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int lAPBDLETable_destroy(struct lAPBDLETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
lAPBDLETable_destroy(struct lAPBDLETable_data **thedata)
{
	struct lAPBDLETable_data *StorageDel;

	DEBUGMSGTL(("lAPBDLETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lAPBDLETable_add(struct lAPBDLETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lAPBDLETable table data set.
 * Adds a table row structure to the lAPBDLETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lAPBDLETable_add(struct lAPBDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lAPBDLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&lAPBDLETableStorage, vars, thedata);
	DEBUGMSGTL(("lAPBDLETable", "registered an entry\n"));
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lAPBDLETable_del(struct lAPBDLETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the lAPBDLETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lAPBDLETable_del(struct lAPBDLETable_data *thedata)
{
	struct lAPBDLETable_data *StorageDel;

	DEBUGMSGTL(("lAPBDLETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lAPBDLETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lAPBDLETableStorage, hciptr);
	}
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lAPBDLETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lAPBDLETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lAPBDLETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lAPBDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct lAPBDLETable_data *StorageTmp = lAPBDLETable_create();

	DEBUGMSGTL(("lAPBDLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT3Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmW, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmXSend, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmXReceive, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT2Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEreceivedMlpResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEtimesMT1Expired, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEIframesReassignments, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEmlpFramesReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEmlpFramesSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLERowStatus, &tmpsize);
	lAPBDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
}

/*
 * store_lAPBDLETable(): store configuraiton file for lAPBDLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lAPBDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lAPBDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lAPBDLETable", "storing data...  "));
	refresh_lAPBDLETable();
	(void) tmpsize;
	for (hcindex = lAPBDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lAPBDLETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lAPBDLETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT1Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT3Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmW, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmXSend, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmXReceive, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT2Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEreceivedMlpResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEtimesMT1Expired, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEIframesReassignments, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEmlpFramesReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEmlpFramesSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sLPPMTable_data *sLPPMTable_create(void)
 * @brief create a fresh data structure representing a new row in the sLPPMTable table.
 * Creates a new sLPPMTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sLPPMTable_data *
sLPPMTable_create(void)
{
	struct sLPPMTable_data *StorageNew = SNMP_MALLOC_STRUCT(sLPPMTable_data);

	DBUGMSGTL(("sLPPMTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sLPPMRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int sLPPMTable_destroy(struct sLPPMTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
sLPPMTable_destroy(struct sLPPMTable_data **thedata)
{
	struct sLPPMTable_data *StorageDel;

	DEBUGMSGTL(("sLPPMTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPPMTable_add(struct sLPPMTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sLPPMTable table data set.
 * Adds a table row structure to the sLPPMTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sLPPMTable_add(struct sLPPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sLPPMTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&sLPPMTableStorage, vars, thedata);
	DEBUGMSGTL(("sLPPMTable", "registered an entry\n"));
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPPMTable_del(struct sLPPMTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sLPPMTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sLPPMTable_del(struct sLPPMTable_data *thedata)
{
	struct sLPPMTable_data *StorageDel;

	DEBUGMSGTL(("sLPPMTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sLPPMTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sLPPMTableStorage, hciptr);
	}
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sLPPMTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sLPPMTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sLPPMTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sLPPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPPMTable_data *StorageTmp = sLPPMTable_create();

	DEBUGMSGTL(("sLPPMTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPPMadministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPPMRowStatus, &tmpsize);
	sLPPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
}

/*
 * store_sLPPMTable(): store configuraiton file for sLPPMTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sLPPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sLPPMTable", "storing data...  "));
	refresh_sLPPMTable();
	(void) tmpsize;
	for (hcindex = sLPPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPPMTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sLPPMTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPPMadministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPPMRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sLPConnectionTable_data *sLPConnectionTable_create(void)
 * @brief create a fresh data structure representing a new row in the sLPConnectionTable table.
 * Creates a new sLPConnectionTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sLPConnectionTable_data *
sLPConnectionTable_create(void)
{
	struct sLPConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(sLPConnectionTable_data);

	DBUGMSGTL(("sLPConnectionTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sLPConnectionRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int sLPConnectionTable_destroy(struct sLPConnectionTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
sLPConnectionTable_destroy(struct sLPConnectionTable_data **thedata)
{
	struct sLPConnectionTable_data *StorageDel;

	DEBUGMSGTL(("sLPConnectionTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->sLPConnectionProceduralStatus);
		StorageDel->sLPConnectionProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->sLPConnectionAlarmStatus);
		StorageDel->sLPConnectionAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPConnectionTable_add(struct sLPConnectionTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sLPConnectionTable table data set.
 * Adds a table row structure to the sLPConnectionTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sLPConnectionTable_add(struct sLPConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sLPConnectionTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&sLPConnectionTableStorage, vars, thedata);
	DEBUGMSGTL(("sLPConnectionTable", "registered an entry\n"));
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPConnectionTable_del(struct sLPConnectionTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sLPConnectionTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sLPConnectionTable_del(struct sLPConnectionTable_data *thedata)
{
	struct sLPConnectionTable_data *StorageDel;

	DEBUGMSGTL(("sLPConnectionTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sLPConnectionTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sLPConnectionTableStorage, hciptr);
	}
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sLPConnectionTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sLPConnectionTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sLPConnectionTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sLPConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPConnectionTable_data *StorageTmp = sLPConnectionTable_create();

	DEBUGMSGTL(("sLPConnectionTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionInterfaceType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionK, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionN2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionSequenceModulus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT2Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFCSErrorsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFRMRsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFRMRsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFrameDataOctetsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFrameDataOctetsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFramesReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFramesSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionPollsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionREJsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionREJsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionRNRsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionRNRsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionSABMsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionSABMsSent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionProtocolState, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT1Expired, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT3Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT3Expired, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT4Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT4Expired, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionLinkResetsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionLinkResetsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesN2Reached, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionUsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sLPConnectionProceduralStatus, &StorageTmp->sLPConnectionProceduralStatusLen);
	if (StorageTmp->sLPConnectionProceduralStatus == NULL) {
		config_perror("invalid specification for sLPConnectionProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sLPConnectionAlarmStatus, &StorageTmp->sLPConnectionAlarmStatusLen);
	if (StorageTmp->sLPConnectionAlarmStatus == NULL) {
		config_perror("invalid specification for sLPConnectionAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionRowStatus, &tmpsize);
	sLPConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
}

/*
 * store_sLPConnectionTable(): store configuraiton file for sLPConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sLPConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sLPConnectionTable", "storing data...  "));
	refresh_sLPConnectionTable();
	(void) tmpsize;
	for (hcindex = sLPConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPConnectionTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sLPConnectionTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionInterfaceType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionK, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionN1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionN2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionSequenceModulus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT1Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT2Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionFCSErrorsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionFRMRsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionFRMRsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFrameDataOctetsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFrameDataOctetsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFramesReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFramesSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionPollsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionREJsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionREJsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionRNRsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionRNRsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionSABMsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionSABMsSent, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionProtocolState, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesT1Expired, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT3Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesT3Expired, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT4Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesT4Expired, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionLinkResetsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionLinkResetsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesN2Reached, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sLPConnectionProceduralStatus, &StorageTmp->sLPConnectionProceduralStatusLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sLPConnectionAlarmStatus, &StorageTmp->sLPConnectionAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sLPConnectionIVMOTable_data *sLPConnectionIVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the sLPConnectionIVMOTable table.
 * Creates a new sLPConnectionIVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sLPConnectionIVMOTable_data *
sLPConnectionIVMOTable_create(void)
{
	struct sLPConnectionIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(sLPConnectionIVMOTable_data);

	DBUGMSGTL(("sLPConnectionIVMOTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sLPConnectionIVMORowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int sLPConnectionIVMOTable_destroy(struct sLPConnectionIVMOTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
sLPConnectionIVMOTable_destroy(struct sLPConnectionIVMOTable_data **thedata)
{
	struct sLPConnectionIVMOTable_data *StorageDel;

	DEBUGMSGTL(("sLPConnectionIVMOTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->sLPConnectionIVMOid);
		StorageDel->sLPConnectionIVMOidLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPConnectionIVMOTable_add(struct sLPConnectionIVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sLPConnectionIVMOTable table data set.
 * Adds a table row structure to the sLPConnectionIVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sLPConnectionIVMOTable_add(struct sLPConnectionIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sLPConnectionIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&sLPConnectionIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("sLPConnectionIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPConnectionIVMOTable_del(struct sLPConnectionIVMOTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sLPConnectionIVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sLPConnectionIVMOTable_del(struct sLPConnectionIVMOTable_data *thedata)
{
	struct sLPConnectionIVMOTable_data *StorageDel;

	DEBUGMSGTL(("sLPConnectionIVMOTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sLPConnectionIVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sLPConnectionIVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sLPConnectionIVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sLPConnectionIVMOTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sLPConnectionIVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sLPConnectionIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPConnectionIVMOTable_data *StorageTmp = sLPConnectionIVMOTable_create();

	DEBUGMSGTL(("sLPConnectionIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sLPConnectionIVMOid, &StorageTmp->sLPConnectionIVMOidLen);
	if (StorageTmp->sLPConnectionIVMOid == NULL) {
		config_perror("invalid specification for sLPConnectionIVMOid");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOinterfaceType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOk, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOn1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOn2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOsequenceModulus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt2Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt3Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt4Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMORowStatus, &tmpsize);
	sLPConnectionIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
}

/*
 * store_sLPConnectionIVMOTable(): store configuraiton file for sLPConnectionIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sLPConnectionIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPConnectionIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sLPConnectionIVMOTable", "storing data...  "));
	refresh_sLPConnectionIVMOTable();
	(void) tmpsize;
	for (hcindex = sLPConnectionIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPConnectionIVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sLPConnectionIVMOTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sLPConnectionIVMOid, &StorageTmp->sLPConnectionIVMOidLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOinterfaceType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOk, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOn1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOn2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOsequenceModulus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt1Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt2Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt3Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt4Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mACDLETable_data *mACDLETable_create(void)
 * @brief create a fresh data structure representing a new row in the mACDLETable table.
 * Creates a new mACDLETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mACDLETable_data *
mACDLETable_create(void)
{
	struct mACDLETable_data *StorageNew = SNMP_MALLOC_STRUCT(mACDLETable_data);

	DBUGMSGTL(("mACDLETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mACDLERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mACDLETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int mACDLETable_destroy(struct mACDLETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
mACDLETable_destroy(struct mACDLETable_data **thedata)
{
	struct mACDLETable_data *StorageDel;

	DEBUGMSGTL(("mACDLETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mACDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mACDLETable_add(struct mACDLETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mACDLETable table data set.
 * Adds a table row structure to the mACDLETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mACDLETable_add(struct mACDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mACDLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&mACDLETableStorage, vars, thedata);
	DEBUGMSGTL(("mACDLETable", "registered an entry\n"));
	DEBUGMSGTL(("mACDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mACDLETable_del(struct mACDLETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mACDLETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mACDLETable_del(struct mACDLETable_data *thedata)
{
	struct mACDLETable_data *StorageDel;

	DEBUGMSGTL(("mACDLETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mACDLETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mACDLETableStorage, hciptr);
	}
	DEBUGMSGTL(("mACDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mACDLETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mACDLETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mACDLETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mACDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct mACDLETable_data *StorageTmp = mACDLETable_create();

	DEBUGMSGTL(("mACDLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACDLERowStatus, &tmpsize);
	mACDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mACDLETable", "done.\n"));
}

/*
 * store_mACDLETable(): store configuraiton file for mACDLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mACDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mACDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mACDLETable", "storing data...  "));
	refresh_mACDLETable();
	(void) tmpsize;
	for (hcindex = mACDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mACDLETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mACDLETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACDLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mACDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mACTable_data *mACTable_create(void)
 * @brief create a fresh data structure representing a new row in the mACTable table.
 * Creates a new mACTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mACTable_data *
mACTable_create(void)
{
	struct mACTable_data *StorageNew = SNMP_MALLOC_STRUCT(mACTable_data);

	DBUGMSGTL(("mACTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mACRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mACTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int mACTable_destroy(struct mACTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
mACTable_destroy(struct mACTable_data **thedata)
{
	struct mACTable_data *StorageDel;

	DEBUGMSGTL(("mACTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->mACId);
		StorageDel->mACIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mACTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mACTable_add(struct mACTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mACTable table data set.
 * Adds a table row structure to the mACTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mACTable_add(struct mACTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mACTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* mACId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mACId, thedata->mACIdLen);
	header_complex_add_data(&mACTableStorage, vars, thedata);
	DEBUGMSGTL(("mACTable", "registered an entry\n"));
	DEBUGMSGTL(("mACTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mACTable_del(struct mACTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the mACTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mACTable_del(struct mACTable_data *thedata)
{
	struct mACTable_data *StorageDel;

	DEBUGMSGTL(("mACTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mACTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mACTableStorage, hciptr);
	}
	DEBUGMSGTL(("mACTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mACTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mACTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mACTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mACTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mACTable_data *StorageTmp = mACTable_create();

	DEBUGMSGTL(("mACTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACOperationalState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mACId, &StorageTmp->mACIdLen);
	if (StorageTmp->mACId == NULL) {
		config_perror("invalid specification for mACId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACRowStatus, &tmpsize);
	mACTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mACTable", "done.\n"));
}

/*
 * store_mACTable(): store configuraiton file for mACTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mACTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mACTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mACTable", "storing data...  "));
	refresh_mACTable();
	(void) tmpsize;
	for (hcindex = mACTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mACTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mACTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mACId, &StorageTmp->mACIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mACTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCDLETable_data *lLCDLETable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCDLETable table.
 * Creates a new lLCDLETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCDLETable_data *
lLCDLETable_create(void)
{
	struct lLCDLETable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCDLETable_data);

	DBUGMSGTL(("lLCDLETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lLCDLERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int lLCDLETable_destroy(struct lLCDLETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCDLETable_destroy(struct lLCDLETable_data **thedata)
{
	struct lLCDLETable_data *StorageDel;

	DEBUGMSGTL(("lLCDLETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCDLETable_add(struct lLCDLETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCDLETable table data set.
 * Adds a table row structure to the lLCDLETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCDLETable_add(struct lLCDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCDLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&lLCDLETableStorage, vars, thedata);
	DEBUGMSGTL(("lLCDLETable", "registered an entry\n"));
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCDLETable_del(struct lLCDLETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the lLCDLETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCDLETable_del(struct lLCDLETable_data *thedata)
{
	struct lLCDLETable_data *StorageDel;

	DEBUGMSGTL(("lLCDLETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCDLETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCDLETableStorage, hciptr);
	}
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCDLETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCDLETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCDLETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCDLETable_data *StorageTmp = lLCDLETable_create();

	DEBUGMSGTL(("lLCDLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCDLERowStatus, &tmpsize);
	lLCDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
}

/*
 * store_lLCDLETable(): store configuraiton file for lLCDLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCDLETable", "storing data...  "));
	refresh_lLCDLETable();
	(void) tmpsize;
	for (hcindex = lLCDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCDLETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCDLETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCDLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCCLPMTable_data *lLCCLPMTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCCLPMTable table.
 * Creates a new lLCCLPMTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCCLPMTable_data *
lLCCLPMTable_create(void)
{
	struct lLCCLPMTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCCLPMTable_data);

	DBUGMSGTL(("lLCCLPMTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lLCCLPMRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int lLCCLPMTable_destroy(struct lLCCLPMTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCCLPMTable_destroy(struct lLCCLPMTable_data **thedata)
{
	struct lLCCLPMTable_data *StorageDel;

	DEBUGMSGTL(("lLCCLPMTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCCLPMTable_add(struct lLCCLPMTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCCLPMTable table data set.
 * Adds a table row structure to the lLCCLPMTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCCLPMTable_add(struct lLCCLPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCCLPMTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	header_complex_add_data(&lLCCLPMTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCCLPMTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCCLPMTable_del(struct lLCCLPMTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the lLCCLPMTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCCLPMTable_del(struct lLCCLPMTable_data *thedata)
{
	struct lLCCLPMTable_data *StorageDel;

	DEBUGMSGTL(("lLCCLPMTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCCLPMTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCCLPMTableStorage, hciptr);
	}
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCCLPMTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCCLPMTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCCLPMTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCCLPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCCLPMTable_data *StorageTmp = lLCCLPMTable_create();

	DEBUGMSGTL(("lLCCLPMTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCCLPMRowStatus, &tmpsize);
	lLCCLPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
}

/*
 * store_lLCCLPMTable(): store configuraiton file for lLCCLPMTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCCLPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCCLPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCCLPMTable", "storing data...  "));
	refresh_lLCCLPMTable();
	(void) tmpsize;
	for (hcindex = lLCCLPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCCLPMTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCCLPMTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCCLPMRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCCOPMTable_data *lLCCOPMTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCCOPMTable table.
 * Creates a new lLCCOPMTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCCOPMTable_data *
lLCCOPMTable_create(void)
{
	struct lLCCOPMTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCCOPMTable_data);

	DBUGMSGTL(("lLCCOPMTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lLCCOPMRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int lLCCOPMTable_destroy(struct lLCCOPMTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCCOPMTable_destroy(struct lLCCOPMTable_data **thedata)
{
	struct lLCCOPMTable_data *StorageDel;

	DEBUGMSGTL(("lLCCOPMTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCCOPMTable_add(struct lLCCOPMTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCCOPMTable table data set.
 * Adds a table row structure to the lLCCOPMTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCCOPMTable_add(struct lLCCOPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCCOPMTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&lLCCOPMTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCCOPMTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCCOPMTable_del(struct lLCCOPMTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the lLCCOPMTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCCOPMTable_del(struct lLCCOPMTable_data *thedata)
{
	struct lLCCOPMTable_data *StorageDel;

	DEBUGMSGTL(("lLCCOPMTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCCOPMTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCCOPMTableStorage, hciptr);
	}
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCCOPMTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCCOPMTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCCOPMTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCCOPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCCOPMTable_data *StorageTmp = lLCCOPMTable_create();

	DEBUGMSGTL(("lLCCOPMTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCCOPMRowStatus, &tmpsize);
	lLCCOPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
}

/*
 * store_lLCCOPMTable(): store configuraiton file for lLCCOPMTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCCOPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCCOPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCCOPMTable", "storing data...  "));
	refresh_lLCCOPMTable();
	(void) tmpsize;
	for (hcindex = lLCCOPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCCOPMTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCCOPMTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCCOPMRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct resourceTypeIdTable_data *resourceTypeIdTable_create(void)
 * @brief create a fresh data structure representing a new row in the resourceTypeIdTable table.
 * Creates a new resourceTypeIdTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct resourceTypeIdTable_data *
resourceTypeIdTable_create(void)
{
	struct resourceTypeIdTable_data *StorageNew = SNMP_MALLOC_STRUCT(resourceTypeIdTable_data);

	DBUGMSGTL(("resourceTypeIdTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->resourceTypeIdName = strdup("\"RTID\"");
		StorageNew->resourceTypeIdNameLen = strlen("\"RTID\"");

	}
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int resourceTypeIdTable_destroy(struct resourceTypeIdTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
resourceTypeIdTable_destroy(struct resourceTypeIdTable_data **thedata)
{
	struct resourceTypeIdTable_data *StorageDel;

	DEBUGMSGTL(("resourceTypeIdTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->resourceTypeIdName);
		StorageDel->resourceTypeIdNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerOUI);
		StorageDel->resourceInfoManufacturerOUILen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerName);
		StorageDel->resourceInfoManufacturerNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerProductName);
		StorageDel->resourceInfoManufacturerProductNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerProductVersion);
		StorageDel->resourceInfoManufacturerProductVersionLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int resourceTypeIdTable_add(struct resourceTypeIdTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the resourceTypeIdTable table data set.
 * Adds a table row structure to the resourceTypeIdTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
resourceTypeIdTable_add(struct resourceTypeIdTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("resourceTypeIdTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&resourceTypeIdTableStorage, vars, thedata);
	DEBUGMSGTL(("resourceTypeIdTable", "registered an entry\n"));
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int resourceTypeIdTable_del(struct resourceTypeIdTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the resourceTypeIdTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
resourceTypeIdTable_del(struct resourceTypeIdTable_data *thedata)
{
	struct resourceTypeIdTable_data *StorageDel;

	DEBUGMSGTL(("resourceTypeIdTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(resourceTypeIdTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&resourceTypeIdTableStorage, hciptr);
	}
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_resourceTypeIdTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for resourceTypeIdTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case resourceTypeIdTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_resourceTypeIdTable(const char *token, char *line)
{
	size_t tmpsize;
	struct resourceTypeIdTable_data *StorageTmp = resourceTypeIdTable_create();

	DEBUGMSGTL(("resourceTypeIdTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceTypeIdName, &StorageTmp->resourceTypeIdNameLen);
	if (StorageTmp->resourceTypeIdName == NULL) {
		config_perror("invalid specification for resourceTypeIdName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerOUI, &StorageTmp->resourceInfoManufacturerOUILen);
	if (StorageTmp->resourceInfoManufacturerOUI == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerOUI");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerName, &StorageTmp->resourceInfoManufacturerNameLen);
	if (StorageTmp->resourceInfoManufacturerName == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerProductName, &StorageTmp->resourceInfoManufacturerProductNameLen);
	if (StorageTmp->resourceInfoManufacturerProductName == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerProductName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerProductVersion, &StorageTmp->resourceInfoManufacturerProductVersionLen);
	if (StorageTmp->resourceInfoManufacturerProductVersion == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerProductVersion");
		return;
	}
	resourceTypeIdTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
}

/*
 * store_resourceTypeIdTable(): store configuraiton file for resourceTypeIdTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_resourceTypeIdTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct resourceTypeIdTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("resourceTypeIdTable", "storing data...  "));
	refresh_resourceTypeIdTable();
	(void) tmpsize;
	for (hcindex = resourceTypeIdTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct resourceTypeIdTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "resourceTypeIdTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceTypeIdName, &StorageTmp->resourceTypeIdNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerOUI, &StorageTmp->resourceInfoManufacturerOUILen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerName, &StorageTmp->resourceInfoManufacturerNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerProductName, &StorageTmp->resourceInfoManufacturerProductNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerProductVersion, &StorageTmp->resourceInfoManufacturerProductVersionLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCStationTable_data *lLCStationTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCStationTable table.
 * Creates a new lLCStationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCStationTable_data *
lLCStationTable_create(void)
{
	struct lLCStationTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCStationTable_data);

	DBUGMSGTL(("lLCStationTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int lLCStationTable_destroy(struct lLCStationTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCStationTable_destroy(struct lLCStationTable_data **thedata)
{
	struct lLCStationTable_data *StorageDel;

	DEBUGMSGTL(("lLCStationTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->lLCStationLLCName);
		StorageDel->lLCStationLLCNameLen = 0;
		SNMP_FREE(StorageDel->lLCStationSupportedServicesTypes);
		StorageDel->lLCStationSupportedServicesTypesLen = 0;
		SNMP_FREE(StorageDel->lLCStationSTRIndicator);
		StorageDel->lLCStationSTRIndicatorLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCStationTable_add(struct lLCStationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCStationTable table data set.
 * Adds a table row structure to the lLCStationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCStationTable_add(struct lLCStationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCStationTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&lLCStationTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCStationTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCStationTable_del(struct lLCStationTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the lLCStationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCStationTable_del(struct lLCStationTable_data *thedata)
{
	struct lLCStationTable_data *StorageDel;

	DEBUGMSGTL(("lLCStationTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCStationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCStationTableStorage, hciptr);
	}
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCStationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCStationTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCStationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCStationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCStationTable_data *StorageTmp = lLCStationTable_create();

	DEBUGMSGTL(("lLCStationTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCStationLLCName, &StorageTmp->lLCStationLLCNameLen);
	if (StorageTmp->lLCStationLLCName == NULL) {
		config_perror("invalid specification for lLCStationLLCName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumLSAPsConfigured, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationNumberOfActiveLSAPs, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCStationSupportedServicesTypes, &StorageTmp->lLCStationSupportedServicesTypesLen);
	if (StorageTmp->lLCStationSupportedServicesTypes == NULL) {
		config_perror("invalid specification for lLCStationSupportedServicesTypes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType1AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType1MaximumRetryCount, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumPDUN3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumRetransmissions4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationReceiveVariableLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationTransmitVariableLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType3AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationType3Retransmissions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationAvgBufferUseSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationBufferProblems, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationBufferSize, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationMaxBufferUseSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationInactiveLSAP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationPDUsDiscard, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCStationSTRIndicator, &StorageTmp->lLCStationSTRIndicatorLen);
	if (StorageTmp->lLCStationSTRIndicator == NULL) {
		config_perror("invalid specification for lLCStationSTRIndicator");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationVersionNumber, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts, &tmpsize);
	lLCStationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
}

/*
 * store_lLCStationTable(): store configuraiton file for lLCStationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCStationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCStationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCStationTable", "storing data...  "));
	refresh_lLCStationTable();
	(void) tmpsize;
	for (hcindex = lLCStationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCStationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCStationTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCStationLLCName, &StorageTmp->lLCStationLLCNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumLSAPsConfigured, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationNumberOfActiveLSAPs, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCStationSupportedServicesTypes, &StorageTmp->lLCStationSupportedServicesTypesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType1AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType1MaximumRetryCount, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumPDUN3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumRetransmissions4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationReceiveVariableLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationTransmitVariableLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType3AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationType3Retransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationAvgBufferUseSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationBufferProblems, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationBufferSize, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationMaxBufferUseSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationInactiveLSAP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationPDUsDiscard, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCStationSTRIndicator, &StorageTmp->lLCStationSTRIndicatorLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationVersionNumber, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCSAPTable_data *lLCSAPTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCSAPTable table.
 * Creates a new lLCSAPTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCSAPTable_data *
lLCSAPTable_create(void)
{
	struct lLCSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCSAPTable_data);

	DBUGMSGTL(("lLCSAPTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int lLCSAPTable_destroy(struct lLCSAPTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCSAPTable_destroy(struct lLCSAPTable_data **thedata)
{
	struct lLCSAPTable_data *StorageDel;

	DEBUGMSGTL(("lLCSAPTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->lLCSAPName);
		StorageDel->lLCSAPNameLen = 0;
		SNMP_FREE(StorageDel->lLCSAPAddress);
		StorageDel->lLCSAPAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCSAPTable_add(struct lLCSAPTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCSAPTable table data set.
 * Adds a table row structure to the lLCSAPTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCSAPTable_add(struct lLCSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCSAPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&lLCSAPTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCSAPTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCSAPTable_del(struct lLCSAPTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the lLCSAPTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCSAPTable_del(struct lLCSAPTable_data *thedata)
{
	struct lLCSAPTable_data *StorageDel;

	DEBUGMSGTL(("lLCSAPTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCSAPTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCSAPTableStorage, hciptr);
	}
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCSAPTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCSAPTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCSAPTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCSAPTable_data *StorageTmp = lLCSAPTable_create();

	DEBUGMSGTL(("lLCSAPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCSAPName, &StorageTmp->lLCSAPNameLen);
	if (StorageTmp->lLCSAPName == NULL) {
		config_perror("invalid specification for lLCSAPName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCSAPAddress, &StorageTmp->lLCSAPAddressLen);
	if (StorageTmp->lLCSAPAddress == NULL) {
		config_perror("invalid specification for lLCSAPAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCSAPRDE, &tmpsize);
	lLCSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
}

/*
 * store_lLCSAPTable(): store configuraiton file for lLCSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCSAPTable", "storing data...  "));
	refresh_lLCSAPTable();
	(void) tmpsize;
	for (hcindex = lLCSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCSAPTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCSAPTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCSAPName, &StorageTmp->lLCSAPNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCSAPAddress, &StorageTmp->lLCSAPAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCSAPRDE, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct rDESetupTable_data *rDESetupTable_create(void)
 * @brief create a fresh data structure representing a new row in the rDESetupTable table.
 * Creates a new rDESetupTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct rDESetupTable_data *
rDESetupTable_create(void)
{
	struct rDESetupTable_data *StorageNew = SNMP_MALLOC_STRUCT(rDESetupTable_data);

	DBUGMSGTL(("rDESetupTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int rDESetupTable_destroy(struct rDESetupTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
rDESetupTable_destroy(struct rDESetupTable_data **thedata)
{
	struct rDESetupTable_data *StorageDel;

	DEBUGMSGTL(("rDESetupTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int rDESetupTable_add(struct rDESetupTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the rDESetupTable table data set.
 * Adds a table row structure to the rDESetupTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
rDESetupTable_add(struct rDESetupTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("rDESetupTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&rDESetupTableStorage, vars, thedata);
	DEBUGMSGTL(("rDESetupTable", "registered an entry\n"));
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int rDESetupTable_del(struct rDESetupTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the rDESetupTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
rDESetupTable_del(struct rDESetupTable_data *thedata)
{
	struct rDESetupTable_data *StorageDel;

	DEBUGMSGTL(("rDESetupTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(rDESetupTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&rDESetupTableStorage, hciptr);
	}
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_rDESetupTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for rDESetupTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case rDESetupTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_rDESetupTable(const char *token, char *line)
{
	size_t tmpsize;
	struct rDESetupTable_data *StorageTmp = rDESetupTable_create();

	DEBUGMSGTL(("rDESetupTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupAgingEnabled, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupAgingValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupEnableType2Reset, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMaximumRouteDescriptors, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMaximumResponseTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMinimumPDUSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupRDEHold, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupRDEReplace, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupName, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupResetOnTestEnabled, &tmpsize);
	rDESetupTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
}

/*
 * store_rDESetupTable(): store configuraiton file for rDESetupTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_rDESetupTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct rDESetupTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("rDESetupTable", "storing data...  "));
	refresh_rDESetupTable();
	(void) tmpsize;
	for (hcindex = rDESetupTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct rDESetupTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "rDESetupTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupAgingEnabled, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupAgingValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupEnableType2Reset, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMaximumRouteDescriptors, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMaximumResponseTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMinimumPDUSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupRDEHold, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupRDEReplace, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupResetOnTestEnabled, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct rDEPairTable_data *rDEPairTable_create(void)
 * @brief create a fresh data structure representing a new row in the rDEPairTable table.
 * Creates a new rDEPairTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct rDEPairTable_data *
rDEPairTable_create(void)
{
	struct rDEPairTable_data *StorageNew = SNMP_MALLOC_STRUCT(rDEPairTable_data);

	DBUGMSGTL(("rDEPairTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int rDEPairTable_destroy(struct rDEPairTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
rDEPairTable_destroy(struct rDEPairTable_data **thedata)
{
	struct rDEPairTable_data *StorageDel;

	DEBUGMSGTL(("rDEPairTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->rDEPairName);
		StorageDel->rDEPairNameLen = 0;
		SNMP_FREE(StorageDel->rDEPairRIF);
		StorageDel->rDEPairRIFLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int rDEPairTable_add(struct rDEPairTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the rDEPairTable table data set.
 * Adds a table row structure to the rDEPairTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
rDEPairTable_add(struct rDEPairTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("rDEPairTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	/* rDEPairName */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->rDEPairName, thedata->rDEPairNameLen);
	header_complex_add_data(&rDEPairTableStorage, vars, thedata);
	DEBUGMSGTL(("rDEPairTable", "registered an entry\n"));
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int rDEPairTable_del(struct rDEPairTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the rDEPairTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
rDEPairTable_del(struct rDEPairTable_data *thedata)
{
	struct rDEPairTable_data *StorageDel;

	DEBUGMSGTL(("rDEPairTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(rDEPairTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&rDEPairTableStorage, hciptr);
	}
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_rDEPairTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for rDEPairTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case rDEPairTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_rDEPairTable(const char *token, char *line)
{
	size_t tmpsize;
	struct rDEPairTable_data *StorageTmp = rDEPairTable_create();

	DEBUGMSGTL(("rDEPairTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->rDEPairName, &StorageTmp->rDEPairNameLen);
	if (StorageTmp->rDEPairName == NULL) {
		config_perror("invalid specification for rDEPairName");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairDiscardCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairNSRPDUCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairNSRSelectedCounter, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->rDEPairRIF, &StorageTmp->rDEPairRIFLen);
	if (StorageTmp->rDEPairRIF == NULL) {
		config_perror("invalid specification for rDEPairRIF");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairSRFPDUCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairQueryCounter, &tmpsize);
	rDEPairTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
}

/*
 * store_rDEPairTable(): store configuraiton file for rDEPairTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_rDEPairTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct rDEPairTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("rDEPairTable", "storing data...  "));
	refresh_rDEPairTable();
	(void) tmpsize;
	for (hcindex = rDEPairTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct rDEPairTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "rDEPairTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->rDEPairName, &StorageTmp->rDEPairNameLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairDiscardCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairNSRPDUCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairNSRSelectedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->rDEPairRIF, &StorageTmp->rDEPairRIFLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairSRFPDUCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairQueryCounter, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCConnectionLessTable_data *lLCConnectionLessTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCConnectionLessTable table.
 * Creates a new lLCConnectionLessTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCConnectionLessTable_data *
lLCConnectionLessTable_create(void)
{
	struct lLCConnectionLessTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnectionLessTable_data);

	DBUGMSGTL(("lLCConnectionLessTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int lLCConnectionLessTable_destroy(struct lLCConnectionLessTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCConnectionLessTable_destroy(struct lLCConnectionLessTable_data **thedata)
{
	struct lLCConnectionLessTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionLessTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnectionlessName);
		StorageDel->lLCConnectionlessNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionLessTable_add(struct lLCConnectionLessTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCConnectionLessTable table data set.
 * Adds a table row structure to the lLCConnectionLessTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCConnectionLessTable_add(struct lLCConnectionLessTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnectionLessTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	header_complex_add_data(&lLCConnectionLessTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnectionLessTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionLessTable_del(struct lLCConnectionLessTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the lLCConnectionLessTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCConnectionLessTable_del(struct lLCConnectionLessTable_data *thedata)
{
	struct lLCConnectionLessTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionLessTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCConnectionLessTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCConnectionLessTableStorage, hciptr);
	}
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCConnectionLessTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCConnectionLessTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCConnectionLessTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCConnectionLessTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionLessTable_data *StorageTmp = lLCConnectionLessTable_create();

	DEBUGMSGTL(("lLCConnectionLessTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessName, &StorageTmp->lLCConnectionlessNameLen);
	if (StorageTmp->lLCConnectionlessName == NULL) {
		config_perror("invalid specification for lLCConnectionlessName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessUIReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessUISent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDSentResponse, &tmpsize);
	lLCConnectionLessTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
}

/*
 * store_lLCConnectionLessTable(): store configuraiton file for lLCConnectionLessTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionLessTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionLessTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnectionLessTable", "storing data...  "));
	refresh_lLCConnectionLessTable();
	(void) tmpsize;
	for (hcindex = lLCConnectionLessTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionLessTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionLessTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessName, &StorageTmp->lLCConnectionlessNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessUIReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessUISent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDSentResponse, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCConnection2Table_data *lLCConnection2Table_create(void)
 * @brief create a fresh data structure representing a new row in the lLCConnection2Table table.
 * Creates a new lLCConnection2Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCConnection2Table_data *
lLCConnection2Table_create(void)
{
	struct lLCConnection2Table_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnection2Table_data);

	DBUGMSGTL(("lLCConnection2Table", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int lLCConnection2Table_destroy(struct lLCConnection2Table_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCConnection2Table_destroy(struct lLCConnection2Table_data **thedata)
{
	struct lLCConnection2Table_data *StorageDel;

	DEBUGMSGTL(("lLCConnection2Table", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2Name);
		StorageDel->lLCConnection2NameLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2Route);
		StorageDel->lLCConnection2RouteLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2ProceduralStatus);
		StorageDel->lLCConnection2ProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2AlarmStatus);
		StorageDel->lLCConnection2AlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnection2Table_add(struct lLCConnection2Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCConnection2Table table data set.
 * Adds a table row structure to the lLCConnection2Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCConnection2Table_add(struct lLCConnection2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnection2Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&lLCConnection2TableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnection2Table", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnection2Table_del(struct lLCConnection2Table_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the lLCConnection2Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCConnection2Table_del(struct lLCConnection2Table_data *thedata)
{
	struct lLCConnection2Table_data *StorageDel;

	DEBUGMSGTL(("lLCConnection2Table", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCConnection2TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCConnection2TableStorage, hciptr);
	}
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCConnection2Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCConnection2Table entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCConnection2Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCConnection2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnection2Table_data *StorageTmp = lLCConnection2Table_create();

	DEBUGMSGTL(("lLCConnection2Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2Name, &StorageTmp->lLCConnection2NameLen);
	if (StorageTmp->lLCConnection2Name == NULL) {
		config_perror("invalid specification for lLCConnection2Name");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2MaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2ReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2SendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2BusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2PBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2RejectTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2LocalBusy, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2RemoteBusy, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2RemoteReset, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2LocalReset, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ProviderReset, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2Route, &StorageTmp->lLCConnection2RouteLen);
	if (StorageTmp->lLCConnection2Route == NULL) {
		config_perror("invalid specification for lLCConnection2Route");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2KStep, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2MaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedI, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentI, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentAcks, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedAcks, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedFRMR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentFRMR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedRR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentRR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedRNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentRNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedREJ, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentREJ, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedSABME, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentSABME, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedUA, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentUA, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedDISC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentDISC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedDM, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentDM, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDUsDiscarded1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDUsDiscarded2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDURetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2OptionalTolerationIPDUs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2DuplicateIPDUsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2Violation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2ProtocolState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2AdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2OperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2UsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCConnection2ProceduralStatus, &StorageTmp->lLCConnection2ProceduralStatusLen);
	if (StorageTmp->lLCConnection2ProceduralStatus == NULL) {
		config_perror("invalid specification for lLCConnection2ProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCConnection2AlarmStatus, &StorageTmp->lLCConnection2AlarmStatusLen);
	if (StorageTmp->lLCConnection2AlarmStatus == NULL) {
		config_perror("invalid specification for lLCConnection2AlarmStatus");
		return;
	}
	lLCConnection2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
}

/*
 * store_lLCConnection2Table(): store configuraiton file for lLCConnection2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnection2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnection2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnection2Table", "storing data...  "));
	refresh_lLCConnection2Table();
	(void) tmpsize;
	for (hcindex = lLCConnection2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnection2Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnection2Table ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2Name, &StorageTmp->lLCConnection2NameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2MaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2ReceivedWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2SendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2BusyStateTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2PBitTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2RejectTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2LocalBusy, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2RemoteBusy, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2RemoteReset, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2LocalReset, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ProviderReset, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2Route, &StorageTmp->lLCConnection2RouteLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2KStep, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2MaxSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedI, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentI, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentAcks, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedAcks, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedFRMR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentFRMR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedRR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentRR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedRNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentRNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedREJ, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentREJ, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedSABME, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentSABME, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedUA, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentUA, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedDISC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentDISC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedDM, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentDM, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDUsDiscarded1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDUsDiscarded2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDURetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2OptionalTolerationIPDUs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2DuplicateIPDUsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2Violation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2ProtocolState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2AdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2OperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2UsageState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCConnection2ProceduralStatus, &StorageTmp->lLCConnection2ProceduralStatusLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCConnection2AlarmStatus, &StorageTmp->lLCConnection2AlarmStatusLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCConnection2IVMOTable_data *lLCConnection2IVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCConnection2IVMOTable table.
 * Creates a new lLCConnection2IVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCConnection2IVMOTable_data *
lLCConnection2IVMOTable_create(void)
{
	struct lLCConnection2IVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnection2IVMOTable_data);

	DBUGMSGTL(("lLCConnection2IVMOTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int lLCConnection2IVMOTable_destroy(struct lLCConnection2IVMOTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCConnection2IVMOTable_destroy(struct lLCConnection2IVMOTable_data **thedata)
{
	struct lLCConnection2IVMOTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnection2IVMOTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2IVMOName);
		StorageDel->lLCConnection2IVMONameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnection2IVMOTable_add(struct lLCConnection2IVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCConnection2IVMOTable table data set.
 * Adds a table row structure to the lLCConnection2IVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCConnection2IVMOTable_add(struct lLCConnection2IVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnection2IVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&lLCConnection2IVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnection2IVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnection2IVMOTable_del(struct lLCConnection2IVMOTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the lLCConnection2IVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCConnection2IVMOTable_del(struct lLCConnection2IVMOTable_data *thedata)
{
	struct lLCConnection2IVMOTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnection2IVMOTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCConnection2IVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCConnection2IVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCConnection2IVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCConnection2IVMOTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCConnection2IVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCConnection2IVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnection2IVMOTable_data *StorageTmp = lLCConnection2IVMOTable_create();

	DEBUGMSGTL(("lLCConnection2IVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2IVMOName, &StorageTmp->lLCConnection2IVMONameLen);
	if (StorageTmp->lLCConnection2IVMOName == NULL) {
		config_perror("invalid specification for lLCConnection2IVMOName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMORejectTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMORoute, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOKStep, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOMaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs, &tmpsize);
	lLCConnection2IVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
}

/*
 * store_lLCConnection2IVMOTable(): store configuraiton file for lLCConnection2IVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnection2IVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnection2IVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnection2IVMOTable", "storing data...  "));
	refresh_lLCConnection2IVMOTable();
	(void) tmpsize;
	for (hcindex = lLCConnection2IVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnection2IVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnection2IVMOTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2IVMOName, &StorageTmp->lLCConnection2IVMONameLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOReceivedWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOBitTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMORejectTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMORoute, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOKStep, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOMaxSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCConnectionlessAckTable_data *lLCConnectionlessAckTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCConnectionlessAckTable table.
 * Creates a new lLCConnectionlessAckTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCConnectionlessAckTable_data *
lLCConnectionlessAckTable_create(void)
{
	struct lLCConnectionlessAckTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnectionlessAckTable_data);

	DBUGMSGTL(("lLCConnectionlessAckTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int lLCConnectionlessAckTable_destroy(struct lLCConnectionlessAckTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCConnectionlessAckTable_destroy(struct lLCConnectionlessAckTable_data **thedata)
{
	struct lLCConnectionlessAckTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionlessAckTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnectionlessAckName);
		StorageDel->lLCConnectionlessAckNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionlessAckTable_add(struct lLCConnectionlessAckTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCConnectionlessAckTable table data set.
 * Adds a table row structure to the lLCConnectionlessAckTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCConnectionlessAckTable_add(struct lLCConnectionlessAckTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnectionlessAckTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* lLCConnectionlessAckName */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCConnectionlessAckName, thedata->lLCConnectionlessAckNameLen);
	header_complex_add_data(&lLCConnectionlessAckTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnectionlessAckTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionlessAckTable_del(struct lLCConnectionlessAckTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the lLCConnectionlessAckTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCConnectionlessAckTable_del(struct lLCConnectionlessAckTable_data *thedata)
{
	struct lLCConnectionlessAckTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionlessAckTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCConnectionlessAckTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCConnectionlessAckTableStorage, hciptr);
	}
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCConnectionlessAckTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCConnectionlessAckTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCConnectionlessAckTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCConnectionlessAckTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionlessAckTable_data *StorageTmp = lLCConnectionlessAckTable_create();

	DEBUGMSGTL(("lLCConnectionlessAckTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessAckName, &StorageTmp->lLCConnectionlessAckNameLen);
	if (StorageTmp->lLCConnectionlessAckName == NULL) {
		config_perror("invalid specification for lLCConnectionlessAckName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentResponse, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckReceiveResources, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckUIReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckUISent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDSentResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckNoResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandIP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandIT, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandOK, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandPE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandRS, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandUE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandUN, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckReceivedACCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckSentACCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseIP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseIT, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseNE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseOK, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseRS, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseUE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseUN, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckViolation, &tmpsize);
	lLCConnectionlessAckTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
}

/*
 * store_lLCConnectionlessAckTable(): store configuraiton file for lLCConnectionlessAckTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionlessAckTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionlessAckTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnectionlessAckTable", "storing data...  "));
	refresh_lLCConnectionlessAckTable();
	(void) tmpsize;
	for (hcindex = lLCConnectionlessAckTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionlessAckTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionlessAckTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessAckName, &StorageTmp->lLCConnectionlessAckNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckReceiveResources, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckUIReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckUISent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckNoResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandIP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandIT, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandOK, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandPE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandRS, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandUE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandUN, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckReceivedACCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckSentACCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseIP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseIT, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseNE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseOK, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseRS, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseUE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseUN, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckViolation, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCConnectionlessAckIVMOTable_data *lLCConnectionlessAckIVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCConnectionlessAckIVMOTable table.
 * Creates a new lLCConnectionlessAckIVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCConnectionlessAckIVMOTable_data *
lLCConnectionlessAckIVMOTable_create(void)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnectionlessAckIVMOTable_data);

	DBUGMSGTL(("lLCConnectionlessAckIVMOTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lLCConnectionlessAckIVMORowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int lLCConnectionlessAckIVMOTable_destroy(struct lLCConnectionlessAckIVMOTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCConnectionlessAckIVMOTable_destroy(struct lLCConnectionlessAckIVMOTable_data **thedata)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnectionlessAckIVMOName);
		StorageDel->lLCConnectionlessAckIVMONameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionlessAckIVMOTable_add(struct lLCConnectionlessAckIVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCConnectionlessAckIVMOTable table data set.
 * Adds a table row structure to the lLCConnectionlessAckIVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCConnectionlessAckIVMOTable_add(struct lLCConnectionlessAckIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* lLCConnectionlessAckIVMOName */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCConnectionlessAckIVMOName, thedata->lLCConnectionlessAckIVMONameLen);
	header_complex_add_data(&lLCConnectionlessAckIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionlessAckIVMOTable_del(struct lLCConnectionlessAckIVMOTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the lLCConnectionlessAckIVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCConnectionlessAckIVMOTable_del(struct lLCConnectionlessAckIVMOTable_data *thedata)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCConnectionlessAckIVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCConnectionlessAckIVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCConnectionlessAckIVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCConnectionlessAckIVMOTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCConnectionlessAckIVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCConnectionlessAckIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = lLCConnectionlessAckIVMOTable_create();

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessAckIVMOName, &StorageTmp->lLCConnectionlessAckIVMONameLen);
	if (StorageTmp->lLCConnectionlessAckIVMOName == NULL) {
		config_perror("invalid specification for lLCConnectionlessAckIVMOName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMORowStatus, &tmpsize);
	lLCConnectionlessAckIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
}

/*
 * store_lLCConnectionlessAckIVMOTable(): store configuraiton file for lLCConnectionlessAckIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionlessAckIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "storing data...  "));
	refresh_lLCConnectionlessAckIVMOTable();
	(void) tmpsize;
	for (hcindex = lLCConnectionlessAckIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionlessAckIVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionlessAckIVMOTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessAckIVMOName, &StorageTmp->lLCConnectionlessAckIVMONameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct networkEntityTable_data *networkEntityTable_create(void)
 * @brief create a fresh data structure representing a new row in the networkEntityTable table.
 * Creates a new networkEntityTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct networkEntityTable_data *
networkEntityTable_create(void)
{
	struct networkEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(networkEntityTable_data);

	DBUGMSGTL(("networkEntityTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->networkEntityRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("networkEntityTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int networkEntityTable_destroy(struct networkEntityTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
networkEntityTable_destroy(struct networkEntityTable_data **thedata)
{
	struct networkEntityTable_data *StorageDel;

	DEBUGMSGTL(("networkEntityTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->networkEntityTitles);
		StorageDel->networkEntityTitlesLen = 0;
		SNMP_FREE(StorageDel->networkEntitySystemTypes);
		StorageDel->networkEntitySystemTypesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("networkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int networkEntityTable_add(struct networkEntityTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the networkEntityTable table data set.
 * Adds a table row structure to the networkEntityTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
networkEntityTable_add(struct networkEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("networkEntityTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&networkEntityTableStorage, vars, thedata);
	DEBUGMSGTL(("networkEntityTable", "registered an entry\n"));
	DEBUGMSGTL(("networkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int networkEntityTable_del(struct networkEntityTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the networkEntityTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
networkEntityTable_del(struct networkEntityTable_data *thedata)
{
	struct networkEntityTable_data *StorageDel;

	DEBUGMSGTL(("networkEntityTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(networkEntityTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&networkEntityTableStorage, hciptr);
	}
	DEBUGMSGTL(("networkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_networkEntityTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for networkEntityTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case networkEntityTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_networkEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct networkEntityTable_data *StorageTmp = networkEntityTable_create();

	DEBUGMSGTL(("networkEntityTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->networkEntityTitles, &StorageTmp->networkEntityTitlesLen);
	if (StorageTmp->networkEntityTitles == NULL) {
		config_perror("invalid specification for networkEntityTitles");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->networkEntitySystemTypes, &StorageTmp->networkEntitySystemTypesLen);
	if (StorageTmp->networkEntitySystemTypes == NULL) {
		config_perror("invalid specification for networkEntitySystemTypes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->networkEntityRowStatus, &tmpsize);
	networkEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("networkEntityTable", "done.\n"));
}

/*
 * store_networkEntityTable(): store configuraiton file for networkEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_networkEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct networkEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("networkEntityTable", "storing data...  "));
	refresh_networkEntityTable();
	(void) tmpsize;
	for (hcindex = networkEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct networkEntityTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "networkEntityTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->networkEntityTitles, &StorageTmp->networkEntityTitlesLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->networkEntitySystemTypes, &StorageTmp->networkEntitySystemTypesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->networkEntityRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("networkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct nSAPTable_data *nSAPTable_create(void)
 * @brief create a fresh data structure representing a new row in the nSAPTable table.
 * Creates a new nSAPTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct nSAPTable_data *
nSAPTable_create(void)
{
	struct nSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(nSAPTable_data);

	DBUGMSGTL(("nSAPTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->nSAPRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("nSAPTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int nSAPTable_destroy(struct nSAPTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
nSAPTable_destroy(struct nSAPTable_data **thedata)
{
	struct nSAPTable_data *StorageDel;

	DEBUGMSGTL(("nSAPTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("nSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int nSAPTable_add(struct nSAPTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the nSAPTable table data set.
 * Adds a table row structure to the nSAPTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
nSAPTable_add(struct nSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("nSAPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&nSAPTableStorage, vars, thedata);
	DEBUGMSGTL(("nSAPTable", "registered an entry\n"));
	DEBUGMSGTL(("nSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int nSAPTable_del(struct nSAPTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the nSAPTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
nSAPTable_del(struct nSAPTable_data *thedata)
{
	struct nSAPTable_data *StorageDel;

	DEBUGMSGTL(("nSAPTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(nSAPTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&nSAPTableStorage, hciptr);
	}
	DEBUGMSGTL(("nSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_nSAPTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for nSAPTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case nSAPTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_nSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct nSAPTable_data *StorageTmp = nSAPTable_create();

	DEBUGMSGTL(("nSAPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->nSAPRowStatus, &tmpsize);
	nSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("nSAPTable", "done.\n"));
}

/*
 * store_nSAPTable(): store configuraiton file for nSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_nSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct nSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("nSAPTable", "storing data...  "));
	refresh_nSAPTable();
	(void) tmpsize;
	for (hcindex = nSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct nSAPTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "nSAPTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->nSAPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("nSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct cLNSTable_data *cLNSTable_create(void)
 * @brief create a fresh data structure representing a new row in the cLNSTable table.
 * Creates a new cLNSTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct cLNSTable_data *
cLNSTable_create(void)
{
	struct cLNSTable_data *StorageNew = SNMP_MALLOC_STRUCT(cLNSTable_data);

	DBUGMSGTL(("cLNSTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->cLNSEnableChecksum = false;
		StorageNew->cLNSRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("cLNSTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int cLNSTable_destroy(struct cLNSTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
cLNSTable_destroy(struct cLNSTable_data **thedata)
{
	struct cLNSTable_data *StorageDel;

	DEBUGMSGTL(("cLNSTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cLNSSupportedProtocols);
		StorageDel->cLNSSupportedProtocolsLen = 0;
		SNMP_FREE(StorageDel->cLNSOperationalSystemType);
		StorageDel->cLNSOperationalSystemTypeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("cLNSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSTable_add(struct cLNSTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the cLNSTable table data set.
 * Adds a table row structure to the cLNSTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
cLNSTable_add(struct cLNSTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("cLNSTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	header_complex_add_data(&cLNSTableStorage, vars, thedata);
	DEBUGMSGTL(("cLNSTable", "registered an entry\n"));
	DEBUGMSGTL(("cLNSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSTable_del(struct cLNSTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the cLNSTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
cLNSTable_del(struct cLNSTable_data *thedata)
{
	struct cLNSTable_data *StorageDel;

	DEBUGMSGTL(("cLNSTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(cLNSTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&cLNSTableStorage, hciptr);
	}
	DEBUGMSGTL(("cLNSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_cLNSTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for cLNSTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case cLNSTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_cLNSTable(const char *token, char *line)
{
	size_t tmpsize;
	struct cLNSTable_data *StorageTmp = cLNSTable_create();

	DEBUGMSGTL(("cLNSTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSSupportedProtocols, &StorageTmp->cLNSSupportedProtocolsLen);
	if (StorageTmp->cLNSSupportedProtocols == NULL) {
		config_perror("invalid specification for cLNSSupportedProtocols");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->cLNSOperationalSystemType, &StorageTmp->cLNSOperationalSystemTypeLen);
	if (StorageTmp->cLNSOperationalSystemType == NULL) {
		config_perror("invalid specification for cLNSOperationalSystemType");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSOctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSOctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSSegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSSegmentsDiscarded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSAssemblingSegmentsDiscarded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSErrorReportsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSpDUDiscards, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSCongestionDiscards, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSMaximumLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSEnableChecksum, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSRowStatus, &tmpsize);
	cLNSTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("cLNSTable", "done.\n"));
}

/*
 * store_cLNSTable(): store configuraiton file for cLNSTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_cLNSTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cLNSTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("cLNSTable", "storing data...  "));
	refresh_cLNSTable();
	(void) tmpsize;
	for (hcindex = cLNSTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cLNSTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cLNSTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSSupportedProtocols, &StorageTmp->cLNSSupportedProtocolsLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->cLNSOperationalSystemType, &StorageTmp->cLNSOperationalSystemTypeLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSOctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSOctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSSegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSSegmentsDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSAssemblingSegmentsDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSErrorReportsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSpDUDiscards, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSCongestionDiscards, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSMaximumLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSEnableChecksum, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("cLNSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct cLNSISISTable_data *cLNSISISTable_create(void)
 * @brief create a fresh data structure representing a new row in the cLNSISISTable table.
 * Creates a new cLNSISISTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct cLNSISISTable_data *
cLNSISISTable_create(void)
{
	struct cLNSISISTable_data *StorageNew = SNMP_MALLOC_STRUCT(cLNSISISTable_data);

	DBUGMSGTL(("cLNSISISTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->cLNSISISRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("cLNSISISTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int cLNSISISTable_destroy(struct cLNSISISTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
cLNSISISTable_destroy(struct cLNSISISTable_data **thedata)
{
	struct cLNSISISTable_data *StorageDel;

	DEBUGMSGTL(("cLNSISISTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cLNSISISversion);
		StorageDel->cLNSISISversionLen = 0;
		SNMP_FREE(StorageDel->cLNSISISsystemId);
		StorageDel->cLNSISISsystemIdLen = 0;
		SNMP_FREE(StorageDel->cLNSISISmanualAreaAddresses);
		StorageDel->cLNSISISmanualAreaAddressesLen = 0;
		SNMP_FREE(StorageDel->cLNSISISareaAddresses);
		StorageDel->cLNSISISareaAddressesLen = 0;
		SNMP_FREE(StorageDel->cLNSISISareaTransmitPassword);
		StorageDel->cLNSISISareaTransmitPasswordLen = 0;
		SNMP_FREE(StorageDel->cLNSISISareaReceivePasswords);
		StorageDel->cLNSISISareaReceivePasswordsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("cLNSISISTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSISISTable_add(struct cLNSISISTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the cLNSISISTable table data set.
 * Adds a table row structure to the cLNSISISTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
cLNSISISTable_add(struct cLNSISISTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("cLNSISISTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	header_complex_add_data(&cLNSISISTableStorage, vars, thedata);
	DEBUGMSGTL(("cLNSISISTable", "registered an entry\n"));
	DEBUGMSGTL(("cLNSISISTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSISISTable_del(struct cLNSISISTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the cLNSISISTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
cLNSISISTable_del(struct cLNSISISTable_data *thedata)
{
	struct cLNSISISTable_data *StorageDel;

	DEBUGMSGTL(("cLNSISISTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(cLNSISISTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&cLNSISISTableStorage, hciptr);
	}
	DEBUGMSGTL(("cLNSISISTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_cLNSISISTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for cLNSISISTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case cLNSISISTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_cLNSISISTable(const char *token, char *line)
{
	size_t tmpsize;
	struct cLNSISISTable_data *StorageTmp = cLNSISISTable_create();

	DEBUGMSGTL(("cLNSISISTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISversion, &StorageTmp->cLNSISISversionLen);
	if (StorageTmp->cLNSISISversion == NULL) {
		config_perror("invalid specification for cLNSISISversion");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISiSType, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISsystemId, &StorageTmp->cLNSISISsystemIdLen);
	if (StorageTmp->cLNSISISsystemId == NULL) {
		config_perror("invalid specification for cLNSISISsystemId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISmaximumPathSplits, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISminimumLSPTransmissionInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISmaximumLSPGenerationInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISIScompleteSNPInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISoriginatingL1LSPBufferSize, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISmanualAreaAddresses, &StorageTmp->cLNSISISmanualAreaAddressesLen);
	if (StorageTmp->cLNSISISmanualAreaAddresses == NULL) {
		config_perror("invalid specification for cLNSISISmanualAreaAddresses");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISmaximumAreaAddresses, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISminimumLSPGenerationInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISpollESHelloRate, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISpartialSNPInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISwaitingTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISdRISISHelloTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISl1State, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISareaAddresses, &StorageTmp->cLNSISISareaAddressesLen);
	if (StorageTmp->cLNSISISareaAddresses == NULL) {
		config_perror("invalid specification for cLNSISISareaAddresses");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISIScorruptedLSPsDetected, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISlSPL1DatabaseOverloads, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISmanualAddressesDroppedFromAreas, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISsequenceNumberSkips, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISownLSPPurges, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISiDFieldLengthMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISmaximumAreaAddressesMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISlSPTooLargeToPropagate, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISareaTransmitPassword, &StorageTmp->cLNSISISareaTransmitPasswordLen);
	if (StorageTmp->cLNSISISareaTransmitPassword == NULL) {
		config_perror("invalid specification for cLNSISISareaTransmitPassword");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISareaReceivePasswords, &StorageTmp->cLNSISISareaReceivePasswordsLen);
	if (StorageTmp->cLNSISISareaReceivePasswords == NULL) {
		config_perror("invalid specification for cLNSISISareaReceivePasswords");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISauthenticationFailures, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISRowStatus, &tmpsize);
	cLNSISISTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("cLNSISISTable", "done.\n"));
}

/*
 * store_cLNSISISTable(): store configuraiton file for cLNSISISTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_cLNSISISTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cLNSISISTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("cLNSISISTable", "storing data...  "));
	refresh_cLNSISISTable();
	(void) tmpsize;
	for (hcindex = cLNSISISTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cLNSISISTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cLNSISISTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISversion, &StorageTmp->cLNSISISversionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISiSType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISsystemId, &StorageTmp->cLNSISISsystemIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISmaximumPathSplits, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISminimumLSPTransmissionInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISmaximumLSPGenerationInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISIScompleteSNPInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISoriginatingL1LSPBufferSize, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISmanualAreaAddresses, &StorageTmp->cLNSISISmanualAreaAddressesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISmaximumAreaAddresses, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISminimumLSPGenerationInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISpollESHelloRate, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISpartialSNPInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISwaitingTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISdRISISHelloTimer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISl1State, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISareaAddresses, &StorageTmp->cLNSISISareaAddressesLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISIScorruptedLSPsDetected, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISlSPL1DatabaseOverloads, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISmanualAddressesDroppedFromAreas, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISsequenceNumberSkips, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISownLSPPurges, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISiDFieldLengthMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISmaximumAreaAddressesMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISlSPTooLargeToPropagate, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISareaTransmitPassword, &StorageTmp->cLNSISISareaTransmitPasswordLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISareaReceivePasswords, &StorageTmp->cLNSISISareaReceivePasswordsLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISauthenticationFailures, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("cLNSISISTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct cLNSISISLevel2Table_data *cLNSISISLevel2Table_create(void)
 * @brief create a fresh data structure representing a new row in the cLNSISISLevel2Table table.
 * Creates a new cLNSISISLevel2Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct cLNSISISLevel2Table_data *
cLNSISISLevel2Table_create(void)
{
	struct cLNSISISLevel2Table_data *StorageNew = SNMP_MALLOC_STRUCT(cLNSISISLevel2Table_data);

	DBUGMSGTL(("cLNSISISLevel2Table", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->cLNSISISLevel2RowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("cLNSISISLevel2Table", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int cLNSISISLevel2Table_destroy(struct cLNSISISLevel2Table_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
cLNSISISLevel2Table_destroy(struct cLNSISISLevel2Table_data **thedata)
{
	struct cLNSISISLevel2Table_data *StorageDel;

	DEBUGMSGTL(("cLNSISISLevel2Table", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2partitionAreaAddresses);
		StorageDel->cLNSISISLevel2partitionAreaAddressesLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2partitionDesignatedL2IntermediateSystem);
		StorageDel->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2domainTransmitPassword);
		StorageDel->cLNSISISLevel2domainTransmitPasswordLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2domainReceivePasswords);
		StorageDel->cLNSISISLevel2domainReceivePasswordsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("cLNSISISLevel2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSISISLevel2Table_add(struct cLNSISISLevel2Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the cLNSISISLevel2Table table data set.
 * Adds a table row structure to the cLNSISISLevel2Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
cLNSISISLevel2Table_add(struct cLNSISISLevel2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("cLNSISISLevel2Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&cLNSISISLevel2TableStorage, vars, thedata);
	DEBUGMSGTL(("cLNSISISLevel2Table", "registered an entry\n"));
	DEBUGMSGTL(("cLNSISISLevel2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSISISLevel2Table_del(struct cLNSISISLevel2Table_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the cLNSISISLevel2Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
cLNSISISLevel2Table_del(struct cLNSISISLevel2Table_data *thedata)
{
	struct cLNSISISLevel2Table_data *StorageDel;

	DEBUGMSGTL(("cLNSISISLevel2Table", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(cLNSISISLevel2TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&cLNSISISLevel2TableStorage, hciptr);
	}
	DEBUGMSGTL(("cLNSISISLevel2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_cLNSISISLevel2Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for cLNSISISLevel2Table entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case cLNSISISLevel2Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_cLNSISISLevel2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct cLNSISISLevel2Table_data *StorageTmp = cLNSISISLevel2Table_create();

	DEBUGMSGTL(("cLNSISISLevel2Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2partitionAreaAddresses, &StorageTmp->cLNSISISLevel2partitionAreaAddressesLen);
	if (StorageTmp->cLNSISISLevel2partitionAreaAddresses == NULL) {
		config_perror("invalid specification for cLNSISISLevel2partitionAreaAddresses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem, &StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen);
	if (StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem == NULL) {
		config_perror("invalid specification for cLNSISISLevel2partitionDesignatedL2IntermediateSystem");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2l2State, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2domainTransmitPassword, &StorageTmp->cLNSISISLevel2domainTransmitPasswordLen);
	if (StorageTmp->cLNSISISLevel2domainTransmitPassword == NULL) {
		config_perror("invalid specification for cLNSISISLevel2domainTransmitPassword");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2domainReceivePasswords, &StorageTmp->cLNSISISLevel2domainReceivePasswordsLen);
	if (StorageTmp->cLNSISISLevel2domainReceivePasswords == NULL) {
		config_perror("invalid specification for cLNSISISLevel2domainReceivePasswords");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2RowStatus, &tmpsize);
	cLNSISISLevel2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("cLNSISISLevel2Table", "done.\n"));
}

/*
 * store_cLNSISISLevel2Table(): store configuraiton file for cLNSISISLevel2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_cLNSISISLevel2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cLNSISISLevel2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("cLNSISISLevel2Table", "storing data...  "));
	refresh_cLNSISISLevel2Table();
	(void) tmpsize;
	for (hcindex = cLNSISISLevel2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cLNSISISLevel2Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cLNSISISLevel2Table ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2partitionAreaAddresses, &StorageTmp->cLNSISISLevel2partitionAreaAddressesLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem,
						   &StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2l2State, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2domainTransmitPassword, &StorageTmp->cLNSISISLevel2domainTransmitPasswordLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2domainReceivePasswords, &StorageTmp->cLNSISISLevel2domainReceivePasswordsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2RowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("cLNSISISLevel2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct linkageTable_data *linkageTable_create(void)
 * @brief create a fresh data structure representing a new row in the linkageTable table.
 * Creates a new linkageTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct linkageTable_data *
linkageTable_create(void)
{
	struct linkageTable_data *StorageNew = SNMP_MALLOC_STRUCT(linkageTable_data);

	DBUGMSGTL(("linkageTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->linkageRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("linkageTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int linkageTable_destroy(struct linkageTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
linkageTable_destroy(struct linkageTable_data **thedata)
{
	struct linkageTable_data *StorageDel;

	DEBUGMSGTL(("linkageTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->protocolMachineId);
		StorageDel->protocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->linkageId);
		StorageDel->linkageIdLen = 0;
		SNMP_FREE(StorageDel->linkageSnServiceProvider);
		StorageDel->linkageSnServiceProviderLen = 0;
		SNMP_FREE(StorageDel->linkageSnSAP);
		StorageDel->linkageSnSAPLen = 0;
		SNMP_FREE(StorageDel->linkageOperationalProtocols);
		StorageDel->linkageOperationalProtocolsLen = 0;
		SNMP_FREE(StorageDel->linkageISiSO9542OperationalSubsets);
		StorageDel->linkageISiSO9542OperationalSubsetsLen = 0;
		SNMP_FREE(StorageDel->linkageISHoldingTimerMultiplier);
		StorageDel->linkageISHoldingTimerMultiplierLen = 0;
		SNMP_FREE(StorageDel->linkageISISConfigurationTimer);
		StorageDel->linkageISISConfigurationTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISSuggestedEsConfigurationTimer);
		StorageDel->linkageISSuggestedEsConfigurationTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISRedirectHoldingTime);
		StorageDel->linkageISRedirectHoldingTimeLen = 0;
		SNMP_FREE(StorageDel->linkageESiSO9542OperationalSubsets);
		StorageDel->linkageESiSO9542OperationalSubsetsLen = 0;
		SNMP_FREE(StorageDel->linkageESHoldingTimerMultiplier);
		StorageDel->linkageESHoldingTimerMultiplierLen = 0;
		SNMP_FREE(StorageDel->linkageESManualISSNPAAddress);
		StorageDel->linkageESManualISSNPAAddressLen = 0;
		SNMP_FREE(StorageDel->linkageESDefaultESConfigTimer);
		StorageDel->linkageESDefaultESConfigTimerLen = 0;
		SNMP_FREE(StorageDel->linkageESActiveESConfigTimer);
		StorageDel->linkageESActiveESConfigTimerLen = 0;
		SNMP_FREE(StorageDel->linkageInitialMinimumTimer);
		StorageDel->linkageInitialMinimumTimerLen = 0;
		SNMP_FREE(StorageDel->linkageReserveTimer);
		StorageDel->linkageReserveTimerLen = 0;
		SNMP_FREE(StorageDel->linkageIdleTimer);
		StorageDel->linkageIdleTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISISType);
		StorageDel->linkageISISTypeLen = 0;
		SNMP_FREE(StorageDel->linkageISISiSISHelloTimer);
		StorageDel->linkageISISiSISHelloTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1DefaultMetric);
		StorageDel->linkageISISl1DefaultMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1DelayMetric);
		StorageDel->linkageISISl1DelayMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1ExpenseMetric);
		StorageDel->linkageISISl1ExpenseMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1ErrorMetric);
		StorageDel->linkageISISl1ErrorMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISexternalDomain);
		StorageDel->linkageISISexternalDomainLen = 0;
		SNMP_FREE(StorageDel->linkageISIScircuitTransmitPassword);
		StorageDel->linkageISIScircuitTransmitPasswordLen = 0;
		SNMP_FREE(StorageDel->linkageISIScircuitReceivedPasswords);
		StorageDel->linkageISIScircuitReceivedPasswordsLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1IntermediateSystemPriority);
		StorageDel->linkageISISl1IntermediateSystemPriorityLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1CircuitID);
		StorageDel->linkageISISl1CircuitIDLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1DesignatedIntermediateSystem);
		StorageDel->linkageISISl1DesignatedIntermediateSystemLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentDefaultMetricIncrement);
		StorageDel->linkageISIScallEstablishmentDefaultMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentDelayMetricIncrement);
		StorageDel->linkageISIScallEstablishmentDelayMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentExpenseMetricIncrement);
		StorageDel->linkageISIScallEstablishmentExpenseMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentErrorMetricIncrement);
		StorageDel->linkageISIScallEstablishmentErrorMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISISptPtCircuitID);
		StorageDel->linkageISISptPtCircuitIDLen = 0;
		SNMP_FREE(StorageDel->linkageISISoutgoingCallIVMO);
		StorageDel->linkageISISoutgoingCallIVMOLen = 0;
		SNMP_FREE(StorageDel->linkageISISneighborSNPAAddress);
		StorageDel->linkageISISneighborSNPAAddressLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2DefaultMetric);
		StorageDel->linkageISISl2DefaultMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2DelayMetric);
		StorageDel->linkageISISl2DelayMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2ExpenseMetric);
		StorageDel->linkageISISl2ExpenseMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2ErrorMetric);
		StorageDel->linkageISISl2ErrorMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2IntermediateSystemPriority);
		StorageDel->linkageISISl2IntermediateSystemPriorityLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2CircuitID);
		StorageDel->linkageISISl2CircuitIDLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2DesignatedIntermediateSystem);
		StorageDel->linkageISISl2DesignatedIntermediateSystemLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("linkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int linkageTable_add(struct linkageTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the linkageTable table data set.
 * Adds a table row structure to the linkageTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
linkageTable_add(struct linkageTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("linkageTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* protocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->protocolMachineId, thedata->protocolMachineIdLen);
	/* linkageId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->linkageId, thedata->linkageIdLen);
	header_complex_add_data(&linkageTableStorage, vars, thedata);
	DEBUGMSGTL(("linkageTable", "registered an entry\n"));
	DEBUGMSGTL(("linkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int linkageTable_del(struct linkageTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the linkageTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
linkageTable_del(struct linkageTable_data *thedata)
{
	struct linkageTable_data *StorageDel;

	DEBUGMSGTL(("linkageTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(linkageTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&linkageTableStorage, hciptr);
	}
	DEBUGMSGTL(("linkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_linkageTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for linkageTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case linkageTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_linkageTable(const char *token, char *line)
{
	size_t tmpsize;
	struct linkageTable_data *StorageTmp = linkageTable_create();

	DEBUGMSGTL(("linkageTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->protocolMachineId, &StorageTmp->protocolMachineIdLen);
	if (StorageTmp->protocolMachineId == NULL) {
		config_perror("invalid specification for protocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageId, &StorageTmp->linkageIdLen);
	if (StorageTmp->linkageId == NULL) {
		config_perror("invalid specification for linkageId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageSnServiceProvider, &StorageTmp->linkageSnServiceProviderLen);
	if (StorageTmp->linkageSnServiceProvider == NULL) {
		config_perror("invalid specification for linkageSnServiceProvider");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->linkageSnSAP, &StorageTmp->linkageSnSAPLen);
	if (StorageTmp->linkageSnSAP == NULL) {
		config_perror("invalid specification for linkageSnSAP");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageOperationalProtocols, &StorageTmp->linkageOperationalProtocolsLen);
	if (StorageTmp->linkageOperationalProtocols == NULL) {
		config_perror("invalid specification for linkageOperationalProtocols");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISiSO9542OperationalSubsets, &StorageTmp->linkageISiSO9542OperationalSubsetsLen);
	if (StorageTmp->linkageISiSO9542OperationalSubsets == NULL) {
		config_perror("invalid specification for linkageISiSO9542OperationalSubsets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISHoldingTimerMultiplier, &StorageTmp->linkageISHoldingTimerMultiplierLen);
	if (StorageTmp->linkageISHoldingTimerMultiplier == NULL) {
		config_perror("invalid specification for linkageISHoldingTimerMultiplier");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISConfigurationTimer, &StorageTmp->linkageISISConfigurationTimerLen);
	if (StorageTmp->linkageISISConfigurationTimer == NULL) {
		config_perror("invalid specification for linkageISISConfigurationTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISSuggestedEsConfigurationTimer, &StorageTmp->linkageISSuggestedEsConfigurationTimerLen);
	if (StorageTmp->linkageISSuggestedEsConfigurationTimer == NULL) {
		config_perror("invalid specification for linkageISSuggestedEsConfigurationTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISRedirectHoldingTime, &StorageTmp->linkageISRedirectHoldingTimeLen);
	if (StorageTmp->linkageISRedirectHoldingTime == NULL) {
		config_perror("invalid specification for linkageISRedirectHoldingTime");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISESReachabilityChanges, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISInvalid9542PDUs, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESiSO9542OperationalSubsets, &StorageTmp->linkageESiSO9542OperationalSubsetsLen);
	if (StorageTmp->linkageESiSO9542OperationalSubsets == NULL) {
		config_perror("invalid specification for linkageESiSO9542OperationalSubsets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESHoldingTimerMultiplier, &StorageTmp->linkageESHoldingTimerMultiplierLen);
	if (StorageTmp->linkageESHoldingTimerMultiplier == NULL) {
		config_perror("invalid specification for linkageESHoldingTimerMultiplier");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESManualISSNPAAddress, &StorageTmp->linkageESManualISSNPAAddressLen);
	if (StorageTmp->linkageESManualISSNPAAddress == NULL) {
		config_perror("invalid specification for linkageESManualISSNPAAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESDefaultESConfigTimer, &StorageTmp->linkageESDefaultESConfigTimerLen);
	if (StorageTmp->linkageESDefaultESConfigTimer == NULL) {
		config_perror("invalid specification for linkageESDefaultESConfigTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESActiveESConfigTimer, &StorageTmp->linkageESActiveESConfigTimerLen);
	if (StorageTmp->linkageESActiveESConfigTimer == NULL) {
		config_perror("invalid specification for linkageESActiveESConfigTimer");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageESISReachabilityChanges, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageESInvalid9542PDUs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageEnableChecksum, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageInitialMinimumTimer, &StorageTmp->linkageInitialMinimumTimerLen);
	if (StorageTmp->linkageInitialMinimumTimer == NULL) {
		config_perror("invalid specification for linkageInitialMinimumTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageReserveTimer, &StorageTmp->linkageReserveTimerLen);
	if (StorageTmp->linkageReserveTimer == NULL) {
		config_perror("invalid specification for linkageReserveTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageIdleTimer, &StorageTmp->linkageIdleTimerLen);
	if (StorageTmp->linkageIdleTimer == NULL) {
		config_perror("invalid specification for linkageIdleTimer");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageSNDCFCallsPlaced, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageSNDCFCallsFailed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageCODLCallsPlaced, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageCODLCallsFailed, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISType, &StorageTmp->linkageISISTypeLen);
	if (StorageTmp->linkageISISType == NULL) {
		config_perror("invalid specification for linkageISISType");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISiSISHelloTimer, &StorageTmp->linkageISISiSISHelloTimerLen);
	if (StorageTmp->linkageISISiSISHelloTimer == NULL) {
		config_perror("invalid specification for linkageISISiSISHelloTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1DefaultMetric, &StorageTmp->linkageISISl1DefaultMetricLen);
	if (StorageTmp->linkageISISl1DefaultMetric == NULL) {
		config_perror("invalid specification for linkageISISl1DefaultMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1DelayMetric, &StorageTmp->linkageISISl1DelayMetricLen);
	if (StorageTmp->linkageISISl1DelayMetric == NULL) {
		config_perror("invalid specification for linkageISISl1DelayMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1ExpenseMetric, &StorageTmp->linkageISISl1ExpenseMetricLen);
	if (StorageTmp->linkageISISl1ExpenseMetric == NULL) {
		config_perror("invalid specification for linkageISISl1ExpenseMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1ErrorMetric, &StorageTmp->linkageISISl1ErrorMetricLen);
	if (StorageTmp->linkageISISl1ErrorMetric == NULL) {
		config_perror("invalid specification for linkageISISl1ErrorMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISexternalDomain, &StorageTmp->linkageISISexternalDomainLen);
	if (StorageTmp->linkageISISexternalDomain == NULL) {
		config_perror("invalid specification for linkageISISexternalDomain");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISchangedInAdjacencyState, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISinitialisationFailures, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISrejectedAdjacencies, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISiSISControlPDUsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISiSISControlPDUsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISiDFieldLenthMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISmaximumAreaAddressesMismatches, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScircuitTransmitPassword, &StorageTmp->linkageISIScircuitTransmitPasswordLen);
	if (StorageTmp->linkageISIScircuitTransmitPassword == NULL) {
		config_perror("invalid specification for linkageISIScircuitTransmitPassword");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScircuitReceivedPasswords, &StorageTmp->linkageISIScircuitReceivedPasswordsLen);
	if (StorageTmp->linkageISIScircuitReceivedPasswords == NULL) {
		config_perror("invalid specification for linkageISIScircuitReceivedPasswords");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISauthenticationFailures, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1IntermediateSystemPriority, &StorageTmp->linkageISISl1IntermediateSystemPriorityLen);
	if (StorageTmp->linkageISISl1IntermediateSystemPriority == NULL) {
		config_perror("invalid specification for linkageISISl1IntermediateSystemPriority");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1CircuitID, &StorageTmp->linkageISISl1CircuitIDLen);
	if (StorageTmp->linkageISISl1CircuitID == NULL) {
		config_perror("invalid specification for linkageISISl1CircuitID");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1DesignatedIntermediateSystem, &StorageTmp->linkageISISl1DesignatedIntermediateSystemLen);
	if (StorageTmp->linkageISISl1DesignatedIntermediateSystem == NULL) {
		config_perror("invalid specification for linkageISISl1DesignatedIntermediateSystem");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement, &StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrementLen);
	if (StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentDefaultMetricIncrement");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement, &StorageTmp->linkageISIScallEstablishmentDelayMetricIncrementLen);
	if (StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentDelayMetricIncrement");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement, &StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrementLen);
	if (StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentExpenseMetricIncrement");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement, &StorageTmp->linkageISIScallEstablishmentErrorMetricIncrementLen);
	if (StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentErrorMetricIncrement");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISptPtCircuitID, &StorageTmp->linkageISISptPtCircuitIDLen);
	if (StorageTmp->linkageISISptPtCircuitID == NULL) {
		config_perror("invalid specification for linkageISISptPtCircuitID");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISoutgoingCallIVMO, &StorageTmp->linkageISISoutgoingCallIVMOLen);
	if (StorageTmp->linkageISISoutgoingCallIVMO == NULL) {
		config_perror("invalid specification for linkageISISoutgoingCallIVMO");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISneighborSNPAAddress, &StorageTmp->linkageISISneighborSNPAAddressLen);
	if (StorageTmp->linkageISISneighborSNPAAddress == NULL) {
		config_perror("invalid specification for linkageISISneighborSNPAAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2DefaultMetric, &StorageTmp->linkageISISl2DefaultMetricLen);
	if (StorageTmp->linkageISISl2DefaultMetric == NULL) {
		config_perror("invalid specification for linkageISISl2DefaultMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2DelayMetric, &StorageTmp->linkageISISl2DelayMetricLen);
	if (StorageTmp->linkageISISl2DelayMetric == NULL) {
		config_perror("invalid specification for linkageISISl2DelayMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2ExpenseMetric, &StorageTmp->linkageISISl2ExpenseMetricLen);
	if (StorageTmp->linkageISISl2ExpenseMetric == NULL) {
		config_perror("invalid specification for linkageISISl2ExpenseMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2ErrorMetric, &StorageTmp->linkageISISl2ErrorMetricLen);
	if (StorageTmp->linkageISISl2ErrorMetric == NULL) {
		config_perror("invalid specification for linkageISISl2ErrorMetric");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageISISmanualL2OnlyMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2IntermediateSystemPriority, &StorageTmp->linkageISISl2IntermediateSystemPriorityLen);
	if (StorageTmp->linkageISISl2IntermediateSystemPriority == NULL) {
		config_perror("invalid specification for linkageISISl2IntermediateSystemPriority");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2CircuitID, &StorageTmp->linkageISISl2CircuitIDLen);
	if (StorageTmp->linkageISISl2CircuitID == NULL) {
		config_perror("invalid specification for linkageISISl2CircuitID");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2DesignatedIntermediateSystem, &StorageTmp->linkageISISl2DesignatedIntermediateSystemLen);
	if (StorageTmp->linkageISISl2DesignatedIntermediateSystem == NULL) {
		config_perror("invalid specification for linkageISISl2DesignatedIntermediateSystem");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageRowStatus, &tmpsize);
	linkageTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("linkageTable", "done.\n"));
}

/*
 * store_linkageTable(): store configuraiton file for linkageTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_linkageTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct linkageTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("linkageTable", "storing data...  "));
	refresh_linkageTable();
	(void) tmpsize;
	for (hcindex = linkageTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct linkageTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "linkageTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->protocolMachineId, &StorageTmp->protocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageId, &StorageTmp->linkageIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageSnServiceProvider, &StorageTmp->linkageSnServiceProviderLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->linkageSnSAP, &StorageTmp->linkageSnSAPLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageOperationalProtocols, &StorageTmp->linkageOperationalProtocolsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISiSO9542OperationalSubsets, &StorageTmp->linkageISiSO9542OperationalSubsetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISHoldingTimerMultiplier, &StorageTmp->linkageISHoldingTimerMultiplierLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISConfigurationTimer, &StorageTmp->linkageISISConfigurationTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISSuggestedEsConfigurationTimer, &StorageTmp->linkageISSuggestedEsConfigurationTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISRedirectHoldingTime, &StorageTmp->linkageISRedirectHoldingTimeLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISESReachabilityChanges, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISInvalid9542PDUs, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESiSO9542OperationalSubsets, &StorageTmp->linkageESiSO9542OperationalSubsetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESHoldingTimerMultiplier, &StorageTmp->linkageESHoldingTimerMultiplierLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESManualISSNPAAddress, &StorageTmp->linkageESManualISSNPAAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESDefaultESConfigTimer, &StorageTmp->linkageESDefaultESConfigTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESActiveESConfigTimer, &StorageTmp->linkageESActiveESConfigTimerLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageESISReachabilityChanges, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageESInvalid9542PDUs, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageEnableChecksum, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageInitialMinimumTimer, &StorageTmp->linkageInitialMinimumTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageReserveTimer, &StorageTmp->linkageReserveTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageIdleTimer, &StorageTmp->linkageIdleTimerLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageSNDCFCallsPlaced, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageSNDCFCallsFailed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageCODLCallsPlaced, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageCODLCallsFailed, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISType, &StorageTmp->linkageISISTypeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISiSISHelloTimer, &StorageTmp->linkageISISiSISHelloTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1DefaultMetric, &StorageTmp->linkageISISl1DefaultMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1DelayMetric, &StorageTmp->linkageISISl1DelayMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1ExpenseMetric, &StorageTmp->linkageISISl1ExpenseMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1ErrorMetric, &StorageTmp->linkageISISl1ErrorMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISexternalDomain, &StorageTmp->linkageISISexternalDomainLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISchangedInAdjacencyState, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISinitialisationFailures, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISrejectedAdjacencies, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISiSISControlPDUsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISiSISControlPDUsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISiDFieldLenthMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISmaximumAreaAddressesMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScircuitTransmitPassword, &StorageTmp->linkageISIScircuitTransmitPasswordLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScircuitReceivedPasswords, &StorageTmp->linkageISIScircuitReceivedPasswordsLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISauthenticationFailures, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1IntermediateSystemPriority, &StorageTmp->linkageISISl1IntermediateSystemPriorityLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1CircuitID, &StorageTmp->linkageISISl1CircuitIDLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1DesignatedIntermediateSystem, &StorageTmp->linkageISISl1DesignatedIntermediateSystemLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges, &tmpsize);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement,
						   &StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrementLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement,
						   &StorageTmp->linkageISIScallEstablishmentDelayMetricIncrementLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement,
						   &StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrementLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement,
						   &StorageTmp->linkageISIScallEstablishmentErrorMetricIncrementLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISptPtCircuitID, &StorageTmp->linkageISISptPtCircuitIDLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISoutgoingCallIVMO, &StorageTmp->linkageISISoutgoingCallIVMOLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISneighborSNPAAddress, &StorageTmp->linkageISISneighborSNPAAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2DefaultMetric, &StorageTmp->linkageISISl2DefaultMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2DelayMetric, &StorageTmp->linkageISISl2DelayMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2ExpenseMetric, &StorageTmp->linkageISISl2ExpenseMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2ErrorMetric, &StorageTmp->linkageISISl2ErrorMetricLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageISISmanualL2OnlyMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2IntermediateSystemPriority, &StorageTmp->linkageISISl2IntermediateSystemPriorityLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2CircuitID, &StorageTmp->linkageISISl2CircuitIDLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2DesignatedIntermediateSystem, &StorageTmp->linkageISISl2DesignatedIntermediateSystemLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("linkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct cONSTable_data *cONSTable_create(void)
 * @brief create a fresh data structure representing a new row in the cONSTable table.
 * Creates a new cONSTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct cONSTable_data *
cONSTable_create(void)
{
	struct cONSTable_data *StorageNew = SNMP_MALLOC_STRUCT(cONSTable_data);

	DBUGMSGTL(("cONSTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->cONSRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("cONSTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int cONSTable_destroy(struct cONSTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
cONSTable_destroy(struct cONSTable_data **thedata)
{
	struct cONSTable_data *StorageDel;

	DEBUGMSGTL(("cONSTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cONSOperationalSystemType);
		StorageDel->cONSOperationalSystemTypeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("cONSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cONSTable_add(struct cONSTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the cONSTable table data set.
 * Adds a table row structure to the cONSTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
cONSTable_add(struct cONSTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("cONSTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&cONSTableStorage, vars, thedata);
	DEBUGMSGTL(("cONSTable", "registered an entry\n"));
	DEBUGMSGTL(("cONSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cONSTable_del(struct cONSTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the cONSTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
cONSTable_del(struct cONSTable_data *thedata)
{
	struct cONSTable_data *StorageDel;

	DEBUGMSGTL(("cONSTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(cONSTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&cONSTableStorage, hciptr);
	}
	DEBUGMSGTL(("cONSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_cONSTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for cONSTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case cONSTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_cONSTable(const char *token, char *line)
{
	size_t tmpsize;
	struct cONSTable_data *StorageTmp = cONSTable_create();

	DEBUGMSGTL(("cONSTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cONSAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->cONSOperationalSystemType, &StorageTmp->cONSOperationalSystemTypeLen);
	if (StorageTmp->cONSOperationalSystemType == NULL) {
		config_perror("invalid specification for cONSOperationalSystemType");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cONSRowStatus, &tmpsize);
	cONSTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("cONSTable", "done.\n"));
}

/*
 * store_cONSTable(): store configuraiton file for cONSTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_cONSTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cONSTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("cONSTable", "storing data...  "));
	refresh_cONSTable();
	(void) tmpsize;
	for (hcindex = cONSTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cONSTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cONSTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cONSAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->cONSOperationalSystemType, &StorageTmp->cONSOperationalSystemTypeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cONSRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("cONSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct networkConnectionTable_data *networkConnectionTable_create(void)
 * @brief create a fresh data structure representing a new row in the networkConnectionTable table.
 * Creates a new networkConnectionTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct networkConnectionTable_data *
networkConnectionTable_create(void)
{
	struct networkConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(networkConnectionTable_data);

	DBUGMSGTL(("networkConnectionTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->networkConnectionRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("networkConnectionTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int networkConnectionTable_destroy(struct networkConnectionTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
networkConnectionTable_destroy(struct networkConnectionTable_data **thedata)
{
	struct networkConnectionTable_data *StorageDel;

	DEBUGMSGTL(("networkConnectionTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->networkConnectionLocalNSAPMO);
		StorageDel->networkConnectionLocalNSAPMOLen = 0;
		SNMP_FREE(StorageDel->networkConnectionRemoteNSAPAddress);
		StorageDel->networkConnectionRemoteNSAPAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("networkConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int networkConnectionTable_add(struct networkConnectionTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the networkConnectionTable table data set.
 * Adds a table row structure to the networkConnectionTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
networkConnectionTable_add(struct networkConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("networkConnectionTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&networkConnectionTableStorage, vars, thedata);
	DEBUGMSGTL(("networkConnectionTable", "registered an entry\n"));
	DEBUGMSGTL(("networkConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int networkConnectionTable_del(struct networkConnectionTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the networkConnectionTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
networkConnectionTable_del(struct networkConnectionTable_data *thedata)
{
	struct networkConnectionTable_data *StorageDel;

	DEBUGMSGTL(("networkConnectionTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(networkConnectionTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&networkConnectionTableStorage, hciptr);
	}
	DEBUGMSGTL(("networkConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_networkConnectionTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for networkConnectionTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case networkConnectionTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_networkConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct networkConnectionTable_data *StorageTmp = networkConnectionTable_create();

	DEBUGMSGTL(("networkConnectionTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->networkConnectionLocalNSAPMO, &StorageTmp->networkConnectionLocalNSAPMOLen);
	if (StorageTmp->networkConnectionLocalNSAPMO == NULL) {
		config_perror("invalid specification for networkConnectionLocalNSAPMO");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->networkConnectionRemoteNSAPAddress, &StorageTmp->networkConnectionRemoteNSAPAddressLen);
	if (StorageTmp->networkConnectionRemoteNSAPAddress == NULL) {
		config_perror("invalid specification for networkConnectionRemoteNSAPAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->networkConnectionRowStatus, &tmpsize);
	networkConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("networkConnectionTable", "done.\n"));
}

/*
 * store_networkConnectionTable(): store configuraiton file for networkConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_networkConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct networkConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("networkConnectionTable", "storing data...  "));
	refresh_networkConnectionTable();
	(void) tmpsize;
	for (hcindex = networkConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct networkConnectionTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "networkConnectionTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->networkConnectionLocalNSAPMO, &StorageTmp->networkConnectionLocalNSAPMOLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->networkConnectionRemoteNSAPAddress, &StorageTmp->networkConnectionRemoteNSAPAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->networkConnectionRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("networkConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLETable_data *x25PLETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLETable table.
 * Creates a new x25PLETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLETable_data *
x25PLETable_create(void)
{
	struct x25PLETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLETable_data);

	DBUGMSGTL(("x25PLETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PLERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLETable_destroy(struct x25PLETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLETable_destroy(struct x25PLETable_data **thedata)
{
	struct x25PLETable_data *StorageDel;

	DEBUGMSGTL(("x25PLETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEprotocolVersionSupported);
		StorageDel->x25PLEprotocolVersionSupportedLen = 0;
		SNMP_FREE(StorageDel->x25PLElocalDTEAddress);
		StorageDel->x25PLElocalDTEAddressLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultThroughputClasses);
		StorageDel->x25PLEdefaultThroughputClassesLen = 0;
		SNMP_FREE(StorageDel->x25PLEflowControlParameterNegotiation);
		StorageDel->x25PLEflowControlParameterNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultPackageSizes);
		StorageDel->x25PLEdefaultPackageSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLEthroughputClassNegotiation);
		StorageDel->x25PLEthroughputClassNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEsNserviceProvider);
		StorageDel->x25PLEsNserviceProviderLen = 0;
		SNMP_FREE(StorageDel->x25PLEsNsAP);
		StorageDel->x25PLEsNsAPLen = 0;
		SNMP_FREE(StorageDel->x25PElogicalChannelAssignments);
		StorageDel->x25PElogicalChannelAssignmentsLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultThroughputClass);
		StorageDel->x25PLEdefaultThroughputClassLen = 0;
		SNMP_FREE(StorageDel->x25PLEflowControlNegotiationPermitted);
		StorageDel->x25PLEflowControlNegotiationPermittedLen = 0;
		SNMP_FREE(StorageDel->x25PLEmaxActiveCircuits);
		StorageDel->x25PLEmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLErestartTime);
		StorageDel->x25PLErestartTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultPacketSize);
		StorageDel->x25PLEdefaultPacketSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultWindowSize);
		StorageDel->x25PLEdefaultWindowSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEminimumRecallTimer);
		StorageDel->x25PLEminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLErestartCount);
		StorageDel->x25PLErestartCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEsN_ServiceProvider);
		StorageDel->x25PLEsN_ServiceProviderLen = 0;
		SNMP_FREE(StorageDel->x25PLEsN_SA_P);
		StorageDel->x25PLEsN_SA_PLen = 0;
		SNMP_FREE(StorageDel->x25PLElogicalChannelAssignments);
		StorageDel->x25PLElogicalChannelAssignmentsLen = 0;
		SNMP_FREE(StorageDel->x25PLEpacketSequencing);
		StorageDel->x25PLEpacketSequencingLen = 0;
		SNMP_FREE(StorageDel->x25PLEoctetsSentCounter);
		StorageDel->x25PLEoctetsSentCounterLen = 0;
		SNMP_FREE(StorageDel->x25PLEoctetsReceivedCounter);
		StorageDel->x25PLEoctetsReceivedCounterLen = 0;
		SNMP_FREE(StorageDel->x25PLEdataPacketsSent);
		StorageDel->x25PLEdataPacketsSentLen = 0;
		SNMP_FREE(StorageDel->x25PLEdataPacketsReceived);
		StorageDel->x25PLEdataPacketsReceivedLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallAttempts);
		StorageDel->x25PLEcallAttemptsLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallsConnected);
		StorageDel->x25PLEcallsConnectedLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallTimeouts);
		StorageDel->x25PLEcallTimeoutsLen = 0;
		SNMP_FREE(StorageDel->x25PLEclearTimeouts);
		StorageDel->x25PLEclearTimeoutsLen = 0;
		SNMP_FREE(StorageDel->x25PLEremotelyInitiatedResets);
		StorageDel->x25PLEremotelyInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->x25PLEdataRetransmissionTimerExpiries);
		StorageDel->x25PLEdataRetransmissionTimerExpiriesLen = 0;
		SNMP_FREE(StorageDel->x25PLEproviderInitiatedResets);
		StorageDel->x25PLEproviderInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->x25PLEresetTimeouts);
		StorageDel->x25PLEresetTimeoutsLen = 0;
		SNMP_FREE(StorageDel->x25PLEremotelyInitiatedRestarts);
		StorageDel->x25PLEremotelyInitiatedRestartsLen = 0;
		SNMP_FREE(StorageDel->x25PLErestartCountsExceeded);
		StorageDel->x25PLErestartCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEprotocolErrorsDetectedLocally);
		StorageDel->x25PLEprotocolErrorsDetectedLocallyLen = 0;
		SNMP_FREE(StorageDel->x25PLEprotocolErrorsAccusedOf);
		StorageDel->x25PLEprotocolErrorsAccusedOfLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallEstablishmentRetryCountsExceeded);
		StorageDel->x25PLEcallEstablishmentRetryCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEclearCountsExceeded);
		StorageDel->x25PLEclearCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEpLEClientMOName);
		StorageDel->x25PLEpLEClientMONameLen = 0;
		SNMP_FREE(StorageDel->x25PLEregistrationRequestTime);
		StorageDel->x25PLEregistrationRequestTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEregistrationRequestCount);
		StorageDel->x25PLEregistrationRequestCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLETable_add(struct x25PLETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLETable table data set.
 * Adds a table row structure to the x25PLETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLETable_add(struct x25PLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLETable_del(struct x25PLETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLETable_del(struct x25PLETable_data *thedata)
{
	struct x25PLETable_data *StorageDel;

	DEBUGMSGTL(("x25PLETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLETable_data *StorageTmp = x25PLETable_create();

	DEBUGMSGTL(("x25PLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEoperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEadministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEprotocolVersionSupported, &StorageTmp->x25PLEprotocolVersionSupportedLen);
	if (StorageTmp->x25PLEprotocolVersionSupported == NULL) {
		config_perror("invalid specification for x25PLEprotocolVersionSupported");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLElocalDTEAddress, &StorageTmp->x25PLElocalDTEAddressLen);
	if (StorageTmp->x25PLElocalDTEAddress == NULL) {
		config_perror("invalid specification for x25PLElocalDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultThroughputClasses, &StorageTmp->x25PLEdefaultThroughputClassesLen);
	if (StorageTmp->x25PLEdefaultThroughputClasses == NULL) {
		config_perror("invalid specification for x25PLEdefaultThroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEflowControlParameterNegotiation, &StorageTmp->x25PLEflowControlParameterNegotiationLen);
	if (StorageTmp->x25PLEflowControlParameterNegotiation == NULL) {
		config_perror("invalid specification for x25PLEflowControlParameterNegotiation");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultPackageSizes, &StorageTmp->x25PLEdefaultPackageSizesLen);
	if (StorageTmp->x25PLEdefaultPackageSizes == NULL) {
		config_perror("invalid specification for x25PLEdefaultPackageSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEthroughputClassNegotiation, &StorageTmp->x25PLEthroughputClassNegotiationLen);
	if (StorageTmp->x25PLEthroughputClassNegotiation == NULL) {
		config_perror("invalid specification for x25PLEthroughputClassNegotiation");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsNserviceProvider, &StorageTmp->x25PLEsNserviceProviderLen);
	if (StorageTmp->x25PLEsNserviceProvider == NULL) {
		config_perror("invalid specification for x25PLEsNserviceProvider");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsNsAP, &StorageTmp->x25PLEsNsAPLen);
	if (StorageTmp->x25PLEsNsAP == NULL) {
		config_perror("invalid specification for x25PLEsNsAP");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PElogicalChannelAssignments, &StorageTmp->x25PElogicalChannelAssignmentsLen);
	if (StorageTmp->x25PElogicalChannelAssignments == NULL) {
		config_perror("invalid specification for x25PElogicalChannelAssignments");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEinterfaceMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultThroughputClass, &StorageTmp->x25PLEdefaultThroughputClassLen);
	if (StorageTmp->x25PLEdefaultThroughputClass == NULL) {
		config_perror("invalid specification for x25PLEdefaultThroughputClass");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEflowControlNegotiationPermitted, &StorageTmp->x25PLEflowControlNegotiationPermittedLen);
	if (StorageTmp->x25PLEflowControlNegotiationPermitted == NULL) {
		config_perror("invalid specification for x25PLEflowControlNegotiationPermitted");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEcallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEmaxActiveCircuits, &StorageTmp->x25PLEmaxActiveCircuitsLen);
	if (StorageTmp->x25PLEmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLEmaxActiveCircuits");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLErestartTime, &StorageTmp->x25PLErestartTimeLen);
	if (StorageTmp->x25PLErestartTime == NULL) {
		config_perror("invalid specification for x25PLErestartTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultPacketSize, &StorageTmp->x25PLEdefaultPacketSizeLen);
	if (StorageTmp->x25PLEdefaultPacketSize == NULL) {
		config_perror("invalid specification for x25PLEdefaultPacketSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultWindowSize, &StorageTmp->x25PLEdefaultWindowSizeLen);
	if (StorageTmp->x25PLEdefaultWindowSize == NULL) {
		config_perror("invalid specification for x25PLEdefaultWindowSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEminimumRecallTimer, &StorageTmp->x25PLEminimumRecallTimerLen);
	if (StorageTmp->x25PLEminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLEminimumRecallTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLErestartCount, &StorageTmp->x25PLErestartCountLen);
	if (StorageTmp->x25PLErestartCount == NULL) {
		config_perror("invalid specification for x25PLErestartCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsN_ServiceProvider, &StorageTmp->x25PLEsN_ServiceProviderLen);
	if (StorageTmp->x25PLEsN_ServiceProvider == NULL) {
		config_perror("invalid specification for x25PLEsN_ServiceProvider");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsN_SA_P, &StorageTmp->x25PLEsN_SA_PLen);
	if (StorageTmp->x25PLEsN_SA_P == NULL) {
		config_perror("invalid specification for x25PLEsN_SA_P");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLElogicalChannelAssignments, &StorageTmp->x25PLElogicalChannelAssignmentsLen);
	if (StorageTmp->x25PLElogicalChannelAssignments == NULL) {
		config_perror("invalid specification for x25PLElogicalChannelAssignments");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEpacketSequencing, &StorageTmp->x25PLEpacketSequencingLen);
	if (StorageTmp->x25PLEpacketSequencing == NULL) {
		config_perror("invalid specification for x25PLEpacketSequencing");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEoctetsSentCounter, &StorageTmp->x25PLEoctetsSentCounterLen);
	if (StorageTmp->x25PLEoctetsSentCounter == NULL) {
		config_perror("invalid specification for x25PLEoctetsSentCounter");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEoctetsReceivedCounter, &StorageTmp->x25PLEoctetsReceivedCounterLen);
	if (StorageTmp->x25PLEoctetsReceivedCounter == NULL) {
		config_perror("invalid specification for x25PLEoctetsReceivedCounter");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdataPacketsSent, &StorageTmp->x25PLEdataPacketsSentLen);
	if (StorageTmp->x25PLEdataPacketsSent == NULL) {
		config_perror("invalid specification for x25PLEdataPacketsSent");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdataPacketsReceived, &StorageTmp->x25PLEdataPacketsReceivedLen);
	if (StorageTmp->x25PLEdataPacketsReceived == NULL) {
		config_perror("invalid specification for x25PLEdataPacketsReceived");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallAttempts, &StorageTmp->x25PLEcallAttemptsLen);
	if (StorageTmp->x25PLEcallAttempts == NULL) {
		config_perror("invalid specification for x25PLEcallAttempts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallsConnected, &StorageTmp->x25PLEcallsConnectedLen);
	if (StorageTmp->x25PLEcallsConnected == NULL) {
		config_perror("invalid specification for x25PLEcallsConnected");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallTimeouts, &StorageTmp->x25PLEcallTimeoutsLen);
	if (StorageTmp->x25PLEcallTimeouts == NULL) {
		config_perror("invalid specification for x25PLEcallTimeouts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEclearTimeouts, &StorageTmp->x25PLEclearTimeoutsLen);
	if (StorageTmp->x25PLEclearTimeouts == NULL) {
		config_perror("invalid specification for x25PLEclearTimeouts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEremotelyInitiatedResets, &StorageTmp->x25PLEremotelyInitiatedResetsLen);
	if (StorageTmp->x25PLEremotelyInitiatedResets == NULL) {
		config_perror("invalid specification for x25PLEremotelyInitiatedResets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdataRetransmissionTimerExpiries, &StorageTmp->x25PLEdataRetransmissionTimerExpiriesLen);
	if (StorageTmp->x25PLEdataRetransmissionTimerExpiries == NULL) {
		config_perror("invalid specification for x25PLEdataRetransmissionTimerExpiries");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEproviderInitiatedResets, &StorageTmp->x25PLEproviderInitiatedResetsLen);
	if (StorageTmp->x25PLEproviderInitiatedResets == NULL) {
		config_perror("invalid specification for x25PLEproviderInitiatedResets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEresetTimeouts, &StorageTmp->x25PLEresetTimeoutsLen);
	if (StorageTmp->x25PLEresetTimeouts == NULL) {
		config_perror("invalid specification for x25PLEresetTimeouts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEremotelyInitiatedRestarts, &StorageTmp->x25PLEremotelyInitiatedRestartsLen);
	if (StorageTmp->x25PLEremotelyInitiatedRestarts == NULL) {
		config_perror("invalid specification for x25PLEremotelyInitiatedRestarts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLErestartCountsExceeded, &StorageTmp->x25PLErestartCountsExceededLen);
	if (StorageTmp->x25PLErestartCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLErestartCountsExceeded");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEprotocolErrorsDetectedLocally, &StorageTmp->x25PLEprotocolErrorsDetectedLocallyLen);
	if (StorageTmp->x25PLEprotocolErrorsDetectedLocally == NULL) {
		config_perror("invalid specification for x25PLEprotocolErrorsDetectedLocally");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEprotocolErrorsAccusedOf, &StorageTmp->x25PLEprotocolErrorsAccusedOfLen);
	if (StorageTmp->x25PLEprotocolErrorsAccusedOf == NULL) {
		config_perror("invalid specification for x25PLEprotocolErrorsAccusedOf");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded, &StorageTmp->x25PLEcallEstablishmentRetryCountsExceededLen);
	if (StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLEcallEstablishmentRetryCountsExceeded");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEclearCountsExceeded, &StorageTmp->x25PLEclearCountsExceededLen);
	if (StorageTmp->x25PLEclearCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLEclearCountsExceeded");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEpLEClientMOName, &StorageTmp->x25PLEpLEClientMONameLen);
	if (StorageTmp->x25PLEpLEClientMOName == NULL) {
		config_perror("invalid specification for x25PLEpLEClientMOName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEregistrationRequestTime, &StorageTmp->x25PLEregistrationRequestTimeLen);
	if (StorageTmp->x25PLEregistrationRequestTime == NULL) {
		config_perror("invalid specification for x25PLEregistrationRequestTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEregistrationRequestCount, &StorageTmp->x25PLEregistrationRequestCountLen);
	if (StorageTmp->x25PLEregistrationRequestCount == NULL) {
		config_perror("invalid specification for x25PLEregistrationRequestCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEregistrationPermitted, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLERowStatus, &tmpsize);
	x25PLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLETable", "done.\n"));
}

/*
 * store_x25PLETable(): store configuraiton file for x25PLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLETable", "storing data...  "));
	refresh_x25PLETable();
	(void) tmpsize;
	for (hcindex = x25PLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEoperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEadministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEprotocolVersionSupported, &StorageTmp->x25PLEprotocolVersionSupportedLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLElocalDTEAddress, &StorageTmp->x25PLElocalDTEAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultThroughputClasses, &StorageTmp->x25PLEdefaultThroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEflowControlParameterNegotiation, &StorageTmp->x25PLEflowControlParameterNegotiationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultPackageSizes, &StorageTmp->x25PLEdefaultPackageSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEthroughputClassNegotiation, &StorageTmp->x25PLEthroughputClassNegotiationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsNserviceProvider, &StorageTmp->x25PLEsNserviceProviderLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsNsAP, &StorageTmp->x25PLEsNsAPLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PElogicalChannelAssignments, &StorageTmp->x25PElogicalChannelAssignmentsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEinterfaceMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultThroughputClass, &StorageTmp->x25PLEdefaultThroughputClassLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEflowControlNegotiationPermitted, &StorageTmp->x25PLEflowControlNegotiationPermittedLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEcallDeflectionSubscription, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEmaxActiveCircuits, &StorageTmp->x25PLEmaxActiveCircuitsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLErestartTime, &StorageTmp->x25PLErestartTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultPacketSize, &StorageTmp->x25PLEdefaultPacketSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultWindowSize, &StorageTmp->x25PLEdefaultWindowSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEminimumRecallTimer, &StorageTmp->x25PLEminimumRecallTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLErestartCount, &StorageTmp->x25PLErestartCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsN_ServiceProvider, &StorageTmp->x25PLEsN_ServiceProviderLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsN_SA_P, &StorageTmp->x25PLEsN_SA_PLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLElogicalChannelAssignments, &StorageTmp->x25PLElogicalChannelAssignmentsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEpacketSequencing, &StorageTmp->x25PLEpacketSequencingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEoctetsSentCounter, &StorageTmp->x25PLEoctetsSentCounterLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEoctetsReceivedCounter, &StorageTmp->x25PLEoctetsReceivedCounterLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdataPacketsSent, &StorageTmp->x25PLEdataPacketsSentLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdataPacketsReceived, &StorageTmp->x25PLEdataPacketsReceivedLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallAttempts, &StorageTmp->x25PLEcallAttemptsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallsConnected, &StorageTmp->x25PLEcallsConnectedLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallTimeouts, &StorageTmp->x25PLEcallTimeoutsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEclearTimeouts, &StorageTmp->x25PLEclearTimeoutsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEremotelyInitiatedResets, &StorageTmp->x25PLEremotelyInitiatedResetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdataRetransmissionTimerExpiries, &StorageTmp->x25PLEdataRetransmissionTimerExpiriesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEproviderInitiatedResets, &StorageTmp->x25PLEproviderInitiatedResetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEresetTimeouts, &StorageTmp->x25PLEresetTimeoutsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEremotelyInitiatedRestarts, &StorageTmp->x25PLEremotelyInitiatedRestartsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLErestartCountsExceeded, &StorageTmp->x25PLErestartCountsExceededLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEprotocolErrorsDetectedLocally, &StorageTmp->x25PLEprotocolErrorsDetectedLocallyLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEprotocolErrorsAccusedOf, &StorageTmp->x25PLEprotocolErrorsAccusedOfLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded, &StorageTmp->x25PLEcallEstablishmentRetryCountsExceededLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEclearCountsExceeded, &StorageTmp->x25PLEclearCountsExceededLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEpLEClientMOName, &StorageTmp->x25PLEpLEClientMONameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEregistrationRequestTime, &StorageTmp->x25PLEregistrationRequestTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEregistrationRequestCount, &StorageTmp->x25PLEregistrationRequestCountLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEregistrationPermitted, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLE_DTETable_data *x25PLE_DTETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLE_DTETable table.
 * Creates a new x25PLE_DTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLE_DTETable_data *
x25PLE_DTETable_create(void)
{
	struct x25PLE_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLE_DTETable_data);

	DBUGMSGTL(("x25PLE_DTETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25PLE_DTETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLE_DTETable_destroy(struct x25PLE_DTETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLE_DTETable_destroy(struct x25PLE_DTETable_data **thedata)
{
	struct x25PLE_DTETable_data *StorageDel;

	DEBUGMSGTL(("x25PLE_DTETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEcallRequestResponseTimer);
		StorageDel->x25PLE_DTEcallRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEextendedPacketSequenceNumbering);
		StorageDel->x25PLE_DTEextendedPacketSequenceNumberingLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEmaxActiveCircuits);
		StorageDel->x25PLE_DTEmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEminimumRecallTimer);
		StorageDel->x25PLE_DTEminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEresetRequestResponseTimer);
		StorageDel->x25PLE_DTEresetRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTErestartRequestRetransmissionCount);
		StorageDel->x25PLE_DTErestartRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTErestartRequestResponseTimer);
		StorageDel->x25PLE_DTErestartRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEclearRequestResponseTimer);
		StorageDel->x25PLE_DTEclearRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEinterruptResponseTimer);
		StorageDel->x25PLE_DTEinterruptResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEresetRequestRetransmissionCount);
		StorageDel->x25PLE_DTEresetRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEclearRequestRetransmissionCount);
		StorageDel->x25PLE_DTEclearRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEwindowStatusTransmissionTimer);
		StorageDel->x25PLE_DTEwindowStatusTransmissionTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEwindowRotationTimer);
		StorageDel->x25PLE_DTEwindowRotationTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEdataPacketRetransmissionCount);
		StorageDel->x25PLE_DTEdataPacketRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTErejectResponseTimer);
		StorageDel->x25PLE_DTErejectResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTErejectRetransmissionCount);
		StorageDel->x25PLE_DTErejectRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEregistrationRequestResponseTimer);
		StorageDel->x25PLE_DTEregistrationRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEregistrationRequestRetransmissionCount);
		StorageDel->x25PLE_DTEregistrationRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLE_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLE_DTETable_add(struct x25PLE_DTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLE_DTETable table data set.
 * Adds a table row structure to the x25PLE_DTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLE_DTETable_add(struct x25PLE_DTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLE_DTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLE_DTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLE_DTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLE_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLE_DTETable_del(struct x25PLE_DTETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLE_DTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLE_DTETable_del(struct x25PLE_DTETable_data *thedata)
{
	struct x25PLE_DTETable_data *StorageDel;

	DEBUGMSGTL(("x25PLE_DTETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLE_DTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLE_DTETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLE_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLE_DTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLE_DTETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLE_DTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLE_DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLE_DTETable_data *StorageTmp = x25PLE_DTETable_create();

	DEBUGMSGTL(("x25PLE_DTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DTEcallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEcallRequestResponseTimer, &StorageTmp->x25PLE_DTEcallRequestResponseTimerLen);
	if (StorageTmp->x25PLE_DTEcallRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEcallRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEextendedPacketSequenceNumbering, &StorageTmp->x25PLE_DTEextendedPacketSequenceNumberingLen);
	if (StorageTmp->x25PLE_DTEextendedPacketSequenceNumbering == NULL) {
		config_perror("invalid specification for x25PLE_DTEextendedPacketSequenceNumbering");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEmaxActiveCircuits, &StorageTmp->x25PLE_DTEmaxActiveCircuitsLen);
	if (StorageTmp->x25PLE_DTEmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLE_DTEmaxActiveCircuits");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEminimumRecallTimer, &StorageTmp->x25PLE_DTEminimumRecallTimerLen);
	if (StorageTmp->x25PLE_DTEminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEminimumRecallTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEresetRequestResponseTimer, &StorageTmp->x25PLE_DTEresetRequestResponseTimerLen);
	if (StorageTmp->x25PLE_DTEresetRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEresetRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTErestartRequestRetransmissionCount, &StorageTmp->x25PLE_DTErestartRequestRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTErestartRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTErestartRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTErestartRequestResponseTimer, &StorageTmp->x25PLE_DTErestartRequestResponseTimerLen);
	if (StorageTmp->x25PLE_DTErestartRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTErestartRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEclearRequestResponseTimer, &StorageTmp->x25PLE_DTEclearRequestResponseTimerLen);
	if (StorageTmp->x25PLE_DTEclearRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEclearRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEinterruptResponseTimer, &StorageTmp->x25PLE_DTEinterruptResponseTimerLen);
	if (StorageTmp->x25PLE_DTEinterruptResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEinterruptResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEresetRequestRetransmissionCount, &StorageTmp->x25PLE_DTEresetRequestRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTEresetRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTEresetRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEclearRequestRetransmissionCount, &StorageTmp->x25PLE_DTEclearRequestRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTEclearRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTEclearRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEcallAttempts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEprotocolErrorsDetectedLocally, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEprotocolErrorsAccusedOf, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEcallEstablishmentRetryCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEcallTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEcallsConnected, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEclearCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEclearTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEdataRetransmissionTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTErestartCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEwindowStatusTransmissionTimer, &StorageTmp->x25PLE_DTEwindowStatusTransmissionTimerLen);
	if (StorageTmp->x25PLE_DTEwindowStatusTransmissionTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEwindowStatusTransmissionTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEwindowRotationTimer, &StorageTmp->x25PLE_DTEwindowRotationTimerLen);
	if (StorageTmp->x25PLE_DTEwindowRotationTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEwindowRotationTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEdataPacketRetransmissionCount, &StorageTmp->x25PLE_DTEdataPacketRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTEdataPacketRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTEdataPacketRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTErejectResponseTimer, &StorageTmp->x25PLE_DTErejectResponseTimerLen);
	if (StorageTmp->x25PLE_DTErejectResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTErejectResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTErejectRetransmissionCount, &StorageTmp->x25PLE_DTErejectRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTErejectRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTErejectRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEregistrationRequestResponseTimer, &StorageTmp->x25PLE_DTEregistrationRequestResponseTimerLen);
	if (StorageTmp->x25PLE_DTEregistrationRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEregistrationRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCount, &StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTEregistrationRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DTEregistrationPermitted, &tmpsize);
	x25PLE_DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLE_DTETable", "done.\n"));
}

/*
 * store_x25PLE_DTETable(): store configuraiton file for x25PLE_DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLE_DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLE_DTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLE_DTETable", "storing data...  "));
	refresh_x25PLE_DTETable();
	(void) tmpsize;
	for (hcindex = x25PLE_DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLE_DTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLE_DTETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DTEcallDeflectionSubscription, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEcallRequestResponseTimer, &StorageTmp->x25PLE_DTEcallRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEextendedPacketSequenceNumbering, &StorageTmp->x25PLE_DTEextendedPacketSequenceNumberingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEmaxActiveCircuits, &StorageTmp->x25PLE_DTEmaxActiveCircuitsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEminimumRecallTimer, &StorageTmp->x25PLE_DTEminimumRecallTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEresetRequestResponseTimer, &StorageTmp->x25PLE_DTEresetRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTErestartRequestRetransmissionCount, &StorageTmp->x25PLE_DTErestartRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTErestartRequestResponseTimer, &StorageTmp->x25PLE_DTErestartRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEclearRequestResponseTimer, &StorageTmp->x25PLE_DTEclearRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEinterruptResponseTimer, &StorageTmp->x25PLE_DTEinterruptResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEresetRequestRetransmissionCount, &StorageTmp->x25PLE_DTEresetRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEclearRequestRetransmissionCount, &StorageTmp->x25PLE_DTEclearRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEcallAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEprotocolErrorsDetectedLocally, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEprotocolErrorsAccusedOf, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEcallEstablishmentRetryCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEcallTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEcallsConnected, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEclearCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEclearTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEdataRetransmissionTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTErestartCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEwindowStatusTransmissionTimer, &StorageTmp->x25PLE_DTEwindowStatusTransmissionTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEwindowRotationTimer, &StorageTmp->x25PLE_DTEwindowRotationTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEdataPacketRetransmissionCount, &StorageTmp->x25PLE_DTEdataPacketRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTErejectResponseTimer, &StorageTmp->x25PLE_DTErejectResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTErejectRetransmissionCount, &StorageTmp->x25PLE_DTErejectRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEregistrationRequestResponseTimer, &StorageTmp->x25PLE_DTEregistrationRequestResponseTimerLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCount,
						   &StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DTEregistrationPermitted, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLE_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLE_DCETable_data *x25PLE_DCETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLE_DCETable table.
 * Creates a new x25PLE_DCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLE_DCETable_data *
x25PLE_DCETable_create(void)
{
	struct x25PLE_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLE_DCETable_data);

	DBUGMSGTL(("x25PLE_DCETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25PLE_DCETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLE_DCETable_destroy(struct x25PLE_DCETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLE_DCETable_destroy(struct x25PLE_DCETable_data **thedata)
{
	struct x25PLE_DCETable_data *StorageDel;

	DEBUGMSGTL(("x25PLE_DCETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEdefaultThroughputClassesAssignment);
		StorageDel->x25PLE_DCEdefaultThroughputClassesAssignmentLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEextendedPacketSequenceNumbering);
		StorageDel->x25PLE_DCEextendedPacketSequenceNumberingLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEnonStandardDefaultPacketSizes);
		StorageDel->x25PLE_DCEnonStandardDefaultPacketSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEnonStandardDefaultWindowSizes);
		StorageDel->x25PLE_DCEnonStandardDefaultWindowSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEincomingCall);
		StorageDel->x25PLE_DCEincomingCallLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEresetIndication);
		StorageDel->x25PLE_DCEresetIndicationLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCErestartIndication);
		StorageDel->x25PLE_DCErestartIndicationLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLE_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLE_DCETable_add(struct x25PLE_DCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLE_DCETable table data set.
 * Adds a table row structure to the x25PLE_DCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLE_DCETable_add(struct x25PLE_DCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLE_DCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLE_DCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLE_DCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLE_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLE_DCETable_del(struct x25PLE_DCETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLE_DCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLE_DCETable_del(struct x25PLE_DCETable_data *thedata)
{
	struct x25PLE_DCETable_data *StorageDel;

	DEBUGMSGTL(("x25PLE_DCETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLE_DCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLE_DCETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLE_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLE_DCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLE_DCETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLE_DCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLE_DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLE_DCETable_data *StorageTmp = x25PLE_DCETable_create();

	DEBUGMSGTL(("x25PLE_DCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEcallAttempts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEcallsConnected, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEcUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEfastSelectAcceptance, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEincomingCallsBarred, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEoneWayLogicalChannelOutgoing, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEoutgoingCallsBarred, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEinterruptPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEinterruptPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEinterruptTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEx25SegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEx25SegmentsSent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEbilateralCUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEbilateralCUGWithOutgoingAccess, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEcallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEcallRedirection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEchargingInformation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEcUGWithIncomingAccess, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEcUGWithOutgoingAccess, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEdBitModification, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignment, &StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignmentLen);
	if (StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignment == NULL) {
		config_perror("invalid specification for x25PLE_DCEdefaultThroughputClassesAssignment");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEextendedPacketSequenceNumbering, &StorageTmp->x25PLE_DCEextendedPacketSequenceNumberingLen);
	if (StorageTmp->x25PLE_DCEextendedPacketSequenceNumbering == NULL) {
		config_perror("invalid specification for x25PLE_DCEextendedPacketSequenceNumbering");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEhuntGroup, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEincomingCallBarredWithinCUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCElocalChargingPrevention, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizes, &StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizesLen);
	if (StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizes == NULL) {
		config_perror("invalid specification for x25PLE_DCEnonStandardDefaultPacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizes, &StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizesLen);
	if (StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizes == NULL) {
		config_perror("invalid specification for x25PLE_DCEnonStandardDefaultWindowSizes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEnUIOverride, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEnUISubscription, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEoneWayLogicalChannelIncoming, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEonlineFacilityRegistration, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEoutgoingCallBarredWithinCUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEpacketRetransmission, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEreverseChargingAcceptance, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCErOASubscription, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEclearIndication, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEincomingCall, &StorageTmp->x25PLE_DCEincomingCallLen);
	if (StorageTmp->x25PLE_DCEincomingCall == NULL) {
		config_perror("invalid specification for x25PLE_DCEincomingCall");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEresetIndication, &StorageTmp->x25PLE_DCEresetIndicationLen);
	if (StorageTmp->x25PLE_DCEresetIndication == NULL) {
		config_perror("invalid specification for x25PLE_DCEresetIndication");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCErestartIndication, &StorageTmp->x25PLE_DCErestartIndicationLen);
	if (StorageTmp->x25PLE_DCErestartIndication == NULL) {
		config_perror("invalid specification for x25PLE_DCErestartIndication");
		return;
	}
	x25PLE_DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLE_DCETable", "done.\n"));
}

/*
 * store_x25PLE_DCETable(): store configuraiton file for x25PLE_DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLE_DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLE_DCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLE_DCETable", "storing data...  "));
	refresh_x25PLE_DCETable();
	(void) tmpsize;
	for (hcindex = x25PLE_DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLE_DCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLE_DCETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEcallAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEcallsConnected, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEcUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEfastSelectAcceptance, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEincomingCallsBarred, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEoneWayLogicalChannelOutgoing, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEoutgoingCallsBarred, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEinterruptPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEinterruptPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEinterruptTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEx25SegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEx25SegmentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEbilateralCUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEbilateralCUGWithOutgoingAccess, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEcallDeflectionSubscription, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEcallRedirection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEchargingInformation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEcUGWithIncomingAccess, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEcUGWithOutgoingAccess, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEdBitModification, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignment, &StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignmentLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEextendedPacketSequenceNumbering, &StorageTmp->x25PLE_DCEextendedPacketSequenceNumberingLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEhuntGroup, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEincomingCallBarredWithinCUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCElocalChargingPrevention, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizes, &StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizes, &StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEnUIOverride, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEnUISubscription, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEoneWayLogicalChannelIncoming, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEonlineFacilityRegistration, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEoutgoingCallBarredWithinCUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEpacketRetransmission, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEreverseChargingAcceptance, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCErOASubscription, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEclearIndication, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEincomingCall, &StorageTmp->x25PLE_DCEincomingCallLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEresetIndication, &StorageTmp->x25PLE_DCEresetIndicationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCErestartIndication, &StorageTmp->x25PLE_DCErestartIndicationLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLE_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEIVMOTable_data *x25PLEIVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEIVMOTable table.
 * Creates a new x25PLEIVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEIVMOTable_data *
x25PLEIVMOTable_create(void)
{
	struct x25PLEIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMOTable_data);

	DBUGMSGTL(("x25PLEIVMOTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PLEIVMORowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEIVMOTable_destroy(struct x25PLEIVMOTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEIVMOTable_destroy(struct x25PLEIVMOTable_data **thedata)
{
	struct x25PLEIVMOTable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMOTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOlocalDTEAddress);
		StorageDel->x25PLEIVMOlocalDTEAddressLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOlogicalChannelAssignments);
		StorageDel->x25PLEIVMOlogicalChannelAssignmentsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOsN_ServiceProvider);
		StorageDel->x25PLEIVMOsN_ServiceProviderLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultPacketSizes);
		StorageDel->x25PLEIVMOdefaultPacketSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultThroughputClasses);
		StorageDel->x25PLEIVMOdefaultThroughputClassesLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultWindowSizes);
		StorageDel->x25PLEIVMOdefaultWindowSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOflowControlParameterNegotiation);
		StorageDel->x25PLEIVMOflowControlParameterNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOthroughputClassNegotiation);
		StorageDel->x25PLEIVMOthroughputClassNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOx25PLEMode);
		StorageDel->x25PLEIVMOx25PLEModeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultThroughputClass);
		StorageDel->x25PLEIVMOdefaultThroughputClassLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOflowControlNegotiationPermitted);
		StorageDel->x25PLEIVMOflowControlNegotiationPermittedLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOmaxActiveCircuits);
		StorageDel->x25PLEIVMOmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOrestartTime);
		StorageDel->x25PLEIVMOrestartTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultPacketSize);
		StorageDel->x25PLEIVMOdefaultPacketSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultWindowSize);
		StorageDel->x25PLEIVMOdefaultWindowSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOminimumRecallTimer);
		StorageDel->x25PLEIVMOminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOrestartCount);
		StorageDel->x25PLEIVMOrestartCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOpacketSequencing);
		StorageDel->x25PLEIVMOpacketSequencingLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOregistrationRequestTime);
		StorageDel->x25PLEIVMOregistrationRequestTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOregistrationRequestCount);
		StorageDel->x25PLEIVMOregistrationRequestCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMOTable_add(struct x25PLEIVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEIVMOTable table data set.
 * Adds a table row structure to the x25PLEIVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEIVMOTable_add(struct x25PLEIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId, thedata->x25PLEIVMOIdLen);
	header_complex_add_data(&x25PLEIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMOTable_del(struct x25PLEIVMOTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEIVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEIVMOTable_del(struct x25PLEIVMOTable_data *thedata)
{
	struct x25PLEIVMOTable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMOTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLEIVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEIVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEIVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEIVMOTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEIVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMOTable_data *StorageTmp = x25PLEIVMOTable_create();

	DEBUGMSGTL(("x25PLEIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOlocalDTEAddress, &StorageTmp->x25PLEIVMOlocalDTEAddressLen);
	if (StorageTmp->x25PLEIVMOlocalDTEAddress == NULL) {
		config_perror("invalid specification for x25PLEIVMOlocalDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOlogicalChannelAssignments, &StorageTmp->x25PLEIVMOlogicalChannelAssignmentsLen);
	if (StorageTmp->x25PLEIVMOlogicalChannelAssignments == NULL) {
		config_perror("invalid specification for x25PLEIVMOlogicalChannelAssignments");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOsN_ServiceProvider, &StorageTmp->x25PLEIVMOsN_ServiceProviderLen);
	if (StorageTmp->x25PLEIVMOsN_ServiceProvider == NULL) {
		config_perror("invalid specification for x25PLEIVMOsN_ServiceProvider");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultPacketSizes, &StorageTmp->x25PLEIVMOdefaultPacketSizesLen);
	if (StorageTmp->x25PLEIVMOdefaultPacketSizes == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultPacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultThroughputClasses, &StorageTmp->x25PLEIVMOdefaultThroughputClassesLen);
	if (StorageTmp->x25PLEIVMOdefaultThroughputClasses == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultThroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultWindowSizes, &StorageTmp->x25PLEIVMOdefaultWindowSizesLen);
	if (StorageTmp->x25PLEIVMOdefaultWindowSizes == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultWindowSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOflowControlParameterNegotiation, &StorageTmp->x25PLEIVMOflowControlParameterNegotiationLen);
	if (StorageTmp->x25PLEIVMOflowControlParameterNegotiation == NULL) {
		config_perror("invalid specification for x25PLEIVMOflowControlParameterNegotiation");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOthroughputClassNegotiation, &StorageTmp->x25PLEIVMOthroughputClassNegotiationLen);
	if (StorageTmp->x25PLEIVMOthroughputClassNegotiation == NULL) {
		config_perror("invalid specification for x25PLEIVMOthroughputClassNegotiation");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOx25PLEMode, &StorageTmp->x25PLEIVMOx25PLEModeLen);
	if (StorageTmp->x25PLEIVMOx25PLEMode == NULL) {
		config_perror("invalid specification for x25PLEIVMOx25PLEMode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMOinterfaceMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultThroughputClass, &StorageTmp->x25PLEIVMOdefaultThroughputClassLen);
	if (StorageTmp->x25PLEIVMOdefaultThroughputClass == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultThroughputClass");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOflowControlNegotiationPermitted, &StorageTmp->x25PLEIVMOflowControlNegotiationPermittedLen);
	if (StorageTmp->x25PLEIVMOflowControlNegotiationPermitted == NULL) {
		config_perror("invalid specification for x25PLEIVMOflowControlNegotiationPermitted");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMOcallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOmaxActiveCircuits, &StorageTmp->x25PLEIVMOmaxActiveCircuitsLen);
	if (StorageTmp->x25PLEIVMOmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLEIVMOmaxActiveCircuits");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOrestartTime, &StorageTmp->x25PLEIVMOrestartTimeLen);
	if (StorageTmp->x25PLEIVMOrestartTime == NULL) {
		config_perror("invalid specification for x25PLEIVMOrestartTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultPacketSize, &StorageTmp->x25PLEIVMOdefaultPacketSizeLen);
	if (StorageTmp->x25PLEIVMOdefaultPacketSize == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultPacketSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultWindowSize, &StorageTmp->x25PLEIVMOdefaultWindowSizeLen);
	if (StorageTmp->x25PLEIVMOdefaultWindowSize == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultWindowSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOminimumRecallTimer, &StorageTmp->x25PLEIVMOminimumRecallTimerLen);
	if (StorageTmp->x25PLEIVMOminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMOminimumRecallTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOrestartCount, &StorageTmp->x25PLEIVMOrestartCountLen);
	if (StorageTmp->x25PLEIVMOrestartCount == NULL) {
		config_perror("invalid specification for x25PLEIVMOrestartCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOpacketSequencing, &StorageTmp->x25PLEIVMOpacketSequencingLen);
	if (StorageTmp->x25PLEIVMOpacketSequencing == NULL) {
		config_perror("invalid specification for x25PLEIVMOpacketSequencing");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOregistrationRequestTime, &StorageTmp->x25PLEIVMOregistrationRequestTimeLen);
	if (StorageTmp->x25PLEIVMOregistrationRequestTime == NULL) {
		config_perror("invalid specification for x25PLEIVMOregistrationRequestTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOregistrationRequestCount, &StorageTmp->x25PLEIVMOregistrationRequestCountLen);
	if (StorageTmp->x25PLEIVMOregistrationRequestCount == NULL) {
		config_perror("invalid specification for x25PLEIVMOregistrationRequestCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMOregistrationPermitted, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMORowStatus, &tmpsize);
	x25PLEIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
}

/*
 * store_x25PLEIVMOTable(): store configuraiton file for x25PLEIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMOTable", "storing data...  "));
	refresh_x25PLEIVMOTable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMOTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOlocalDTEAddress, &StorageTmp->x25PLEIVMOlocalDTEAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOlogicalChannelAssignments, &StorageTmp->x25PLEIVMOlogicalChannelAssignmentsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOsN_ServiceProvider, &StorageTmp->x25PLEIVMOsN_ServiceProviderLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultPacketSizes, &StorageTmp->x25PLEIVMOdefaultPacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultThroughputClasses, &StorageTmp->x25PLEIVMOdefaultThroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultWindowSizes, &StorageTmp->x25PLEIVMOdefaultWindowSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOflowControlParameterNegotiation, &StorageTmp->x25PLEIVMOflowControlParameterNegotiationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOthroughputClassNegotiation, &StorageTmp->x25PLEIVMOthroughputClassNegotiationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOx25PLEMode, &StorageTmp->x25PLEIVMOx25PLEModeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMOinterfaceMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultThroughputClass, &StorageTmp->x25PLEIVMOdefaultThroughputClassLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOflowControlNegotiationPermitted, &StorageTmp->x25PLEIVMOflowControlNegotiationPermittedLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMOcallDeflectionSubscription, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOmaxActiveCircuits, &StorageTmp->x25PLEIVMOmaxActiveCircuitsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOrestartTime, &StorageTmp->x25PLEIVMOrestartTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultPacketSize, &StorageTmp->x25PLEIVMOdefaultPacketSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultWindowSize, &StorageTmp->x25PLEIVMOdefaultWindowSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOminimumRecallTimer, &StorageTmp->x25PLEIVMOminimumRecallTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOrestartCount, &StorageTmp->x25PLEIVMOrestartCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOpacketSequencing, &StorageTmp->x25PLEIVMOpacketSequencingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOregistrationRequestTime, &StorageTmp->x25PLEIVMOregistrationRequestTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOregistrationRequestCount, &StorageTmp->x25PLEIVMOregistrationRequestCountLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMOregistrationPermitted, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEIVMO_DTETable_data *x25PLEIVMO_DTETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEIVMO_DTETable table.
 * Creates a new x25PLEIVMO_DTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEIVMO_DTETable_data *
x25PLEIVMO_DTETable_create(void)
{
	struct x25PLEIVMO_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMO_DTETable_data);

	DBUGMSGTL(("x25PLEIVMO_DTETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PLEIVMO_DTERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PLEIVMO_DTETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEIVMO_DTETable_destroy(struct x25PLEIVMO_DTETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEIVMO_DTETable_destroy(struct x25PLEIVMO_DTETable_data **thedata)
{
	struct x25PLEIVMO_DTETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMO_DTETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEcallRequestResponseTimer);
		StorageDel->x25PLEIVMO_DTEcallRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEextendedPacketSequenceNumbering);
		StorageDel->x25PLEIVMO_DTEextendedPacketSequenceNumberingLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEmaxActiveCircuits);
		StorageDel->x25PLEIVMO_DTEmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEminimumRecallTimer);
		StorageDel->x25PLEIVMO_DTEminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEresetRequestResponseTimer);
		StorageDel->x25PLEIVMO_DTEresetRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTErestartRequestRetransmissionCount);
		StorageDel->x25PLEIVMO_DTErestartRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTErestartRequestResponseTimer);
		StorageDel->x25PLEIVMO_DTErestartRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEclearRequestResponseTimer);
		StorageDel->x25PLEIVMO_DTEclearRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEinterruptResponseTimer);
		StorageDel->x25PLEIVMO_DTEinterruptResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEresetRequestRetransmissionCount);
		StorageDel->x25PLEIVMO_DTEresetRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEclearRequestRetransmissionCount);
		StorageDel->x25PLEIVMO_DTEclearRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEcallAttempts);
		StorageDel->x25PLEIVMO_DTEcallAttemptsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEprotocolErrorsDetectedLocally);
		StorageDel->x25PLEIVMO_DTEprotocolErrorsDetectedLocallyLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEprotocolErrorsAccusedOf);
		StorageDel->x25PLEIVMO_DTEprotocolErrorsAccusedOfLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded);
		StorageDel->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEwindowStatusTransmissionTimer);
		StorageDel->x25PLEIVMO_DTEwindowStatusTransmissionTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEwindowRotationTimer);
		StorageDel->x25PLEIVMO_DTEwindowRotationTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEdataPacketRetransmissionCount);
		StorageDel->x25PLEIVMO_DTEdataPacketRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTErejectResponseTimer);
		StorageDel->x25PLEIVMO_DTErejectResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTErejectRetransmissionCount);
		StorageDel->x25PLEIVMO_DTErejectRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEregistrationRequestResponseTimer);
		StorageDel->x25PLEIVMO_DTEregistrationRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEregistrationRequestRetransmissionCount);
		StorageDel->x25PLEIVMO_DTEregistrationRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEIVMO_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMO_DTETable_add(struct x25PLEIVMO_DTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEIVMO_DTETable table data set.
 * Adds a table row structure to the x25PLEIVMO_DTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEIVMO_DTETable_add(struct x25PLEIVMO_DTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMO_DTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId, thedata->x25PLEIVMOIdLen);
	header_complex_add_data(&x25PLEIVMO_DTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMO_DTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMO_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMO_DTETable_del(struct x25PLEIVMO_DTETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEIVMO_DTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEIVMO_DTETable_del(struct x25PLEIVMO_DTETable_data *thedata)
{
	struct x25PLEIVMO_DTETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMO_DTETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLEIVMO_DTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEIVMO_DTETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEIVMO_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEIVMO_DTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEIVMO_DTETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEIVMO_DTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEIVMO_DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMO_DTETable_data *StorageTmp = x25PLEIVMO_DTETable_create();

	DEBUGMSGTL(("x25PLEIVMO_DTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO_DTEcallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEcallRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumbering, &StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumberingLen);
	if (StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumbering == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEextendedPacketSequenceNumbering");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEmaxActiveCircuits, &StorageTmp->x25PLEIVMO_DTEmaxActiveCircuitsLen);
	if (StorageTmp->x25PLEIVMO_DTEmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEmaxActiveCircuits");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEminimumRecallTimer, &StorageTmp->x25PLEIVMO_DTEminimumRecallTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEminimumRecallTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEresetRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTErestartRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTErestartRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEclearRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEinterruptResponseTimer, &StorageTmp->x25PLEIVMO_DTEinterruptResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEinterruptResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEinterruptResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEresetRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEclearRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEcallAttempts, &StorageTmp->x25PLEIVMO_DTEcallAttemptsLen);
	if (StorageTmp->x25PLEIVMO_DTEcallAttempts == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEcallAttempts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocally, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocallyLen);
	if (StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocally == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEprotocolErrorsDetectedLocally");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOf, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOfLen);
	if (StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOf == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEprotocolErrorsAccusedOf");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded, &StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceededLen);
	if (StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEcallTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEcallsConnected, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEclearCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEclearTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEdataRetransmissionTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTErestartCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimer, &StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEwindowStatusTransmissionTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEwindowRotationTimer, &StorageTmp->x25PLEIVMO_DTEwindowRotationTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEwindowRotationTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEwindowRotationTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEdataPacketRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTErejectResponseTimer, &StorageTmp->x25PLEIVMO_DTErejectResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTErejectResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTErejectResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTErejectRetransmissionCount, &StorageTmp->x25PLEIVMO_DTErejectRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTErejectRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTErejectRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEregistrationRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEregistrationRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO_DTEregistrationPermitted, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO_DTERowStatus, &tmpsize);
	x25PLEIVMO_DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMO_DTETable", "done.\n"));
}

/*
 * store_x25PLEIVMO_DTETable(): store configuraiton file for x25PLEIVMO_DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMO_DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMO_DTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMO_DTETable", "storing data...  "));
	refresh_x25PLEIVMO_DTETable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMO_DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMO_DTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMO_DTETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO_DTEcallDeflectionSubscription, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumbering, &StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumberingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEmaxActiveCircuits, &StorageTmp->x25PLEIVMO_DTEmaxActiveCircuitsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEminimumRecallTimer, &StorageTmp->x25PLEIVMO_DTEminimumRecallTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimerLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEinterruptResponseTimer, &StorageTmp->x25PLEIVMO_DTEinterruptResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEcallAttempts, &StorageTmp->x25PLEIVMO_DTEcallAttemptsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocally, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocallyLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOf, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOfLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded,
						   &StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceededLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEcallTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEcallsConnected, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEclearCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEclearTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEdataRetransmissionTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTErestartCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimer, &StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEwindowRotationTimer, &StorageTmp->x25PLEIVMO_DTEwindowRotationTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTErejectResponseTimer, &StorageTmp->x25PLEIVMO_DTErejectResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTErejectRetransmissionCount, &StorageTmp->x25PLEIVMO_DTErejectRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimerLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCount,
						   &StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO_DTEregistrationPermitted, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO_DTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEIVMO_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEIVMO_DCETable_data *x25PLEIVMO_DCETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEIVMO_DCETable table.
 * Creates a new x25PLEIVMO_DCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEIVMO_DCETable_data *
x25PLEIVMO_DCETable_create(void)
{
	struct x25PLEIVMO_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMO_DCETable_data);

	DBUGMSGTL(("x25PLEIVMO_DCETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PLEIVMO_DCERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PLEIVMO_DCETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEIVMO_DCETable_destroy(struct x25PLEIVMO_DCETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEIVMO_DCETable_destroy(struct x25PLEIVMO_DCETable_data **thedata)
{
	struct x25PLEIVMO_DCETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMO_DCETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEIVMO_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMO_DCETable_add(struct x25PLEIVMO_DCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEIVMO_DCETable table data set.
 * Adds a table row structure to the x25PLEIVMO_DCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEIVMO_DCETable_add(struct x25PLEIVMO_DCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMO_DCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId, thedata->x25PLEIVMOIdLen);
	header_complex_add_data(&x25PLEIVMO_DCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMO_DCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMO_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMO_DCETable_del(struct x25PLEIVMO_DCETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEIVMO_DCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEIVMO_DCETable_del(struct x25PLEIVMO_DCETable_data *thedata)
{
	struct x25PLEIVMO_DCETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMO_DCETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLEIVMO_DCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEIVMO_DCETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEIVMO_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEIVMO_DCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEIVMO_DCETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEIVMO_DCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEIVMO_DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMO_DCETable_data *StorageTmp = x25PLEIVMO_DCETable_create();

	DEBUGMSGTL(("x25PLEIVMO_DCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO_DCERowStatus, &tmpsize);
	x25PLEIVMO_DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMO_DCETable", "done.\n"));
}

/*
 * store_x25PLEIVMO_DCETable(): store configuraiton file for x25PLEIVMO_DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMO_DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMO_DCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMO_DCETable", "storing data...  "));
	refresh_x25PLEIVMO_DCETable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMO_DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMO_DCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMO_DCETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO_DCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEIVMO_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCallTable_data *virtualCallTable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCallTable table.
 * Creates a new virtualCallTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCallTable_data *
virtualCallTable_create(void)
{
	struct virtualCallTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCallTable_data);

	DBUGMSGTL(("virtualCallTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("virtualCallTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int virtualCallTable_destroy(struct virtualCallTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCallTable_destroy(struct virtualCallTable_data **thedata)
{
	struct virtualCallTable_data *StorageDel;

	DEBUGMSGTL(("virtualCallTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCallId);
		StorageDel->virtualCallIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallChannel);
		StorageDel->virtualCallChannelLen = 0;
		SNMP_FREE(StorageDel->virtualCallPacketSize);
		StorageDel->virtualCallPacketSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallWindowSize);
		StorageDel->virtualCallWindowSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallOctetsSentCounter);
		StorageDel->virtualCallOctetsSentCounterLen = 0;
		SNMP_FREE(StorageDel->virtualCallOctetsReceivedCounter);
		StorageDel->virtualCallOctetsReceivedCounterLen = 0;
		SNMP_FREE(StorageDel->virtualCallDataPacketsSent);
		StorageDel->virtualCallDataPacketsSentLen = 0;
		SNMP_FREE(StorageDel->virtualCallDataPacketsReceived);
		StorageDel->virtualCallDataPacketsReceivedLen = 0;
		SNMP_FREE(StorageDel->virtualCallRemotelyInitiatedResets);
		StorageDel->virtualCallRemotelyInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->virtualCallDataRetransmissionTimerExpiries);
		StorageDel->virtualCallDataRetransmissionTimerExpiriesLen = 0;
		SNMP_FREE(StorageDel->virtualCallProviderInitiatedResets);
		StorageDel->virtualCallProviderInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->virtualCallResetTimeouts);
		StorageDel->virtualCallResetTimeoutsLen = 0;
		SNMP_FREE(StorageDel->virtualCallInterruptPacketsSent);
		StorageDel->virtualCallInterruptPacketsSentLen = 0;
		SNMP_FREE(StorageDel->virtualCallInterruptPacketsReceived);
		StorageDel->virtualCallInterruptPacketsReceivedLen = 0;
		SNMP_FREE(StorageDel->virtualCallInterruptTimerExpiries);
		StorageDel->virtualCallInterruptTimerExpiriesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCallTable_add(struct virtualCallTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCallTable table data set.
 * Adds a table row structure to the virtualCallTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCallTable_add(struct virtualCallTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCallTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* virtualCallId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallId, thedata->virtualCallIdLen);
	header_complex_add_data(&virtualCallTableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCallTable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCallTable_del(struct virtualCallTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the virtualCallTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCallTable_del(struct virtualCallTable_data *thedata)
{
	struct virtualCallTable_data *StorageDel;

	DEBUGMSGTL(("virtualCallTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCallTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCallTableStorage, hciptr);
	}
	DEBUGMSGTL(("virtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCallTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCallTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCallTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCallTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCallTable_data *StorageTmp = virtualCallTable_create();

	DEBUGMSGTL(("virtualCallTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
	if (StorageTmp->virtualCallId == NULL) {
		config_perror("invalid specification for virtualCallId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallChannel, &StorageTmp->virtualCallChannelLen);
	if (StorageTmp->virtualCallChannel == NULL) {
		config_perror("invalid specification for virtualCallChannel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallPacketSize, &StorageTmp->virtualCallPacketSizeLen);
	if (StorageTmp->virtualCallPacketSize == NULL) {
		config_perror("invalid specification for virtualCallPacketSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallWindowSize, &StorageTmp->virtualCallWindowSizeLen);
	if (StorageTmp->virtualCallWindowSize == NULL) {
		config_perror("invalid specification for virtualCallWindowSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallOctetsSentCounter, &StorageTmp->virtualCallOctetsSentCounterLen);
	if (StorageTmp->virtualCallOctetsSentCounter == NULL) {
		config_perror("invalid specification for virtualCallOctetsSentCounter");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallOctetsReceivedCounter, &StorageTmp->virtualCallOctetsReceivedCounterLen);
	if (StorageTmp->virtualCallOctetsReceivedCounter == NULL) {
		config_perror("invalid specification for virtualCallOctetsReceivedCounter");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallDataPacketsSent, &StorageTmp->virtualCallDataPacketsSentLen);
	if (StorageTmp->virtualCallDataPacketsSent == NULL) {
		config_perror("invalid specification for virtualCallDataPacketsSent");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallDataPacketsReceived, &StorageTmp->virtualCallDataPacketsReceivedLen);
	if (StorageTmp->virtualCallDataPacketsReceived == NULL) {
		config_perror("invalid specification for virtualCallDataPacketsReceived");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallRemotelyInitiatedResets, &StorageTmp->virtualCallRemotelyInitiatedResetsLen);
	if (StorageTmp->virtualCallRemotelyInitiatedResets == NULL) {
		config_perror("invalid specification for virtualCallRemotelyInitiatedResets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallDataRetransmissionTimerExpiries, &StorageTmp->virtualCallDataRetransmissionTimerExpiriesLen);
	if (StorageTmp->virtualCallDataRetransmissionTimerExpiries == NULL) {
		config_perror("invalid specification for virtualCallDataRetransmissionTimerExpiries");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallProviderInitiatedResets, &StorageTmp->virtualCallProviderInitiatedResetsLen);
	if (StorageTmp->virtualCallProviderInitiatedResets == NULL) {
		config_perror("invalid specification for virtualCallProviderInitiatedResets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallResetTimeouts, &StorageTmp->virtualCallResetTimeoutsLen);
	if (StorageTmp->virtualCallResetTimeouts == NULL) {
		config_perror("invalid specification for virtualCallResetTimeouts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallInterruptPacketsSent, &StorageTmp->virtualCallInterruptPacketsSentLen);
	if (StorageTmp->virtualCallInterruptPacketsSent == NULL) {
		config_perror("invalid specification for virtualCallInterruptPacketsSent");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallInterruptPacketsReceived, &StorageTmp->virtualCallInterruptPacketsReceivedLen);
	if (StorageTmp->virtualCallInterruptPacketsReceived == NULL) {
		config_perror("invalid specification for virtualCallInterruptPacketsReceived");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallInterruptTimerExpiries, &StorageTmp->virtualCallInterruptTimerExpiriesLen);
	if (StorageTmp->virtualCallInterruptTimerExpiries == NULL) {
		config_perror("invalid specification for virtualCallInterruptTimerExpiries");
		return;
	}
	virtualCallTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCallTable", "done.\n"));
}

/*
 * store_virtualCallTable(): store configuraiton file for virtualCallTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCallTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCallTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCallTable", "storing data...  "));
	refresh_virtualCallTable();
	(void) tmpsize;
	for (hcindex = virtualCallTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCallTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCallTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallChannel, &StorageTmp->virtualCallChannelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallPacketSize, &StorageTmp->virtualCallPacketSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallWindowSize, &StorageTmp->virtualCallWindowSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallOctetsSentCounter, &StorageTmp->virtualCallOctetsSentCounterLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallOctetsReceivedCounter, &StorageTmp->virtualCallOctetsReceivedCounterLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallDataPacketsSent, &StorageTmp->virtualCallDataPacketsSentLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallDataPacketsReceived, &StorageTmp->virtualCallDataPacketsReceivedLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallRemotelyInitiatedResets, &StorageTmp->virtualCallRemotelyInitiatedResetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallDataRetransmissionTimerExpiries, &StorageTmp->virtualCallDataRetransmissionTimerExpiriesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallProviderInitiatedResets, &StorageTmp->virtualCallProviderInitiatedResetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallResetTimeouts, &StorageTmp->virtualCallResetTimeoutsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallInterruptPacketsSent, &StorageTmp->virtualCallInterruptPacketsSentLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallInterruptPacketsReceived, &StorageTmp->virtualCallInterruptPacketsReceivedLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallInterruptTimerExpiries, &StorageTmp->virtualCallInterruptTimerExpiriesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCircuitTable_data *virtualCircuitTable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCircuitTable table.
 * Creates a new virtualCircuitTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCircuitTable_data *
virtualCircuitTable_create(void)
{
	struct virtualCircuitTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCircuitTable_data);

	DBUGMSGTL(("virtualCircuitTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("virtualCircuitTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int virtualCircuitTable_destroy(struct virtualCircuitTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCircuitTable_destroy(struct virtualCircuitTable_data **thedata)
{
	struct virtualCircuitTable_data *StorageDel;

	DEBUGMSGTL(("virtualCircuitTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitLogicalChannel);
		StorageDel->virtualCircuitLogicalChannelLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitPacketSizes);
		StorageDel->virtualCircuitPacketSizesLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitThroughputClasses);
		StorageDel->virtualCircuitThroughputClassesLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitWindowSizes);
		StorageDel->virtualCircuitWindowSizesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuitTable_add(struct virtualCircuitTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCircuitTable table data set.
 * Adds a table row structure to the virtualCircuitTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCircuitTable_add(struct virtualCircuitTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCircuitTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&virtualCircuitTableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCircuitTable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuitTable_del(struct virtualCircuitTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the virtualCircuitTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCircuitTable_del(struct virtualCircuitTable_data *thedata)
{
	struct virtualCircuitTable_data *StorageDel;

	DEBUGMSGTL(("virtualCircuitTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCircuitTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCircuitTableStorage, hciptr);
	}
	DEBUGMSGTL(("virtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCircuitTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCircuitTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCircuitTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCircuitTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCircuitTable_data *StorageTmp = virtualCircuitTable_create();

	DEBUGMSGTL(("virtualCircuitTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitLogicalChannel, &StorageTmp->virtualCircuitLogicalChannelLen);
	if (StorageTmp->virtualCircuitLogicalChannel == NULL) {
		config_perror("invalid specification for virtualCircuitLogicalChannel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitPacketSizes, &StorageTmp->virtualCircuitPacketSizesLen);
	if (StorageTmp->virtualCircuitPacketSizes == NULL) {
		config_perror("invalid specification for virtualCircuitPacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitThroughputClasses, &StorageTmp->virtualCircuitThroughputClassesLen);
	if (StorageTmp->virtualCircuitThroughputClasses == NULL) {
		config_perror("invalid specification for virtualCircuitThroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitWindowSizes, &StorageTmp->virtualCircuitWindowSizesLen);
	if (StorageTmp->virtualCircuitWindowSizes == NULL) {
		config_perror("invalid specification for virtualCircuitWindowSizes");
		return;
	}
	virtualCircuitTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCircuitTable", "done.\n"));
}

/*
 * store_virtualCircuitTable(): store configuraiton file for virtualCircuitTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCircuitTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCircuitTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCircuitTable", "storing data...  "));
	refresh_virtualCircuitTable();
	(void) tmpsize;
	for (hcindex = virtualCircuitTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCircuitTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCircuitTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitLogicalChannel, &StorageTmp->virtualCircuitLogicalChannelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitPacketSizes, &StorageTmp->virtualCircuitPacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitThroughputClasses, &StorageTmp->virtualCircuitThroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitWindowSizes, &StorageTmp->virtualCircuitWindowSizesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCircuit_DTETable_data *virtualCircuit_DTETable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCircuit_DTETable table.
 * Creates a new virtualCircuit_DTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCircuit_DTETable_data *
virtualCircuit_DTETable_create(void)
{
	struct virtualCircuit_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCircuit_DTETable_data);

	DBUGMSGTL(("virtualCircuit_DTETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("virtualCircuit_DTETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int virtualCircuit_DTETable_destroy(struct virtualCircuit_DTETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCircuit_DTETable_destroy(struct virtualCircuit_DTETable_data **thedata)
{
	struct virtualCircuit_DTETable_data *StorageDel;

	DEBUGMSGTL(("virtualCircuit_DTETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCircuit_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuit_DTETable_add(struct virtualCircuit_DTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCircuit_DTETable table data set.
 * Adds a table row structure to the virtualCircuit_DTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCircuit_DTETable_add(struct virtualCircuit_DTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCircuit_DTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&virtualCircuit_DTETableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCircuit_DTETable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCircuit_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuit_DTETable_del(struct virtualCircuit_DTETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the virtualCircuit_DTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCircuit_DTETable_del(struct virtualCircuit_DTETable_data *thedata)
{
	struct virtualCircuit_DTETable_data *StorageDel;

	DEBUGMSGTL(("virtualCircuit_DTETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCircuit_DTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCircuit_DTETableStorage, hciptr);
	}
	DEBUGMSGTL(("virtualCircuit_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCircuit_DTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCircuit_DTETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCircuit_DTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCircuit_DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCircuit_DTETable_data *StorageTmp = virtualCircuit_DTETable_create();

	DEBUGMSGTL(("virtualCircuit_DTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEdataRetransmissionTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEinterruptPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEinterruptPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEinterruptTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEresetTimeouts, &tmpsize);
	virtualCircuit_DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCircuit_DTETable", "done.\n"));
}

/*
 * store_virtualCircuit_DTETable(): store configuraiton file for virtualCircuit_DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCircuit_DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCircuit_DTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCircuit_DTETable", "storing data...  "));
	refresh_virtualCircuit_DTETable();
	(void) tmpsize;
	for (hcindex = virtualCircuit_DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCircuit_DTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCircuit_DTETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEdataRetransmissionTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEinterruptPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEinterruptPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEinterruptTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEresetTimeouts, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCircuit_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCircuit_DCETable_data *virtualCircuit_DCETable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCircuit_DCETable table.
 * Creates a new virtualCircuit_DCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCircuit_DCETable_data *
virtualCircuit_DCETable_create(void)
{
	struct virtualCircuit_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCircuit_DCETable_data);

	DBUGMSGTL(("virtualCircuit_DCETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("virtualCircuit_DCETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int virtualCircuit_DCETable_destroy(struct virtualCircuit_DCETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCircuit_DCETable_destroy(struct virtualCircuit_DCETable_data **thedata)
{
	struct virtualCircuit_DCETable_data *StorageDel;

	DEBUGMSGTL(("virtualCircuit_DCETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCircuit_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuit_DCETable_add(struct virtualCircuit_DCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCircuit_DCETable table data set.
 * Adds a table row structure to the virtualCircuit_DCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCircuit_DCETable_add(struct virtualCircuit_DCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCircuit_DCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&virtualCircuit_DCETableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCircuit_DCETable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCircuit_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuit_DCETable_del(struct virtualCircuit_DCETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the virtualCircuit_DCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCircuit_DCETable_del(struct virtualCircuit_DCETable_data *thedata)
{
	struct virtualCircuit_DCETable_data *StorageDel;

	DEBUGMSGTL(("virtualCircuit_DCETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCircuit_DCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCircuit_DCETableStorage, hciptr);
	}
	DEBUGMSGTL(("virtualCircuit_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCircuit_DCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCircuit_DCETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCircuit_DCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCircuit_DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCircuit_DCETable_data *StorageTmp = virtualCircuit_DCETable_create();

	DEBUGMSGTL(("virtualCircuit_DCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEinterruptPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEinterruptPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEinterruptTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEx25SegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEx25SegmentsSent, &tmpsize);
	virtualCircuit_DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCircuit_DCETable", "done.\n"));
}

/*
 * store_virtualCircuit_DCETable(): store configuraiton file for virtualCircuit_DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCircuit_DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCircuit_DCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCircuit_DCETable", "storing data...  "));
	refresh_virtualCircuit_DCETable();
	(void) tmpsize;
	for (hcindex = virtualCircuit_DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCircuit_DCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCircuit_DCETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEinterruptPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEinterruptPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEinterruptTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEx25SegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEx25SegmentsSent, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCircuit_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct permanentVirtualCircuitTable_data *permanentVirtualCircuitTable_create(void)
 * @brief create a fresh data structure representing a new row in the permanentVirtualCircuitTable table.
 * Creates a new permanentVirtualCircuitTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct permanentVirtualCircuitTable_data *
permanentVirtualCircuitTable_create(void)
{
	struct permanentVirtualCircuitTable_data *StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuitTable_data);

	DBUGMSGTL(("permanentVirtualCircuitTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->permanentVirtualCircuitRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("permanentVirtualCircuitTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int permanentVirtualCircuitTable_destroy(struct permanentVirtualCircuitTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
permanentVirtualCircuitTable_destroy(struct permanentVirtualCircuitTable_data **thedata)
{
	struct permanentVirtualCircuitTable_data *StorageDel;

	DEBUGMSGTL(("permanentVirtualCircuitTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallId);
		StorageDel->virtualCallIdLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuitChannel);
		StorageDel->permanentVirtualCircuitChannelLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("permanentVirtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuitTable_add(struct permanentVirtualCircuitTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the permanentVirtualCircuitTable table data set.
 * Adds a table row structure to the permanentVirtualCircuitTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
permanentVirtualCircuitTable_add(struct permanentVirtualCircuitTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("permanentVirtualCircuitTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCallId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallId, thedata->virtualCallIdLen);
	header_complex_add_data(&permanentVirtualCircuitTableStorage, vars, thedata);
	DEBUGMSGTL(("permanentVirtualCircuitTable", "registered an entry\n"));
	DEBUGMSGTL(("permanentVirtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuitTable_del(struct permanentVirtualCircuitTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the permanentVirtualCircuitTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
permanentVirtualCircuitTable_del(struct permanentVirtualCircuitTable_data *thedata)
{
	struct permanentVirtualCircuitTable_data *StorageDel;

	DEBUGMSGTL(("permanentVirtualCircuitTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(permanentVirtualCircuitTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&permanentVirtualCircuitTableStorage, hciptr);
	}
	DEBUGMSGTL(("permanentVirtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_permanentVirtualCircuitTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for permanentVirtualCircuitTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case permanentVirtualCircuitTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_permanentVirtualCircuitTable(const char *token, char *line)
{
	size_t tmpsize;
	struct permanentVirtualCircuitTable_data *StorageTmp = permanentVirtualCircuitTable_create();

	DEBUGMSGTL(("permanentVirtualCircuitTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
	if (StorageTmp->virtualCallId == NULL) {
		config_perror("invalid specification for virtualCallId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuitChannel, &StorageTmp->permanentVirtualCircuitChannelLen);
	if (StorageTmp->permanentVirtualCircuitChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuitChannel");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuitRowStatus, &tmpsize);
	permanentVirtualCircuitTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("permanentVirtualCircuitTable", "done.\n"));
}

/*
 * store_permanentVirtualCircuitTable(): store configuraiton file for permanentVirtualCircuitTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_permanentVirtualCircuitTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct permanentVirtualCircuitTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("permanentVirtualCircuitTable", "storing data...  "));
	refresh_permanentVirtualCircuitTable();
	(void) tmpsize;
	for (hcindex = permanentVirtualCircuitTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct permanentVirtualCircuitTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "permanentVirtualCircuitTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuitChannel, &StorageTmp->permanentVirtualCircuitChannelLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuitRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("permanentVirtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct permanentVirtualCircuit_DTETable_data *permanentVirtualCircuit_DTETable_create(void)
 * @brief create a fresh data structure representing a new row in the permanentVirtualCircuit_DTETable table.
 * Creates a new permanentVirtualCircuit_DTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct permanentVirtualCircuit_DTETable_data *
permanentVirtualCircuit_DTETable_create(void)
{
	struct permanentVirtualCircuit_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuit_DTETable_data);

	DBUGMSGTL(("permanentVirtualCircuit_DTETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->permanentVirtualCircuit_DTERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int permanentVirtualCircuit_DTETable_destroy(struct permanentVirtualCircuit_DTETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
permanentVirtualCircuit_DTETable_destroy(struct permanentVirtualCircuit_DTETable_data **thedata)
{
	struct permanentVirtualCircuit_DTETable_data *StorageDel;

	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DTElogicalChannel);
		StorageDel->permanentVirtualCircuit_DTElogicalChannelLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DTEpacketSizes);
		StorageDel->permanentVirtualCircuit_DTEpacketSizesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DTEthroughputClasses);
		StorageDel->permanentVirtualCircuit_DTEthroughputClassesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DTEwindowSizes);
		StorageDel->permanentVirtualCircuit_DTEwindowSizesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuit_DTETable_add(struct permanentVirtualCircuit_DTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the permanentVirtualCircuit_DTETable table data set.
 * Adds a table row structure to the permanentVirtualCircuit_DTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
permanentVirtualCircuit_DTETable_add(struct permanentVirtualCircuit_DTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&permanentVirtualCircuit_DTETableStorage, vars, thedata);
	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "registered an entry\n"));
	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuit_DTETable_del(struct permanentVirtualCircuit_DTETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the permanentVirtualCircuit_DTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
permanentVirtualCircuit_DTETable_del(struct permanentVirtualCircuit_DTETable_data *thedata)
{
	struct permanentVirtualCircuit_DTETable_data *StorageDel;

	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(permanentVirtualCircuit_DTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&permanentVirtualCircuit_DTETableStorage, hciptr);
	}
	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_permanentVirtualCircuit_DTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for permanentVirtualCircuit_DTETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case permanentVirtualCircuit_DTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_permanentVirtualCircuit_DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct permanentVirtualCircuit_DTETable_data *StorageTmp = permanentVirtualCircuit_DTETable_create();

	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DTElogicalChannel, &StorageTmp->permanentVirtualCircuit_DTElogicalChannelLen);
	if (StorageTmp->permanentVirtualCircuit_DTElogicalChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DTElogicalChannel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DTEpacketSizes, &StorageTmp->permanentVirtualCircuit_DTEpacketSizesLen);
	if (StorageTmp->permanentVirtualCircuit_DTEpacketSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DTEpacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DTEthroughputClasses, &StorageTmp->permanentVirtualCircuit_DTEthroughputClassesLen);
	if (StorageTmp->permanentVirtualCircuit_DTEthroughputClasses == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DTEthroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DTEwindowSizes, &StorageTmp->permanentVirtualCircuit_DTEwindowSizesLen);
	if (StorageTmp->permanentVirtualCircuit_DTEwindowSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DTEwindowSizes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuit_DTERowStatus, &tmpsize);
	permanentVirtualCircuit_DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "done.\n"));
}

/*
 * store_permanentVirtualCircuit_DTETable(): store configuraiton file for permanentVirtualCircuit_DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_permanentVirtualCircuit_DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct permanentVirtualCircuit_DTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "storing data...  "));
	refresh_permanentVirtualCircuit_DTETable();
	(void) tmpsize;
	for (hcindex = permanentVirtualCircuit_DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct permanentVirtualCircuit_DTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "permanentVirtualCircuit_DTETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DTElogicalChannel, &StorageTmp->permanentVirtualCircuit_DTElogicalChannelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DTEpacketSizes, &StorageTmp->permanentVirtualCircuit_DTEpacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DTEthroughputClasses, &StorageTmp->permanentVirtualCircuit_DTEthroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DTEwindowSizes, &StorageTmp->permanentVirtualCircuit_DTEwindowSizesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuit_DTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("permanentVirtualCircuit_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct permanentVirtualCircuit_DCETable_data *permanentVirtualCircuit_DCETable_create(void)
 * @brief create a fresh data structure representing a new row in the permanentVirtualCircuit_DCETable table.
 * Creates a new permanentVirtualCircuit_DCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct permanentVirtualCircuit_DCETable_data *
permanentVirtualCircuit_DCETable_create(void)
{
	struct permanentVirtualCircuit_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuit_DCETable_data);

	DBUGMSGTL(("permanentVirtualCircuit_DCETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->permanentVirtualCircuit_DCERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int permanentVirtualCircuit_DCETable_destroy(struct permanentVirtualCircuit_DCETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
permanentVirtualCircuit_DCETable_destroy(struct permanentVirtualCircuit_DCETable_data **thedata)
{
	struct permanentVirtualCircuit_DCETable_data *StorageDel;

	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEchargingDirection);
		StorageDel->permanentVirtualCircuit_DCEchargingDirectionLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCElogicalChannel);
		StorageDel->permanentVirtualCircuit_DCElogicalChannelLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEpacketSizes);
		StorageDel->permanentVirtualCircuit_DCEpacketSizesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEthroughputClasses);
		StorageDel->permanentVirtualCircuit_DCEthroughputClassesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEwindowSizes);
		StorageDel->permanentVirtualCircuit_DCEwindowSizesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEremoteDTEAddress);
		StorageDel->permanentVirtualCircuit_DCEremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEremoteLogicalChannel);
		StorageDel->permanentVirtualCircuit_DCEremoteLogicalChannelLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuit_DCETable_add(struct permanentVirtualCircuit_DCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the permanentVirtualCircuit_DCETable table data set.
 * Adds a table row structure to the permanentVirtualCircuit_DCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
permanentVirtualCircuit_DCETable_add(struct permanentVirtualCircuit_DCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&permanentVirtualCircuit_DCETableStorage, vars, thedata);
	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "registered an entry\n"));
	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuit_DCETable_del(struct permanentVirtualCircuit_DCETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the permanentVirtualCircuit_DCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
permanentVirtualCircuit_DCETable_del(struct permanentVirtualCircuit_DCETable_data *thedata)
{
	struct permanentVirtualCircuit_DCETable_data *StorageDel;

	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(permanentVirtualCircuit_DCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&permanentVirtualCircuit_DCETableStorage, hciptr);
	}
	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_permanentVirtualCircuit_DCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for permanentVirtualCircuit_DCETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case permanentVirtualCircuit_DCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_permanentVirtualCircuit_DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct permanentVirtualCircuit_DCETable_data *StorageTmp = permanentVirtualCircuit_DCETable_create();

	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEchargingDirection, &StorageTmp->permanentVirtualCircuit_DCEchargingDirectionLen);
	if (StorageTmp->permanentVirtualCircuit_DCEchargingDirection == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEchargingDirection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCElogicalChannel, &StorageTmp->permanentVirtualCircuit_DCElogicalChannelLen);
	if (StorageTmp->permanentVirtualCircuit_DCElogicalChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCElogicalChannel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEpacketSizes, &StorageTmp->permanentVirtualCircuit_DCEpacketSizesLen);
	if (StorageTmp->permanentVirtualCircuit_DCEpacketSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEpacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEthroughputClasses, &StorageTmp->permanentVirtualCircuit_DCEthroughputClassesLen);
	if (StorageTmp->permanentVirtualCircuit_DCEthroughputClasses == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEthroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEwindowSizes, &StorageTmp->permanentVirtualCircuit_DCEwindowSizesLen);
	if (StorageTmp->permanentVirtualCircuit_DCEwindowSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEwindowSizes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuit_DCEoperationalState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddress, &StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddressLen);
	if (StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddress == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEremoteDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannel, &StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannelLen);
	if (StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEremoteLogicalChannel");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuit_DCERowStatus, &tmpsize);
	permanentVirtualCircuit_DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "done.\n"));
}

/*
 * store_permanentVirtualCircuit_DCETable(): store configuraiton file for permanentVirtualCircuit_DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_permanentVirtualCircuit_DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct permanentVirtualCircuit_DCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "storing data...  "));
	refresh_permanentVirtualCircuit_DCETable();
	(void) tmpsize;
	for (hcindex = permanentVirtualCircuit_DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct permanentVirtualCircuit_DCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "permanentVirtualCircuit_DCETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEchargingDirection, &StorageTmp->permanentVirtualCircuit_DCEchargingDirectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCElogicalChannel, &StorageTmp->permanentVirtualCircuit_DCElogicalChannelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEpacketSizes, &StorageTmp->permanentVirtualCircuit_DCEpacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEthroughputClasses, &StorageTmp->permanentVirtualCircuit_DCEthroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEwindowSizes, &StorageTmp->permanentVirtualCircuit_DCEwindowSizesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuit_DCEoperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddress, &StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddressLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannel, &StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannelLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuit_DCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("permanentVirtualCircuit_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCallIVMOTable_data *virtualCallIVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCallIVMOTable table.
 * Creates a new virtualCallIVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCallIVMOTable_data *
virtualCallIVMOTable_create(void)
{
	struct virtualCallIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCallIVMOTable_data);

	DBUGMSGTL(("virtualCallIVMOTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->virtualCallIVMORowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("virtualCallIVMOTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int virtualCallIVMOTable_destroy(struct virtualCallIVMOTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCallIVMOTable_destroy(struct virtualCallIVMOTable_data **thedata)
{
	struct virtualCallIVMOTable_data *StorageDel;

	DEBUGMSGTL(("virtualCallIVMOTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOId);
		StorageDel->virtualCallIVMOIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOpacketSizes);
		StorageDel->virtualCallIVMOpacketSizesLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOreverseCharging);
		StorageDel->virtualCallIVMOreverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOthroughputClasses);
		StorageDel->virtualCallIVMOthroughputClassesLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOwindowSizes);
		StorageDel->virtualCallIVMOwindowSizesLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOproposedPacketSize);
		StorageDel->virtualCallIVMOproposedPacketSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOproposedWindowSize);
		StorageDel->virtualCallIVMOproposedWindowSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOacceptReverseCharging);
		StorageDel->virtualCallIVMOacceptReverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOproposeReverseCharging);
		StorageDel->virtualCallIVMOproposeReverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOcallTime);
		StorageDel->virtualCallIVMOcallTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOresetTime);
		StorageDel->virtualCallIVMOresetTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOclearTime);
		StorageDel->virtualCallIVMOclearTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOinterruptTime);
		StorageDel->virtualCallIVMOinterruptTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOresetCount);
		StorageDel->virtualCallIVMOresetCountLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOclearCount);
		StorageDel->virtualCallIVMOclearCountLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOwindowTime);
		StorageDel->virtualCallIVMOwindowTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOdataRetransmissionTime);
		StorageDel->virtualCallIVMOdataRetransmissionTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOdataRetransmissionCount);
		StorageDel->virtualCallIVMOdataRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOrejectTime);
		StorageDel->virtualCallIVMOrejectTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOrejectCount);
		StorageDel->virtualCallIVMOrejectCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCallIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCallIVMOTable_add(struct virtualCallIVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCallIVMOTable table data set.
 * Adds a table row structure to the virtualCallIVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCallIVMOTable_add(struct virtualCallIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCallIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCallIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallIVMOId, thedata->virtualCallIVMOIdLen);
	header_complex_add_data(&virtualCallIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCallIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCallIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCallIVMOTable_del(struct virtualCallIVMOTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the virtualCallIVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCallIVMOTable_del(struct virtualCallIVMOTable_data *thedata)
{
	struct virtualCallIVMOTable_data *StorageDel;

	DEBUGMSGTL(("virtualCallIVMOTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCallIVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCallIVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("virtualCallIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCallIVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCallIVMOTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCallIVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCallIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCallIVMOTable_data *StorageTmp = virtualCallIVMOTable_create();

	DEBUGMSGTL(("virtualCallIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOId, &StorageTmp->virtualCallIVMOIdLen);
	if (StorageTmp->virtualCallIVMOId == NULL) {
		config_perror("invalid specification for virtualCallIVMOId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCallIVMOfastSelect, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOpacketSizes, &StorageTmp->virtualCallIVMOpacketSizesLen);
	if (StorageTmp->virtualCallIVMOpacketSizes == NULL) {
		config_perror("invalid specification for virtualCallIVMOpacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOreverseCharging, &StorageTmp->virtualCallIVMOreverseChargingLen);
	if (StorageTmp->virtualCallIVMOreverseCharging == NULL) {
		config_perror("invalid specification for virtualCallIVMOreverseCharging");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOthroughputClasses, &StorageTmp->virtualCallIVMOthroughputClassesLen);
	if (StorageTmp->virtualCallIVMOthroughputClasses == NULL) {
		config_perror("invalid specification for virtualCallIVMOthroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOwindowSizes, &StorageTmp->virtualCallIVMOwindowSizesLen);
	if (StorageTmp->virtualCallIVMOwindowSizes == NULL) {
		config_perror("invalid specification for virtualCallIVMOwindowSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOproposedPacketSize, &StorageTmp->virtualCallIVMOproposedPacketSizeLen);
	if (StorageTmp->virtualCallIVMOproposedPacketSize == NULL) {
		config_perror("invalid specification for virtualCallIVMOproposedPacketSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOproposedWindowSize, &StorageTmp->virtualCallIVMOproposedWindowSizeLen);
	if (StorageTmp->virtualCallIVMOproposedWindowSize == NULL) {
		config_perror("invalid specification for virtualCallIVMOproposedWindowSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOacceptReverseCharging, &StorageTmp->virtualCallIVMOacceptReverseChargingLen);
	if (StorageTmp->virtualCallIVMOacceptReverseCharging == NULL) {
		config_perror("invalid specification for virtualCallIVMOacceptReverseCharging");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOproposeReverseCharging, &StorageTmp->virtualCallIVMOproposeReverseChargingLen);
	if (StorageTmp->virtualCallIVMOproposeReverseCharging == NULL) {
		config_perror("invalid specification for virtualCallIVMOproposeReverseCharging");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOcallTime, &StorageTmp->virtualCallIVMOcallTimeLen);
	if (StorageTmp->virtualCallIVMOcallTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOcallTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOresetTime, &StorageTmp->virtualCallIVMOresetTimeLen);
	if (StorageTmp->virtualCallIVMOresetTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOresetTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOclearTime, &StorageTmp->virtualCallIVMOclearTimeLen);
	if (StorageTmp->virtualCallIVMOclearTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOclearTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOinterruptTime, &StorageTmp->virtualCallIVMOinterruptTimeLen);
	if (StorageTmp->virtualCallIVMOinterruptTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOinterruptTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOresetCount, &StorageTmp->virtualCallIVMOresetCountLen);
	if (StorageTmp->virtualCallIVMOresetCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOresetCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOclearCount, &StorageTmp->virtualCallIVMOclearCountLen);
	if (StorageTmp->virtualCallIVMOclearCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOclearCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOwindowTime, &StorageTmp->virtualCallIVMOwindowTimeLen);
	if (StorageTmp->virtualCallIVMOwindowTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOwindowTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOdataRetransmissionTime, &StorageTmp->virtualCallIVMOdataRetransmissionTimeLen);
	if (StorageTmp->virtualCallIVMOdataRetransmissionTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOdataRetransmissionTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOdataRetransmissionCount, &StorageTmp->virtualCallIVMOdataRetransmissionCountLen);
	if (StorageTmp->virtualCallIVMOdataRetransmissionCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOdataRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOrejectTime, &StorageTmp->virtualCallIVMOrejectTimeLen);
	if (StorageTmp->virtualCallIVMOrejectTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOrejectTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOrejectCount, &StorageTmp->virtualCallIVMOrejectCountLen);
	if (StorageTmp->virtualCallIVMOrejectCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOrejectCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCallIVMORowStatus, &tmpsize);
	virtualCallIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCallIVMOTable", "done.\n"));
}

/*
 * store_virtualCallIVMOTable(): store configuraiton file for virtualCallIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCallIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCallIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCallIVMOTable", "storing data...  "));
	refresh_virtualCallIVMOTable();
	(void) tmpsize;
	for (hcindex = virtualCallIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCallIVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCallIVMOTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOId, &StorageTmp->virtualCallIVMOIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCallIVMOfastSelect, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOpacketSizes, &StorageTmp->virtualCallIVMOpacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOreverseCharging, &StorageTmp->virtualCallIVMOreverseChargingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOthroughputClasses, &StorageTmp->virtualCallIVMOthroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOwindowSizes, &StorageTmp->virtualCallIVMOwindowSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOproposedPacketSize, &StorageTmp->virtualCallIVMOproposedPacketSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOproposedWindowSize, &StorageTmp->virtualCallIVMOproposedWindowSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOacceptReverseCharging, &StorageTmp->virtualCallIVMOacceptReverseChargingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOproposeReverseCharging, &StorageTmp->virtualCallIVMOproposeReverseChargingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOcallTime, &StorageTmp->virtualCallIVMOcallTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOresetTime, &StorageTmp->virtualCallIVMOresetTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOclearTime, &StorageTmp->virtualCallIVMOclearTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOinterruptTime, &StorageTmp->virtualCallIVMOinterruptTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOresetCount, &StorageTmp->virtualCallIVMOresetCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOclearCount, &StorageTmp->virtualCallIVMOclearCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOwindowTime, &StorageTmp->virtualCallIVMOwindowTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOdataRetransmissionTime, &StorageTmp->virtualCallIVMOdataRetransmissionTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOdataRetransmissionCount, &StorageTmp->virtualCallIVMOdataRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOrejectTime, &StorageTmp->virtualCallIVMOrejectTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOrejectCount, &StorageTmp->virtualCallIVMOrejectCountLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCallIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCallIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct switchedVirtualCallTable_data *switchedVirtualCallTable_create(void)
 * @brief create a fresh data structure representing a new row in the switchedVirtualCallTable table.
 * Creates a new switchedVirtualCallTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct switchedVirtualCallTable_data *
switchedVirtualCallTable_create(void)
{
	struct switchedVirtualCallTable_data *StorageNew = SNMP_MALLOC_STRUCT(switchedVirtualCallTable_data);

	DBUGMSGTL(("switchedVirtualCallTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->switchedVirtualCallRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("switchedVirtualCallTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int switchedVirtualCallTable_destroy(struct switchedVirtualCallTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
switchedVirtualCallTable_destroy(struct switchedVirtualCallTable_data **thedata)
{
	struct switchedVirtualCallTable_data *StorageDel;

	DEBUGMSGTL(("switchedVirtualCallTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallId);
		StorageDel->virtualCallIdLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCalldirection);
		StorageDel->switchedVirtualCalldirectionLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallremoteDTEAddress);
		StorageDel->switchedVirtualCallremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallthroughputClass);
		StorageDel->switchedVirtualCallthroughputClassLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallredirectReason);
		StorageDel->switchedVirtualCallredirectReasonLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCalloriginallyCalledAddress);
		StorageDel->switchedVirtualCalloriginallyCalledAddressLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallcallingAddressExtension);
		StorageDel->switchedVirtualCallcallingAddressExtensionLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallcalledAddressExtension);
		StorageDel->switchedVirtualCallcalledAddressExtensionLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("switchedVirtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int switchedVirtualCallTable_add(struct switchedVirtualCallTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the switchedVirtualCallTable table data set.
 * Adds a table row structure to the switchedVirtualCallTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
switchedVirtualCallTable_add(struct switchedVirtualCallTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("switchedVirtualCallTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCallId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallId, thedata->virtualCallIdLen);
	header_complex_add_data(&switchedVirtualCallTableStorage, vars, thedata);
	DEBUGMSGTL(("switchedVirtualCallTable", "registered an entry\n"));
	DEBUGMSGTL(("switchedVirtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int switchedVirtualCallTable_del(struct switchedVirtualCallTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the switchedVirtualCallTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
switchedVirtualCallTable_del(struct switchedVirtualCallTable_data *thedata)
{
	struct switchedVirtualCallTable_data *StorageDel;

	DEBUGMSGTL(("switchedVirtualCallTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(switchedVirtualCallTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&switchedVirtualCallTableStorage, hciptr);
	}
	DEBUGMSGTL(("switchedVirtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_switchedVirtualCallTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for switchedVirtualCallTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case switchedVirtualCallTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_switchedVirtualCallTable(const char *token, char *line)
{
	size_t tmpsize;
	struct switchedVirtualCallTable_data *StorageTmp = switchedVirtualCallTable_create();

	DEBUGMSGTL(("switchedVirtualCallTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
	if (StorageTmp->virtualCallId == NULL) {
		config_perror("invalid specification for virtualCallId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCalldirection, &StorageTmp->switchedVirtualCalldirectionLen);
	if (StorageTmp->switchedVirtualCalldirection == NULL) {
		config_perror("invalid specification for switchedVirtualCalldirection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallremoteDTEAddress, &StorageTmp->switchedVirtualCallremoteDTEAddressLen);
	if (StorageTmp->switchedVirtualCallremoteDTEAddress == NULL) {
		config_perror("invalid specification for switchedVirtualCallremoteDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallthroughputClass, &StorageTmp->switchedVirtualCallthroughputClassLen);
	if (StorageTmp->switchedVirtualCallthroughputClass == NULL) {
		config_perror("invalid specification for switchedVirtualCallthroughputClass");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallredirectReason, &StorageTmp->switchedVirtualCallredirectReasonLen);
	if (StorageTmp->switchedVirtualCallredirectReason == NULL) {
		config_perror("invalid specification for switchedVirtualCallredirectReason");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCalloriginallyCalledAddress, &StorageTmp->switchedVirtualCalloriginallyCalledAddressLen);
	if (StorageTmp->switchedVirtualCalloriginallyCalledAddress == NULL) {
		config_perror("invalid specification for switchedVirtualCalloriginallyCalledAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallcallingAddressExtension, &StorageTmp->switchedVirtualCallcallingAddressExtensionLen);
	if (StorageTmp->switchedVirtualCallcallingAddressExtension == NULL) {
		config_perror("invalid specification for switchedVirtualCallcallingAddressExtension");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallcalledAddressExtension, &StorageTmp->switchedVirtualCallcalledAddressExtensionLen);
	if (StorageTmp->switchedVirtualCallcalledAddressExtension == NULL) {
		config_perror("invalid specification for switchedVirtualCallcalledAddressExtension");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->switchedVirtualCallRowStatus, &tmpsize);
	switchedVirtualCallTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("switchedVirtualCallTable", "done.\n"));
}

/*
 * store_switchedVirtualCallTable(): store configuraiton file for switchedVirtualCallTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_switchedVirtualCallTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct switchedVirtualCallTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("switchedVirtualCallTable", "storing data...  "));
	refresh_switchedVirtualCallTable();
	(void) tmpsize;
	for (hcindex = switchedVirtualCallTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct switchedVirtualCallTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "switchedVirtualCallTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCalldirection, &StorageTmp->switchedVirtualCalldirectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallremoteDTEAddress, &StorageTmp->switchedVirtualCallremoteDTEAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallthroughputClass, &StorageTmp->switchedVirtualCallthroughputClassLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallredirectReason, &StorageTmp->switchedVirtualCallredirectReasonLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCalloriginallyCalledAddress, &StorageTmp->switchedVirtualCalloriginallyCalledAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallcallingAddressExtension, &StorageTmp->switchedVirtualCallcallingAddressExtensionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallcalledAddressExtension, &StorageTmp->switchedVirtualCallcalledAddressExtensionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->switchedVirtualCallRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("switchedVirtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCall_DTETable_data *virtualCall_DTETable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCall_DTETable table.
 * Creates a new virtualCall_DTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCall_DTETable_data *
virtualCall_DTETable_create(void)
{
	struct virtualCall_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCall_DTETable_data);

	DBUGMSGTL(("virtualCall_DTETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->virtualCall_DTERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("virtualCall_DTETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int virtualCall_DTETable_destroy(struct virtualCall_DTETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCall_DTETable_destroy(struct virtualCall_DTETable_data **thedata)
{
	struct virtualCall_DTETable_data *StorageDel;

	DEBUGMSGTL(("virtualCall_DTETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEcallingAddressExtension);
		StorageDel->virtualCall_DTEcallingAddressExtensionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEcalledAddressExtension);
		StorageDel->virtualCall_DTEcalledAddressExtensionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEdirection);
		StorageDel->virtualCall_DTEdirectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEoriginallyCalledAddress);
		StorageDel->virtualCall_DTEoriginallyCalledAddressLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEredirectReason);
		StorageDel->virtualCall_DTEredirectReasonLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEremoteDTEAddress);
		StorageDel->virtualCall_DTEremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEreverseCharging);
		StorageDel->virtualCall_DTEreverseChargingLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCall_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCall_DTETable_add(struct virtualCall_DTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCall_DTETable table data set.
 * Adds a table row structure to the virtualCall_DTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCall_DTETable_add(struct virtualCall_DTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCall_DTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&virtualCall_DTETableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCall_DTETable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCall_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCall_DTETable_del(struct virtualCall_DTETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the virtualCall_DTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCall_DTETable_del(struct virtualCall_DTETable_data *thedata)
{
	struct virtualCall_DTETable_data *StorageDel;

	DEBUGMSGTL(("virtualCall_DTETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCall_DTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCall_DTETableStorage, hciptr);
	}
	DEBUGMSGTL(("virtualCall_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCall_DTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCall_DTETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCall_DTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCall_DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCall_DTETable_data *StorageTmp = virtualCall_DTETable_create();

	DEBUGMSGTL(("virtualCall_DTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEcallingAddressExtension, &StorageTmp->virtualCall_DTEcallingAddressExtensionLen);
	if (StorageTmp->virtualCall_DTEcallingAddressExtension == NULL) {
		config_perror("invalid specification for virtualCall_DTEcallingAddressExtension");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEcalledAddressExtension, &StorageTmp->virtualCall_DTEcalledAddressExtensionLen);
	if (StorageTmp->virtualCall_DTEcalledAddressExtension == NULL) {
		config_perror("invalid specification for virtualCall_DTEcalledAddressExtension");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEdirection, &StorageTmp->virtualCall_DTEdirectionLen);
	if (StorageTmp->virtualCall_DTEdirection == NULL) {
		config_perror("invalid specification for virtualCall_DTEdirection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DTEfastSelect, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEoriginallyCalledAddress, &StorageTmp->virtualCall_DTEoriginallyCalledAddressLen);
	if (StorageTmp->virtualCall_DTEoriginallyCalledAddress == NULL) {
		config_perror("invalid specification for virtualCall_DTEoriginallyCalledAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEredirectReason, &StorageTmp->virtualCall_DTEredirectReasonLen);
	if (StorageTmp->virtualCall_DTEredirectReason == NULL) {
		config_perror("invalid specification for virtualCall_DTEredirectReason");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEremoteDTEAddress, &StorageTmp->virtualCall_DTEremoteDTEAddressLen);
	if (StorageTmp->virtualCall_DTEremoteDTEAddress == NULL) {
		config_perror("invalid specification for virtualCall_DTEremoteDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEreverseCharging, &StorageTmp->virtualCall_DTEreverseChargingLen);
	if (StorageTmp->virtualCall_DTEreverseCharging == NULL) {
		config_perror("invalid specification for virtualCall_DTEreverseCharging");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DTERowStatus, &tmpsize);
	virtualCall_DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCall_DTETable", "done.\n"));
}

/*
 * store_virtualCall_DTETable(): store configuraiton file for virtualCall_DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCall_DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCall_DTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCall_DTETable", "storing data...  "));
	refresh_virtualCall_DTETable();
	(void) tmpsize;
	for (hcindex = virtualCall_DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCall_DTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCall_DTETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEcallingAddressExtension, &StorageTmp->virtualCall_DTEcallingAddressExtensionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEcalledAddressExtension, &StorageTmp->virtualCall_DTEcalledAddressExtensionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEdirection, &StorageTmp->virtualCall_DTEdirectionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DTEfastSelect, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEoriginallyCalledAddress, &StorageTmp->virtualCall_DTEoriginallyCalledAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEredirectReason, &StorageTmp->virtualCall_DTEredirectReasonLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEremoteDTEAddress, &StorageTmp->virtualCall_DTEremoteDTEAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEreverseCharging, &StorageTmp->virtualCall_DTEreverseChargingLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCall_DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCall_DCETable_data *virtualCall_DCETable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCall_DCETable table.
 * Creates a new virtualCall_DCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCall_DCETable_data *
virtualCall_DCETable_create(void)
{
	struct virtualCall_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCall_DCETable_data);

	DBUGMSGTL(("virtualCall_DCETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->virtualCall_DCERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("virtualCall_DCETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int virtualCall_DCETable_destroy(struct virtualCall_DCETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCall_DCETable_destroy(struct virtualCall_DCETable_data **thedata)
{
	struct virtualCall_DCETable_data *StorageDel;

	DEBUGMSGTL(("virtualCall_DCETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEchargingDirection);
		StorageDel->virtualCall_DCEchargingDirectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEcUGSelection);
		StorageDel->virtualCall_DCEcUGSelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEdirection);
		StorageDel->virtualCall_DCEdirectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEremoteDTEAddress);
		StorageDel->virtualCall_DCEremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEtransitDelaySelectionAndIndication);
		StorageDel->virtualCall_DCEtransitDelaySelectionAndIndicationLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEbilateralCUGSelection);
		StorageDel->virtualCall_DCEbilateralCUGSelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEcUGWithOutgoingAccessSelection);
		StorageDel->virtualCall_DCEcUGWithOutgoingAccessSelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEnUISelection);
		StorageDel->virtualCall_DCEnUISelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEreverseCharging);
		StorageDel->virtualCall_DCEreverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCErOASelection);
		StorageDel->virtualCall_DCErOASelectionLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCall_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCall_DCETable_add(struct virtualCall_DCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCall_DCETable table data set.
 * Adds a table row structure to the virtualCall_DCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCall_DCETable_add(struct virtualCall_DCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCall_DCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&virtualCall_DCETableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCall_DCETable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCall_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCall_DCETable_del(struct virtualCall_DCETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the virtualCall_DCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCall_DCETable_del(struct virtualCall_DCETable_data *thedata)
{
	struct virtualCall_DCETable_data *StorageDel;

	DEBUGMSGTL(("virtualCall_DCETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCall_DCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCall_DCETableStorage, hciptr);
	}
	DEBUGMSGTL(("virtualCall_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCall_DCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCall_DCETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCall_DCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCall_DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCall_DCETable_data *StorageTmp = virtualCall_DCETable_create();

	DEBUGMSGTL(("virtualCall_DCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEchargingDirection, &StorageTmp->virtualCall_DCEchargingDirectionLen);
	if (StorageTmp->virtualCall_DCEchargingDirection == NULL) {
		config_perror("invalid specification for virtualCall_DCEchargingDirection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEcUGSelection, &StorageTmp->virtualCall_DCEcUGSelectionLen);
	if (StorageTmp->virtualCall_DCEcUGSelection == NULL) {
		config_perror("invalid specification for virtualCall_DCEcUGSelection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEdirection, &StorageTmp->virtualCall_DCEdirectionLen);
	if (StorageTmp->virtualCall_DCEdirection == NULL) {
		config_perror("invalid specification for virtualCall_DCEdirection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DCEfastSelect, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEremoteDTEAddress, &StorageTmp->virtualCall_DCEremoteDTEAddressLen);
	if (StorageTmp->virtualCall_DCEremoteDTEAddress == NULL) {
		config_perror("invalid specification for virtualCall_DCEremoteDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndication, &StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndicationLen);
	if (StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndication == NULL) {
		config_perror("invalid specification for virtualCall_DCEtransitDelaySelectionAndIndication");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEbilateralCUGSelection, &StorageTmp->virtualCall_DCEbilateralCUGSelectionLen);
	if (StorageTmp->virtualCall_DCEbilateralCUGSelection == NULL) {
		config_perror("invalid specification for virtualCall_DCEbilateralCUGSelection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DCEcallRedirectionDeflectionNotification, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DCEcalledLineAddressModifiedNotification, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelection, &StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelectionLen);
	if (StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelection == NULL) {
		config_perror("invalid specification for virtualCall_DCEcUGWithOutgoingAccessSelection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEnUISelection, &StorageTmp->virtualCall_DCEnUISelectionLen);
	if (StorageTmp->virtualCall_DCEnUISelection == NULL) {
		config_perror("invalid specification for virtualCall_DCEnUISelection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEreverseCharging, &StorageTmp->virtualCall_DCEreverseChargingLen);
	if (StorageTmp->virtualCall_DCEreverseCharging == NULL) {
		config_perror("invalid specification for virtualCall_DCEreverseCharging");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCErOASelection, &StorageTmp->virtualCall_DCErOASelectionLen);
	if (StorageTmp->virtualCall_DCErOASelection == NULL) {
		config_perror("invalid specification for virtualCall_DCErOASelection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DCERowStatus, &tmpsize);
	virtualCall_DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCall_DCETable", "done.\n"));
}

/*
 * store_virtualCall_DCETable(): store configuraiton file for virtualCall_DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCall_DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCall_DCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCall_DCETable", "storing data...  "));
	refresh_virtualCall_DCETable();
	(void) tmpsize;
	for (hcindex = virtualCall_DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCall_DCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCall_DCETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEchargingDirection, &StorageTmp->virtualCall_DCEchargingDirectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEcUGSelection, &StorageTmp->virtualCall_DCEcUGSelectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEdirection, &StorageTmp->virtualCall_DCEdirectionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DCEfastSelect, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEremoteDTEAddress, &StorageTmp->virtualCall_DCEremoteDTEAddressLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndication,
						   &StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndicationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEbilateralCUGSelection, &StorageTmp->virtualCall_DCEbilateralCUGSelectionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DCEcallRedirectionDeflectionNotification, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DCEcalledLineAddressModifiedNotification, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelection, &StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEnUISelection, &StorageTmp->virtualCall_DCEnUISelectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEreverseCharging, &StorageTmp->virtualCall_DCEreverseChargingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCErOASelection, &StorageTmp->virtualCall_DCErOASelectionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCall_DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dSeriesCountsTable_data *dSeriesCountsTable_create(void)
 * @brief create a fresh data structure representing a new row in the dSeriesCountsTable table.
 * Creates a new dSeriesCountsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dSeriesCountsTable_data *
dSeriesCountsTable_create(void)
{
	struct dSeriesCountsTable_data *StorageNew = SNMP_MALLOC_STRUCT(dSeriesCountsTable_data);

	DBUGMSGTL(("dSeriesCountsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dSeriesRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dSeriesCountsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int dSeriesCountsTable_destroy(struct dSeriesCountsTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
dSeriesCountsTable_destroy(struct dSeriesCountsTable_data **thedata)
{
	struct dSeriesCountsTable_data *StorageDel;

	DEBUGMSGTL(("dSeriesCountsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->dSeriesId);
		StorageDel->dSeriesIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dSeriesCountsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dSeriesCountsTable_add(struct dSeriesCountsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dSeriesCountsTable table data set.
 * Adds a table row structure to the dSeriesCountsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dSeriesCountsTable_add(struct dSeriesCountsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dSeriesCountsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	/* dSeriesId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->dSeriesId, thedata->dSeriesIdLen);
	header_complex_add_data(&dSeriesCountsTableStorage, vars, thedata);
	DEBUGMSGTL(("dSeriesCountsTable", "registered an entry\n"));
	DEBUGMSGTL(("dSeriesCountsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dSeriesCountsTable_del(struct dSeriesCountsTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the dSeriesCountsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dSeriesCountsTable_del(struct dSeriesCountsTable_data *thedata)
{
	struct dSeriesCountsTable_data *StorageDel;

	DEBUGMSGTL(("dSeriesCountsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dSeriesCountsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dSeriesCountsTableStorage, hciptr);
	}
	DEBUGMSGTL(("dSeriesCountsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dSeriesCountsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dSeriesCountsTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case dSeriesCountsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dSeriesCountsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dSeriesCountsTable_data *StorageTmp = dSeriesCountsTable_create();

	DEBUGMSGTL(("dSeriesCountsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dSeriesId, &StorageTmp->dSeriesIdLen);
	if (StorageTmp->dSeriesId == NULL) {
		config_perror("invalid specification for dSeriesId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dSeriesResetRequestIndicationPackets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dSeriesSegmentsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dSeriesSegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dSeriesRowStatus, &tmpsize);
	dSeriesCountsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dSeriesCountsTable", "done.\n"));
}

/*
 * store_dSeriesCountsTable(): store configuraiton file for dSeriesCountsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dSeriesCountsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dSeriesCountsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dSeriesCountsTable", "storing data...  "));
	refresh_dSeriesCountsTable();
	(void) tmpsize;
	for (hcindex = dSeriesCountsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dSeriesCountsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dSeriesCountsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dSeriesId, &StorageTmp->dSeriesIdLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dSeriesResetRequestIndicationPackets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dSeriesSegmentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dSeriesSegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dSeriesRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dSeriesCountsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct adjacencyTable_data *adjacencyTable_create(void)
 * @brief create a fresh data structure representing a new row in the adjacencyTable table.
 * Creates a new adjacencyTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct adjacencyTable_data *
adjacencyTable_create(void)
{
	struct adjacencyTable_data *StorageNew = SNMP_MALLOC_STRUCT(adjacencyTable_data);

	DBUGMSGTL(("adjacencyTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->adjacencyUsage = undefined;
		StorageNew->adjacencyRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("adjacencyTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int adjacencyTable_destroy(struct adjacencyTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
adjacencyTable_destroy(struct adjacencyTable_data **thedata)
{
	struct adjacencyTable_data *StorageDel;

	DEBUGMSGTL(("adjacencyTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->linkageId);
		StorageDel->linkageIdLen = 0;
		SNMP_FREE(StorageDel->adjacencyId);
		StorageDel->adjacencyIdLen = 0;
		SNMP_FREE(StorageDel->neighbourSNPAAddress);
		StorageDel->neighbourSNPAAddressLen = 0;
		SNMP_FREE(StorageDel->neighbourSystemIds);
		StorageDel->neighbourSystemIdsLen = 0;
		SNMP_FREE(StorageDel->areaAddressesOfNeighbour);
		StorageDel->areaAddressesOfNeighbourLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("adjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int adjacencyTable_add(struct adjacencyTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the adjacencyTable table data set.
 * Adds a table row structure to the adjacencyTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
adjacencyTable_add(struct adjacencyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("adjacencyTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	/* linkageId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->linkageId, thedata->linkageIdLen);
	/* adjacencyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->adjacencyId, thedata->adjacencyIdLen);
	header_complex_add_data(&adjacencyTableStorage, vars, thedata);
	DEBUGMSGTL(("adjacencyTable", "registered an entry\n"));
	DEBUGMSGTL(("adjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int adjacencyTable_del(struct adjacencyTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the adjacencyTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
adjacencyTable_del(struct adjacencyTable_data *thedata)
{
	struct adjacencyTable_data *StorageDel;

	DEBUGMSGTL(("adjacencyTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(adjacencyTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&adjacencyTableStorage, hciptr);
	}
	DEBUGMSGTL(("adjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_adjacencyTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for adjacencyTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case adjacencyTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_adjacencyTable(const char *token, char *line)
{
	size_t tmpsize;
	struct adjacencyTable_data *StorageTmp = adjacencyTable_create();

	DEBUGMSGTL(("adjacencyTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageId, &StorageTmp->linkageIdLen);
	if (StorageTmp->linkageId == NULL) {
		config_perror("invalid specification for linkageId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->adjacencyId, &StorageTmp->adjacencyIdLen);
	if (StorageTmp->adjacencyId == NULL) {
		config_perror("invalid specification for adjacencyId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->adjacencyState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->neighbourSNPAAddress, &StorageTmp->neighbourSNPAAddressLen);
	if (StorageTmp->neighbourSNPAAddress == NULL) {
		config_perror("invalid specification for neighbourSNPAAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->neighbourSystemType, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->neighbourSystemIds, &StorageTmp->neighbourSystemIdsLen);
	if (StorageTmp->neighbourSystemIds == NULL) {
		config_perror("invalid specification for neighbourSystemIds");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->adjacencyUsage, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->areaAddressesOfNeighbour, &StorageTmp->areaAddressesOfNeighbourLen);
	if (StorageTmp->areaAddressesOfNeighbour == NULL) {
		config_perror("invalid specification for areaAddressesOfNeighbour");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->holdingTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->priorityOfNeighbour, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->adjacencyRowStatus, &tmpsize);
	adjacencyTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("adjacencyTable", "done.\n"));
}

/*
 * store_adjacencyTable(): store configuraiton file for adjacencyTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_adjacencyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct adjacencyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("adjacencyTable", "storing data...  "));
	refresh_adjacencyTable();
	(void) tmpsize;
	for (hcindex = adjacencyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct adjacencyTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "adjacencyTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageId, &StorageTmp->linkageIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->adjacencyId, &StorageTmp->adjacencyIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->adjacencyState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->neighbourSNPAAddress, &StorageTmp->neighbourSNPAAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->neighbourSystemType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->neighbourSystemIds, &StorageTmp->neighbourSystemIdsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->adjacencyUsage, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->areaAddressesOfNeighbour, &StorageTmp->areaAddressesOfNeighbourLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->holdingTimer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->priorityOfNeighbour, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->adjacencyRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("adjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualAdjacencyTable_data *virtualAdjacencyTable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualAdjacencyTable table.
 * Creates a new virtualAdjacencyTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualAdjacencyTable_data *
virtualAdjacencyTable_create(void)
{
	struct virtualAdjacencyTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualAdjacencyTable_data);

	DBUGMSGTL(("virtualAdjacencyTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("virtualAdjacencyTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int virtualAdjacencyTable_destroy(struct virtualAdjacencyTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualAdjacencyTable_destroy(struct virtualAdjacencyTable_data **thedata)
{
	struct virtualAdjacencyTable_data *StorageDel;

	DEBUGMSGTL(("virtualAdjacencyTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->virtualAdjacencyNetworkEntityTitle);
		StorageDel->virtualAdjacencyNetworkEntityTitleLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualAdjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualAdjacencyTable_add(struct virtualAdjacencyTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualAdjacencyTable table data set.
 * Adds a table row structure to the virtualAdjacencyTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualAdjacencyTable_add(struct virtualAdjacencyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualAdjacencyTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	/* virtualAdjacencyNetworkEntityTitle */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualAdjacencyNetworkEntityTitle, thedata->virtualAdjacencyNetworkEntityTitleLen);
	header_complex_add_data(&virtualAdjacencyTableStorage, vars, thedata);
	DEBUGMSGTL(("virtualAdjacencyTable", "registered an entry\n"));
	DEBUGMSGTL(("virtualAdjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualAdjacencyTable_del(struct virtualAdjacencyTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the virtualAdjacencyTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualAdjacencyTable_del(struct virtualAdjacencyTable_data *thedata)
{
	struct virtualAdjacencyTable_data *StorageDel;

	DEBUGMSGTL(("virtualAdjacencyTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualAdjacencyTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualAdjacencyTableStorage, hciptr);
	}
	DEBUGMSGTL(("virtualAdjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualAdjacencyTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualAdjacencyTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualAdjacencyTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualAdjacencyTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualAdjacencyTable_data *StorageTmp = virtualAdjacencyTable_create();

	DEBUGMSGTL(("virtualAdjacencyTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualAdjacencyNetworkEntityTitle, &StorageTmp->virtualAdjacencyNetworkEntityTitleLen);
	if (StorageTmp->virtualAdjacencyNetworkEntityTitle == NULL) {
		config_perror("invalid specification for virtualAdjacencyNetworkEntityTitle");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualAdjacencyMetric, &tmpsize);
	virtualAdjacencyTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualAdjacencyTable", "done.\n"));
}

/*
 * store_virtualAdjacencyTable(): store configuraiton file for virtualAdjacencyTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualAdjacencyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualAdjacencyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualAdjacencyTable", "storing data...  "));
	refresh_virtualAdjacencyTable();
	(void) tmpsize;
	for (hcindex = virtualAdjacencyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualAdjacencyTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualAdjacencyTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualAdjacencyNetworkEntityTitle, &StorageTmp->virtualAdjacencyNetworkEntityTitleLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualAdjacencyMetric, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualAdjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct destinationTable_data *destinationTable_create(void)
 * @brief create a fresh data structure representing a new row in the destinationTable table.
 * Creates a new destinationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct destinationTable_data *
destinationTable_create(void)
{
	struct destinationTable_data *StorageNew = SNMP_MALLOC_STRUCT(destinationTable_data);

	DBUGMSGTL(("destinationTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("destinationTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int destinationTable_destroy(struct destinationTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
destinationTable_destroy(struct destinationTable_data **thedata)
{
	struct destinationTable_data *StorageDel;

	DEBUGMSGTL(("destinationTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->destinationAddressPrefix);
		StorageDel->destinationAddressPrefixLen = 0;
		SNMP_FREE(StorageDel->destinationDefaultMetricOutputAdjacencies);
		StorageDel->destinationDefaultMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel->destinationDelayMetricOutputAdjacencies);
		StorageDel->destinationDelayMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel->destinationExpenseMetricOutputAdjacencies);
		StorageDel->destinationExpenseMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel->destinationErrorMetricOutputAdjacencies);
		StorageDel->destinationErrorMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("destinationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationTable_add(struct destinationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the destinationTable table data set.
 * Adds a table row structure to the destinationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
destinationTable_add(struct destinationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("destinationTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	/* destinationAddressPrefix */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->destinationAddressPrefix, thedata->destinationAddressPrefixLen);
	header_complex_add_data(&destinationTableStorage, vars, thedata);
	DEBUGMSGTL(("destinationTable", "registered an entry\n"));
	DEBUGMSGTL(("destinationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationTable_del(struct destinationTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the destinationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
destinationTable_del(struct destinationTable_data *thedata)
{
	struct destinationTable_data *StorageDel;

	DEBUGMSGTL(("destinationTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(destinationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&destinationTableStorage, hciptr);
	}
	DEBUGMSGTL(("destinationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_destinationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for destinationTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case destinationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_destinationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct destinationTable_data *StorageTmp = destinationTable_create();

	DEBUGMSGTL(("destinationTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationAddressPrefix, &StorageTmp->destinationAddressPrefixLen);
	if (StorageTmp->destinationAddressPrefix == NULL) {
		config_perror("invalid specification for destinationAddressPrefix");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationDefaultMetricPathCost, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationDefaultMetricOutputAdjacencies, &StorageTmp->destinationDefaultMetricOutputAdjacenciesLen);
	if (StorageTmp->destinationDefaultMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationDefaultMetricOutputAdjacencies");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationDelayMetricPathCost, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationDelayMetricOutputAdjacencies, &StorageTmp->destinationDelayMetricOutputAdjacenciesLen);
	if (StorageTmp->destinationDelayMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationDelayMetricOutputAdjacencies");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationExpenseMetricPathCost, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationExpenseMetricOutputAdjacencies, &StorageTmp->destinationExpenseMetricOutputAdjacenciesLen);
	if (StorageTmp->destinationExpenseMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationExpenseMetricOutputAdjacencies");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationErrorMetricPathCost, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationErrorMetricOutputAdjacencies, &StorageTmp->destinationErrorMetricOutputAdjacenciesLen);
	if (StorageTmp->destinationErrorMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationErrorMetricOutputAdjacencies");
		return;
	}
	destinationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("destinationTable", "done.\n"));
}

/*
 * store_destinationTable(): store configuraiton file for destinationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_destinationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct destinationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("destinationTable", "storing data...  "));
	refresh_destinationTable();
	(void) tmpsize;
	for (hcindex = destinationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct destinationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "destinationTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationAddressPrefix, &StorageTmp->destinationAddressPrefixLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationDefaultMetricPathCost, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationDefaultMetricOutputAdjacencies, &StorageTmp->destinationDefaultMetricOutputAdjacenciesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationDelayMetricPathCost, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationDelayMetricOutputAdjacencies, &StorageTmp->destinationDelayMetricOutputAdjacenciesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationExpenseMetricPathCost, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationExpenseMetricOutputAdjacencies, &StorageTmp->destinationExpenseMetricOutputAdjacenciesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationErrorMetricPathCost, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationErrorMetricOutputAdjacencies, &StorageTmp->destinationErrorMetricOutputAdjacenciesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("destinationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct destinationSystemTable_data *destinationSystemTable_create(void)
 * @brief create a fresh data structure representing a new row in the destinationSystemTable table.
 * Creates a new destinationSystemTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct destinationSystemTable_data *
destinationSystemTable_create(void)
{
	struct destinationSystemTable_data *StorageNew = SNMP_MALLOC_STRUCT(destinationSystemTable_data);

	DBUGMSGTL(("destinationSystemTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("destinationSystemTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int destinationSystemTable_destroy(struct destinationSystemTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
destinationSystemTable_destroy(struct destinationSystemTable_data **thedata)
{
	struct destinationSystemTable_data *StorageDel;

	DEBUGMSGTL(("destinationSystemTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->destinationSystemNetworkEntityTitle);
		StorageDel->destinationSystemNetworkEntityTitleLen = 0;
		SNMP_FREE(StorageDel->destinationSystemAdjacency);
		StorageDel->destinationSystemAdjacencyLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("destinationSystemTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationSystemTable_add(struct destinationSystemTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the destinationSystemTable table data set.
 * Adds a table row structure to the destinationSystemTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
destinationSystemTable_add(struct destinationSystemTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("destinationSystemTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	/* destinationSystemNetworkEntityTitle */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->destinationSystemNetworkEntityTitle, thedata->destinationSystemNetworkEntityTitleLen);
	/* destinationSystemMetricType */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->destinationSystemMetricType, sizeof(thedata->destinationSystemMetricType));
	/* destinationSystemAdjacency */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OBJECT_ID, (u_char *) thedata->destinationSystemAdjacency, thedata->destinationSystemAdjacencyLen);
	header_complex_add_data(&destinationSystemTableStorage, vars, thedata);
	DEBUGMSGTL(("destinationSystemTable", "registered an entry\n"));
	DEBUGMSGTL(("destinationSystemTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationSystemTable_del(struct destinationSystemTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the destinationSystemTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
destinationSystemTable_del(struct destinationSystemTable_data *thedata)
{
	struct destinationSystemTable_data *StorageDel;

	DEBUGMSGTL(("destinationSystemTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(destinationSystemTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&destinationSystemTableStorage, hciptr);
	}
	DEBUGMSGTL(("destinationSystemTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_destinationSystemTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for destinationSystemTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case destinationSystemTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_destinationSystemTable(const char *token, char *line)
{
	size_t tmpsize;
	struct destinationSystemTable_data *StorageTmp = destinationSystemTable_create();

	DEBUGMSGTL(("destinationSystemTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationSystemNetworkEntityTitle, &StorageTmp->destinationSystemNetworkEntityTitleLen);
	if (StorageTmp->destinationSystemNetworkEntityTitle == NULL) {
		config_perror("invalid specification for destinationSystemNetworkEntityTitle");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationSystemMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->desintationSystemMetric, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->destinationSystemAdjacency, &StorageTmp->destinationSystemAdjacencyLen);
	if (StorageTmp->destinationSystemAdjacency == NULL) {
		config_perror("invalid specification for destinationSystemAdjacency");
		return;
	}
	destinationSystemTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("destinationSystemTable", "done.\n"));
}

/*
 * store_destinationSystemTable(): store configuraiton file for destinationSystemTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_destinationSystemTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct destinationSystemTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("destinationSystemTable", "storing data...  "));
	refresh_destinationSystemTable();
	(void) tmpsize;
	for (hcindex = destinationSystemTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct destinationSystemTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "destinationSystemTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationSystemNetworkEntityTitle, &StorageTmp->destinationSystemNetworkEntityTitleLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationSystemMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->desintationSystemMetric, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->destinationSystemAdjacency, &StorageTmp->destinationSystemAdjacencyLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("destinationSystemTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct destinationAreaTable_data *destinationAreaTable_create(void)
 * @brief create a fresh data structure representing a new row in the destinationAreaTable table.
 * Creates a new destinationAreaTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct destinationAreaTable_data *
destinationAreaTable_create(void)
{
	struct destinationAreaTable_data *StorageNew = SNMP_MALLOC_STRUCT(destinationAreaTable_data);

	DBUGMSGTL(("destinationAreaTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("destinationAreaTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int destinationAreaTable_destroy(struct destinationAreaTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
destinationAreaTable_destroy(struct destinationAreaTable_data **thedata)
{
	struct destinationAreaTable_data *StorageDel;

	DEBUGMSGTL(("destinationAreaTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->destinationAreaId);
		StorageDel->destinationAreaIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("destinationAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationAreaTable_add(struct destinationAreaTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the destinationAreaTable table data set.
 * Adds a table row structure to the destinationAreaTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
destinationAreaTable_add(struct destinationAreaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("destinationAreaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* destinationAreaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->destinationAreaId, thedata->destinationAreaIdLen);
	header_complex_add_data(&destinationAreaTableStorage, vars, thedata);
	DEBUGMSGTL(("destinationAreaTable", "registered an entry\n"));
	DEBUGMSGTL(("destinationAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationAreaTable_del(struct destinationAreaTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the destinationAreaTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
destinationAreaTable_del(struct destinationAreaTable_data *thedata)
{
	struct destinationAreaTable_data *StorageDel;

	DEBUGMSGTL(("destinationAreaTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(destinationAreaTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&destinationAreaTableStorage, hciptr);
	}
	DEBUGMSGTL(("destinationAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_destinationAreaTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for destinationAreaTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case destinationAreaTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_destinationAreaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct destinationAreaTable_data *StorageTmp = destinationAreaTable_create();

	DEBUGMSGTL(("destinationAreaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationAreaId, &StorageTmp->destinationAreaIdLen);
	if (StorageTmp->destinationAreaId == NULL) {
		config_perror("invalid specification for destinationAreaId");
		return;
	}
	destinationAreaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("destinationAreaTable", "done.\n"));
}

/*
 * store_destinationAreaTable(): store configuraiton file for destinationAreaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_destinationAreaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct destinationAreaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("destinationAreaTable", "storing data...  "));
	refresh_destinationAreaTable();
	(void) tmpsize;
	for (hcindex = destinationAreaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct destinationAreaTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "destinationAreaTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationAreaId, &StorageTmp->destinationAreaIdLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("destinationAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct reachableAddressTable_data *reachableAddressTable_create(void)
 * @brief create a fresh data structure representing a new row in the reachableAddressTable table.
 * Creates a new reachableAddressTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct reachableAddressTable_data *
reachableAddressTable_create(void)
{
	struct reachableAddressTable_data *StorageNew = SNMP_MALLOC_STRUCT(reachableAddressTable_data);

	DBUGMSGTL(("reachableAddressTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->reachableAddressDefaultMetric = 20;
		StorageNew->reachableAddressDefaultMetricType = internal;
		StorageNew->reachableAddressDelayMetricType = internal;
		StorageNew->reachableAddressExpenseMetricType = internal;
		StorageNew->reachableAddressErrorMetricType = internal;
		StorageNew->reachableAddressSNPAMask = strdup("\"\"");
		StorageNew->reachableAddressSNPAMaskLen = strlen("\"\"");
		StorageNew->reachableAddressSNPAPrefix = strdup("\"\"");
		StorageNew->reachableAddressSNPAPrefixLen = strlen("\"\"");
		StorageNew->reachableAddressRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("reachableAddressTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int reachableAddressTable_destroy(struct reachableAddressTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
reachableAddressTable_destroy(struct reachableAddressTable_data **thedata)
{
	struct reachableAddressTable_data *StorageDel;

	DEBUGMSGTL(("reachableAddressTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->reachableAddressId);
		StorageDel->reachableAddressIdLen = 0;
		SNMP_FREE(StorageDel->reachableAddressPrefix);
		StorageDel->reachableAddressPrefixLen = 0;
		SNMP_FREE(StorageDel->reachableAddressSNPAAddresses);
		StorageDel->reachableAddressSNPAAddressesLen = 0;
		SNMP_FREE(StorageDel->reachableAddressSNPAMask);
		StorageDel->reachableAddressSNPAMaskLen = 0;
		SNMP_FREE(StorageDel->reachableAddressSNPAPrefix);
		StorageDel->reachableAddressSNPAPrefixLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("reachableAddressTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int reachableAddressTable_add(struct reachableAddressTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the reachableAddressTable table data set.
 * Adds a table row structure to the reachableAddressTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
reachableAddressTable_add(struct reachableAddressTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("reachableAddressTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* reachableAddressId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->reachableAddressId, thedata->reachableAddressIdLen);
	header_complex_add_data(&reachableAddressTableStorage, vars, thedata);
	DEBUGMSGTL(("reachableAddressTable", "registered an entry\n"));
	DEBUGMSGTL(("reachableAddressTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int reachableAddressTable_del(struct reachableAddressTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the reachableAddressTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
reachableAddressTable_del(struct reachableAddressTable_data *thedata)
{
	struct reachableAddressTable_data *StorageDel;

	DEBUGMSGTL(("reachableAddressTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(reachableAddressTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&reachableAddressTableStorage, hciptr);
	}
	DEBUGMSGTL(("reachableAddressTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_reachableAddressTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for reachableAddressTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case reachableAddressTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_reachableAddressTable(const char *token, char *line)
{
	size_t tmpsize;
	struct reachableAddressTable_data *StorageTmp = reachableAddressTable_create();

	DEBUGMSGTL(("reachableAddressTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressId, &StorageTmp->reachableAddressIdLen);
	if (StorageTmp->reachableAddressId == NULL) {
		config_perror("invalid specification for reachableAddressId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressPrefix, &StorageTmp->reachableAddressPrefixLen);
	if (StorageTmp->reachableAddressPrefix == NULL) {
		config_perror("invalid specification for reachableAddressPrefix");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressMappingType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDefaultMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDelayMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressExpenseMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressErrorMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDefaultMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDelayMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressExpenseMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressErrorMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressSNPAAddresses, &StorageTmp->reachableAddressSNPAAddressesLen);
	if (StorageTmp->reachableAddressSNPAAddresses == NULL) {
		config_perror("invalid specification for reachableAddressSNPAAddresses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressSNPAMask, &StorageTmp->reachableAddressSNPAMaskLen);
	if (StorageTmp->reachableAddressSNPAMask == NULL) {
		config_perror("invalid specification for reachableAddressSNPAMask");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressSNPAPrefix, &StorageTmp->reachableAddressSNPAPrefixLen);
	if (StorageTmp->reachableAddressSNPAPrefix == NULL) {
		config_perror("invalid specification for reachableAddressSNPAPrefix");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressRowStatus, &tmpsize);
	reachableAddressTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("reachableAddressTable", "done.\n"));
}

/*
 * store_reachableAddressTable(): store configuraiton file for reachableAddressTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_reachableAddressTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct reachableAddressTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("reachableAddressTable", "storing data...  "));
	refresh_reachableAddressTable();
	(void) tmpsize;
	for (hcindex = reachableAddressTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct reachableAddressTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "reachableAddressTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressId, &StorageTmp->reachableAddressIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressPrefix, &StorageTmp->reachableAddressPrefixLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressMappingType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDefaultMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDelayMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressExpenseMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressErrorMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDefaultMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDelayMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressExpenseMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressErrorMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressSNPAAddresses, &StorageTmp->reachableAddressSNPAAddressesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressSNPAMask, &StorageTmp->reachableAddressSNPAMaskLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressSNPAPrefix, &StorageTmp->reachableAddressSNPAPrefixLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("reachableAddressTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_communicationsEntityTable(void)
 * @brief refresh the scalar values of the communicationsEntityTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_communicationsEntityTable(void)
{
	if (communicationsEntityTable_refresh == 0)
		return;
	communicationsEntityTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_communicationsEntityTable_row(struct communicationsEntityTable_data *StorageTmp)
 * @brief refresh the contents of the communicationsEntityTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_communicationsEntityTable_row(struct communicationsEntityTable_data *StorageTmp)
{
	if (StorageTmp->communicationsEntityTable_request == sa_request)
		return;
	StorageTmp->communicationsEntityTable_request = sa_request;
}

/**
 * @fn u_char *var_communicationsEntityTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in communicationsEntityTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_communicationsEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct communicationsEntityTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_communicationsEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_communicationsEntityTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(communicationsEntityTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_communicationsEntityTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case COMMUNICATIONSENTITYLOCALSAPNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->communicationsEntityLocalSapNamesLen;
		return (u_char *) StorageTmp->communicationsEntityLocalSapNames;
	case COMMUNICATIONSENTITYOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->communicationsEntityOperationalState);
		return (u_char *) &StorageTmp->communicationsEntityOperationalState;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sap1Table(void)
 * @brief refresh the scalar values of the sap1Table.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sap1Table(void)
{
	if (sap1Table_refresh == 0)
		return;
	sap1Table_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sap1Table_row(struct sap1Table_data *StorageTmp)
 * @brief refresh the contents of the sap1Table row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sap1Table_row(struct sap1Table_data *StorageTmp)
{
	if (StorageTmp->sap1Table_request == sa_request)
		return;
	StorageTmp->sap1Table_request = sa_request;
}

/**
 * @fn u_char *var_sap1Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sap1Table.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sap1Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sap1Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_sap1Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sap1Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sap1TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sap1Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SAP1ADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sap1Address);
		return (u_char *) &StorageTmp->sap1Address;
	case SAP1USERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sap1UserEntityNamesLen;
		return (u_char *) StorageTmp->sap1UserEntityNames;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sap2Table(void)
 * @brief refresh the scalar values of the sap2Table.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sap2Table(void)
{
	if (sap2Table_refresh == 0)
		return;
	sap2Table_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sap2Table_row(struct sap2Table_data *StorageTmp)
 * @brief refresh the contents of the sap2Table row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sap2Table_row(struct sap2Table_data *StorageTmp)
{
	if (StorageTmp->sap2Table_request == sa_request)
		return;
	StorageTmp->sap2Table_request = sa_request;
}

/**
 * @fn u_char *var_sap2Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sap2Table.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sap2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sap2Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_sap2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sap2Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sap2TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sap2Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SAP2ADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sap2AddressLen;
		return (u_char *) StorageTmp->sap2Address;
	case SAP2USERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sap2UserEntityNamesLen;
		return (u_char *) StorageTmp->sap2UserEntityNames;
	case SAP2PROVIDERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sap2ProviderEntityNamesLen;
		return (u_char *) StorageTmp->sap2ProviderEntityNames;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_clProtocolMachineTable(void)
 * @brief refresh the scalar values of the clProtocolMachineTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_clProtocolMachineTable(void)
{
	if (clProtocolMachineTable_refresh == 0)
		return;
	clProtocolMachineTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_clProtocolMachineTable_row(struct clProtocolMachineTable_data *StorageTmp)
 * @brief refresh the contents of the clProtocolMachineTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_clProtocolMachineTable_row(struct clProtocolMachineTable_data *StorageTmp)
{
	if (StorageTmp->clProtocolMachineTable_request == sa_request)
		return;
	StorageTmp->clProtocolMachineTable_request = sa_request;
}

/**
 * @fn u_char *var_clProtocolMachineTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in clProtocolMachineTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_clProtocolMachineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct clProtocolMachineTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_clProtocolMachineTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_clProtocolMachineTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(clProtocolMachineTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_clProtocolMachineTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case CLPROTOCOLMACHINEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->clProtocolMachineOperationalState);
		return (u_char *) &StorageTmp->clProtocolMachineOperationalState;
	case CLPROTOCOLMACHINETOTALREMOTESAPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->clProtocolMachineTotalRemoteSAPs);
		return (u_char *) &StorageTmp->clProtocolMachineTotalRemoteSAPs;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_coProtocolMachineTable(void)
 * @brief refresh the scalar values of the coProtocolMachineTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_coProtocolMachineTable(void)
{
	if (coProtocolMachineTable_refresh == 0)
		return;
	coProtocolMachineTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_coProtocolMachineTable_row(struct coProtocolMachineTable_data *StorageTmp)
 * @brief refresh the contents of the coProtocolMachineTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_coProtocolMachineTable_row(struct coProtocolMachineTable_data *StorageTmp)
{
	if (StorageTmp->coProtocolMachineTable_request == sa_request)
		return;
	StorageTmp->coProtocolMachineTable_request = sa_request;
}

/**
 * @fn u_char *var_coProtocolMachineTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in coProtocolMachineTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_coProtocolMachineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct coProtocolMachineTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_coProtocolMachineTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_coProtocolMachineTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(coProtocolMachineTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_coProtocolMachineTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case COPROTOCOLMACHINEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->coProtocolMachineOperationalState);
		return (u_char *) &StorageTmp->coProtocolMachineOperationalState;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_singlePeerConnectionTable(void)
 * @brief refresh the scalar values of the singlePeerConnectionTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_singlePeerConnectionTable(void)
{
	if (singlePeerConnectionTable_refresh == 0)
		return;
	singlePeerConnectionTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_singlePeerConnectionTable_row(struct singlePeerConnectionTable_data *StorageTmp)
 * @brief refresh the contents of the singlePeerConnectionTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_singlePeerConnectionTable_row(struct singlePeerConnectionTable_data *StorageTmp)
{
	if (StorageTmp->singlePeerConnectionTable_request == sa_request)
		return;
	StorageTmp->singlePeerConnectionTable_request = sa_request;
}

/**
 * @fn u_char *var_singlePeerConnectionTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in singlePeerConnectionTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_singlePeerConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct singlePeerConnectionTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_singlePeerConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_singlePeerConnectionTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(singlePeerConnectionTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_singlePeerConnectionTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case UNDERLYINGCONNECTIONNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->underlyingConnectionNamesLen;
		return (u_char *) StorageTmp->underlyingConnectionNames;
	case SUPPPORTEDCONNECTIONNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->suppportedConnectionNamesLen;
		return (u_char *) StorageTmp->suppportedConnectionNames;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_physicalEntityTable(void)
 * @brief refresh the scalar values of the physicalEntityTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_physicalEntityTable(void)
{
	if (physicalEntityTable_refresh == 0)
		return;
	physicalEntityTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_physicalEntityTable_row(struct physicalEntityTable_data *StorageTmp)
 * @brief refresh the contents of the physicalEntityTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_physicalEntityTable_row(struct physicalEntityTable_data *StorageTmp)
{
	if (StorageTmp->physicalEntityTable_request == sa_request)
		return;
	StorageTmp->physicalEntityTable_request = sa_request;
}

/**
 * @fn u_char *var_physicalEntityTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in physicalEntityTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_physicalEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct physicalEntityTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_physicalEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_physicalEntityTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(physicalEntityTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_physicalEntityTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case PHYSICALENTITYPHYSICALENTITYTITLES:
		*write_method = write_physicalEntityPhysicalEntityTitles;
		*var_len = StorageTmp->physicalEntityPhysicalEntityTitlesLen;
		return (u_char *) StorageTmp->physicalEntityPhysicalEntityTitles;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_physicalSAPTable(void)
 * @brief refresh the scalar values of the physicalSAPTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_physicalSAPTable(void)
{
	if (physicalSAPTable_refresh == 0)
		return;
	physicalSAPTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_physicalSAPTable_row(struct physicalSAPTable_data *StorageTmp)
 * @brief refresh the contents of the physicalSAPTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_physicalSAPTable_row(struct physicalSAPTable_data *StorageTmp)
{
	if (StorageTmp->physicalSAPTable_request == sa_request)
		return;
	StorageTmp->physicalSAPTable_request = sa_request;
}

/**
 * @fn u_char *var_physicalSAPTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in physicalSAPTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_physicalSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct physicalSAPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_physicalSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_physicalSAPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(physicalSAPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_physicalSAPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_dataCircuitTable(void)
 * @brief refresh the scalar values of the dataCircuitTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dataCircuitTable(void)
{
	if (dataCircuitTable_refresh == 0)
		return;
	dataCircuitTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_dataCircuitTable_row(struct dataCircuitTable_data *StorageTmp)
 * @brief refresh the contents of the dataCircuitTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_dataCircuitTable_row(struct dataCircuitTable_data *StorageTmp)
{
	if (StorageTmp->dataCircuitTable_request == sa_request)
		return;
	StorageTmp->dataCircuitTable_request = sa_request;
}

/**
 * @fn u_char *var_dataCircuitTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dataCircuitTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_dataCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dataCircuitTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_dataCircuitTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_dataCircuitTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(dataCircuitTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_dataCircuitTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DATACIRCUITBITERRORSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->dataCircuitBitErrorsReceived);
		return (u_char *) &StorageTmp->dataCircuitBitErrorsReceived;
	case DATACIRCUITBITERRORSTRANSMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->dataCircuitBitErrorsTransmitted);
		return (u_char *) &StorageTmp->dataCircuitBitErrorsTransmitted;
	case DATACIRCUITBITERRORSTHRESHOLD:
		*write_method = write_dataCircuitBitErrorsThreshold;
		*var_len = StorageTmp->dataCircuitBitErrorsThresholdLen;
		return (u_char *) StorageTmp->dataCircuitBitErrorsThreshold;
	case DATACIRCUITTYPE:
		*write_method = write_dataCircuitType;
		*var_len = sizeof(StorageTmp->dataCircuitType);
		return (u_char *) &StorageTmp->dataCircuitType;
	case DATACIRCUITPHYSICALMEDIANAMES:
		*write_method = write_dataCircuitPhysicalMediaNames;
		*var_len = StorageTmp->dataCircuitPhysicalMediaNamesLen;
		return (u_char *) StorageTmp->dataCircuitPhysicalMediaNames;
	case DATACIRCUITPHYSICALINTERFACETYPE:
		*write_method = write_dataCircuitPhysicalInterfaceType;
		*var_len = StorageTmp->dataCircuitPhysicalInterfaceTypeLen;
		return (u_char *) StorageTmp->dataCircuitPhysicalInterfaceType;
	case DATACIRCUITPHYSICALINTERFACESTANDARD:
		*write_method = write_dataCircuitPhysicalInterfaceStandard;
		*var_len = StorageTmp->dataCircuitPhysicalInterfaceStandardLen;
		return (u_char *) StorageTmp->dataCircuitPhysicalInterfaceStandard;
	case DATACIRCUITSYNCHRONIZATIONMODE:
		*write_method = write_dataCircuitSynchronizationMode;
		*var_len = sizeof(StorageTmp->dataCircuitSynchronizationMode);
		return (u_char *) &StorageTmp->dataCircuitSynchronizationMode;
	case DATACIRCUITTRANSMISSIONCODING:
		*write_method = write_dataCircuitTransmissionCoding;
		*var_len = StorageTmp->dataCircuitTransmissionCodingLen;
		return (u_char *) StorageTmp->dataCircuitTransmissionCoding;
	case DATACIRCUITTRANSMISSIONMODE:
		*write_method = write_dataCircuitTransmissionMode;
		*var_len = sizeof(StorageTmp->dataCircuitTransmissionMode);
		return (u_char *) &StorageTmp->dataCircuitTransmissionMode;
	case DATACIRCUITTRANSMISSIONRATE:
		*write_method = write_dataCircuitTransmissionRate;
		*var_len = StorageTmp->dataCircuitTransmissionRateLen;
		return (u_char *) StorageTmp->dataCircuitTransmissionRate;
	case DATACIRCUITROWSTATUS:
		*write_method = write_dataCircuitRowStatus;
		*var_len = sizeof(StorageTmp->dataCircuitRowStatus);
		return (u_char *) &StorageTmp->dataCircuitRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_physicalConnectionTable(void)
 * @brief refresh the scalar values of the physicalConnectionTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_physicalConnectionTable(void)
{
	if (physicalConnectionTable_refresh == 0)
		return;
	physicalConnectionTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_physicalConnectionTable_row(struct physicalConnectionTable_data *StorageTmp)
 * @brief refresh the contents of the physicalConnectionTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_physicalConnectionTable_row(struct physicalConnectionTable_data *StorageTmp)
{
	if (StorageTmp->physicalConnectionTable_request == sa_request)
		return;
	StorageTmp->physicalConnectionTable_request = sa_request;
}

/**
 * @fn u_char *var_physicalConnectionTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in physicalConnectionTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_physicalConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct physicalConnectionTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_physicalConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_physicalConnectionTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(physicalConnectionTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_physicalConnectionTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case PHYSICALCONNECTIONENDPOINTIDENTIFIER:
		*write_method = write_physicalConnectionEndpointIdentifier;
		*var_len = StorageTmp->physicalConnectionEndpointIdentifierLen;
		return (u_char *) StorageTmp->physicalConnectionEndpointIdentifier;
	case PHYSICALCONNECTIONPORTNUMBER:
		*write_method = write_physicalConnectionPortNumber;
		*var_len = sizeof(StorageTmp->physicalConnectionPortNumber);
		return (u_char *) &StorageTmp->physicalConnectionPortNumber;
	case PHYSICALCONNECTIONROWSTATUS:
		*write_method = write_physicalConnectionRowStatus;
		*var_len = sizeof(StorageTmp->physicalConnectionRowStatus);
		return (u_char *) &StorageTmp->physicalConnectionRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_datalinkEntityTable(void)
 * @brief refresh the scalar values of the datalinkEntityTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_datalinkEntityTable(void)
{
	if (datalinkEntityTable_refresh == 0)
		return;
	datalinkEntityTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_datalinkEntityTable_row(struct datalinkEntityTable_data *StorageTmp)
 * @brief refresh the contents of the datalinkEntityTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_datalinkEntityTable_row(struct datalinkEntityTable_data *StorageTmp)
{
	if (StorageTmp->datalinkEntityTable_request == sa_request)
		return;
	StorageTmp->datalinkEntityTable_request = sa_request;
}

/**
 * @fn u_char *var_datalinkEntityTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in datalinkEntityTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_datalinkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct datalinkEntityTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_datalinkEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_datalinkEntityTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(datalinkEntityTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_datalinkEntityTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DATALINKENTITYPROVIDERENTITYNAMES:
		*write_method = write_datalinkEntityProviderEntityNames;
		*var_len = StorageTmp->datalinkEntityProviderEntityNamesLen;
		return (u_char *) StorageTmp->datalinkEntityProviderEntityNames;
	case DATALINKENTITYROWSTATUS:
		*write_method = write_datalinkEntityRowStatus;
		*var_len = sizeof(StorageTmp->datalinkEntityRowStatus);
		return (u_char *) &StorageTmp->datalinkEntityRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_dLSAPTable(void)
 * @brief refresh the scalar values of the dLSAPTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dLSAPTable(void)
{
	if (dLSAPTable_refresh == 0)
		return;
	dLSAPTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_dLSAPTable_row(struct dLSAPTable_data *StorageTmp)
 * @brief refresh the contents of the dLSAPTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_dLSAPTable_row(struct dLSAPTable_data *StorageTmp)
{
	if (StorageTmp->dLSAPTable_request == sa_request)
		return;
	StorageTmp->dLSAPTable_request = sa_request;
}

/**
 * @fn u_char *var_dLSAPTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dLSAPTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_dLSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dLSAPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_dLSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_dLSAPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(dLSAPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_dLSAPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DLSAPROWSTATUS:
		*write_method = write_dLSAPRowStatus;
		*var_len = sizeof(StorageTmp->dLSAPRowStatus);
		return (u_char *) &StorageTmp->dLSAPRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_lAPBDLETable(void)
 * @brief refresh the scalar values of the lAPBDLETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lAPBDLETable(void)
{
	if (lAPBDLETable_refresh == 0)
		return;
	lAPBDLETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_lAPBDLETable_row(struct lAPBDLETable_data *StorageTmp)
 * @brief refresh the contents of the lAPBDLETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lAPBDLETable_row(struct lAPBDLETable_data *StorageTmp)
{
	if (StorageTmp->lAPBDLETable_request == sa_request)
		return;
	StorageTmp->lAPBDLETable_request = sa_request;
}

/**
 * @fn u_char *var_lAPBDLETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lAPBDLETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lAPBDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lAPBDLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lAPBDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lAPBDLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lAPBDLETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lAPBDLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LAPBDLEMT1TIMER:
		*write_method = write_lAPBDLEmT1Timer;
		*var_len = sizeof(StorageTmp->lAPBDLEmT1Timer);
		return (u_char *) &StorageTmp->lAPBDLEmT1Timer;
	case LAPBDLEMT3TIMER:
		*write_method = write_lAPBDLEmT3Timer;
		*var_len = sizeof(StorageTmp->lAPBDLEmT3Timer);
		return (u_char *) &StorageTmp->lAPBDLEmT3Timer;
	case LAPBDLEMW:
		*write_method = write_lAPBDLEmW;
		*var_len = sizeof(StorageTmp->lAPBDLEmW);
		return (u_char *) &StorageTmp->lAPBDLEmW;
	case LAPBDLEMXSEND:
		*write_method = write_lAPBDLEmXSend;
		*var_len = sizeof(StorageTmp->lAPBDLEmXSend);
		return (u_char *) &StorageTmp->lAPBDLEmXSend;
	case LAPBDLEMXRECEIVE:
		*write_method = write_lAPBDLEmXReceive;
		*var_len = sizeof(StorageTmp->lAPBDLEmXReceive);
		return (u_char *) &StorageTmp->lAPBDLEmXReceive;
	case LAPBDLEMT2TIMER:
		*write_method = write_lAPBDLEmT2Timer;
		*var_len = sizeof(StorageTmp->lAPBDLEmT2Timer);
		return (u_char *) &StorageTmp->lAPBDLEmT2Timer;
	case LAPBDLERECEIVEDMLPRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEreceivedMlpResets);
		return (u_char *) &StorageTmp->lAPBDLEreceivedMlpResets;
	case LAPBDLETIMESMT1EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEtimesMT1Expired);
		return (u_char *) &StorageTmp->lAPBDLEtimesMT1Expired;
	case LAPBDLEIFRAMESREASSIGNMENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEIframesReassignments);
		return (u_char *) &StorageTmp->lAPBDLEIframesReassignments;
	case LAPBDLEMLPFRAMESRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesReceived);
		return (u_char *) &StorageTmp->lAPBDLEmlpFramesReceived;
	case LAPBDLEMLPFRAMESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesSent);
		return (u_char *) &StorageTmp->lAPBDLEmlpFramesSent;
	case LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard);
		return (u_char *) &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard;
	case LAPBDLERECEIVEDMLPFRAMESINGUARDREGION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion);
		return (u_char *) &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion;
	case LAPBDLEROWSTATUS:
		*write_method = write_lAPBDLERowStatus;
		*var_len = sizeof(StorageTmp->lAPBDLERowStatus);
		return (u_char *) &StorageTmp->lAPBDLERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sLPPMTable(void)
 * @brief refresh the scalar values of the sLPPMTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sLPPMTable(void)
{
	if (sLPPMTable_refresh == 0)
		return;
	sLPPMTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sLPPMTable_row(struct sLPPMTable_data *StorageTmp)
 * @brief refresh the contents of the sLPPMTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sLPPMTable_row(struct sLPPMTable_data *StorageTmp)
{
	if (StorageTmp->sLPPMTable_request == sa_request)
		return;
	StorageTmp->sLPPMTable_request = sa_request;
}

/**
 * @fn u_char *var_sLPPMTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sLPPMTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sLPPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sLPPMTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_sLPPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sLPPMTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sLPPMTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sLPPMTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SLPPMADMINISTRATIVESTATE:
		*write_method = write_sLPPMadministrativeState;
		*var_len = sizeof(StorageTmp->sLPPMadministrativeState);
		return (u_char *) &StorageTmp->sLPPMadministrativeState;
	case SLPPMROWSTATUS:
		*write_method = write_sLPPMRowStatus;
		*var_len = sizeof(StorageTmp->sLPPMRowStatus);
		return (u_char *) &StorageTmp->sLPPMRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sLPConnectionTable(void)
 * @brief refresh the scalar values of the sLPConnectionTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sLPConnectionTable(void)
{
	if (sLPConnectionTable_refresh == 0)
		return;
	sLPConnectionTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sLPConnectionTable_row(struct sLPConnectionTable_data *StorageTmp)
 * @brief refresh the contents of the sLPConnectionTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sLPConnectionTable_row(struct sLPConnectionTable_data *StorageTmp)
{
	if (StorageTmp->sLPConnectionTable_request == sa_request)
		return;
	StorageTmp->sLPConnectionTable_request = sa_request;
}

/**
 * @fn u_char *var_sLPConnectionTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sLPConnectionTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sLPConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sLPConnectionTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_sLPConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sLPConnectionTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sLPConnectionTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SLPCONNECTIONINTERFACETYPE:
		*write_method = write_sLPConnectionInterfaceType;
		*var_len = sizeof(StorageTmp->sLPConnectionInterfaceType);
		return (u_char *) &StorageTmp->sLPConnectionInterfaceType;
	case SLPCONNECTIONK:
		*write_method = write_sLPConnectionK;
		*var_len = sizeof(StorageTmp->sLPConnectionK);
		return (u_char *) &StorageTmp->sLPConnectionK;
	case SLPCONNECTIONN1:
		*write_method = write_sLPConnectionN1;
		*var_len = sizeof(StorageTmp->sLPConnectionN1);
		return (u_char *) &StorageTmp->sLPConnectionN1;
	case SLPCONNECTIONN2:
		*write_method = write_sLPConnectionN2;
		*var_len = sizeof(StorageTmp->sLPConnectionN2);
		return (u_char *) &StorageTmp->sLPConnectionN2;
	case SLPCONNECTIONSEQUENCEMODULUS:
		*write_method = write_sLPConnectionSequenceModulus;
		*var_len = sizeof(StorageTmp->sLPConnectionSequenceModulus);
		return (u_char *) &StorageTmp->sLPConnectionSequenceModulus;
	case SLPCONNECTIONT1TIMER:
		*write_method = write_sLPConnectionT1Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT1Timer);
		return (u_char *) &StorageTmp->sLPConnectionT1Timer;
	case SLPCONNECTIONT2TIMER:
		*write_method = write_sLPConnectionT2Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT2Timer);
		return (u_char *) &StorageTmp->sLPConnectionT2Timer;
	case SLPCONNECTIONFCSERRORSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionFCSErrorsReceived);
		return (u_char *) &StorageTmp->sLPConnectionFCSErrorsReceived;
	case SLPCONNECTIONFRMRSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionFRMRsReceived);
		return (u_char *) &StorageTmp->sLPConnectionFRMRsReceived;
	case SLPCONNECTIONFRMRSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionFRMRsSent);
		return (u_char *) &StorageTmp->sLPConnectionFRMRsSent;
	case SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFrameDataOctetsReceived);
		return (u_char *) &StorageTmp->sLPConnectionIFrameDataOctetsReceived;
	case SLPCONNECTIONIFRAMEDATAOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFrameDataOctetsSent);
		return (u_char *) &StorageTmp->sLPConnectionIFrameDataOctetsSent;
	case SLPCONNECTIONIFRAMESRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFramesReceived);
		return (u_char *) &StorageTmp->sLPConnectionIFramesReceived;
	case SLPCONNECTIONIFRAMESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFramesSent);
		return (u_char *) &StorageTmp->sLPConnectionIFramesSent;
	case SLPCONNECTIONPOLLSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionPollsReceived);
		return (u_char *) &StorageTmp->sLPConnectionPollsReceived;
	case SLPCONNECTIONREJSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionREJsReceived);
		return (u_char *) &StorageTmp->sLPConnectionREJsReceived;
	case SLPCONNECTIONREJSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionREJsSent);
		return (u_char *) &StorageTmp->sLPConnectionREJsSent;
	case SLPCONNECTIONRNRSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionRNRsReceived);
		return (u_char *) &StorageTmp->sLPConnectionRNRsReceived;
	case SLPCONNECTIONRNRSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionRNRsSent);
		return (u_char *) &StorageTmp->sLPConnectionRNRsSent;
	case SLPCONNECTIONSABMSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionSABMsReceived);
		return (u_char *) &StorageTmp->sLPConnectionSABMsReceived;
	case SLPCONNECTIONSABMSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionSABMsSent);
		return (u_char *) &StorageTmp->sLPConnectionSABMsSent;
	case SLPCONNECTIONPROTOCOLSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionProtocolState);
		return (u_char *) &StorageTmp->sLPConnectionProtocolState;
	case SLPCONNECTIONTIMEST1EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT1Expired);
		return (u_char *) &StorageTmp->sLPConnectionTimesT1Expired;
	case SLPCONNECTIONT3TIMER:
		*write_method = write_sLPConnectionT3Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT3Timer);
		return (u_char *) &StorageTmp->sLPConnectionT3Timer;
	case SLPCONNECTIONTIMEST3EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT3Expired);
		return (u_char *) &StorageTmp->sLPConnectionTimesT3Expired;
	case SLPCONNECTIONT4TIMER:
		*write_method = write_sLPConnectionT4Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT4Timer);
		return (u_char *) &StorageTmp->sLPConnectionT4Timer;
	case SLPCONNECTIONTIMEST4EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT4Expired);
		return (u_char *) &StorageTmp->sLPConnectionTimesT4Expired;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived);
		return (u_char *) &StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent);
		return (u_char *) &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent;
	case SLPCONNECTIONLINKRESETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionLinkResetsReceived);
		return (u_char *) &StorageTmp->sLPConnectionLinkResetsReceived;
	case SLPCONNECTIONLINKRESETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionLinkResetsSent);
		return (u_char *) &StorageTmp->sLPConnectionLinkResetsSent;
	case SLPCONNECTIONTIMESN2REACHED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesN2Reached);
		return (u_char *) &StorageTmp->sLPConnectionTimesN2Reached;
	case SLPCONNECTIONADMINISTRATIVESTATE:
		*write_method = write_sLPConnectionAdministrativeState;
		*var_len = sizeof(StorageTmp->sLPConnectionAdministrativeState);
		return (u_char *) &StorageTmp->sLPConnectionAdministrativeState;
	case SLPCONNECTIONOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionOperationalState);
		return (u_char *) &StorageTmp->sLPConnectionOperationalState;
	case SLPCONNECTIONUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionUsageState);
		return (u_char *) &StorageTmp->sLPConnectionUsageState;
	case SLPCONNECTIONPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sLPConnectionProceduralStatusLen;
		return (u_char *) StorageTmp->sLPConnectionProceduralStatus;
	case SLPCONNECTIONALARMSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sLPConnectionAlarmStatusLen;
		return (u_char *) StorageTmp->sLPConnectionAlarmStatus;
	case SLPCONNECTIONROWSTATUS:
		*write_method = write_sLPConnectionRowStatus;
		*var_len = sizeof(StorageTmp->sLPConnectionRowStatus);
		return (u_char *) &StorageTmp->sLPConnectionRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sLPConnectionIVMOTable(void)
 * @brief refresh the scalar values of the sLPConnectionIVMOTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sLPConnectionIVMOTable(void)
{
	if (sLPConnectionIVMOTable_refresh == 0)
		return;
	sLPConnectionIVMOTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sLPConnectionIVMOTable_row(struct sLPConnectionIVMOTable_data *StorageTmp)
 * @brief refresh the contents of the sLPConnectionIVMOTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sLPConnectionIVMOTable_row(struct sLPConnectionIVMOTable_data *StorageTmp)
{
	if (StorageTmp->sLPConnectionIVMOTable_request == sa_request)
		return;
	StorageTmp->sLPConnectionIVMOTable_request = sa_request;
}

/**
 * @fn u_char *var_sLPConnectionIVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sLPConnectionIVMOTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sLPConnectionIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_sLPConnectionIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sLPConnectionIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sLPConnectionIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SLPCONNECTIONIVMOID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sLPConnectionIVMOidLen;
		return (u_char *) StorageTmp->sLPConnectionIVMOid;
	case SLPCONNECTIONIVMOINTERFACETYPE:
		*write_method = write_sLPConnectionIVMOinterfaceType;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOinterfaceType);
		return (u_char *) &StorageTmp->sLPConnectionIVMOinterfaceType;
	case SLPCONNECTIONIVMOK:
		*write_method = write_sLPConnectionIVMOk;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOk);
		return (u_char *) &StorageTmp->sLPConnectionIVMOk;
	case SLPCONNECTIONIVMON1:
		*write_method = write_sLPConnectionIVMOn1;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOn1);
		return (u_char *) &StorageTmp->sLPConnectionIVMOn1;
	case SLPCONNECTIONIVMON2:
		*write_method = write_sLPConnectionIVMOn2;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOn2);
		return (u_char *) &StorageTmp->sLPConnectionIVMOn2;
	case SLPCONNECTIONIVMOSEQUENCEMODULUS:
		*write_method = write_sLPConnectionIVMOsequenceModulus;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOsequenceModulus);
		return (u_char *) &StorageTmp->sLPConnectionIVMOsequenceModulus;
	case SLPCONNECTIONIVMOT1TIMER:
		*write_method = write_sLPConnectionIVMOt1Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt1Timer);
		return (u_char *) &StorageTmp->sLPConnectionIVMOt1Timer;
	case SLPCONNECTIONIVMOT2TIMER:
		*write_method = write_sLPConnectionIVMOt2Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt2Timer);
		return (u_char *) &StorageTmp->sLPConnectionIVMOt2Timer;
	case SLPCONNECTIONIVMOT3TIMER:
		*write_method = write_sLPConnectionIVMOt3Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt3Timer);
		return (u_char *) &StorageTmp->sLPConnectionIVMOt3Timer;
	case SLPCONNECTIONIVMOT4TIMER:
		*write_method = write_sLPConnectionIVMOt4Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt4Timer);
		return (u_char *) &StorageTmp->sLPConnectionIVMOt4Timer;
	case SLPCONNECTIONIVMOROWSTATUS:
		*write_method = write_sLPConnectionIVMORowStatus;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMORowStatus);
		return (u_char *) &StorageTmp->sLPConnectionIVMORowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mACDLETable(void)
 * @brief refresh the scalar values of the mACDLETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mACDLETable(void)
{
	if (mACDLETable_refresh == 0)
		return;
	mACDLETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mACDLETable_row(struct mACDLETable_data *StorageTmp)
 * @brief refresh the contents of the mACDLETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mACDLETable_row(struct mACDLETable_data *StorageTmp)
{
	if (StorageTmp->mACDLETable_request == sa_request)
		return;
	StorageTmp->mACDLETable_request = sa_request;
}

/**
 * @fn u_char *var_mACDLETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mACDLETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_mACDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mACDLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_mACDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mACDLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mACDLETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mACDLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MACDLEROWSTATUS:
		*write_method = write_mACDLERowStatus;
		*var_len = sizeof(StorageTmp->mACDLERowStatus);
		return (u_char *) &StorageTmp->mACDLERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_mACTable(void)
 * @brief refresh the scalar values of the mACTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mACTable(void)
{
	if (mACTable_refresh == 0)
		return;
	mACTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_mACTable_row(struct mACTable_data *StorageTmp)
 * @brief refresh the contents of the mACTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mACTable_row(struct mACTable_data *StorageTmp)
{
	if (StorageTmp->mACTable_request == sa_request)
		return;
	StorageTmp->mACTable_request = sa_request;
}

/**
 * @fn u_char *var_mACTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mACTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_mACTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mACTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_mACTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mACTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mACTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mACTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MACOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mACOperationalState);
		return (u_char *) &StorageTmp->mACOperationalState;
	case MACROWSTATUS:
		*write_method = write_mACRowStatus;
		*var_len = sizeof(StorageTmp->mACRowStatus);
		return (u_char *) &StorageTmp->mACRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_lLCDLETable(void)
 * @brief refresh the scalar values of the lLCDLETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCDLETable(void)
{
	if (lLCDLETable_refresh == 0)
		return;
	lLCDLETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_lLCDLETable_row(struct lLCDLETable_data *StorageTmp)
 * @brief refresh the contents of the lLCDLETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCDLETable_row(struct lLCDLETable_data *StorageTmp)
{
	if (StorageTmp->lLCDLETable_request == sa_request)
		return;
	StorageTmp->lLCDLETable_request = sa_request;
}

/**
 * @fn u_char *var_lLCDLETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCDLETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCDLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCDLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCDLETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCDLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCDLEROWSTATUS:
		*write_method = write_lLCDLERowStatus;
		*var_len = sizeof(StorageTmp->lLCDLERowStatus);
		return (u_char *) &StorageTmp->lLCDLERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_lLCCLPMTable(void)
 * @brief refresh the scalar values of the lLCCLPMTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCCLPMTable(void)
{
	if (lLCCLPMTable_refresh == 0)
		return;
	lLCCLPMTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_lLCCLPMTable_row(struct lLCCLPMTable_data *StorageTmp)
 * @brief refresh the contents of the lLCCLPMTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCCLPMTable_row(struct lLCCLPMTable_data *StorageTmp)
{
	if (StorageTmp->lLCCLPMTable_request == sa_request)
		return;
	StorageTmp->lLCCLPMTable_request = sa_request;
}

/**
 * @fn u_char *var_lLCCLPMTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCCLPMTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCCLPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCCLPMTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCCLPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCCLPMTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCCLPMTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCCLPMTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCLPMROWSTATUS:
		*write_method = write_lLCCLPMRowStatus;
		*var_len = sizeof(StorageTmp->lLCCLPMRowStatus);
		return (u_char *) &StorageTmp->lLCCLPMRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_lLCCOPMTable(void)
 * @brief refresh the scalar values of the lLCCOPMTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCCOPMTable(void)
{
	if (lLCCOPMTable_refresh == 0)
		return;
	lLCCOPMTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_lLCCOPMTable_row(struct lLCCOPMTable_data *StorageTmp)
 * @brief refresh the contents of the lLCCOPMTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCCOPMTable_row(struct lLCCOPMTable_data *StorageTmp)
{
	if (StorageTmp->lLCCOPMTable_request == sa_request)
		return;
	StorageTmp->lLCCOPMTable_request = sa_request;
}

/**
 * @fn u_char *var_lLCCOPMTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCCOPMTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCCOPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCCOPMTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCCOPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCCOPMTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCCOPMTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCCOPMTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCOPMROWSTATUS:
		*write_method = write_lLCCOPMRowStatus;
		*var_len = sizeof(StorageTmp->lLCCOPMRowStatus);
		return (u_char *) &StorageTmp->lLCCOPMRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_resourceTypeIdTable(void)
 * @brief refresh the scalar values of the resourceTypeIdTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_resourceTypeIdTable(void)
{
	if (resourceTypeIdTable_refresh == 0)
		return;
	resourceTypeIdTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_resourceTypeIdTable_row(struct resourceTypeIdTable_data *StorageTmp)
 * @brief refresh the contents of the resourceTypeIdTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_resourceTypeIdTable_row(struct resourceTypeIdTable_data *StorageTmp)
{
	if (StorageTmp->resourceTypeIdTable_request == sa_request)
		return;
	StorageTmp->resourceTypeIdTable_request = sa_request;
}

/**
 * @fn u_char *var_resourceTypeIdTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in resourceTypeIdTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_resourceTypeIdTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct resourceTypeIdTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_resourceTypeIdTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_resourceTypeIdTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(resourceTypeIdTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_resourceTypeIdTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case RESOURCETYPEIDNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceTypeIdNameLen;
		return (u_char *) StorageTmp->resourceTypeIdName;
	case RESOURCEINFOMANUFACTUREROUI:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerOUILen;
		return (u_char *) StorageTmp->resourceInfoManufacturerOUI;
	case RESOURCEINFOMANUFACTURERNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerNameLen;
		return (u_char *) StorageTmp->resourceInfoManufacturerName;
	case RESOURCEINFOMANUFACTURERPRODUCTNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerProductNameLen;
		return (u_char *) StorageTmp->resourceInfoManufacturerProductName;
	case RESOURCEINFOMANUFACTURERPRODUCTVERSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerProductVersionLen;
		return (u_char *) StorageTmp->resourceInfoManufacturerProductVersion;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_lLCStationTable(void)
 * @brief refresh the scalar values of the lLCStationTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCStationTable(void)
{
	if (lLCStationTable_refresh == 0)
		return;
	lLCStationTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_lLCStationTable_row(struct lLCStationTable_data *StorageTmp)
 * @brief refresh the contents of the lLCStationTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCStationTable_row(struct lLCStationTable_data *StorageTmp)
{
	if (StorageTmp->lLCStationTable_request == sa_request)
		return;
	StorageTmp->lLCStationTable_request = sa_request;
}

/**
 * @fn u_char *var_lLCStationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCStationTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCStationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCStationTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCStationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCStationTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCStationTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCStationTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCSTATIONLLCNAME:
		*write_method = write_lLCStationLLCName;
		*var_len = StorageTmp->lLCStationLLCNameLen;
		return (u_char *) StorageTmp->lLCStationLLCName;
	case LLCSTATIONMAXIMUMLSAPSCONFIGURED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationMaximumLSAPsConfigured);
		return (u_char *) &StorageTmp->lLCStationMaximumLSAPsConfigured;
	case LLCSTATIONNUMBEROFACTIVELSAPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationNumberOfActiveLSAPs);
		return (u_char *) &StorageTmp->lLCStationNumberOfActiveLSAPs;
	case LLCSTATIONSUPPORTEDSERVICESTYPES:
		*write_method = write_lLCStationSupportedServicesTypes;
		*var_len = StorageTmp->lLCStationSupportedServicesTypesLen;
		return (u_char *) StorageTmp->lLCStationSupportedServicesTypes;
	case LLCSTATIONSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationStatus);
		return (u_char *) &StorageTmp->lLCStationStatus;
	case LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType1AcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCStationType1AcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCStationType1AcknowledgeTimeoutValue;
	case LLCSTATIONTYPE1MAXIMUMRETRYCOUNT:
		*write_method = write_lLCStationType1MaximumRetryCount;
		*var_len = sizeof(StorageTmp->lLCStationType1MaximumRetryCount);
		return (u_char *) &StorageTmp->lLCStationType1MaximumRetryCount;
	case LLCSTATIONMAXIMUMPDUN3:
		*write_method = write_lLCStationMaximumPDUN3;
		*var_len = sizeof(StorageTmp->lLCStationMaximumPDUN3);
		return (u_char *) &StorageTmp->lLCStationMaximumPDUN3;
	case LLCSTATIONMAXIMUMRETRANSMISSIONS4:
		*write_method = write_lLCStationMaximumRetransmissions4;
		*var_len = sizeof(StorageTmp->lLCStationMaximumRetransmissions4);
		return (u_char *) &StorageTmp->lLCStationMaximumRetransmissions4;
	case LLCSTATIONRECEIVEVARIABLELIFETIME:
		*write_method = write_lLCStationReceiveVariableLifetime;
		*var_len = sizeof(StorageTmp->lLCStationReceiveVariableLifetime);
		return (u_char *) &StorageTmp->lLCStationReceiveVariableLifetime;
	case LLCSTATIONTRANSMITVARIABLELIFETIME:
		*write_method = write_lLCStationTransmitVariableLifetime;
		*var_len = sizeof(StorageTmp->lLCStationTransmitVariableLifetime);
		return (u_char *) &StorageTmp->lLCStationTransmitVariableLifetime;
	case LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType3AcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCStationType3AcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCStationType3AcknowledgeTimeoutValue;
	case LLCSTATIONTYPE3RETRANSMISSIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationType3Retransmissions);
		return (u_char *) &StorageTmp->lLCStationType3Retransmissions;
	case LLCSTATIONAVGBUFFERUSESIZE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationAvgBufferUseSize);
		return (u_char *) &StorageTmp->lLCStationAvgBufferUseSize;
	case LLCSTATIONBUFFERPROBLEMS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationBufferProblems);
		return (u_char *) &StorageTmp->lLCStationBufferProblems;
	case LLCSTATIONBUFFERSIZE:
		*write_method = write_lLCStationBufferSize;
		*var_len = sizeof(StorageTmp->lLCStationBufferSize);
		return (u_char *) &StorageTmp->lLCStationBufferSize;
	case LLCSTATIONMAXBUFFERUSESIZE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationMaxBufferUseSize);
		return (u_char *) &StorageTmp->lLCStationMaxBufferUseSize;
	case LLCSTATIONINACTIVELSAP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationInactiveLSAP);
		return (u_char *) &StorageTmp->lLCStationInactiveLSAP;
	case LLCSTATIONPDUSDISCARD:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationPDUsDiscard);
		return (u_char *) &StorageTmp->lLCStationPDUsDiscard;
	case LLCSTATIONSTRINDICATOR:
		*write_method = write_lLCStationSTRIndicator;
		*var_len = StorageTmp->lLCStationSTRIndicatorLen;
		return (u_char *) StorageTmp->lLCStationSTRIndicator;
	case LLCSTATIONVERSIONNUMBER:
		*write_method = write_lLCStationVersionNumber;
		*var_len = sizeof(StorageTmp->lLCStationVersionNumber);
		return (u_char *) &StorageTmp->lLCStationVersionNumber;
	case LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts);
		return (u_char *) &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_lLCSAPTable(void)
 * @brief refresh the scalar values of the lLCSAPTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCSAPTable(void)
{
	if (lLCSAPTable_refresh == 0)
		return;
	lLCSAPTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_lLCSAPTable_row(struct lLCSAPTable_data *StorageTmp)
 * @brief refresh the contents of the lLCSAPTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCSAPTable_row(struct lLCSAPTable_data *StorageTmp)
{
	if (StorageTmp->lLCSAPTable_request == sa_request)
		return;
	StorageTmp->lLCSAPTable_request = sa_request;
}

/**
 * @fn u_char *var_lLCSAPTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCSAPTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCSAPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCSAPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCSAPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCSAPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCSAPADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->lLCSAPAddressLen;
		return (u_char *) StorageTmp->lLCSAPAddress;
	case LLCSAPRDE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCSAPRDE);
		return (u_char *) &StorageTmp->lLCSAPRDE;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_rDESetupTable(void)
 * @brief refresh the scalar values of the rDESetupTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_rDESetupTable(void)
{
	if (rDESetupTable_refresh == 0)
		return;
	rDESetupTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_rDESetupTable_row(struct rDESetupTable_data *StorageTmp)
 * @brief refresh the contents of the rDESetupTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_rDESetupTable_row(struct rDESetupTable_data *StorageTmp)
{
	if (StorageTmp->rDESetupTable_request == sa_request)
		return;
	StorageTmp->rDESetupTable_request = sa_request;
}

/**
 * @fn u_char *var_rDESetupTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in rDESetupTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_rDESetupTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct rDESetupTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_rDESetupTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_rDESetupTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(rDESetupTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_rDESetupTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case RDESETUPAGINGENABLED:
		*write_method = write_rDESetupAgingEnabled;
		*var_len = sizeof(StorageTmp->rDESetupAgingEnabled);
		return (u_char *) &StorageTmp->rDESetupAgingEnabled;
	case RDESETUPAGINGVALUE:
		*write_method = write_rDESetupAgingValue;
		*var_len = sizeof(StorageTmp->rDESetupAgingValue);
		return (u_char *) &StorageTmp->rDESetupAgingValue;
	case RDESETUPENABLETYPE2RESET:
		*write_method = write_rDESetupEnableType2Reset;
		*var_len = sizeof(StorageTmp->rDESetupEnableType2Reset);
		return (u_char *) &StorageTmp->rDESetupEnableType2Reset;
	case RDESETUPMAXIMUMROUTEDESCRIPTORS:
		*write_method = write_rDESetupMaximumRouteDescriptors;
		*var_len = sizeof(StorageTmp->rDESetupMaximumRouteDescriptors);
		return (u_char *) &StorageTmp->rDESetupMaximumRouteDescriptors;
	case RDESETUPMAXIMUMRESPONSETIME:
		*write_method = write_rDESetupMaximumResponseTime;
		*var_len = sizeof(StorageTmp->rDESetupMaximumResponseTime);
		return (u_char *) &StorageTmp->rDESetupMaximumResponseTime;
	case RDESETUPMINIMUMPDUSIZE:
		*write_method = write_rDESetupMinimumPDUSize;
		*var_len = sizeof(StorageTmp->rDESetupMinimumPDUSize);
		return (u_char *) &StorageTmp->rDESetupMinimumPDUSize;
	case RDESETUPRDEHOLD:
		*write_method = write_rDESetupRDEHold;
		*var_len = sizeof(StorageTmp->rDESetupRDEHold);
		return (u_char *) &StorageTmp->rDESetupRDEHold;
	case RDESETUPRDEREPLACE:
		*write_method = write_rDESetupRDEReplace;
		*var_len = sizeof(StorageTmp->rDESetupRDEReplace);
		return (u_char *) &StorageTmp->rDESetupRDEReplace;
	case RDESETUPNAME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDESetupName);
		return (u_char *) &StorageTmp->rDESetupName;
	case RDESETUPRESETONTESTENABLED:
		*write_method = write_rDESetupResetOnTestEnabled;
		*var_len = sizeof(StorageTmp->rDESetupResetOnTestEnabled);
		return (u_char *) &StorageTmp->rDESetupResetOnTestEnabled;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_rDEPairTable(void)
 * @brief refresh the scalar values of the rDEPairTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_rDEPairTable(void)
{
	if (rDEPairTable_refresh == 0)
		return;
	rDEPairTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_rDEPairTable_row(struct rDEPairTable_data *StorageTmp)
 * @brief refresh the contents of the rDEPairTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_rDEPairTable_row(struct rDEPairTable_data *StorageTmp)
{
	if (StorageTmp->rDEPairTable_request == sa_request)
		return;
	StorageTmp->rDEPairTable_request = sa_request;
}

/**
 * @fn u_char *var_rDEPairTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in rDEPairTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_rDEPairTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct rDEPairTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_rDEPairTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_rDEPairTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(rDEPairTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_rDEPairTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case RDEPAIRDISCARDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairDiscardCounter);
		return (u_char *) &StorageTmp->rDEPairDiscardCounter;
	case RDEPAIRNSRPDUCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairNSRPDUCounter);
		return (u_char *) &StorageTmp->rDEPairNSRPDUCounter;
	case RDEPAIRNSRSELECTEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairNSRSelectedCounter);
		return (u_char *) &StorageTmp->rDEPairNSRSelectedCounter;
	case RDEPAIRRIF:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->rDEPairRIFLen;
		return (u_char *) StorageTmp->rDEPairRIF;
	case RDEPAIRSRFPDUCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairSRFPDUCounter);
		return (u_char *) &StorageTmp->rDEPairSRFPDUCounter;
	case RDEPAIRQUERYCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairQueryCounter);
		return (u_char *) &StorageTmp->rDEPairQueryCounter;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_lLCConnectionLessTable(void)
 * @brief refresh the scalar values of the lLCConnectionLessTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionLessTable(void)
{
	if (lLCConnectionLessTable_refresh == 0)
		return;
	lLCConnectionLessTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_lLCConnectionLessTable_row(struct lLCConnectionLessTable_data *StorageTmp)
 * @brief refresh the contents of the lLCConnectionLessTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnectionLessTable_row(struct lLCConnectionLessTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnectionLessTable_request == sa_request)
		return;
	StorageTmp->lLCConnectionLessTable_request = sa_request;
}

/**
 * @fn u_char *var_lLCConnectionLessTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCConnectionLessTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnectionLessTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionLessTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCConnectionLessTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnectionLessTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnectionLessTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnectionLessTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTIONLESSNAME:
		*write_method = write_lLCConnectionlessName;
		*var_len = StorageTmp->lLCConnectionlessNameLen;
		return (u_char *) StorageTmp->lLCConnectionlessName;
	case LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedABBResponse;
	case LLCCONNECTIONLESSTESTRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedCommand;
	case LLCCONNECTIONLESSTESTRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedResponse;
	case LLCCONNECTIONLESSTESTSENTABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTSentABBResponse;
	case LLCCONNECTIONLESSTESTSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTSentCommand;
	case LLCCONNECTIONLESSTESTSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTSentResponse;
	case LLCCONNECTIONLESSUIRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessUIReceived);
		return (u_char *) &StorageTmp->lLCConnectionlessUIReceived;
	case LLCCONNECTIONLESSUISENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessUISent);
		return (u_char *) &StorageTmp->lLCConnectionlessUISent;
	case LLCCONNECTIONLESSXIDRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDReceivedCommand;
	case LLCCONNECTIONLESSXIDRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDReceivedResponse;
	case LLCCONNECTIONLESSXIDSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDSentCommand;
	case LLCCONNECTIONLESSXIDSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDSentResponse;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_lLCConnection2Table(void)
 * @brief refresh the scalar values of the lLCConnection2Table.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnection2Table(void)
{
	if (lLCConnection2Table_refresh == 0)
		return;
	lLCConnection2Table_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_lLCConnection2Table_row(struct lLCConnection2Table_data *StorageTmp)
 * @brief refresh the contents of the lLCConnection2Table row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnection2Table_row(struct lLCConnection2Table_data *StorageTmp)
{
	if (StorageTmp->lLCConnection2Table_request == sa_request)
		return;
	StorageTmp->lLCConnection2Table_request = sa_request;
}

/**
 * @fn u_char *var_lLCConnection2Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCConnection2Table.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnection2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnection2Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCConnection2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnection2Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnection2Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTION2NAME:
		*write_method = write_lLCConnection2Name;
		*var_len = StorageTmp->lLCConnection2NameLen;
		return (u_char *) StorageTmp->lLCConnection2Name;
	case LLCCONNECTION2MAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2MaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnection2MaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2MaximumRetransmissions;
	case LLCCONNECTION2RECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2ReceivedWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedWindowSize;
	case LLCCONNECTION2SENDWINDOWSIZE:
		*write_method = write_lLCConnection2SendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2SendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2SendWindowSize;
	case LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2AcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2AcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2AcknowledgeTimeoutValue;
	case LLCCONNECTION2BUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2BusyStateTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2BusyStateTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2BusyStateTimeoutValue;
	case LLCCONNECTION2PBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2PBitTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2PBitTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2PBitTimeoutValue;
	case LLCCONNECTION2REJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2RejectTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2RejectTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2RejectTimeoutValue;
	case LLCCONNECTION2LOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2LocalBusy);
		return (u_char *) &StorageTmp->lLCConnection2LocalBusy;
	case LLCCONNECTION2REMOTEBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2RemoteBusy);
		return (u_char *) &StorageTmp->lLCConnection2RemoteBusy;
	case LLCCONNECTION2REMOTERESET:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2RemoteReset);
		return (u_char *) &StorageTmp->lLCConnection2RemoteReset;
	case LLCCONNECTION2LOCALRESET:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2LocalReset);
		return (u_char *) &StorageTmp->lLCConnection2LocalReset;
	case LLCCONNECTION2PROVIDERRESET:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ProviderReset);
		return (u_char *) &StorageTmp->lLCConnection2ProviderReset;
	case LLCCONNECTION2ROUTE:
		*write_method = write_lLCConnection2Route;
		*var_len = StorageTmp->lLCConnection2RouteLen;
		return (u_char *) StorageTmp->lLCConnection2Route;
	case LLCCONNECTION2KSTEP:
		*write_method = write_lLCConnection2KStep;
		*var_len = sizeof(StorageTmp->lLCConnection2KStep);
		return (u_char *) &StorageTmp->lLCConnection2KStep;
	case LLCCONNECTION2MAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2MaxSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2MaxSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2MaxSendWindowSize;
	case LLCCONNECTION2RECEIVEDI:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedI);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedI;
	case LLCCONNECTION2SENTI:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentI);
		return (u_char *) &StorageTmp->lLCConnection2SentI;
	case LLCCONNECTION2SENTACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentAcks);
		return (u_char *) &StorageTmp->lLCConnection2SentAcks;
	case LLCCONNECTION2RECEIVEDACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedAcks);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedAcks;
	case LLCCONNECTION2RECEIVEDFRMR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedFRMR);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedFRMR;
	case LLCCONNECTION2SENTFRMR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentFRMR);
		return (u_char *) &StorageTmp->lLCConnection2SentFRMR;
	case LLCCONNECTION2RECEIVEDRR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedRR);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedRR;
	case LLCCONNECTION2SENTRR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentRR);
		return (u_char *) &StorageTmp->lLCConnection2SentRR;
	case LLCCONNECTION2RECEIVEDRNR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedRNR);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedRNR;
	case LLCCONNECTION2SENTRNR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentRNR);
		return (u_char *) &StorageTmp->lLCConnection2SentRNR;
	case LLCCONNECTION2RECEIVEDREJ:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedREJ);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedREJ;
	case LLCCONNECTION2SENTREJ:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentREJ);
		return (u_char *) &StorageTmp->lLCConnection2SentREJ;
	case LLCCONNECTION2RECEIVEDSABME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedSABME);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedSABME;
	case LLCCONNECTION2SENTSABME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentSABME);
		return (u_char *) &StorageTmp->lLCConnection2SentSABME;
	case LLCCONNECTION2RECEIVEDUA:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedUA);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedUA;
	case LLCCONNECTION2SENTUA:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentUA);
		return (u_char *) &StorageTmp->lLCConnection2SentUA;
	case LLCCONNECTION2RECEIVEDDISC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedDISC);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedDISC;
	case LLCCONNECTION2SENTDISC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentDISC);
		return (u_char *) &StorageTmp->lLCConnection2SentDISC;
	case LLCCONNECTION2RECEIVEDDM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedDM);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedDM;
	case LLCCONNECTION2SENTDM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentDM);
		return (u_char *) &StorageTmp->lLCConnection2SentDM;
	case LLCCONNECTION2PDUSDISCARDED1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2PDUsDiscarded1);
		return (u_char *) &StorageTmp->lLCConnection2PDUsDiscarded1;
	case LLCCONNECTION2PDUSDISCARDED2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2PDUsDiscarded2);
		return (u_char *) &StorageTmp->lLCConnection2PDUsDiscarded2;
	case LLCCONNECTION2PDURETRANSMISSIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2PDURetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2PDURetransmissions;
	case LLCCONNECTION2OPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2OptionalTolerationIPDUs;
		*var_len = sizeof(StorageTmp->lLCConnection2OptionalTolerationIPDUs);
		return (u_char *) &StorageTmp->lLCConnection2OptionalTolerationIPDUs;
	case LLCCONNECTION2DUPLICATEIPDUSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2DuplicateIPDUsReceived);
		return (u_char *) &StorageTmp->lLCConnection2DuplicateIPDUsReceived;
	case LLCCONNECTION2VIOLATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2Violation);
		return (u_char *) &StorageTmp->lLCConnection2Violation;
	case LLCCONNECTION2PROTOCOLSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ProtocolState);
		return (u_char *) &StorageTmp->lLCConnection2ProtocolState;
	case LLCCONNECTION2ADMINISTRATIVESTATE:
		*write_method = write_lLCConnection2AdministrativeState;
		*var_len = sizeof(StorageTmp->lLCConnection2AdministrativeState);
		return (u_char *) &StorageTmp->lLCConnection2AdministrativeState;
	case LLCCONNECTION2OPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2OperationalState);
		return (u_char *) &StorageTmp->lLCConnection2OperationalState;
	case LLCCONNECTION2USAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2UsageState);
		return (u_char *) &StorageTmp->lLCConnection2UsageState;
	case LLCCONNECTION2PROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->lLCConnection2ProceduralStatusLen;
		return (u_char *) StorageTmp->lLCConnection2ProceduralStatus;
	case LLCCONNECTION2ALARMSTATUS:
		*write_method = write_lLCConnection2AlarmStatus;
		*var_len = StorageTmp->lLCConnection2AlarmStatusLen;
		return (u_char *) StorageTmp->lLCConnection2AlarmStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_lLCConnection2IVMOTable(void)
 * @brief refresh the scalar values of the lLCConnection2IVMOTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnection2IVMOTable(void)
{
	if (lLCConnection2IVMOTable_refresh == 0)
		return;
	lLCConnection2IVMOTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_lLCConnection2IVMOTable_row(struct lLCConnection2IVMOTable_data *StorageTmp)
 * @brief refresh the contents of the lLCConnection2IVMOTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnection2IVMOTable_row(struct lLCConnection2IVMOTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnection2IVMOTable_request == sa_request)
		return;
	StorageTmp->lLCConnection2IVMOTable_request = sa_request;
}

/**
 * @fn u_char *var_lLCConnection2IVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCConnection2IVMOTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnection2IVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCConnection2IVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnection2IVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnection2IVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2IVMOMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2IVMOMaximumRetransmissions;
	case LLCCONNECTION2IVMORECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOReceivedWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOReceivedWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2IVMOReceivedWindowSize;
	case LLCCONNECTION2IVMOSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2IVMOSendWindowSize;
	case LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOAcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue;
	case LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBusyStateTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue;
	case LLCCONNECTION2IVMOBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBitTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOBitTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMOBitTimeoutValue;
	case LLCCONNECTION2IVMOREJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMORejectTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMORejectTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMORejectTimeoutValue;
	case LLCCONNECTION2IVMOROUTE:
		*write_method = write_lLCConnection2IVMORoute;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMORoute);
		return (u_char *) &StorageTmp->lLCConnection2IVMORoute;
	case LLCCONNECTION2IVMOKSTEP:
		*write_method = write_lLCConnection2IVMOKStep;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOKStep);
		return (u_char *) &StorageTmp->lLCConnection2IVMOKStep;
	case LLCCONNECTION2IVMOMAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOMaxSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOMaxSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2IVMOMaxSendWindowSize;
	case LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2IVMOOptionalTolerationIPDUs;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs);
		return (u_char *) &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_lLCConnectionlessAckTable(void)
 * @brief refresh the scalar values of the lLCConnectionlessAckTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionlessAckTable(void)
{
	if (lLCConnectionlessAckTable_refresh == 0)
		return;
	lLCConnectionlessAckTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_lLCConnectionlessAckTable_row(struct lLCConnectionlessAckTable_data *StorageTmp)
 * @brief refresh the contents of the lLCConnectionlessAckTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnectionlessAckTable_row(struct lLCConnectionlessAckTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnectionlessAckTable_request == sa_request)
		return;
	StorageTmp->lLCConnectionlessAckTable_request = sa_request;
}

/**
 * @fn u_char *var_lLCConnectionlessAckTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCConnectionlessAckTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnectionlessAckTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCConnectionlessAckTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnectionlessAckTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnectionlessAckTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckMaximumRetransmissions;
	case LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse;
	case LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedCommand;
	case LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedResponse;
	case LLCCONNECTIONLESSACKTESTSENTABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentABBResponse;
	case LLCCONNECTIONLESSACKTESTSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentCommand;
	case LLCCONNECTIONLESSACKTESTSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentResponse;
	case LLCCONNECTIONLESSACKRECEIVERESOURCES:
		*write_method = write_lLCConnectionlessAckReceiveResources;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckReceiveResources);
		return (u_char *) &StorageTmp->lLCConnectionlessAckReceiveResources;
	case LLCCONNECTIONLESSACKUIRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckUIReceived);
		return (u_char *) &StorageTmp->lLCConnectionlessAckUIReceived;
	case LLCCONNECTIONLESSACKUISENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckUISent);
		return (u_char *) &StorageTmp->lLCConnectionlessAckUISent;
	case LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDReceivedCommand;
	case LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDReceivedResponse;
	case LLCCONNECTIONLESSACKXIDSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDSentCommand;
	case LLCCONNECTIONLESSACKXIDSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDSentResponse;
	case LLCCONNECTIONLESSACKRETRANSMISSIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckRetransmissions;
	case LLCCONNECTIONLESSACKNORESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckNoResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckNoResponse;
	case LLCCONNECTIONLESSACKCOMMANDIP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandIP);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandIP;
	case LLCCONNECTIONLESSACKCOMMANDIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandIT);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandIT;
	case LLCCONNECTIONLESSACKCOMMANDOK:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandOK);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandOK;
	case LLCCONNECTIONLESSACKCOMMANDPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandPE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandPE;
	case LLCCONNECTIONLESSACKCOMMANDRS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandRS);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandRS;
	case LLCCONNECTIONLESSACKCOMMANDUE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandUE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandUE;
	case LLCCONNECTIONLESSACKCOMMANDUN:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandUN);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandUN;
	case LLCCONNECTIONLESSACKRECEIVEDACCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckReceivedACCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckReceivedACCommand;
	case LLCCONNECTIONLESSACKSENTACCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckSentACCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckSentACCommand;
	case LLCCONNECTIONLESSACKRESPONSEIP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseIP);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseIP;
	case LLCCONNECTIONLESSACKRESPONSEIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseIT);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseIT;
	case LLCCONNECTIONLESSACKRESPONSENE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseNE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseNE;
	case LLCCONNECTIONLESSACKRESPONSENR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseNR);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseNR;
	case LLCCONNECTIONLESSACKRESPONSEOK:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseOK);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseOK;
	case LLCCONNECTIONLESSACKRESPONSERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseRS);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseRS;
	case LLCCONNECTIONLESSACKRESPONSEUE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseUE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseUE;
	case LLCCONNECTIONLESSACKRESPONSEUN:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseUN);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseUN;
	case LLCCONNECTIONLESSACKVIOLATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckViolation);
		return (u_char *) &StorageTmp->lLCConnectionlessAckViolation;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_lLCConnectionlessAckIVMOTable(void)
 * @brief refresh the scalar values of the lLCConnectionlessAckIVMOTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionlessAckIVMOTable(void)
{
	if (lLCConnectionlessAckIVMOTable_refresh == 0)
		return;
	lLCConnectionlessAckIVMOTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_lLCConnectionlessAckIVMOTable_row(struct lLCConnectionlessAckIVMOTable_data *StorageTmp)
 * @brief refresh the contents of the lLCConnectionlessAckIVMOTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnectionlessAckIVMOTable_row(struct lLCConnectionlessAckIVMOTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnectionlessAckIVMOTable_request == sa_request)
		return;
	StorageTmp->lLCConnectionlessAckIVMOTable_request = sa_request;
}

/**
 * @fn u_char *var_lLCConnectionlessAckIVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCConnectionlessAckIVMOTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnectionlessAckIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCConnectionlessAckIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnectionlessAckIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnectionlessAckIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckIVMOMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions;
	case LLCCONNECTIONLESSACKIVMOROWSTATUS:
		*write_method = write_lLCConnectionlessAckIVMORowStatus;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMORowStatus);
		return (u_char *) &StorageTmp->lLCConnectionlessAckIVMORowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_networkEntityTable(void)
 * @brief refresh the scalar values of the networkEntityTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_networkEntityTable(void)
{
	if (networkEntityTable_refresh == 0)
		return;
	networkEntityTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_networkEntityTable_row(struct networkEntityTable_data *StorageTmp)
 * @brief refresh the contents of the networkEntityTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_networkEntityTable_row(struct networkEntityTable_data *StorageTmp)
{
	if (StorageTmp->networkEntityTable_request == sa_request)
		return;
	StorageTmp->networkEntityTable_request = sa_request;
}

/**
 * @fn u_char *var_networkEntityTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in networkEntityTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_networkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct networkEntityTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_networkEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_networkEntityTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(networkEntityTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_networkEntityTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case NETWORKENTITYTITLES:
		*write_method = write_networkEntityTitles;
		*var_len = StorageTmp->networkEntityTitlesLen;
		return (u_char *) StorageTmp->networkEntityTitles;
	case NETWORKENTITYSYSTEMTYPES:
		*write_method = write_networkEntitySystemTypes;
		*var_len = StorageTmp->networkEntitySystemTypesLen;
		return (u_char *) StorageTmp->networkEntitySystemTypes;
	case NETWORKENTITYROWSTATUS:
		*write_method = write_networkEntityRowStatus;
		*var_len = sizeof(StorageTmp->networkEntityRowStatus);
		return (u_char *) &StorageTmp->networkEntityRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_nSAPTable(void)
 * @brief refresh the scalar values of the nSAPTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_nSAPTable(void)
{
	if (nSAPTable_refresh == 0)
		return;
	nSAPTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_nSAPTable_row(struct nSAPTable_data *StorageTmp)
 * @brief refresh the contents of the nSAPTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_nSAPTable_row(struct nSAPTable_data *StorageTmp)
{
	if (StorageTmp->nSAPTable_request == sa_request)
		return;
	StorageTmp->nSAPTable_request = sa_request;
}

/**
 * @fn u_char *var_nSAPTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in nSAPTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_nSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct nSAPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_nSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_nSAPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(nSAPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_nSAPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case NSAPROWSTATUS:
		*write_method = write_nSAPRowStatus;
		*var_len = sizeof(StorageTmp->nSAPRowStatus);
		return (u_char *) &StorageTmp->nSAPRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_cLNSTable(void)
 * @brief refresh the scalar values of the cLNSTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cLNSTable(void)
{
	if (cLNSTable_refresh == 0)
		return;
	cLNSTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_cLNSTable_row(struct cLNSTable_data *StorageTmp)
 * @brief refresh the contents of the cLNSTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_cLNSTable_row(struct cLNSTable_data *StorageTmp)
{
	if (StorageTmp->cLNSTable_request == sa_request)
		return;
	StorageTmp->cLNSTable_request = sa_request;
}

/**
 * @fn u_char *var_cLNSTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in cLNSTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cLNSTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cLNSTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_cLNSTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_cLNSTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(cLNSTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_cLNSTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case CLNSADMINISTRATIVESTATE:
		*write_method = write_cLNSAdministrativeState;
		*var_len = sizeof(StorageTmp->cLNSAdministrativeState);
		return (u_char *) &StorageTmp->cLNSAdministrativeState;
	case CLNSSUPPORTEDPROTOCOLS:
		*write_method = write_cLNSSupportedProtocols;
		*var_len = StorageTmp->cLNSSupportedProtocolsLen;
		return (u_char *) StorageTmp->cLNSSupportedProtocols;
	case CLNSOPERATIONALSYSTEMTYPE:
		*write_method = write_cLNSOperationalSystemType;
		*var_len = StorageTmp->cLNSOperationalSystemTypeLen;
		return (u_char *) StorageTmp->cLNSOperationalSystemType;
	case CLNSOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSOctetsSentCounter);
		return (u_char *) &StorageTmp->cLNSOctetsSentCounter;
	case CLNSOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSOctetsReceivedCounter);
		return (u_char *) &StorageTmp->cLNSOctetsReceivedCounter;
	case CLNSSEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSSegmentsReceived);
		return (u_char *) &StorageTmp->cLNSSegmentsReceived;
	case CLNSSEGMENTSDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSSegmentsDiscarded);
		return (u_char *) &StorageTmp->cLNSSegmentsDiscarded;
	case CLNSASSEMBLINGSEGMENTSDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSAssemblingSegmentsDiscarded);
		return (u_char *) &StorageTmp->cLNSAssemblingSegmentsDiscarded;
	case CLNSERRORREPORTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSErrorReportsReceived);
		return (u_char *) &StorageTmp->cLNSErrorReportsReceived;
	case CLNSPDUDISCARDS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSpDUDiscards);
		return (u_char *) &StorageTmp->cLNSpDUDiscards;
	case CLNSCONGESTIONDISCARDS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSCongestionDiscards);
		return (u_char *) &StorageTmp->cLNSCongestionDiscards;
	case CLNSMAXIMUMLIFETIME:
		*write_method = write_cLNSMaximumLifetime;
		*var_len = sizeof(StorageTmp->cLNSMaximumLifetime);
		return (u_char *) &StorageTmp->cLNSMaximumLifetime;
	case CLNSENABLECHECKSUM:
		*write_method = write_cLNSEnableChecksum;
		*var_len = sizeof(StorageTmp->cLNSEnableChecksum);
		return (u_char *) &StorageTmp->cLNSEnableChecksum;
	case CLNSROWSTATUS:
		*write_method = write_cLNSRowStatus;
		*var_len = sizeof(StorageTmp->cLNSRowStatus);
		return (u_char *) &StorageTmp->cLNSRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_cLNSISISTable(void)
 * @brief refresh the scalar values of the cLNSISISTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cLNSISISTable(void)
{
	if (cLNSISISTable_refresh == 0)
		return;
	cLNSISISTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_cLNSISISTable_row(struct cLNSISISTable_data *StorageTmp)
 * @brief refresh the contents of the cLNSISISTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_cLNSISISTable_row(struct cLNSISISTable_data *StorageTmp)
{
	if (StorageTmp->cLNSISISTable_request == sa_request)
		return;
	StorageTmp->cLNSISISTable_request = sa_request;
}

/**
 * @fn u_char *var_cLNSISISTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in cLNSISISTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cLNSISISTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cLNSISISTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_cLNSISISTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_cLNSISISTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(cLNSISISTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_cLNSISISTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case CLNSISISVERSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISversionLen;
		return (u_char *) StorageTmp->cLNSISISversion;
	case CLNSISISISTYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISiSType);
		return (u_char *) &StorageTmp->cLNSISISiSType;
	case CLNSISISSYSTEMID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISsystemIdLen;
		return (u_char *) StorageTmp->cLNSISISsystemId;
	case CLNSISISMAXIMUMPATHSPLITS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISmaximumPathSplits);
		return (u_char *) &StorageTmp->cLNSISISmaximumPathSplits;
	case CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISminimumLSPTransmissionInterval);
		return (u_char *) &StorageTmp->cLNSISISminimumLSPTransmissionInterval;
	case CLNSISISMAXIMUMLSPGENERATIONINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISmaximumLSPGenerationInterval);
		return (u_char *) &StorageTmp->cLNSISISmaximumLSPGenerationInterval;
	case CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval);
		return (u_char *) &StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval;
	case CLNSISISCOMPLETESNPINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISIScompleteSNPInterval);
		return (u_char *) &StorageTmp->cLNSISIScompleteSNPInterval;
	case CLNSISISORIGINATINGL1LSPBUFFERSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISoriginatingL1LSPBufferSize);
		return (u_char *) &StorageTmp->cLNSISISoriginatingL1LSPBufferSize;
	case CLNSISISMANUALAREAADDRESSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISmanualAreaAddressesLen;
		return (u_char *) StorageTmp->cLNSISISmanualAreaAddresses;
	case CLNSISISMAXIMUMAREAADDRESSES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISmaximumAreaAddresses);
		return (u_char *) &StorageTmp->cLNSISISmaximumAreaAddresses;
	case CLNSISISMINIMUMLSPGENERATIONINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISminimumLSPGenerationInterval);
		return (u_char *) &StorageTmp->cLNSISISminimumLSPGenerationInterval;
	case CLNSISISPOLLESHELLORATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISpollESHelloRate);
		return (u_char *) &StorageTmp->cLNSISISpollESHelloRate;
	case CLNSISISPARTIALSNPINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISpartialSNPInterval);
		return (u_char *) &StorageTmp->cLNSISISpartialSNPInterval;
	case CLNSISISWAITINGTIME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISwaitingTime);
		return (u_char *) &StorageTmp->cLNSISISwaitingTime;
	case CLNSISISDRISISHELLOTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISdRISISHelloTimer);
		return (u_char *) &StorageTmp->cLNSISISdRISISHelloTimer;
	case CLNSISISL1STATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISl1State);
		return (u_char *) &StorageTmp->cLNSISISl1State;
	case CLNSISISAREAADDRESSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISareaAddressesLen;
		return (u_char *) StorageTmp->cLNSISISareaAddresses;
	case CLNSISISCORRUPTEDLSPSDETECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISIScorruptedLSPsDetected);
		return (u_char *) &StorageTmp->cLNSISIScorruptedLSPsDetected;
	case CLNSISISLSPL1DATABASEOVERLOADS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISlSPL1DatabaseOverloads);
		return (u_char *) &StorageTmp->cLNSISISlSPL1DatabaseOverloads;
	case CLNSISISMANUALADDRESSESDROPPEDFROMAREAS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISmanualAddressesDroppedFromAreas);
		return (u_char *) &StorageTmp->cLNSISISmanualAddressesDroppedFromAreas;
	case CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber);
		return (u_char *) &StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber;
	case CLNSISISSEQUENCENUMBERSKIPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISsequenceNumberSkips);
		return (u_char *) &StorageTmp->cLNSISISsequenceNumberSkips;
	case CLNSISISOWNLSPPURGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISownLSPPurges);
		return (u_char *) &StorageTmp->cLNSISISownLSPPurges;
	case CLNSISISIDFIELDLENGTHMISMATCHES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISiDFieldLengthMismatches);
		return (u_char *) &StorageTmp->cLNSISISiDFieldLengthMismatches;
	case CLNSISISMAXIMUMAREAADDRESSESMISMATCHES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISmaximumAreaAddressesMismatches);
		return (u_char *) &StorageTmp->cLNSISISmaximumAreaAddressesMismatches;
	case CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches);
		return (u_char *) &StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches;
	case CLNSISISLSPTOOLARGETOPROPAGATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISlSPTooLargeToPropagate);
		return (u_char *) &StorageTmp->cLNSISISlSPTooLargeToPropagate;
	case CLNSISISAREATRANSMITPASSWORD:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISareaTransmitPasswordLen;
		return (u_char *) StorageTmp->cLNSISISareaTransmitPassword;
	case CLNSISISAREARECEIVEPASSWORDS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISareaReceivePasswordsLen;
		return (u_char *) StorageTmp->cLNSISISareaReceivePasswords;
	case CLNSISISAUTHENTICATIONFAILURES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISauthenticationFailures);
		return (u_char *) &StorageTmp->cLNSISISauthenticationFailures;
	case CLNSISISROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISRowStatus);
		return (u_char *) &StorageTmp->cLNSISISRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_cLNSISISLevel2Table(void)
 * @brief refresh the scalar values of the cLNSISISLevel2Table.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cLNSISISLevel2Table(void)
{
	if (cLNSISISLevel2Table_refresh == 0)
		return;
	cLNSISISLevel2Table_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_cLNSISISLevel2Table_row(struct cLNSISISLevel2Table_data *StorageTmp)
 * @brief refresh the contents of the cLNSISISLevel2Table row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_cLNSISISLevel2Table_row(struct cLNSISISLevel2Table_data *StorageTmp)
{
	if (StorageTmp->cLNSISISLevel2Table_request == sa_request)
		return;
	StorageTmp->cLNSISISLevel2Table_request = sa_request;
}

/**
 * @fn u_char *var_cLNSISISLevel2Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in cLNSISISLevel2Table.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cLNSISISLevel2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cLNSISISLevel2Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_cLNSISISLevel2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_cLNSISISLevel2Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(cLNSISISLevel2TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_cLNSISISLevel2Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies);
		return (u_char *) &StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies;
	case CLNSISISLEVEL2PARTITIONAREAADDRESSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISLevel2partitionAreaAddressesLen;
		return (u_char *) StorageTmp->cLNSISISLevel2partitionAreaAddresses;
	case CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen;
		return (u_char *) StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem;
	case CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges);
		return (u_char *) &StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges;
	case CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize);
		return (u_char *) &StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize;
	case CLNSISISLEVEL2L2STATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2l2State);
		return (u_char *) &StorageTmp->cLNSISISLevel2l2State;
	case CLNSISISLEVEL2LSPL2DATABASEOVERLOADS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads);
		return (u_char *) &StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads;
	case CLNSISISLEVEL2DOMAINTRANSMITPASSWORD:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISLevel2domainTransmitPasswordLen;
		return (u_char *) StorageTmp->cLNSISISLevel2domainTransmitPassword;
	case CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISLevel2domainReceivePasswordsLen;
		return (u_char *) StorageTmp->cLNSISISLevel2domainReceivePasswords;
	case CLNSISISLEVEL2ROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2RowStatus);
		return (u_char *) &StorageTmp->cLNSISISLevel2RowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_linkageTable(void)
 * @brief refresh the scalar values of the linkageTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_linkageTable(void)
{
	if (linkageTable_refresh == 0)
		return;
	linkageTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_linkageTable_row(struct linkageTable_data *StorageTmp)
 * @brief refresh the contents of the linkageTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_linkageTable_row(struct linkageTable_data *StorageTmp)
{
	if (StorageTmp->linkageTable_request == sa_request)
		return;
	StorageTmp->linkageTable_request = sa_request;
}

/**
 * @fn u_char *var_linkageTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in linkageTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_linkageTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct linkageTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_linkageTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_linkageTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(linkageTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_linkageTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LINKAGEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageOperationalState);
		return (u_char *) &StorageTmp->linkageOperationalState;
	case LINKAGEADMINISTRATIVESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageAdministrativeState);
		return (u_char *) &StorageTmp->linkageAdministrativeState;
	case LINKAGESNSERVICEPROVIDER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageSnServiceProviderLen;
		return (u_char *) StorageTmp->linkageSnServiceProvider;
	case LINKAGESNSAP:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageSnSAPLen;
		return (u_char *) StorageTmp->linkageSnSAP;
	case LINKAGEOPERATIONALPROTOCOLS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageOperationalProtocolsLen;
		return (u_char *) StorageTmp->linkageOperationalProtocols;
	case LINKAGEISISO9542OPERATIONALSUBSETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISiSO9542OperationalSubsetsLen;
		return (u_char *) StorageTmp->linkageISiSO9542OperationalSubsets;
	case LINKAGEISHOLDINGTIMERMULTIPLIER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISHoldingTimerMultiplierLen;
		return (u_char *) StorageTmp->linkageISHoldingTimerMultiplier;
	case LINKAGEISISCONFIGURATIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISConfigurationTimerLen;
		return (u_char *) StorageTmp->linkageISISConfigurationTimer;
	case LINKAGEISSUGGESTEDESCONFIGURATIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISSuggestedEsConfigurationTimerLen;
		return (u_char *) StorageTmp->linkageISSuggestedEsConfigurationTimer;
	case LINKAGEISREDIRECTHOLDINGTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISRedirectHoldingTimeLen;
		return (u_char *) StorageTmp->linkageISRedirectHoldingTime;
	case LINKAGEISESREACHABILITYCHANGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISESReachabilityChanges);
		return (u_char *) &StorageTmp->linkageISESReachabilityChanges;
	case LINKAGEISINVALID9542PDUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISInvalid9542PDUs);
		return (u_char *) &StorageTmp->linkageISInvalid9542PDUs;
	case LINKAGEESISO9542OPERATIONALSUBSETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageESiSO9542OperationalSubsetsLen;
		return (u_char *) StorageTmp->linkageESiSO9542OperationalSubsets;
	case LINKAGEESHOLDINGTIMERMULTIPLIER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageESHoldingTimerMultiplierLen;
		return (u_char *) StorageTmp->linkageESHoldingTimerMultiplier;
	case LINKAGEESMANUALISSNPAADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageESManualISSNPAAddressLen;
		return (u_char *) StorageTmp->linkageESManualISSNPAAddress;
	case LINKAGEESDEFAULTESCONFIGTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageESDefaultESConfigTimerLen;
		return (u_char *) StorageTmp->linkageESDefaultESConfigTimer;
	case LINKAGEESACTIVEESCONFIGTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageESActiveESConfigTimerLen;
		return (u_char *) StorageTmp->linkageESActiveESConfigTimer;
	case LINKAGEESISREACHABILITYCHANGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageESISReachabilityChanges);
		return (u_char *) &StorageTmp->linkageESISReachabilityChanges;
	case LINKAGEESINVALID9542PDUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageESInvalid9542PDUs);
		return (u_char *) &StorageTmp->linkageESInvalid9542PDUs;
	case LINKAGEENABLECHECKSUM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageEnableChecksum);
		return (u_char *) &StorageTmp->linkageEnableChecksum;
	case LINKAGEINITIALMINIMUMTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageInitialMinimumTimerLen;
		return (u_char *) StorageTmp->linkageInitialMinimumTimer;
	case LINKAGERESERVETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageReserveTimerLen;
		return (u_char *) StorageTmp->linkageReserveTimer;
	case LINKAGEIDLETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageIdleTimerLen;
		return (u_char *) StorageTmp->linkageIdleTimer;
	case LINKAGESNDCFCALLSPLACED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageSNDCFCallsPlaced);
		return (u_char *) &StorageTmp->linkageSNDCFCallsPlaced;
	case LINKAGESNDCFCALLSFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageSNDCFCallsFailed);
		return (u_char *) &StorageTmp->linkageSNDCFCallsFailed;
	case LINKAGECODLCALLSPLACED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageCODLCallsPlaced);
		return (u_char *) &StorageTmp->linkageCODLCallsPlaced;
	case LINKAGECODLCALLSFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageCODLCallsFailed);
		return (u_char *) &StorageTmp->linkageCODLCallsFailed;
	case LINKAGEISISTYPE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISTypeLen;
		return (u_char *) StorageTmp->linkageISISType;
	case LINKAGEISISISISHELLOTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISiSISHelloTimerLen;
		return (u_char *) StorageTmp->linkageISISiSISHelloTimer;
	case LINKAGEISISL1DEFAULTMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1DefaultMetricLen;
		return (u_char *) StorageTmp->linkageISISl1DefaultMetric;
	case LINKAGEISISL1DELAYMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1DelayMetricLen;
		return (u_char *) StorageTmp->linkageISISl1DelayMetric;
	case LINKAGEISISL1EXPENSEMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1ExpenseMetricLen;
		return (u_char *) StorageTmp->linkageISISl1ExpenseMetric;
	case LINKAGEISISL1ERRORMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1ErrorMetricLen;
		return (u_char *) StorageTmp->linkageISISl1ErrorMetric;
	case LINKAGEISISEXTERNALDOMAIN:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISexternalDomainLen;
		return (u_char *) StorageTmp->linkageISISexternalDomain;
	case LINKAGEISISCHANGEDINADJACENCYSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISchangedInAdjacencyState);
		return (u_char *) &StorageTmp->linkageISISchangedInAdjacencyState;
	case LINKAGEISISINITIALISATIONFAILURES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISinitialisationFailures);
		return (u_char *) &StorageTmp->linkageISISinitialisationFailures;
	case LINKAGEISISREJECTEDADJACENCIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISrejectedAdjacencies);
		return (u_char *) &StorageTmp->linkageISISrejectedAdjacencies;
	case LINKAGEISISISISCONTROLPDUSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISiSISControlPDUsSent);
		return (u_char *) &StorageTmp->linkageISISiSISControlPDUsSent;
	case LINKAGEISISISISCONTROLPDUSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISiSISControlPDUsReceived);
		return (u_char *) &StorageTmp->linkageISISiSISControlPDUsReceived;
	case LINKAGEISISIDFIELDLENTHMISMATCHES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISiDFieldLenthMismatches);
		return (u_char *) &StorageTmp->linkageISISiDFieldLenthMismatches;
	case LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISmaximumAreaAddressesMismatches);
		return (u_char *) &StorageTmp->linkageISISmaximumAreaAddressesMismatches;
	case LINKAGEISISCIRCUITTRANSMITPASSWORD:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScircuitTransmitPasswordLen;
		return (u_char *) StorageTmp->linkageISIScircuitTransmitPassword;
	case LINKAGEISISCIRCUITRECEIVEDPASSWORDS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScircuitReceivedPasswordsLen;
		return (u_char *) StorageTmp->linkageISIScircuitReceivedPasswords;
	case LINKAGEISISAUTHENTICATIONFAILURES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISauthenticationFailures);
		return (u_char *) &StorageTmp->linkageISISauthenticationFailures;
	case LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1IntermediateSystemPriorityLen;
		return (u_char *) StorageTmp->linkageISISl1IntermediateSystemPriority;
	case LINKAGEISISL1CIRCUITID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1CircuitIDLen;
		return (u_char *) StorageTmp->linkageISISl1CircuitID;
	case LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1DesignatedIntermediateSystemLen;
		return (u_char *) StorageTmp->linkageISISl1DesignatedIntermediateSystem;
	case LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges);
		return (u_char *) &StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges;
	case LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrementLen;
		return (u_char *) StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement;
	case LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScallEstablishmentDelayMetricIncrementLen;
		return (u_char *) StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement;
	case LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrementLen;
		return (u_char *) StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement;
	case LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScallEstablishmentErrorMetricIncrementLen;
		return (u_char *) StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement;
	case LINKAGEISISPTPTCIRCUITID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISptPtCircuitIDLen;
		return (u_char *) StorageTmp->linkageISISptPtCircuitID;
	case LINKAGEISISOUTGOINGCALLIVMO:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISoutgoingCallIVMOLen;
		return (u_char *) StorageTmp->linkageISISoutgoingCallIVMO;
	case LINKAGEISISNEIGHBORSNPAADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISneighborSNPAAddressLen;
		return (u_char *) StorageTmp->linkageISISneighborSNPAAddress;
	case LINKAGEISISL2DEFAULTMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2DefaultMetricLen;
		return (u_char *) StorageTmp->linkageISISl2DefaultMetric;
	case LINKAGEISISL2DELAYMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2DelayMetricLen;
		return (u_char *) StorageTmp->linkageISISl2DelayMetric;
	case LINKAGEISISL2EXPENSEMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2ExpenseMetricLen;
		return (u_char *) StorageTmp->linkageISISl2ExpenseMetric;
	case LINKAGEISISL2ERRORMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2ErrorMetricLen;
		return (u_char *) StorageTmp->linkageISISl2ErrorMetric;
	case LINKAGEISISMANUALL2ONLYMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISmanualL2OnlyMode);
		return (u_char *) &StorageTmp->linkageISISmanualL2OnlyMode;
	case LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2IntermediateSystemPriorityLen;
		return (u_char *) StorageTmp->linkageISISl2IntermediateSystemPriority;
	case LINKAGEISISL2CIRCUITID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2CircuitIDLen;
		return (u_char *) StorageTmp->linkageISISl2CircuitID;
	case LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2DesignatedIntermediateSystemLen;
		return (u_char *) StorageTmp->linkageISISl2DesignatedIntermediateSystem;
	case LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges);
		return (u_char *) &StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges;
	case LINKAGEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageRowStatus);
		return (u_char *) &StorageTmp->linkageRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_cONSTable(void)
 * @brief refresh the scalar values of the cONSTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cONSTable(void)
{
	if (cONSTable_refresh == 0)
		return;
	cONSTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_cONSTable_row(struct cONSTable_data *StorageTmp)
 * @brief refresh the contents of the cONSTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_cONSTable_row(struct cONSTable_data *StorageTmp)
{
	if (StorageTmp->cONSTable_request == sa_request)
		return;
	StorageTmp->cONSTable_request = sa_request;
}

/**
 * @fn u_char *var_cONSTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in cONSTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cONSTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cONSTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_cONSTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_cONSTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(cONSTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_cONSTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case CONSADMINISTRATIVESTATE:
		*write_method = write_cONSAdministrativeState;
		*var_len = sizeof(StorageTmp->cONSAdministrativeState);
		return (u_char *) &StorageTmp->cONSAdministrativeState;
	case CONSOPERATIONALSYSTEMTYPE:
		*write_method = write_cONSOperationalSystemType;
		*var_len = StorageTmp->cONSOperationalSystemTypeLen;
		return (u_char *) StorageTmp->cONSOperationalSystemType;
	case CONSROWSTATUS:
		*write_method = write_cONSRowStatus;
		*var_len = sizeof(StorageTmp->cONSRowStatus);
		return (u_char *) &StorageTmp->cONSRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_networkConnectionTable(void)
 * @brief refresh the scalar values of the networkConnectionTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_networkConnectionTable(void)
{
	if (networkConnectionTable_refresh == 0)
		return;
	networkConnectionTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_networkConnectionTable_row(struct networkConnectionTable_data *StorageTmp)
 * @brief refresh the contents of the networkConnectionTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_networkConnectionTable_row(struct networkConnectionTable_data *StorageTmp)
{
	if (StorageTmp->networkConnectionTable_request == sa_request)
		return;
	StorageTmp->networkConnectionTable_request = sa_request;
}

/**
 * @fn u_char *var_networkConnectionTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in networkConnectionTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_networkConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct networkConnectionTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_networkConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_networkConnectionTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(networkConnectionTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_networkConnectionTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case NETWORKCONNECTIONLOCALNSAPMO:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->networkConnectionLocalNSAPMOLen;
		return (u_char *) StorageTmp->networkConnectionLocalNSAPMO;
	case NETWORKCONNECTIONREMOTENSAPADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->networkConnectionRemoteNSAPAddressLen;
		return (u_char *) StorageTmp->networkConnectionRemoteNSAPAddress;
	case NETWORKCONNECTIONROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->networkConnectionRowStatus);
		return (u_char *) &StorageTmp->networkConnectionRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLETable(void)
 * @brief refresh the scalar values of the x25PLETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLETable(void)
{
	if (x25PLETable_refresh == 0)
		return;
	x25PLETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLETable_row(struct x25PLETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLETable_row(struct x25PLETable_data *StorageTmp)
{
	if (StorageTmp->x25PLETable_request == sa_request)
		return;
	StorageTmp->x25PLETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEoperationalState);
		return (u_char *) &StorageTmp->x25PLEoperationalState;
	case X25PLEADMINISTRATIVESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEadministrativeState);
		return (u_char *) &StorageTmp->x25PLEadministrativeState;
	case X25PLEPROTOCOLVERSIONSUPPORTED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEprotocolVersionSupportedLen;
		return (u_char *) StorageTmp->x25PLEprotocolVersionSupported;
	case X25PLELOCALDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLElocalDTEAddressLen;
		return (u_char *) StorageTmp->x25PLElocalDTEAddress;
	case X25PLEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEMode);
		return (u_char *) &StorageTmp->x25PLEMode;
	case X25PLEDEFAULTTHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdefaultThroughputClassesLen;
		return (u_char *) StorageTmp->x25PLEdefaultThroughputClasses;
	case X25PLEFLOWCONTROLPARAMETERNEGOTIATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEflowControlParameterNegotiationLen;
		return (u_char *) StorageTmp->x25PLEflowControlParameterNegotiation;
	case X25PLEDEFAULTPACKAGESIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdefaultPackageSizesLen;
		return (u_char *) StorageTmp->x25PLEdefaultPackageSizes;
	case X25PLETHROUGHPUTCLASSNEGOTIATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEthroughputClassNegotiationLen;
		return (u_char *) StorageTmp->x25PLEthroughputClassNegotiation;
	case X25PLESNSERVICEPROVIDER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEsNserviceProviderLen;
		return (u_char *) StorageTmp->x25PLEsNserviceProvider;
	case X25PLESNSAP:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEsNsAPLen;
		return (u_char *) StorageTmp->x25PLEsNsAP;
	case X25PELOGICALCHANNELASSIGNMENTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PElogicalChannelAssignmentsLen;
		return (u_char *) StorageTmp->x25PElogicalChannelAssignments;
	case X25PLEINTERFACEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEinterfaceMode);
		return (u_char *) &StorageTmp->x25PLEinterfaceMode;
	case X25PLEDEFAULTTHROUGHPUTCLASS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdefaultThroughputClassLen;
		return (u_char *) StorageTmp->x25PLEdefaultThroughputClass;
	case X25PLEFLOWCONTROLNEGOTIATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEflowControlNegotiationPermittedLen;
		return (u_char *) StorageTmp->x25PLEflowControlNegotiationPermitted;
	case X25PLECALLDEFLECTIONSUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEcallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLEcallDeflectionSubscription;
	case X25PLEMAXACTIVECIRCUITS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEmaxActiveCircuitsLen;
		return (u_char *) StorageTmp->x25PLEmaxActiveCircuits;
	case X25PLERESTARTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLErestartTimeLen;
		return (u_char *) StorageTmp->x25PLErestartTime;
	case X25PLEDEFAULTPACKETSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdefaultPacketSizeLen;
		return (u_char *) StorageTmp->x25PLEdefaultPacketSize;
	case X25PLEDEFAULTWINDOWSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdefaultWindowSizeLen;
		return (u_char *) StorageTmp->x25PLEdefaultWindowSize;
	case X25PLEMINIMUMRECALLTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEminimumRecallTimerLen;
		return (u_char *) StorageTmp->x25PLEminimumRecallTimer;
	case X25PLERESTARTCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLErestartCountLen;
		return (u_char *) StorageTmp->x25PLErestartCount;
	case X25PLESN_SERVICEPROVIDER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEsN_ServiceProviderLen;
		return (u_char *) StorageTmp->x25PLEsN_ServiceProvider;
	case X25PLESN_SA_P:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEsN_SA_PLen;
		return (u_char *) StorageTmp->x25PLEsN_SA_P;
	case X25PLELOGICALCHANNELASSIGNMENTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLElogicalChannelAssignmentsLen;
		return (u_char *) StorageTmp->x25PLElogicalChannelAssignments;
	case X25PLEPACKETSEQUENCING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEpacketSequencingLen;
		return (u_char *) StorageTmp->x25PLEpacketSequencing;
	case X25PLEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEoctetsSentCounterLen;
		return (u_char *) StorageTmp->x25PLEoctetsSentCounter;
	case X25PLEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEoctetsReceivedCounterLen;
		return (u_char *) StorageTmp->x25PLEoctetsReceivedCounter;
	case X25PLEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdataPacketsSentLen;
		return (u_char *) StorageTmp->x25PLEdataPacketsSent;
	case X25PLEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdataPacketsReceivedLen;
		return (u_char *) StorageTmp->x25PLEdataPacketsReceived;
	case X25PLECALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEcallAttemptsLen;
		return (u_char *) StorageTmp->x25PLEcallAttempts;
	case X25PLECALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEcallsConnectedLen;
		return (u_char *) StorageTmp->x25PLEcallsConnected;
	case X25PLEPROVIDERINITIATEDDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEproviderInitiatedDisconnects);
		return (u_char *) &StorageTmp->x25PLEproviderInitiatedDisconnects;
	case X25PLECALLTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEcallTimeoutsLen;
		return (u_char *) StorageTmp->x25PLEcallTimeouts;
	case X25PLECLEARTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEclearTimeoutsLen;
		return (u_char *) StorageTmp->x25PLEclearTimeouts;
	case X25PLEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEremotelyInitiatedResetsLen;
		return (u_char *) StorageTmp->x25PLEremotelyInitiatedResets;
	case X25PLEDATARETRANSMISSIONTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdataRetransmissionTimerExpiriesLen;
		return (u_char *) StorageTmp->x25PLEdataRetransmissionTimerExpiries;
	case X25PLEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEproviderInitiatedResetsLen;
		return (u_char *) StorageTmp->x25PLEproviderInitiatedResets;
	case X25PLERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEresetTimeoutsLen;
		return (u_char *) StorageTmp->x25PLEresetTimeouts;
	case X25PLEREMOTELYINITIATEDRESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEremotelyInitiatedRestartsLen;
		return (u_char *) StorageTmp->x25PLEremotelyInitiatedRestarts;
	case X25PLERESTARTCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLErestartCountsExceededLen;
		return (u_char *) StorageTmp->x25PLErestartCountsExceeded;
	case X25PLEPROTOCOLERRORSDETECTEDLOCALLY:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEprotocolErrorsDetectedLocallyLen;
		return (u_char *) StorageTmp->x25PLEprotocolErrorsDetectedLocally;
	case X25PLEPROTOCOLERRORSACCUSEDOF:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEprotocolErrorsAccusedOfLen;
		return (u_char *) StorageTmp->x25PLEprotocolErrorsAccusedOf;
	case X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEcallEstablishmentRetryCountsExceededLen;
		return (u_char *) StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded;
	case X25PLECLEARCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEclearCountsExceededLen;
		return (u_char *) StorageTmp->x25PLEclearCountsExceeded;
	case X25PLEPLECLIENTMONAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEpLEClientMONameLen;
		return (u_char *) StorageTmp->x25PLEpLEClientMOName;
	case X25PLEREGISTRATIONREQUESTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEregistrationRequestTimeLen;
		return (u_char *) StorageTmp->x25PLEregistrationRequestTime;
	case X25PLEREGISTRATIONREQUESTCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEregistrationRequestCountLen;
		return (u_char *) StorageTmp->x25PLEregistrationRequestCount;
	case X25PLEREGISTRATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEregistrationPermitted);
		return (u_char *) &StorageTmp->x25PLEregistrationPermitted;
	case X25PLEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLERowStatus);
		return (u_char *) &StorageTmp->x25PLERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLE_DTETable(void)
 * @brief refresh the scalar values of the x25PLE_DTETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLE_DTETable(void)
{
	if (x25PLE_DTETable_refresh == 0)
		return;
	x25PLE_DTETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLE_DTETable_row(struct x25PLE_DTETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLE_DTETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLE_DTETable_row(struct x25PLE_DTETable_data *StorageTmp)
{
	if (StorageTmp->x25PLE_DTETable_request == sa_request)
		return;
	StorageTmp->x25PLE_DTETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLE_DTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLE_DTETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLE_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLE_DTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLE_DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLE_DTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLE_DTETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLE_DTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLE_DTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEcallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLE_DTEcallDeflectionSubscription;
	case X25PLE_DTECALLREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEcallRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE_DTEcallRequestResponseTimer;
	case X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEextendedPacketSequenceNumberingLen;
		return (u_char *) StorageTmp->x25PLE_DTEextendedPacketSequenceNumbering;
	case X25PLE_DTEMAXACTIVECIRCUITS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEmaxActiveCircuitsLen;
		return (u_char *) StorageTmp->x25PLE_DTEmaxActiveCircuits;
	case X25PLE_DTEMINIMUMRECALLTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEminimumRecallTimerLen;
		return (u_char *) StorageTmp->x25PLE_DTEminimumRecallTimer;
	case X25PLE_DTERESETREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEresetRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE_DTEresetRequestResponseTimer;
	case X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTErestartRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE_DTErestartRequestRetransmissionCount;
	case X25PLE_DTERESTARTREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTErestartRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE_DTErestartRequestResponseTimer;
	case X25PLE_DTECLEARREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEclearRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE_DTEclearRequestResponseTimer;
	case X25PLE_DTEINTERRUPTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEinterruptResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE_DTEinterruptResponseTimer;
	case X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEresetRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE_DTEresetRequestRetransmissionCount;
	case X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEclearRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE_DTEclearRequestRetransmissionCount;
	case X25PLE_DTECALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEcallAttempts);
		return (u_char *) &StorageTmp->x25PLE_DTEcallAttempts;
	case X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEprotocolErrorsDetectedLocally);
		return (u_char *) &StorageTmp->x25PLE_DTEprotocolErrorsDetectedLocally;
	case X25PLE_DTEPROTOCOLERRORSACCUSEDOF:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEprotocolErrorsAccusedOf);
		return (u_char *) &StorageTmp->x25PLE_DTEprotocolErrorsAccusedOf;
	case X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEcallEstablishmentRetryCountsExceeded);
		return (u_char *) &StorageTmp->x25PLE_DTEcallEstablishmentRetryCountsExceeded;
	case X25PLE_DTEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEoctetsReceivedCounter);
		return (u_char *) &StorageTmp->x25PLE_DTEoctetsReceivedCounter;
	case X25PLE_DTEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEoctetsSentCounter);
		return (u_char *) &StorageTmp->x25PLE_DTEoctetsSentCounter;
	case X25PLE_DTECALLTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEcallTimeouts);
		return (u_char *) &StorageTmp->x25PLE_DTEcallTimeouts;
	case X25PLE_DTECALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEcallsConnected);
		return (u_char *) &StorageTmp->x25PLE_DTEcallsConnected;
	case X25PLE_DTECLEARCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEclearCountsExceeded);
		return (u_char *) &StorageTmp->x25PLE_DTEclearCountsExceeded;
	case X25PLE_DTECLEARTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEclearTimeouts);
		return (u_char *) &StorageTmp->x25PLE_DTEclearTimeouts;
	case X25PLE_DTEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEdataPacketsReceived);
		return (u_char *) &StorageTmp->x25PLE_DTEdataPacketsReceived;
	case X25PLE_DTEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEdataPacketsSent);
		return (u_char *) &StorageTmp->x25PLE_DTEdataPacketsSent;
	case X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEdataRetransmissionTimerExpiries);
		return (u_char *) &StorageTmp->x25PLE_DTEdataRetransmissionTimerExpiries;
	case X25PLE_DTEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEproviderInitiatedResets);
		return (u_char *) &StorageTmp->x25PLE_DTEproviderInitiatedResets;
	case X25PLE_DTEPROVIDERINITIATEDDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEproviderInitiatedDisconnects);
		return (u_char *) &StorageTmp->x25PLE_DTEproviderInitiatedDisconnects;
	case X25PLE_DTEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEremotelyInitiatedResets);
		return (u_char *) &StorageTmp->x25PLE_DTEremotelyInitiatedResets;
	case X25PLE_DTEREMOTELYINITIATEDRESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEremotelyInitiatedRestarts);
		return (u_char *) &StorageTmp->x25PLE_DTEremotelyInitiatedRestarts;
	case X25PLE_DTERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEresetTimeouts);
		return (u_char *) &StorageTmp->x25PLE_DTEresetTimeouts;
	case X25PLE_DTERESTARTCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTErestartCountsExceeded);
		return (u_char *) &StorageTmp->x25PLE_DTErestartCountsExceeded;
	case X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEwindowStatusTransmissionTimerLen;
		return (u_char *) StorageTmp->x25PLE_DTEwindowStatusTransmissionTimer;
	case X25PLE_DTEWINDOWROTATIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEwindowRotationTimerLen;
		return (u_char *) StorageTmp->x25PLE_DTEwindowRotationTimer;
	case X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEdataPacketRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE_DTEdataPacketRetransmissionCount;
	case X25PLE_DTEREJECTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTErejectResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE_DTErejectResponseTimer;
	case X25PLE_DTEREJECTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTErejectRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE_DTErejectRetransmissionCount;
	case X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEregistrationRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE_DTEregistrationRequestResponseTimer;
	case X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCount;
	case X25PLE_DTEREGISTRATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DTEregistrationPermitted);
		return (u_char *) &StorageTmp->x25PLE_DTEregistrationPermitted;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLE_DCETable(void)
 * @brief refresh the scalar values of the x25PLE_DCETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLE_DCETable(void)
{
	if (x25PLE_DCETable_refresh == 0)
		return;
	x25PLE_DCETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLE_DCETable_row(struct x25PLE_DCETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLE_DCETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLE_DCETable_row(struct x25PLE_DCETable_data *StorageTmp)
{
	if (StorageTmp->x25PLE_DCETable_request == sa_request)
		return;
	StorageTmp->x25PLE_DCETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLE_DCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLE_DCETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLE_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLE_DCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLE_DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLE_DCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLE_DCETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLE_DCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLE_DCECALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEcallAttempts);
		return (u_char *) &StorageTmp->x25PLE_DCEcallAttempts;
	case X25PLE_DCECALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEcallsConnected);
		return (u_char *) &StorageTmp->x25PLE_DCEcallsConnected;
	case X25PLE_DCECUG:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEcUG);
		return (u_char *) &StorageTmp->x25PLE_DCEcUG;
	case X25PLE_DCEFASTSELECTACCEPTANCE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEfastSelectAcceptance);
		return (u_char *) &StorageTmp->x25PLE_DCEfastSelectAcceptance;
	case X25PLE_DCEINCOMINGCALLSBARRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEincomingCallsBarred);
		return (u_char *) &StorageTmp->x25PLE_DCEincomingCallsBarred;
	case X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEoneWayLogicalChannelOutgoing);
		return (u_char *) &StorageTmp->x25PLE_DCEoneWayLogicalChannelOutgoing;
	case X25PLE_DCEOUTGOINGCALLSBARRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEoutgoingCallsBarred);
		return (u_char *) &StorageTmp->x25PLE_DCEoutgoingCallsBarred;
	case X25PLE_DCEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEdataPacketsReceived);
		return (u_char *) &StorageTmp->x25PLE_DCEdataPacketsReceived;
	case X25PLE_DCEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEdataPacketsSent);
		return (u_char *) &StorageTmp->x25PLE_DCEdataPacketsSent;
	case X25PLE_DCEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEinterruptPacketsReceived);
		return (u_char *) &StorageTmp->x25PLE_DCEinterruptPacketsReceived;
	case X25PLE_DCEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEinterruptPacketsSent);
		return (u_char *) &StorageTmp->x25PLE_DCEinterruptPacketsSent;
	case X25PLE_DCEINTERRUPTTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEinterruptTimerExpiries);
		return (u_char *) &StorageTmp->x25PLE_DCEinterruptTimerExpiries;
	case X25PLE_DCEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEoctetsReceivedCounter);
		return (u_char *) &StorageTmp->x25PLE_DCEoctetsReceivedCounter;
	case X25PLE_DCEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEoctetsSentCounter);
		return (u_char *) &StorageTmp->x25PLE_DCEoctetsSentCounter;
	case X25PLE_DCEPROVIDERINITIATEDDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEproviderInitiatedDisconnects);
		return (u_char *) &StorageTmp->x25PLE_DCEproviderInitiatedDisconnects;
	case X25PLE_DCEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEproviderInitiatedResets);
		return (u_char *) &StorageTmp->x25PLE_DCEproviderInitiatedResets;
	case X25PLE_DCEREMOTELYINITIATEDRESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEremotelyInitiatedRestarts);
		return (u_char *) &StorageTmp->x25PLE_DCEremotelyInitiatedRestarts;
	case X25PLE_DCEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEremotelyInitiatedResets);
		return (u_char *) &StorageTmp->x25PLE_DCEremotelyInitiatedResets;
	case X25PLE_DCERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEresetTimeouts);
		return (u_char *) &StorageTmp->x25PLE_DCEresetTimeouts;
	case X25PLE_DCEX25SEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEx25SegmentsReceived);
		return (u_char *) &StorageTmp->x25PLE_DCEx25SegmentsReceived;
	case X25PLE_DCEX25SEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEx25SegmentsSent);
		return (u_char *) &StorageTmp->x25PLE_DCEx25SegmentsSent;
	case X25PLE_DCEBILATERALCUG:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEbilateralCUG);
		return (u_char *) &StorageTmp->x25PLE_DCEbilateralCUG;
	case X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEbilateralCUGWithOutgoingAccess);
		return (u_char *) &StorageTmp->x25PLE_DCEbilateralCUGWithOutgoingAccess;
	case X25PLE_DCECALLDEFLECTIONSUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEcallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLE_DCEcallDeflectionSubscription;
	case X25PLE_DCECALLREDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEcallRedirection);
		return (u_char *) &StorageTmp->x25PLE_DCEcallRedirection;
	case X25PLE_DCECHARGINGINFORMATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEchargingInformation);
		return (u_char *) &StorageTmp->x25PLE_DCEchargingInformation;
	case X25PLE_DCECUGWITHINCOMINGACCESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEcUGWithIncomingAccess);
		return (u_char *) &StorageTmp->x25PLE_DCEcUGWithIncomingAccess;
	case X25PLE_DCECUGWITHOUTGOINGACCESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEcUGWithOutgoingAccess);
		return (u_char *) &StorageTmp->x25PLE_DCEcUGWithOutgoingAccess;
	case X25PLE_DCEDBITMODIFICATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEdBitModification);
		return (u_char *) &StorageTmp->x25PLE_DCEdBitModification;
	case X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignmentLen;
		return (u_char *) StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignment;
	case X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DCEextendedPacketSequenceNumberingLen;
		return (u_char *) StorageTmp->x25PLE_DCEextendedPacketSequenceNumbering;
	case X25PLE_DCEHUNTGROUP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEhuntGroup);
		return (u_char *) &StorageTmp->x25PLE_DCEhuntGroup;
	case X25PLE_DCEINCOMINGCALLBARREDWITHINCUG:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEincomingCallBarredWithinCUG);
		return (u_char *) &StorageTmp->x25PLE_DCEincomingCallBarredWithinCUG;
	case X25PLE_DCELOCALCHARGINGPREVENTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCElocalChargingPrevention);
		return (u_char *) &StorageTmp->x25PLE_DCElocalChargingPrevention;
	case X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizesLen;
		return (u_char *) StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizes;
	case X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizesLen;
		return (u_char *) StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizes;
	case X25PLE_DCENUIOVERRIDE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEnUIOverride);
		return (u_char *) &StorageTmp->x25PLE_DCEnUIOverride;
	case X25PLE_DCENUISUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEnUISubscription);
		return (u_char *) &StorageTmp->x25PLE_DCEnUISubscription;
	case X25PLE_DCEONEWAYLOGICALCHANNELINCOMING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEoneWayLogicalChannelIncoming);
		return (u_char *) &StorageTmp->x25PLE_DCEoneWayLogicalChannelIncoming;
	case X25PLE_DCEONLINEFACILITYREGISTRATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEonlineFacilityRegistration);
		return (u_char *) &StorageTmp->x25PLE_DCEonlineFacilityRegistration;
	case X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEoutgoingCallBarredWithinCUG);
		return (u_char *) &StorageTmp->x25PLE_DCEoutgoingCallBarredWithinCUG;
	case X25PLE_DCEPACKETRETRANSMISSION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEpacketRetransmission);
		return (u_char *) &StorageTmp->x25PLE_DCEpacketRetransmission;
	case X25PLE_DCEREVERSECHARGINGACCEPTANCE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEreverseChargingAcceptance);
		return (u_char *) &StorageTmp->x25PLE_DCEreverseChargingAcceptance;
	case X25PLE_DCEROASUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCErOASubscription);
		return (u_char *) &StorageTmp->x25PLE_DCErOASubscription;
	case X25PLE_DCECLEARINDICATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE_DCEclearIndication);
		return (u_char *) &StorageTmp->x25PLE_DCEclearIndication;
	case X25PLE_DCEINCOMINGCALL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DCEincomingCallLen;
		return (u_char *) StorageTmp->x25PLE_DCEincomingCall;
	case X25PLE_DCERESETINDICATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DCEresetIndicationLen;
		return (u_char *) StorageTmp->x25PLE_DCEresetIndication;
	case X25PLE_DCERESTARTINDICATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE_DCErestartIndicationLen;
		return (u_char *) StorageTmp->x25PLE_DCErestartIndication;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEIVMOTable(void)
 * @brief refresh the scalar values of the x25PLEIVMOTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMOTable(void)
{
	if (x25PLEIVMOTable_refresh == 0)
		return;
	x25PLEIVMOTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEIVMOTable_row(struct x25PLEIVMOTable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEIVMOTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEIVMOTable_row(struct x25PLEIVMOTable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMOTable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMOTable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEIVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEIVMOTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLEIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLEIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLEIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLEIVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEIVMOLOCALDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOlocalDTEAddressLen;
		return (u_char *) StorageTmp->x25PLEIVMOlocalDTEAddress;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOlogicalChannelAssignmentsLen;
		return (u_char *) StorageTmp->x25PLEIVMOlogicalChannelAssignments;
	case X25PLEIVMOSN_SERVICEPROVIDER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOsN_ServiceProviderLen;
		return (u_char *) StorageTmp->x25PLEIVMOsN_ServiceProvider;
	case X25PLEIVMODEFAULTPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultPacketSizesLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultPacketSizes;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultThroughputClassesLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultThroughputClasses;
	case X25PLEIVMODEFAULTWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultWindowSizesLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultWindowSizes;
	case X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOflowControlParameterNegotiationLen;
		return (u_char *) StorageTmp->x25PLEIVMOflowControlParameterNegotiation;
	case X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOthroughputClassNegotiationLen;
		return (u_char *) StorageTmp->x25PLEIVMOthroughputClassNegotiation;
	case X25PLEIVMOX25PLEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOx25PLEModeLen;
		return (u_char *) StorageTmp->x25PLEIVMOx25PLEMode;
	case X25PLEIVMOINTERFACEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMOinterfaceMode);
		return (u_char *) &StorageTmp->x25PLEIVMOinterfaceMode;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultThroughputClassLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultThroughputClass;
	case X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOflowControlNegotiationPermittedLen;
		return (u_char *) StorageTmp->x25PLEIVMOflowControlNegotiationPermitted;
	case X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMOcallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLEIVMOcallDeflectionSubscription;
	case X25PLEIVMOMAXACTIVECIRCUITS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOmaxActiveCircuitsLen;
		return (u_char *) StorageTmp->x25PLEIVMOmaxActiveCircuits;
	case X25PLEIVMORESTARTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOrestartTimeLen;
		return (u_char *) StorageTmp->x25PLEIVMOrestartTime;
	case X25PLEIVMODEFAULTPACKETSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultPacketSizeLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultPacketSize;
	case X25PLEIVMODEFAULTWINDOWSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultWindowSizeLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultWindowSize;
	case X25PLEIVMOMINIMUMRECALLTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOminimumRecallTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMOminimumRecallTimer;
	case X25PLEIVMORESTARTCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOrestartCountLen;
		return (u_char *) StorageTmp->x25PLEIVMOrestartCount;
	case X25PLEIVMOPACKETSEQUENCING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOpacketSequencingLen;
		return (u_char *) StorageTmp->x25PLEIVMOpacketSequencing;
	case X25PLEIVMOREGISTRATIONREQUESTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOregistrationRequestTimeLen;
		return (u_char *) StorageTmp->x25PLEIVMOregistrationRequestTime;
	case X25PLEIVMOREGISTRATIONREQUESTCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOregistrationRequestCountLen;
		return (u_char *) StorageTmp->x25PLEIVMOregistrationRequestCount;
	case X25PLEIVMOREGISTRATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMOregistrationPermitted);
		return (u_char *) &StorageTmp->x25PLEIVMOregistrationPermitted;
	case X25PLEIVMOROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMORowStatus);
		return (u_char *) &StorageTmp->x25PLEIVMORowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEIVMO_DTETable(void)
 * @brief refresh the scalar values of the x25PLEIVMO_DTETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMO_DTETable(void)
{
	if (x25PLEIVMO_DTETable_refresh == 0)
		return;
	x25PLEIVMO_DTETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEIVMO_DTETable_row(struct x25PLEIVMO_DTETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEIVMO_DTETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEIVMO_DTETable_row(struct x25PLEIVMO_DTETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMO_DTETable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMO_DTETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEIVMO_DTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEIVMO_DTETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLEIVMO_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLEIVMO_DTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLEIVMO_DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMO_DTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLEIVMO_DTETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMO_DTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEcallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEcallDeflectionSubscription;
	case X25PLEIVMO_DTECALLREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimer;
	case X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumberingLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumbering;
	case X25PLEIVMO_DTEMAXACTIVECIRCUITS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEmaxActiveCircuitsLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEmaxActiveCircuits;
	case X25PLEIVMO_DTEMINIMUMRECALLTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEminimumRecallTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEminimumRecallTimer;
	case X25PLEIVMO_DTERESETREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimer;
	case X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCount;
	case X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimer;
	case X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimer;
	case X25PLEIVMO_DTEINTERRUPTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEinterruptResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEinterruptResponseTimer;
	case X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCount;
	case X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCount;
	case X25PLEIVMO_DTECALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEcallAttemptsLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEcallAttempts;
	case X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocallyLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocally;
	case X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOfLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOf;
	case X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceededLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded;
	case X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEoctetsReceivedCounter);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEoctetsReceivedCounter;
	case X25PLEIVMO_DTEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEoctetsSentCounter);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEoctetsSentCounter;
	case X25PLEIVMO_DTECALLTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEcallTimeouts);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEcallTimeouts;
	case X25PLEIVMO_DTECALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEcallsConnected);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEcallsConnected;
	case X25PLEIVMO_DTECLEARCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEclearCountsExceeded);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEclearCountsExceeded;
	case X25PLEIVMO_DTECLEARTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEclearTimeouts);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEclearTimeouts;
	case X25PLEIVMO_DTEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEdataPacketsReceived);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEdataPacketsReceived;
	case X25PLEIVMO_DTEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEdataPacketsSent);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEdataPacketsSent;
	case X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEdataRetransmissionTimerExpiries);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEdataRetransmissionTimerExpiries;
	case X25PLEIVMO_DTEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEproviderInitiatedResets);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEproviderInitiatedResets;
	case X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEproviderInitiatedDisconnects);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEproviderInitiatedDisconnects;
	case X25PLEIVMO_DTEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEremotelyInitiatedResets);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedResets;
	case X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEremotelyInitiatedRestarts);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedRestarts;
	case X25PLEIVMO_DTERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEresetTimeouts);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEresetTimeouts;
	case X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTErestartCountsExceeded);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTErestartCountsExceeded;
	case X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimer;
	case X25PLEIVMO_DTEWINDOWROTATIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEwindowRotationTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEwindowRotationTimer;
	case X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCount;
	case X25PLEIVMO_DTEREJECTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTErejectResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTErejectResponseTimer;
	case X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTErejectRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTErejectRetransmissionCount;
	case X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimer;
	case X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCount;
	case X25PLEIVMO_DTEREGISTRATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEregistrationPermitted);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTEregistrationPermitted;
	case X25PLEIVMO_DTEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTERowStatus);
		return (u_char *) &StorageTmp->x25PLEIVMO_DTERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEIVMO_DCETable(void)
 * @brief refresh the scalar values of the x25PLEIVMO_DCETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMO_DCETable(void)
{
	if (x25PLEIVMO_DCETable_refresh == 0)
		return;
	x25PLEIVMO_DCETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEIVMO_DCETable_row(struct x25PLEIVMO_DCETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEIVMO_DCETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEIVMO_DCETable_row(struct x25PLEIVMO_DCETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMO_DCETable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMO_DCETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEIVMO_DCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEIVMO_DCETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLEIVMO_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLEIVMO_DCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLEIVMO_DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMO_DCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLEIVMO_DCETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMO_DCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEIVMO_DCEROWSTATUS:
		*write_method = write_x25PLEIVMO_DCERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DCERowStatus);
		return (u_char *) &StorageTmp->x25PLEIVMO_DCERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_virtualCallTable(void)
 * @brief refresh the scalar values of the virtualCallTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCallTable(void)
{
	if (virtualCallTable_refresh == 0)
		return;
	virtualCallTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_virtualCallTable_row(struct virtualCallTable_data *StorageTmp)
 * @brief refresh the contents of the virtualCallTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualCallTable_row(struct virtualCallTable_data *StorageTmp)
{
	if (StorageTmp->virtualCallTable_request == sa_request)
		return;
	StorageTmp->virtualCallTable_request = sa_request;
}

/**
 * @fn u_char *var_virtualCallTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCallTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCallTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCallTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCallTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCallTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCallTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCallTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCALLCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallChannelLen;
		return (u_char *) StorageTmp->virtualCallChannel;
	case VIRTUALCALLPACKETSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallPacketSizeLen;
		return (u_char *) StorageTmp->virtualCallPacketSize;
	case VIRTUALCALLWINDOWSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallWindowSizeLen;
		return (u_char *) StorageTmp->virtualCallWindowSize;
	case VIRTUALCALLOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallOctetsSentCounterLen;
		return (u_char *) StorageTmp->virtualCallOctetsSentCounter;
	case VIRTUALCALLOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallOctetsReceivedCounterLen;
		return (u_char *) StorageTmp->virtualCallOctetsReceivedCounter;
	case VIRTUALCALLDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallDataPacketsSentLen;
		return (u_char *) StorageTmp->virtualCallDataPacketsSent;
	case VIRTUALCALLDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallDataPacketsReceivedLen;
		return (u_char *) StorageTmp->virtualCallDataPacketsReceived;
	case VIRTUALCALLREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallRemotelyInitiatedResetsLen;
		return (u_char *) StorageTmp->virtualCallRemotelyInitiatedResets;
	case VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallDataRetransmissionTimerExpiriesLen;
		return (u_char *) StorageTmp->virtualCallDataRetransmissionTimerExpiries;
	case VIRTUALCALLPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallProviderInitiatedResetsLen;
		return (u_char *) StorageTmp->virtualCallProviderInitiatedResets;
	case VIRTUALCALLRESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallResetTimeoutsLen;
		return (u_char *) StorageTmp->virtualCallResetTimeouts;
	case VIRTUALCALLINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallInterruptPacketsSentLen;
		return (u_char *) StorageTmp->virtualCallInterruptPacketsSent;
	case VIRTUALCALLINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallInterruptPacketsReceivedLen;
		return (u_char *) StorageTmp->virtualCallInterruptPacketsReceived;
	case VIRTUALCALLINTERRUPTTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallInterruptTimerExpiriesLen;
		return (u_char *) StorageTmp->virtualCallInterruptTimerExpiries;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_virtualCircuitTable(void)
 * @brief refresh the scalar values of the virtualCircuitTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCircuitTable(void)
{
	if (virtualCircuitTable_refresh == 0)
		return;
	virtualCircuitTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_virtualCircuitTable_row(struct virtualCircuitTable_data *StorageTmp)
 * @brief refresh the contents of the virtualCircuitTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualCircuitTable_row(struct virtualCircuitTable_data *StorageTmp)
{
	if (StorageTmp->virtualCircuitTable_request == sa_request)
		return;
	StorageTmp->virtualCircuitTable_request = sa_request;
}

/**
 * @fn u_char *var_virtualCircuitTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCircuitTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCircuitTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCircuitTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCircuitTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCircuitTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCircuitTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCIRCUITLOGICALCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCircuitLogicalChannelLen;
		return (u_char *) StorageTmp->virtualCircuitLogicalChannel;
	case VIRTUALCIRCUITPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCircuitPacketSizesLen;
		return (u_char *) StorageTmp->virtualCircuitPacketSizes;
	case VIRTUALCIRCUITTHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCircuitThroughputClassesLen;
		return (u_char *) StorageTmp->virtualCircuitThroughputClasses;
	case VIRTUALCIRCUITWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCircuitWindowSizesLen;
		return (u_char *) StorageTmp->virtualCircuitWindowSizes;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_virtualCircuit_DTETable(void)
 * @brief refresh the scalar values of the virtualCircuit_DTETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCircuit_DTETable(void)
{
	if (virtualCircuit_DTETable_refresh == 0)
		return;
	virtualCircuit_DTETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_virtualCircuit_DTETable_row(struct virtualCircuit_DTETable_data *StorageTmp)
 * @brief refresh the contents of the virtualCircuit_DTETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualCircuit_DTETable_row(struct virtualCircuit_DTETable_data *StorageTmp)
{
	if (StorageTmp->virtualCircuit_DTETable_request == sa_request)
		return;
	StorageTmp->virtualCircuit_DTETable_request = sa_request;
}

/**
 * @fn u_char *var_virtualCircuit_DTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCircuit_DTETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCircuit_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCircuit_DTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCircuit_DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCircuit_DTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCircuit_DTETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCircuit_DTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEoctetsSentCounter);
		return (u_char *) &StorageTmp->virtualCircuit_DTEoctetsSentCounter;
	case VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEoctetsReceivedCounter);
		return (u_char *) &StorageTmp->virtualCircuit_DTEoctetsReceivedCounter;
	case VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEdataPacketsReceived);
		return (u_char *) &StorageTmp->virtualCircuit_DTEdataPacketsReceived;
	case VIRTUALCIRCUIT_DTEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEdataPacketsSent);
		return (u_char *) &StorageTmp->virtualCircuit_DTEdataPacketsSent;
	case VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEdataRetransmissionTimerExpiries);
		return (u_char *) &StorageTmp->virtualCircuit_DTEdataRetransmissionTimerExpiries;
	case VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEinterruptPacketsReceived);
		return (u_char *) &StorageTmp->virtualCircuit_DTEinterruptPacketsReceived;
	case VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEinterruptPacketsSent);
		return (u_char *) &StorageTmp->virtualCircuit_DTEinterruptPacketsSent;
	case VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEinterruptTimerExpiries);
		return (u_char *) &StorageTmp->virtualCircuit_DTEinterruptTimerExpiries;
	case VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEproviderInitiatedResets);
		return (u_char *) &StorageTmp->virtualCircuit_DTEproviderInitiatedResets;
	case VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEremotelyInitiatedResets);
		return (u_char *) &StorageTmp->virtualCircuit_DTEremotelyInitiatedResets;
	case VIRTUALCIRCUIT_DTERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEresetTimeouts);
		return (u_char *) &StorageTmp->virtualCircuit_DTEresetTimeouts;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_virtualCircuit_DCETable(void)
 * @brief refresh the scalar values of the virtualCircuit_DCETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCircuit_DCETable(void)
{
	if (virtualCircuit_DCETable_refresh == 0)
		return;
	virtualCircuit_DCETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_virtualCircuit_DCETable_row(struct virtualCircuit_DCETable_data *StorageTmp)
 * @brief refresh the contents of the virtualCircuit_DCETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualCircuit_DCETable_row(struct virtualCircuit_DCETable_data *StorageTmp)
{
	if (StorageTmp->virtualCircuit_DCETable_request == sa_request)
		return;
	StorageTmp->virtualCircuit_DCETable_request = sa_request;
}

/**
 * @fn u_char *var_virtualCircuit_DCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCircuit_DCETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCircuit_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCircuit_DCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCircuit_DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCircuit_DCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCircuit_DCETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCircuit_DCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEdataPacketsReceived);
		return (u_char *) &StorageTmp->virtualCircuit_DCEdataPacketsReceived;
	case VIRTUALCIRCUIT_DCEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEdataPacketsSent);
		return (u_char *) &StorageTmp->virtualCircuit_DCEdataPacketsSent;
	case VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEinterruptPacketsReceived);
		return (u_char *) &StorageTmp->virtualCircuit_DCEinterruptPacketsReceived;
	case VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEinterruptPacketsSent);
		return (u_char *) &StorageTmp->virtualCircuit_DCEinterruptPacketsSent;
	case VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEinterruptTimerExpiries);
		return (u_char *) &StorageTmp->virtualCircuit_DCEinterruptTimerExpiries;
	case VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEoctetsReceivedCounter);
		return (u_char *) &StorageTmp->virtualCircuit_DCEoctetsReceivedCounter;
	case VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEoctetsSentCounter);
		return (u_char *) &StorageTmp->virtualCircuit_DCEoctetsSentCounter;
	case VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEproviderInitiatedDisconnects);
		return (u_char *) &StorageTmp->virtualCircuit_DCEproviderInitiatedDisconnects;
	case VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEproviderInitiatedResets);
		return (u_char *) &StorageTmp->virtualCircuit_DCEproviderInitiatedResets;
	case VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEremotelyInitiatedRestarts);
		return (u_char *) &StorageTmp->virtualCircuit_DCEremotelyInitiatedRestarts;
	case VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEremotelyInitiatedResets);
		return (u_char *) &StorageTmp->virtualCircuit_DCEremotelyInitiatedResets;
	case VIRTUALCIRCUIT_DCERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEresetTimeouts);
		return (u_char *) &StorageTmp->virtualCircuit_DCEresetTimeouts;
	case VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEx25SegmentsReceived);
		return (u_char *) &StorageTmp->virtualCircuit_DCEx25SegmentsReceived;
	case VIRTUALCIRCUIT_DCEX25SEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEx25SegmentsSent);
		return (u_char *) &StorageTmp->virtualCircuit_DCEx25SegmentsSent;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_permanentVirtualCircuitTable(void)
 * @brief refresh the scalar values of the permanentVirtualCircuitTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_permanentVirtualCircuitTable(void)
{
	if (permanentVirtualCircuitTable_refresh == 0)
		return;
	permanentVirtualCircuitTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_permanentVirtualCircuitTable_row(struct permanentVirtualCircuitTable_data *StorageTmp)
 * @brief refresh the contents of the permanentVirtualCircuitTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_permanentVirtualCircuitTable_row(struct permanentVirtualCircuitTable_data *StorageTmp)
{
	if (StorageTmp->permanentVirtualCircuitTable_request == sa_request)
		return;
	StorageTmp->permanentVirtualCircuitTable_request = sa_request;
}

/**
 * @fn u_char *var_permanentVirtualCircuitTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in permanentVirtualCircuitTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_permanentVirtualCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct permanentVirtualCircuitTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_permanentVirtualCircuitTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_permanentVirtualCircuitTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(permanentVirtualCircuitTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_permanentVirtualCircuitTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case PERMANENTVIRTUALCIRCUITCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuitChannelLen;
		return (u_char *) StorageTmp->permanentVirtualCircuitChannel;
	case PERMANENTVIRTUALCIRCUITROWSTATUS:
		*write_method = write_permanentVirtualCircuitRowStatus;
		*var_len = sizeof(StorageTmp->permanentVirtualCircuitRowStatus);
		return (u_char *) &StorageTmp->permanentVirtualCircuitRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_permanentVirtualCircuit_DTETable(void)
 * @brief refresh the scalar values of the permanentVirtualCircuit_DTETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_permanentVirtualCircuit_DTETable(void)
{
	if (permanentVirtualCircuit_DTETable_refresh == 0)
		return;
	permanentVirtualCircuit_DTETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_permanentVirtualCircuit_DTETable_row(struct permanentVirtualCircuit_DTETable_data *StorageTmp)
 * @brief refresh the contents of the permanentVirtualCircuit_DTETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_permanentVirtualCircuit_DTETable_row(struct permanentVirtualCircuit_DTETable_data *StorageTmp)
{
	if (StorageTmp->permanentVirtualCircuit_DTETable_request == sa_request)
		return;
	StorageTmp->permanentVirtualCircuit_DTETable_request = sa_request;
}

/**
 * @fn u_char *var_permanentVirtualCircuit_DTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in permanentVirtualCircuit_DTETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_permanentVirtualCircuit_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct permanentVirtualCircuit_DTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_permanentVirtualCircuit_DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_permanentVirtualCircuit_DTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(permanentVirtualCircuit_DTETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_permanentVirtualCircuit_DTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit_DTElogicalChannelLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit_DTElogicalChannel;
	case PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit_DTEpacketSizesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit_DTEpacketSizes;
	case PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit_DTEthroughputClassesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit_DTEthroughputClasses;
	case PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit_DTEwindowSizesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit_DTEwindowSizes;
	case PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->permanentVirtualCircuit_DTERowStatus);
		return (u_char *) &StorageTmp->permanentVirtualCircuit_DTERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_permanentVirtualCircuit_DCETable(void)
 * @brief refresh the scalar values of the permanentVirtualCircuit_DCETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_permanentVirtualCircuit_DCETable(void)
{
	if (permanentVirtualCircuit_DCETable_refresh == 0)
		return;
	permanentVirtualCircuit_DCETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_permanentVirtualCircuit_DCETable_row(struct permanentVirtualCircuit_DCETable_data *StorageTmp)
 * @brief refresh the contents of the permanentVirtualCircuit_DCETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_permanentVirtualCircuit_DCETable_row(struct permanentVirtualCircuit_DCETable_data *StorageTmp)
{
	if (StorageTmp->permanentVirtualCircuit_DCETable_request == sa_request)
		return;
	StorageTmp->permanentVirtualCircuit_DCETable_request = sa_request;
}

/**
 * @fn u_char *var_permanentVirtualCircuit_DCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in permanentVirtualCircuit_DCETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_permanentVirtualCircuit_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct permanentVirtualCircuit_DCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_permanentVirtualCircuit_DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_permanentVirtualCircuit_DCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(permanentVirtualCircuit_DCETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_permanentVirtualCircuit_DCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit_DCEchargingDirectionLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit_DCEchargingDirection;
	case PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit_DCElogicalChannelLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit_DCElogicalChannel;
	case PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit_DCEpacketSizesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit_DCEpacketSizes;
	case PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit_DCEthroughputClassesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit_DCEthroughputClasses;
	case PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit_DCEwindowSizesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit_DCEwindowSizes;
	case PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->permanentVirtualCircuit_DCEoperationalState);
		return (u_char *) &StorageTmp->permanentVirtualCircuit_DCEoperationalState;
	case PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddressLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddress;
	case PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannelLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannel;
	case PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->permanentVirtualCircuit_DCERowStatus);
		return (u_char *) &StorageTmp->permanentVirtualCircuit_DCERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_virtualCallIVMOTable(void)
 * @brief refresh the scalar values of the virtualCallIVMOTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCallIVMOTable(void)
{
	if (virtualCallIVMOTable_refresh == 0)
		return;
	virtualCallIVMOTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_virtualCallIVMOTable_row(struct virtualCallIVMOTable_data *StorageTmp)
 * @brief refresh the contents of the virtualCallIVMOTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualCallIVMOTable_row(struct virtualCallIVMOTable_data *StorageTmp)
{
	if (StorageTmp->virtualCallIVMOTable_request == sa_request)
		return;
	StorageTmp->virtualCallIVMOTable_request = sa_request;
}

/**
 * @fn u_char *var_virtualCallIVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCallIVMOTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCallIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCallIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCallIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCallIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCallIVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCallIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCALLIVMOFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCallIVMOfastSelect);
		return (u_char *) &StorageTmp->virtualCallIVMOfastSelect;
	case VIRTUALCALLIVMOPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOpacketSizesLen;
		return (u_char *) StorageTmp->virtualCallIVMOpacketSizes;
	case VIRTUALCALLIVMOREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOreverseChargingLen;
		return (u_char *) StorageTmp->virtualCallIVMOreverseCharging;
	case VIRTUALCALLIVMOTHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOthroughputClassesLen;
		return (u_char *) StorageTmp->virtualCallIVMOthroughputClasses;
	case VIRTUALCALLIVMOWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOwindowSizesLen;
		return (u_char *) StorageTmp->virtualCallIVMOwindowSizes;
	case VIRTUALCALLIVMOPROPOSEDPACKETSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOproposedPacketSizeLen;
		return (u_char *) StorageTmp->virtualCallIVMOproposedPacketSize;
	case VIRTUALCALLIVMOPROPOSEDWINDOWSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOproposedWindowSizeLen;
		return (u_char *) StorageTmp->virtualCallIVMOproposedWindowSize;
	case VIRTUALCALLIVMOACCEPTREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOacceptReverseChargingLen;
		return (u_char *) StorageTmp->virtualCallIVMOacceptReverseCharging;
	case VIRTUALCALLIVMOPROPOSEREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOproposeReverseChargingLen;
		return (u_char *) StorageTmp->virtualCallIVMOproposeReverseCharging;
	case VIRTUALCALLIVMOCALLTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOcallTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOcallTime;
	case VIRTUALCALLIVMORESETTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOresetTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOresetTime;
	case VIRTUALCALLIVMOCLEARTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOclearTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOclearTime;
	case VIRTUALCALLIVMOINTERRUPTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOinterruptTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOinterruptTime;
	case VIRTUALCALLIVMORESETCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOresetCountLen;
		return (u_char *) StorageTmp->virtualCallIVMOresetCount;
	case VIRTUALCALLIVMOCLEARCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOclearCountLen;
		return (u_char *) StorageTmp->virtualCallIVMOclearCount;
	case VIRTUALCALLIVMOWINDOWTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOwindowTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOwindowTime;
	case VIRTUALCALLIVMODATARETRANSMISSIONTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOdataRetransmissionTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOdataRetransmissionTime;
	case VIRTUALCALLIVMODATARETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOdataRetransmissionCountLen;
		return (u_char *) StorageTmp->virtualCallIVMOdataRetransmissionCount;
	case VIRTUALCALLIVMOREJECTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOrejectTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOrejectTime;
	case VIRTUALCALLIVMOREJECTCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOrejectCountLen;
		return (u_char *) StorageTmp->virtualCallIVMOrejectCount;
	case VIRTUALCALLIVMOROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCallIVMORowStatus);
		return (u_char *) &StorageTmp->virtualCallIVMORowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_switchedVirtualCallTable(void)
 * @brief refresh the scalar values of the switchedVirtualCallTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_switchedVirtualCallTable(void)
{
	if (switchedVirtualCallTable_refresh == 0)
		return;
	switchedVirtualCallTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_switchedVirtualCallTable_row(struct switchedVirtualCallTable_data *StorageTmp)
 * @brief refresh the contents of the switchedVirtualCallTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_switchedVirtualCallTable_row(struct switchedVirtualCallTable_data *StorageTmp)
{
	if (StorageTmp->switchedVirtualCallTable_request == sa_request)
		return;
	StorageTmp->switchedVirtualCallTable_request = sa_request;
}

/**
 * @fn u_char *var_switchedVirtualCallTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in switchedVirtualCallTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_switchedVirtualCallTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct switchedVirtualCallTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_switchedVirtualCallTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_switchedVirtualCallTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(switchedVirtualCallTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_switchedVirtualCallTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SWITCHEDVIRTUALCALLDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCalldirectionLen;
		return (u_char *) StorageTmp->switchedVirtualCalldirection;
	case SWITCHEDVIRTUALCALLREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCallremoteDTEAddressLen;
		return (u_char *) StorageTmp->switchedVirtualCallremoteDTEAddress;
	case SWITCHEDVIRTUALCALLTHROUGHPUTCLASS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCallthroughputClassLen;
		return (u_char *) StorageTmp->switchedVirtualCallthroughputClass;
	case SWITCHEDVIRTUALCALLREDIRECTREASON:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCallredirectReasonLen;
		return (u_char *) StorageTmp->switchedVirtualCallredirectReason;
	case SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCalloriginallyCalledAddressLen;
		return (u_char *) StorageTmp->switchedVirtualCalloriginallyCalledAddress;
	case SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCallcallingAddressExtensionLen;
		return (u_char *) StorageTmp->switchedVirtualCallcallingAddressExtension;
	case SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCallcalledAddressExtensionLen;
		return (u_char *) StorageTmp->switchedVirtualCallcalledAddressExtension;
	case SWITCHEDVIRTUALCALLROWSTATUS:
		*write_method = write_switchedVirtualCallRowStatus;
		*var_len = sizeof(StorageTmp->switchedVirtualCallRowStatus);
		return (u_char *) &StorageTmp->switchedVirtualCallRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_virtualCall_DTETable(void)
 * @brief refresh the scalar values of the virtualCall_DTETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCall_DTETable(void)
{
	if (virtualCall_DTETable_refresh == 0)
		return;
	virtualCall_DTETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_virtualCall_DTETable_row(struct virtualCall_DTETable_data *StorageTmp)
 * @brief refresh the contents of the virtualCall_DTETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualCall_DTETable_row(struct virtualCall_DTETable_data *StorageTmp)
{
	if (StorageTmp->virtualCall_DTETable_request == sa_request)
		return;
	StorageTmp->virtualCall_DTETable_request = sa_request;
}

/**
 * @fn u_char *var_virtualCall_DTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCall_DTETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCall_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCall_DTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCall_DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCall_DTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCall_DTETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCall_DTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCALL_DTECALLINGADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DTEcallingAddressExtensionLen;
		return (u_char *) StorageTmp->virtualCall_DTEcallingAddressExtension;
	case VIRTUALCALL_DTECALLEDADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DTEcalledAddressExtensionLen;
		return (u_char *) StorageTmp->virtualCall_DTEcalledAddressExtension;
	case VIRTUALCALL_DTEDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DTEdirectionLen;
		return (u_char *) StorageTmp->virtualCall_DTEdirection;
	case VIRTUALCALL_DTEFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCall_DTEfastSelect);
		return (u_char *) &StorageTmp->virtualCall_DTEfastSelect;
	case VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DTEoriginallyCalledAddressLen;
		return (u_char *) StorageTmp->virtualCall_DTEoriginallyCalledAddress;
	case VIRTUALCALL_DTEREDIRECTREASON:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DTEredirectReasonLen;
		return (u_char *) StorageTmp->virtualCall_DTEredirectReason;
	case VIRTUALCALL_DTEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DTEremoteDTEAddressLen;
		return (u_char *) StorageTmp->virtualCall_DTEremoteDTEAddress;
	case VIRTUALCALL_DTEREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DTEreverseChargingLen;
		return (u_char *) StorageTmp->virtualCall_DTEreverseCharging;
	case VIRTUALCALL_DTEROWSTATUS:
		*write_method = write_virtualCall_DTERowStatus;
		*var_len = sizeof(StorageTmp->virtualCall_DTERowStatus);
		return (u_char *) &StorageTmp->virtualCall_DTERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_virtualCall_DCETable(void)
 * @brief refresh the scalar values of the virtualCall_DCETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCall_DCETable(void)
{
	if (virtualCall_DCETable_refresh == 0)
		return;
	virtualCall_DCETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_virtualCall_DCETable_row(struct virtualCall_DCETable_data *StorageTmp)
 * @brief refresh the contents of the virtualCall_DCETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualCall_DCETable_row(struct virtualCall_DCETable_data *StorageTmp)
{
	if (StorageTmp->virtualCall_DCETable_request == sa_request)
		return;
	StorageTmp->virtualCall_DCETable_request = sa_request;
}

/**
 * @fn u_char *var_virtualCall_DCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCall_DCETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCall_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCall_DCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCall_DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCall_DCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCall_DCETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCall_DCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCALL_DCECHARGINGDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DCEchargingDirectionLen;
		return (u_char *) StorageTmp->virtualCall_DCEchargingDirection;
	case VIRTUALCALL_DCECUGSELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DCEcUGSelectionLen;
		return (u_char *) StorageTmp->virtualCall_DCEcUGSelection;
	case VIRTUALCALL_DCEDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DCEdirectionLen;
		return (u_char *) StorageTmp->virtualCall_DCEdirection;
	case VIRTUALCALL_DCEFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCall_DCEfastSelect);
		return (u_char *) &StorageTmp->virtualCall_DCEfastSelect;
	case VIRTUALCALL_DCEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DCEremoteDTEAddressLen;
		return (u_char *) StorageTmp->virtualCall_DCEremoteDTEAddress;
	case VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndicationLen;
		return (u_char *) StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndication;
	case VIRTUALCALL_DCEBILATERALCUGSELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DCEbilateralCUGSelectionLen;
		return (u_char *) StorageTmp->virtualCall_DCEbilateralCUGSelection;
	case VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCall_DCEcallRedirectionDeflectionNotification);
		return (u_char *) &StorageTmp->virtualCall_DCEcallRedirectionDeflectionNotification;
	case VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCall_DCEcalledLineAddressModifiedNotification);
		return (u_char *) &StorageTmp->virtualCall_DCEcalledLineAddressModifiedNotification;
	case VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelectionLen;
		return (u_char *) StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelection;
	case VIRTUALCALL_DCENUISELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DCEnUISelectionLen;
		return (u_char *) StorageTmp->virtualCall_DCEnUISelection;
	case VIRTUALCALL_DCEREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DCEreverseChargingLen;
		return (u_char *) StorageTmp->virtualCall_DCEreverseCharging;
	case VIRTUALCALL_DCEROASELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall_DCErOASelectionLen;
		return (u_char *) StorageTmp->virtualCall_DCErOASelection;
	case VIRTUALCALL_DCEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCall_DCERowStatus);
		return (u_char *) &StorageTmp->virtualCall_DCERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_dSeriesCountsTable(void)
 * @brief refresh the scalar values of the dSeriesCountsTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dSeriesCountsTable(void)
{
	if (dSeriesCountsTable_refresh == 0)
		return;
	dSeriesCountsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_dSeriesCountsTable_row(struct dSeriesCountsTable_data *StorageTmp)
 * @brief refresh the contents of the dSeriesCountsTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_dSeriesCountsTable_row(struct dSeriesCountsTable_data *StorageTmp)
{
	if (StorageTmp->dSeriesCountsTable_request == sa_request)
		return;
	StorageTmp->dSeriesCountsTable_request = sa_request;
}

/**
 * @fn u_char *var_dSeriesCountsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dSeriesCountsTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_dSeriesCountsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dSeriesCountsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_dSeriesCountsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_dSeriesCountsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(dSeriesCountsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_dSeriesCountsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DSERIESRESETREQUESTINDICATIONPACKETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->dSeriesResetRequestIndicationPackets);
		return (u_char *) &StorageTmp->dSeriesResetRequestIndicationPackets;
	case DSERIESSEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->dSeriesSegmentsSent);
		return (u_char *) &StorageTmp->dSeriesSegmentsSent;
	case DSERIESSEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->dSeriesSegmentsReceived);
		return (u_char *) &StorageTmp->dSeriesSegmentsReceived;
	case DSERIESROWSTATUS:
		*write_method = write_dSeriesRowStatus;
		*var_len = sizeof(StorageTmp->dSeriesRowStatus);
		return (u_char *) &StorageTmp->dSeriesRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_adjacencyTable(void)
 * @brief refresh the scalar values of the adjacencyTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_adjacencyTable(void)
{
	if (adjacencyTable_refresh == 0)
		return;
	adjacencyTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_adjacencyTable_row(struct adjacencyTable_data *StorageTmp)
 * @brief refresh the contents of the adjacencyTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_adjacencyTable_row(struct adjacencyTable_data *StorageTmp)
{
	if (StorageTmp->adjacencyTable_request == sa_request)
		return;
	StorageTmp->adjacencyTable_request = sa_request;
}

/**
 * @fn u_char *var_adjacencyTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in adjacencyTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_adjacencyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct adjacencyTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_adjacencyTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_adjacencyTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(adjacencyTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_adjacencyTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case ADJACENCYSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->adjacencyState);
		return (u_char *) &StorageTmp->adjacencyState;
	case NEIGHBOURSNPAADDRESS:
		*write_method = write_neighbourSNPAAddress;
		*var_len = StorageTmp->neighbourSNPAAddressLen;
		return (u_char *) StorageTmp->neighbourSNPAAddress;
	case NEIGHBOURSYSTEMTYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->neighbourSystemType);
		return (u_char *) &StorageTmp->neighbourSystemType;
	case NEIGHBOURSYSTEMIDS:
		*write_method = write_neighbourSystemIds;
		*var_len = StorageTmp->neighbourSystemIdsLen;
		return (u_char *) StorageTmp->neighbourSystemIds;
	case ADJACENCYUSAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->adjacencyUsage);
		return (u_char *) &StorageTmp->adjacencyUsage;
	case AREAADDRESSESOFNEIGHBOUR:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->areaAddressesOfNeighbourLen;
		return (u_char *) StorageTmp->areaAddressesOfNeighbour;
	case HOLDINGTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->holdingTimer);
		return (u_char *) &StorageTmp->holdingTimer;
	case PRIORITYOFNEIGHBOUR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->priorityOfNeighbour);
		return (u_char *) &StorageTmp->priorityOfNeighbour;
	case ADJACENCYROWSTATUS:
		*write_method = write_adjacencyRowStatus;
		*var_len = sizeof(StorageTmp->adjacencyRowStatus);
		return (u_char *) &StorageTmp->adjacencyRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_virtualAdjacencyTable(void)
 * @brief refresh the scalar values of the virtualAdjacencyTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualAdjacencyTable(void)
{
	if (virtualAdjacencyTable_refresh == 0)
		return;
	virtualAdjacencyTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_virtualAdjacencyTable_row(struct virtualAdjacencyTable_data *StorageTmp)
 * @brief refresh the contents of the virtualAdjacencyTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualAdjacencyTable_row(struct virtualAdjacencyTable_data *StorageTmp)
{
	if (StorageTmp->virtualAdjacencyTable_request == sa_request)
		return;
	StorageTmp->virtualAdjacencyTable_request = sa_request;
}

/**
 * @fn u_char *var_virtualAdjacencyTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualAdjacencyTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualAdjacencyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualAdjacencyTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualAdjacencyTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualAdjacencyTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualAdjacencyTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualAdjacencyTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALADJACENCYMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualAdjacencyMetric);
		return (u_char *) &StorageTmp->virtualAdjacencyMetric;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_destinationTable(void)
 * @brief refresh the scalar values of the destinationTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_destinationTable(void)
{
	if (destinationTable_refresh == 0)
		return;
	destinationTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_destinationTable_row(struct destinationTable_data *StorageTmp)
 * @brief refresh the contents of the destinationTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_destinationTable_row(struct destinationTable_data *StorageTmp)
{
	if (StorageTmp->destinationTable_request == sa_request)
		return;
	StorageTmp->destinationTable_request = sa_request;
}

/**
 * @fn u_char *var_destinationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in destinationTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_destinationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct destinationTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_destinationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_destinationTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(destinationTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_destinationTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DESTINATIONDEFAULTMETRICPATHCOST:
		*write_method = write_destinationDefaultMetricPathCost;
		*var_len = sizeof(StorageTmp->destinationDefaultMetricPathCost);
		return (u_char *) &StorageTmp->destinationDefaultMetricPathCost;
	case DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationDefaultMetricOutputAdjacencies;
		*var_len = StorageTmp->destinationDefaultMetricOutputAdjacenciesLen;
		return (u_char *) StorageTmp->destinationDefaultMetricOutputAdjacencies;
	case DESTINATIONDELAYMETRICPATHCOST:
		*write_method = write_destinationDelayMetricPathCost;
		*var_len = sizeof(StorageTmp->destinationDelayMetricPathCost);
		return (u_char *) &StorageTmp->destinationDelayMetricPathCost;
	case DESTINATIONDELAYMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationDelayMetricOutputAdjacencies;
		*var_len = StorageTmp->destinationDelayMetricOutputAdjacenciesLen;
		return (u_char *) StorageTmp->destinationDelayMetricOutputAdjacencies;
	case DESTINATIONEXPENSEMETRICPATHCOST:
		*write_method = write_destinationExpenseMetricPathCost;
		*var_len = sizeof(StorageTmp->destinationExpenseMetricPathCost);
		return (u_char *) &StorageTmp->destinationExpenseMetricPathCost;
	case DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationExpenseMetricOutputAdjacencies;
		*var_len = StorageTmp->destinationExpenseMetricOutputAdjacenciesLen;
		return (u_char *) StorageTmp->destinationExpenseMetricOutputAdjacencies;
	case DESTINATIONERRORMETRICPATHCOST:
		*write_method = write_destinationErrorMetricPathCost;
		*var_len = sizeof(StorageTmp->destinationErrorMetricPathCost);
		return (u_char *) &StorageTmp->destinationErrorMetricPathCost;
	case DESTINATIONERRORMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationErrorMetricOutputAdjacencies;
		*var_len = StorageTmp->destinationErrorMetricOutputAdjacenciesLen;
		return (u_char *) StorageTmp->destinationErrorMetricOutputAdjacencies;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_destinationSystemTable(void)
 * @brief refresh the scalar values of the destinationSystemTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_destinationSystemTable(void)
{
	if (destinationSystemTable_refresh == 0)
		return;
	destinationSystemTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_destinationSystemTable_row(struct destinationSystemTable_data *StorageTmp)
 * @brief refresh the contents of the destinationSystemTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_destinationSystemTable_row(struct destinationSystemTable_data *StorageTmp)
{
	if (StorageTmp->destinationSystemTable_request == sa_request)
		return;
	StorageTmp->destinationSystemTable_request = sa_request;
}

/**
 * @fn u_char *var_destinationSystemTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in destinationSystemTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_destinationSystemTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct destinationSystemTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_destinationSystemTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_destinationSystemTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(destinationSystemTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_destinationSystemTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DESINTATIONSYSTEMMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->desintationSystemMetric);
		return (u_char *) &StorageTmp->desintationSystemMetric;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_destinationAreaTable(void)
 * @brief refresh the scalar values of the destinationAreaTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_destinationAreaTable(void)
{
	if (destinationAreaTable_refresh == 0)
		return;
	destinationAreaTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_destinationAreaTable_row(struct destinationAreaTable_data *StorageTmp)
 * @brief refresh the contents of the destinationAreaTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_destinationAreaTable_row(struct destinationAreaTable_data *StorageTmp)
{
	if (StorageTmp->destinationAreaTable_request == sa_request)
		return;
	StorageTmp->destinationAreaTable_request = sa_request;
}

/**
 * @fn u_char *var_destinationAreaTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in destinationAreaTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_destinationAreaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct destinationAreaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_destinationAreaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_destinationAreaTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(destinationAreaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_destinationAreaTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DESTINATIONAREAID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->destinationAreaIdLen;
		return (u_char *) StorageTmp->destinationAreaId;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_reachableAddressTable(void)
 * @brief refresh the scalar values of the reachableAddressTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_reachableAddressTable(void)
{
	if (reachableAddressTable_refresh == 0)
		return;
	reachableAddressTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_reachableAddressTable_row(struct reachableAddressTable_data *StorageTmp)
 * @brief refresh the contents of the reachableAddressTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_reachableAddressTable_row(struct reachableAddressTable_data *StorageTmp)
{
	if (StorageTmp->reachableAddressTable_request == sa_request)
		return;
	StorageTmp->reachableAddressTable_request = sa_request;
}

/**
 * @fn u_char *var_reachableAddressTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in reachableAddressTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_reachableAddressTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct reachableAddressTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_reachableAddressTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_reachableAddressTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(reachableAddressTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_reachableAddressTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case REACHABLEADDRESSPREFIX:
		*write_method = write_reachableAddressPrefix;
		*var_len = StorageTmp->reachableAddressPrefixLen;
		return (u_char *) StorageTmp->reachableAddressPrefix;
	case REACHABLEADDRESSMAPPINGTYPE:
		*write_method = write_reachableAddressMappingType;
		*var_len = sizeof(StorageTmp->reachableAddressMappingType);
		return (u_char *) &StorageTmp->reachableAddressMappingType;
	case REACHABLEADDRESSDEFAULTMETRIC:
		*write_method = write_reachableAddressDefaultMetric;
		*var_len = sizeof(StorageTmp->reachableAddressDefaultMetric);
		return (u_char *) &StorageTmp->reachableAddressDefaultMetric;
	case REACHABLEADDRESSDELAYMETRIC:
		*write_method = write_reachableAddressDelayMetric;
		*var_len = sizeof(StorageTmp->reachableAddressDelayMetric);
		return (u_char *) &StorageTmp->reachableAddressDelayMetric;
	case REACHABLEADDRESSEXPENSEMETRIC:
		*write_method = write_reachableAddressExpenseMetric;
		*var_len = sizeof(StorageTmp->reachableAddressExpenseMetric);
		return (u_char *) &StorageTmp->reachableAddressExpenseMetric;
	case REACHABLEADDRESSERRORMETRIC:
		*write_method = write_reachableAddressErrorMetric;
		*var_len = sizeof(StorageTmp->reachableAddressErrorMetric);
		return (u_char *) &StorageTmp->reachableAddressErrorMetric;
	case REACHABLEADDRESSDEFAULTMETRICTYPE:
		*write_method = write_reachableAddressDefaultMetricType;
		*var_len = sizeof(StorageTmp->reachableAddressDefaultMetricType);
		return (u_char *) &StorageTmp->reachableAddressDefaultMetricType;
	case REACHABLEADDRESSDELAYMETRICTYPE:
		*write_method = write_reachableAddressDelayMetricType;
		*var_len = sizeof(StorageTmp->reachableAddressDelayMetricType);
		return (u_char *) &StorageTmp->reachableAddressDelayMetricType;
	case REACHABLEADDRESSEXPENSEMETRICTYPE:
		*write_method = write_reachableAddressExpenseMetricType;
		*var_len = sizeof(StorageTmp->reachableAddressExpenseMetricType);
		return (u_char *) &StorageTmp->reachableAddressExpenseMetricType;
	case REACHABLEADDRESSERRORMETRICTYPE:
		*write_method = write_reachableAddressErrorMetricType;
		*var_len = sizeof(StorageTmp->reachableAddressErrorMetricType);
		return (u_char *) &StorageTmp->reachableAddressErrorMetricType;
	case REACHABLEADDRESSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->reachableAddressOperationalState);
		return (u_char *) &StorageTmp->reachableAddressOperationalState;
	case REACHABLEADDRESSADMINISTRATIVESTATE:
		*write_method = write_reachableAddressAdministrativeState;
		*var_len = sizeof(StorageTmp->reachableAddressAdministrativeState);
		return (u_char *) &StorageTmp->reachableAddressAdministrativeState;
	case REACHABLEADDRESSSNPAADDRESSES:
		*write_method = write_reachableAddressSNPAAddresses;
		*var_len = StorageTmp->reachableAddressSNPAAddressesLen;
		return (u_char *) StorageTmp->reachableAddressSNPAAddresses;
	case REACHABLEADDRESSSNPAMASK:
		*write_method = write_reachableAddressSNPAMask;
		*var_len = StorageTmp->reachableAddressSNPAMaskLen;
		return (u_char *) StorageTmp->reachableAddressSNPAMask;
	case REACHABLEADDRESSSNPAPREFIX:
		*write_method = write_reachableAddressSNPAPrefix;
		*var_len = StorageTmp->reachableAddressSNPAPrefixLen;
		return (u_char *) StorageTmp->reachableAddressSNPAPrefix;
	case REACHABLEADDRESSROWSTATUS:
		*write_method = write_reachableAddressRowStatus;
		*var_len = sizeof(StorageTmp->reachableAddressRowStatus);
		return (u_char *) &StorageTmp->reachableAddressRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn int write_physicalEntityPhysicalEntityTitles(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_physicalEntityPhysicalEntityTitles(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct physicalEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("dlMIB", "write_physicalEntityPhysicalEntityTitles entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(physicalEntityTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalEntityPhysicalEntityTitles not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalEntityPhysicalEntityTitles: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->physicalEntityPhysicalEntityTitles;
		old_length = StorageTmp->physicalEntityPhysicalEntityTitlesLen;
		StorageTmp->physicalEntityPhysicalEntityTitles = objid;
		StorageTmp->physicalEntityPhysicalEntityTitlesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->physicalEntityPhysicalEntityTitles = old_value;
		StorageTmp->physicalEntityPhysicalEntityTitlesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitBitErrorsThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitBitErrorsThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitBitErrorsThreshold entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitBitErrorsThreshold: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OPAQUE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitBitErrorsThreshold not ASN_OPAQUE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitBitErrorsThreshold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 7..7 */
		if (string != 7) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitBitErrorsThreshold: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitBitErrorsThreshold;
		old_length = StorageTmp->dataCircuitBitErrorsThresholdLen;
		StorageTmp->dataCircuitBitErrorsThreshold = string;
		StorageTmp->dataCircuitBitErrorsThresholdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitBitErrorsThreshold = old_value;
		StorageTmp->dataCircuitBitErrorsThresholdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_dataCircuitType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case DATACIRCUITTYPE_END_SYSTEM:
		case DATACIRCUITTYPE_RELAY_SYSTEM:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitType;
		StorageTmp->dataCircuitType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitPhysicalMediaNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitPhysicalMediaNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitPhysicalMediaNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalMediaNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalMediaNames not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalMediaNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitPhysicalMediaNames;
		old_length = StorageTmp->dataCircuitPhysicalMediaNamesLen;
		StorageTmp->dataCircuitPhysicalMediaNames = string;
		StorageTmp->dataCircuitPhysicalMediaNamesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitPhysicalMediaNames = old_value;
		StorageTmp->dataCircuitPhysicalMediaNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitPhysicalInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitPhysicalInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitPhysicalInterfaceType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitPhysicalInterfaceType;
		old_length = StorageTmp->dataCircuitPhysicalInterfaceTypeLen;
		StorageTmp->dataCircuitPhysicalInterfaceType = string;
		StorageTmp->dataCircuitPhysicalInterfaceTypeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitPhysicalInterfaceType = old_value;
		StorageTmp->dataCircuitPhysicalInterfaceTypeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitPhysicalInterfaceStandard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitPhysicalInterfaceStandard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitPhysicalInterfaceStandard entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceStandard: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceStandard not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceStandard: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitPhysicalInterfaceStandard;
		old_length = StorageTmp->dataCircuitPhysicalInterfaceStandardLen;
		StorageTmp->dataCircuitPhysicalInterfaceStandard = string;
		StorageTmp->dataCircuitPhysicalInterfaceStandardLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitPhysicalInterfaceStandard = old_value;
		StorageTmp->dataCircuitPhysicalInterfaceStandardLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitSynchronizationMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitSynchronizationMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_dataCircuitSynchronizationMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitSynchronizationMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitSynchronizationMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitSynchronizationMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case DATACIRCUITSYNCHRONIZATIONMODE_SYNCHRONOUS:
		case DATACIRCUITSYNCHRONIZATIONMODE_ASYNCHRONOUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitSynchronizationMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitSynchronizationMode;
		StorageTmp->dataCircuitSynchronizationMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitSynchronizationMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitTransmissionCoding(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitTransmissionCoding(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitTransmissionCoding entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionCoding: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionCoding not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionCoding: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitTransmissionCoding;
		old_length = StorageTmp->dataCircuitTransmissionCodingLen;
		StorageTmp->dataCircuitTransmissionCoding = string;
		StorageTmp->dataCircuitTransmissionCodingLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitTransmissionCoding = old_value;
		StorageTmp->dataCircuitTransmissionCodingLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitTransmissionMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitTransmissionMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_dataCircuitTransmissionMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case DATACIRCUITTRANSMISSIONMODE_SIMPLEX:
		case DATACIRCUITTRANSMISSIONMODE_DUPLEX:
		case DATACIRCUITTRANSMISSIONMODE_HALF_DUPLEX:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitTransmissionMode;
		StorageTmp->dataCircuitTransmissionMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitTransmissionMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionRate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OPAQUE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionRate not ASN_OPAQUE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 7..7 */
		if (string != 7) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitTransmissionRate;
		old_length = StorageTmp->dataCircuitTransmissionRateLen;
		StorageTmp->dataCircuitTransmissionRate = string;
		StorageTmp->dataCircuitTransmissionRateLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitTransmissionRate = old_value;
		StorageTmp->dataCircuitTransmissionRateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_physicalConnectionEndpointIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_physicalConnectionEndpointIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct physicalConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_physicalConnectionEndpointIdentifier entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(physicalConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->physicalConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionEndpointIdentifier: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionEndpointIdentifier not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionEndpointIdentifier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->physicalConnectionEndpointIdentifier;
		old_length = StorageTmp->physicalConnectionEndpointIdentifierLen;
		StorageTmp->physicalConnectionEndpointIdentifier = string;
		StorageTmp->physicalConnectionEndpointIdentifierLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->physicalConnectionEndpointIdentifier = old_value;
		StorageTmp->physicalConnectionEndpointIdentifierLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_physicalConnectionPortNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_physicalConnectionPortNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct physicalConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_physicalConnectionPortNumber entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(physicalConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->physicalConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionPortNumber: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionPortNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionPortNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->physicalConnectionPortNumber;
		StorageTmp->physicalConnectionPortNumber = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->physicalConnectionPortNumber = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_datalinkEntityProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_datalinkEntityProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct datalinkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("dlMIB", "write_datalinkEntityProviderEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(datalinkEntityTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->datalinkEntityRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityProviderEntityNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->datalinkEntityProviderEntityNames;
		old_length = StorageTmp->datalinkEntityProviderEntityNamesLen;
		StorageTmp->datalinkEntityProviderEntityNames = objid;
		StorageTmp->datalinkEntityProviderEntityNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->datalinkEntityProviderEntityNames = old_value;
		StorageTmp->datalinkEntityProviderEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmT1Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT1Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmT1Timer;
		StorageTmp->lAPBDLEmT1Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT1Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmT3Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT3Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmT3Timer;
		StorageTmp->lAPBDLEmT3Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT3Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmW(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmW(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmW entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmW: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmW not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmW: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmW;
		StorageTmp->lAPBDLEmW = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmW = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmXSend(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmXSend(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmXSend entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXSend: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXSend not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXSend: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmXSend;
		StorageTmp->lAPBDLEmXSend = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmXSend = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmXReceive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmXReceive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmXReceive entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXReceive: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXReceive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXReceive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmXReceive;
		StorageTmp->lAPBDLEmXReceive = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmXReceive = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmT2Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT2Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmT2Timer;
		StorageTmp->lAPBDLEmT2Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT2Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPPMadministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPPMadministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPPMTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPPMadministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPPMTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPPMRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMadministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMadministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMadministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPPMADMINISTRATIVESTATE_LOCKED:
		case SLPPMADMINISTRATIVESTATE_UNLOCKED:
		case SLPPMADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMadministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPPMadministrativeState;
		StorageTmp->sLPPMadministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPPMadministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionInterfaceType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionInterfaceType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPCONNECTIONINTERFACETYPE_DTE:
		case SLPCONNECTIONINTERFACETYPE_DCE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionInterfaceType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionInterfaceType;
		StorageTmp->sLPConnectionInterfaceType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionInterfaceType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionK entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionK: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionK;
		StorageTmp->sLPConnectionK = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionK = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionN1;
		StorageTmp->sLPConnectionN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionN2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionN2;
		StorageTmp->sLPConnectionN2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionN2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionSequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionSequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionSequenceModulus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionSequenceModulus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..8 128..128 */
		if (set_value != 8 && set_value != 128) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionSequenceModulus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionSequenceModulus;
		StorageTmp->sLPConnectionSequenceModulus = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionSequenceModulus = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT1Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT1Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionT1Timer;
		StorageTmp->sLPConnectionT1Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT1Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT2Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT2Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionT2Timer;
		StorageTmp->sLPConnectionT2Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT2Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT3Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT3Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionT3Timer;
		StorageTmp->sLPConnectionT3Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT3Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionT4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionT4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT4Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT4Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT4Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionT4Timer;
		StorageTmp->sLPConnectionT4Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT4Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPCONNECTIONADMINISTRATIVESTATE_LOCKED:
		case SLPCONNECTIONADMINISTRATIVESTATE_UNLOCKED:
		case SLPCONNECTIONADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionAdministrativeState;
		StorageTmp->sLPConnectionAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOinterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOinterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOinterfaceType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOinterfaceType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOinterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOinterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPCONNECTIONIVMOINTERFACETYPE_DTE:
		case SLPCONNECTIONIVMOINTERFACETYPE_DCE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOinterfaceType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOinterfaceType;
		StorageTmp->sLPConnectionIVMOinterfaceType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOinterfaceType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOk(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOk(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOk entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOk: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOk not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOk: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOk;
		StorageTmp->sLPConnectionIVMOk = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOk = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOn1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOn1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOn1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOn1;
		StorageTmp->sLPConnectionIVMOn1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOn1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOn2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOn2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOn2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOn2;
		StorageTmp->sLPConnectionIVMOn2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOn2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOsequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOsequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOsequenceModulus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOsequenceModulus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOsequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOsequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..8 128..128 */
		if (set_value != 8 && set_value != 128) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOsequenceModulus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOsequenceModulus;
		StorageTmp->sLPConnectionIVMOsequenceModulus = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOsequenceModulus = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOt1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOt1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt1Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt1Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOt1Timer;
		StorageTmp->sLPConnectionIVMOt1Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt1Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOt2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOt2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt2Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt2Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOt2Timer;
		StorageTmp->sLPConnectionIVMOt2Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt2Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOt3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOt3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt3Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt3Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOt3Timer;
		StorageTmp->sLPConnectionIVMOt3Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt3Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOt4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOt4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt4Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt4Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt4Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOt4Timer;
		StorageTmp->sLPConnectionIVMOt4Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt4Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationLLCName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationLLCName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCStationLLCName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationLLCName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationLLCName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationLLCName;
		old_length = StorageTmp->lLCStationLLCNameLen;
		StorageTmp->lLCStationLLCName = string;
		StorageTmp->lLCStationLLCNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationLLCName = old_value;
		StorageTmp->lLCStationLLCNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationSupportedServicesTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationSupportedServicesTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCStationSupportedServicesTypes entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSupportedServicesTypes not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSupportedServicesTypes: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSupportedServicesTypes: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationSupportedServicesTypes;
		old_length = StorageTmp->lLCStationSupportedServicesTypesLen;
		StorageTmp->lLCStationSupportedServicesTypes = string;
		StorageTmp->lLCStationSupportedServicesTypesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationSupportedServicesTypes = old_value;
		StorageTmp->lLCStationSupportedServicesTypesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationType1AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationType1AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationType1AcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType1AcknowledgeTimeoutValue;
		StorageTmp->lLCStationType1AcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType1AcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationType1MaximumRetryCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationType1MaximumRetryCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationType1MaximumRetryCount entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1MaximumRetryCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1MaximumRetryCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType1MaximumRetryCount;
		StorageTmp->lLCStationType1MaximumRetryCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType1MaximumRetryCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationMaximumPDUN3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationMaximumPDUN3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationMaximumPDUN3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumPDUN3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumPDUN3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationMaximumPDUN3;
		StorageTmp->lLCStationMaximumPDUN3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationMaximumPDUN3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationMaximumRetransmissions4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationMaximumRetransmissions4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationMaximumRetransmissions4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumRetransmissions4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumRetransmissions4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationMaximumRetransmissions4;
		StorageTmp->lLCStationMaximumRetransmissions4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationMaximumRetransmissions4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationReceiveVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationReceiveVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationReceiveVariableLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationReceiveVariableLifetime;
		StorageTmp->lLCStationReceiveVariableLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationReceiveVariableLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationTransmitVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationTransmitVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationTransmitVariableLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationTransmitVariableLifetime;
		StorageTmp->lLCStationTransmitVariableLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationTransmitVariableLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationType3AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationType3AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationType3AcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType3AcknowledgeTimeoutValue;
		StorageTmp->lLCStationType3AcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType3AcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationBufferSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationBufferSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationBufferSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationBufferSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationBufferSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationBufferSize;
		StorageTmp->lLCStationBufferSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationBufferSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationSTRIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationSTRIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCStationSTRIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSTRIndicator not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((1 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSTRIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (1 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSTRIndicator: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationSTRIndicator;
		old_length = StorageTmp->lLCStationSTRIndicatorLen;
		StorageTmp->lLCStationSTRIndicator = string;
		StorageTmp->lLCStationSTRIndicatorLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationSTRIndicator = old_value;
		StorageTmp->lLCStationSTRIndicatorLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationVersionNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationVersionNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationVersionNumber entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationVersionNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationVersionNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationVersionNumber;
		StorageTmp->lLCStationVersionNumber = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationVersionNumber = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupAgingEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupAgingEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupAgingEnabled entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupAgingEnabled;
		StorageTmp->rDESetupAgingEnabled = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupAgingEnabled = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupAgingValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupAgingValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupAgingValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupAgingValue;
		StorageTmp->rDESetupAgingValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupAgingValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupEnableType2Reset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupEnableType2Reset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupEnableType2Reset entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupEnableType2Reset not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupEnableType2Reset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupEnableType2Reset;
		StorageTmp->rDESetupEnableType2Reset = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupEnableType2Reset = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupMaximumRouteDescriptors(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupMaximumRouteDescriptors(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupMaximumRouteDescriptors entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumRouteDescriptors not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumRouteDescriptors: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMaximumRouteDescriptors;
		StorageTmp->rDESetupMaximumRouteDescriptors = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMaximumRouteDescriptors = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupMaximumResponseTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupMaximumResponseTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupMaximumResponseTime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMaximumResponseTime;
		StorageTmp->rDESetupMaximumResponseTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMaximumResponseTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupMinimumPDUSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupMinimumPDUSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupMinimumPDUSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMinimumPDUSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMinimumPDUSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMinimumPDUSize;
		StorageTmp->rDESetupMinimumPDUSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMinimumPDUSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupRDEHold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupRDEHold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupRDEHold entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupRDEHold;
		StorageTmp->rDESetupRDEHold = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupRDEHold = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupRDEReplace(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupRDEReplace(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupRDEReplace entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupRDEReplace;
		StorageTmp->rDESetupRDEReplace = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupRDEReplace = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupResetOnTestEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupResetOnTestEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupResetOnTestEnabled entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupResetOnTestEnabled;
		StorageTmp->rDESetupResetOnTestEnabled = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupResetOnTestEnabled = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnectionLessTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionLessTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessName;
		old_length = StorageTmp->lLCConnectionlessNameLen;
		StorageTmp->lLCConnectionlessName = string;
		StorageTmp->lLCConnectionlessNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessName = old_value;
		StorageTmp->lLCConnectionlessNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionLessTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionLessTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2Name entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Name: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2Name;
		old_length = StorageTmp->lLCConnection2NameLen;
		StorageTmp->lLCConnection2Name = string;
		StorageTmp->lLCConnection2NameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2Name = old_value;
		StorageTmp->lLCConnection2NameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2MaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2MaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2MaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2MaximumRetransmissions;
		StorageTmp->lLCConnection2MaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2MaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2ReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2ReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2ReceivedWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedWindowSize;
		StorageTmp->lLCConnection2ReceivedWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2SendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2SendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2SendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SendWindowSize;
		StorageTmp->lLCConnection2SendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2AcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2AcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2BusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2BusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2BusyStateTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2BusyStateTimeoutValue;
		StorageTmp->lLCConnection2BusyStateTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2BusyStateTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2PBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2PBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2PBitTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2PBitTimeoutValue;
		StorageTmp->lLCConnection2PBitTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2PBitTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2RejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2RejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2RejectTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2RejectTimeoutValue;
		StorageTmp->lLCConnection2RejectTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2RejectTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2Route(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2Route(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2Route entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Route not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Route: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2Route;
		old_length = StorageTmp->lLCConnection2RouteLen;
		StorageTmp->lLCConnection2Route = string;
		StorageTmp->lLCConnection2RouteLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2Route = old_value;
		StorageTmp->lLCConnection2RouteLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2KStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2KStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2KStep entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2KStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2KStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2KStep;
		StorageTmp->lLCConnection2KStep = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2KStep = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2MaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2MaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2MaxSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2MaxSendWindowSize;
		StorageTmp->lLCConnection2MaxSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2MaxSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2OptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2OptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2OptionalTolerationIPDUs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2OptionalTolerationIPDUs;
		StorageTmp->lLCConnection2OptionalTolerationIPDUs = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2OptionalTolerationIPDUs = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2AdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTION2ADMINISTRATIVESTATE_LOCKED:
		case LLCCONNECTION2ADMINISTRATIVESTATE_UNLOCKED:
		case LLCCONNECTION2ADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AdministrativeState;
		StorageTmp->lLCConnection2AdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2AlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2AlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2AlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AlarmStatus;
		old_length = StorageTmp->lLCConnection2AlarmStatusLen;
		StorageTmp->lLCConnection2AlarmStatus = string;
		StorageTmp->lLCConnection2AlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AlarmStatus = old_value;
		StorageTmp->lLCConnection2AlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaximumRetransmissions not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOMaximumRetransmissions;
		StorageTmp->lLCConnection2IVMOMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOReceivedWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOReceivedWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOReceivedWindowSize;
		StorageTmp->lLCConnection2IVMOReceivedWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOReceivedWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOSendWindowSize;
		StorageTmp->lLCConnection2IVMOSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOAcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOBusyStateTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue;
		StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOBitTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOBitTimeoutValue;
		StorageTmp->lLCConnection2IVMOBitTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOBitTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMORejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMORejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMORejectTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMORejectTimeoutValue;
		StorageTmp->lLCConnection2IVMORejectTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMORejectTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMORoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMORoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMORoute entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORoute not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMORoute;
		StorageTmp->lLCConnection2IVMORoute = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMORoute = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOKStep entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOKStep not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOKStep;
		StorageTmp->lLCConnection2IVMOKStep = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOKStep = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOMaxSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaxSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOMaxSendWindowSize;
		StorageTmp->lLCConnection2IVMOMaxSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOMaxSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOOptionalTolerationIPDUs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs;
		StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessAckMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessAckMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckReceiveResources(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessAckReceiveResources(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckReceiveResources entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckReceiveResources;
		StorageTmp->lLCConnectionlessAckReceiveResources = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckReceiveResources = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lLCConnectionlessAckIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckIVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessAckIVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckIVMOMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lLCConnectionlessAckIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumRetransmissions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_networkEntityTitles(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_networkEntityTitles(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct networkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_networkEntityTitles entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(networkEntityTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->networkEntityRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityTitles: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityTitles not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityTitles: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->networkEntityTitles;
		old_length = StorageTmp->networkEntityTitlesLen;
		StorageTmp->networkEntityTitles = string;
		StorageTmp->networkEntityTitlesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->networkEntityTitles = old_value;
		StorageTmp->networkEntityTitlesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_networkEntitySystemTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_networkEntitySystemTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct networkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_networkEntitySystemTypes entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(networkEntityTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->networkEntityRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntitySystemTypes: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntitySystemTypes not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((1 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntitySystemTypes: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (1 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntitySystemTypes: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->networkEntitySystemTypes;
		old_length = StorageTmp->networkEntitySystemTypesLen;
		StorageTmp->networkEntitySystemTypes = string;
		StorageTmp->networkEntitySystemTypesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->networkEntitySystemTypes = old_value;
		StorageTmp->networkEntitySystemTypesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cLNSAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cLNSAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cLNSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case CLNSADMINISTRATIVESTATE_LOCKED:
		case CLNSADMINISTRATIVESTATE_UNLOCKED:
		case CLNSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cLNSAdministrativeState;
		StorageTmp->cLNSAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSSupportedProtocols(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cLNSSupportedProtocols(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_cLNSSupportedProtocols entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cLNSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSSupportedProtocols: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSSupportedProtocols not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSSupportedProtocols: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cLNSSupportedProtocols;
		old_length = StorageTmp->cLNSSupportedProtocolsLen;
		StorageTmp->cLNSSupportedProtocols = string;
		StorageTmp->cLNSSupportedProtocolsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSSupportedProtocols = old_value;
		StorageTmp->cLNSSupportedProtocolsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cLNSOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_cLNSOperationalSystemType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cLNSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSOperationalSystemType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSOperationalSystemType not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((1 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (1 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSOperationalSystemType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cLNSOperationalSystemType;
		old_length = StorageTmp->cLNSOperationalSystemTypeLen;
		StorageTmp->cLNSOperationalSystemType = string;
		StorageTmp->cLNSOperationalSystemTypeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSOperationalSystemType = old_value;
		StorageTmp->cLNSOperationalSystemTypeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSMaximumLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cLNSMaximumLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cLNSMaximumLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cLNSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSMaximumLifetime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSMaximumLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSMaximumLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..255 */
		if ((1 > set_value || set_value > 255)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSMaximumLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cLNSMaximumLifetime;
		StorageTmp->cLNSMaximumLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSMaximumLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSEnableChecksum(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cLNSEnableChecksum(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cLNSEnableChecksum entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cLNSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSEnableChecksum: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSEnableChecksum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSEnableChecksum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSEnableChecksum: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cLNSEnableChecksum;
		StorageTmp->cLNSEnableChecksum = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSEnableChecksum = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cONSAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cONSAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct cONSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cONSAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cONSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cONSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case CONSADMINISTRATIVESTATE_LOCKED:
		case CONSADMINISTRATIVESTATE_UNLOCKED:
		case CONSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cONSAdministrativeState;
		StorageTmp->cONSAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cONSAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cONSOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cONSOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct cONSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_cONSOperationalSystemType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cONSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cONSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSOperationalSystemType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSOperationalSystemType not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((1 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (1 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSOperationalSystemType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cONSOperationalSystemType;
		old_length = StorageTmp->cONSOperationalSystemTypeLen;
		StorageTmp->cONSOperationalSystemType = string;
		StorageTmp->cONSOperationalSystemTypeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cONSOperationalSystemType = old_value;
		StorageTmp->cONSOperationalSystemTypeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_neighbourSNPAAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_neighbourSNPAAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct adjacencyTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_neighbourSNPAAddress entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(adjacencyTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->adjacencyRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSNPAAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSNPAAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..20 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 20))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSNPAAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->neighbourSNPAAddress;
		old_length = StorageTmp->neighbourSNPAAddressLen;
		StorageTmp->neighbourSNPAAddress = string;
		StorageTmp->neighbourSNPAAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->neighbourSNPAAddress = old_value;
		StorageTmp->neighbourSNPAAddressLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_neighbourSystemIds(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_neighbourSystemIds(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct adjacencyTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_neighbourSystemIds entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(adjacencyTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->adjacencyRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSystemIds: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSystemIds not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSystemIds: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->neighbourSystemIds;
		old_length = StorageTmp->neighbourSystemIdsLen;
		StorageTmp->neighbourSystemIds = string;
		StorageTmp->neighbourSystemIdsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->neighbourSystemIds = old_value;
		StorageTmp->neighbourSystemIdsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationDefaultMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationDefaultMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationDefaultMetricPathCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDefaultMetricPathCost;
		StorageTmp->destinationDefaultMetricPathCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDefaultMetricPathCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationDefaultMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationDefaultMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationDefaultMetricOutputAdjacencies entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDefaultMetricOutputAdjacencies;
		old_length = StorageTmp->destinationDefaultMetricOutputAdjacenciesLen;
		StorageTmp->destinationDefaultMetricOutputAdjacencies = string;
		StorageTmp->destinationDefaultMetricOutputAdjacenciesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDefaultMetricOutputAdjacencies = old_value;
		StorageTmp->destinationDefaultMetricOutputAdjacenciesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationDelayMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationDelayMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationDelayMetricPathCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDelayMetricPathCost;
		StorageTmp->destinationDelayMetricPathCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDelayMetricPathCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationDelayMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationDelayMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationDelayMetricOutputAdjacencies entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDelayMetricOutputAdjacencies;
		old_length = StorageTmp->destinationDelayMetricOutputAdjacenciesLen;
		StorageTmp->destinationDelayMetricOutputAdjacencies = string;
		StorageTmp->destinationDelayMetricOutputAdjacenciesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDelayMetricOutputAdjacencies = old_value;
		StorageTmp->destinationDelayMetricOutputAdjacenciesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationExpenseMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationExpenseMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationExpenseMetricPathCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationExpenseMetricPathCost;
		StorageTmp->destinationExpenseMetricPathCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationExpenseMetricPathCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationExpenseMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationExpenseMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationExpenseMetricOutputAdjacencies entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationExpenseMetricOutputAdjacencies;
		old_length = StorageTmp->destinationExpenseMetricOutputAdjacenciesLen;
		StorageTmp->destinationExpenseMetricOutputAdjacencies = string;
		StorageTmp->destinationExpenseMetricOutputAdjacenciesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationExpenseMetricOutputAdjacencies = old_value;
		StorageTmp->destinationExpenseMetricOutputAdjacenciesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationErrorMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationErrorMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationErrorMetricPathCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationErrorMetricPathCost;
		StorageTmp->destinationErrorMetricPathCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationErrorMetricPathCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationErrorMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationErrorMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationErrorMetricOutputAdjacencies entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationErrorMetricOutputAdjacencies;
		old_length = StorageTmp->destinationErrorMetricOutputAdjacenciesLen;
		StorageTmp->destinationErrorMetricOutputAdjacencies = string;
		StorageTmp->destinationErrorMetricOutputAdjacenciesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationErrorMetricOutputAdjacencies = old_value;
		StorageTmp->destinationErrorMetricOutputAdjacenciesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressPrefix entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressPrefix: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..21 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 21))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressPrefix;
		old_length = StorageTmp->reachableAddressPrefixLen;
		StorageTmp->reachableAddressPrefix = string;
		StorageTmp->reachableAddressPrefixLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressPrefix = old_value;
		StorageTmp->reachableAddressPrefixLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressMappingType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressMappingType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressMappingType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressMappingType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressMappingType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressMappingType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case REACHABLEADDRESSMAPPINGTYPE_NONE:
		case REACHABLEADDRESSMAPPINGTYPE_EXPLICIT:
		case REACHABLEADDRESSMAPPINGTYPE_EXTRACTIDI:
		case REACHABLEADDRESSMAPPINGTYPE_EXTRACTDSP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressMappingType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressMappingType;
		StorageTmp->reachableAddressMappingType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressMappingType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressDefaultMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressDefaultMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDefaultMetric entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 1..63 */
		if ((1 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressDefaultMetric;
		StorageTmp->reachableAddressDefaultMetric = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDefaultMetric = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressDelayMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressDelayMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDelayMetric entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressDelayMetric;
		StorageTmp->reachableAddressDelayMetric = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDelayMetric = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressExpenseMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressExpenseMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressExpenseMetric entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressExpenseMetric;
		StorageTmp->reachableAddressExpenseMetric = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressExpenseMetric = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressErrorMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressErrorMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressErrorMetric entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressErrorMetric;
		StorageTmp->reachableAddressErrorMetric = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressErrorMetric = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressDefaultMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressDefaultMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDefaultMetricType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetricType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSDEFAULTMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSDEFAULTMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressDefaultMetricType;
		StorageTmp->reachableAddressDefaultMetricType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDefaultMetricType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressDelayMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressDelayMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDelayMetricType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetricType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSDELAYMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSDELAYMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressDelayMetricType;
		StorageTmp->reachableAddressDelayMetricType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDelayMetricType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressExpenseMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressExpenseMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressExpenseMetricType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetricType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSEXPENSEMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSEXPENSEMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressExpenseMetricType;
		StorageTmp->reachableAddressExpenseMetricType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressExpenseMetricType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressErrorMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressErrorMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressErrorMetricType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetricType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSERRORMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSERRORMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressErrorMetricType;
		StorageTmp->reachableAddressErrorMetricType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressErrorMetricType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case REACHABLEADDRESSADMINISTRATIVESTATE_LOCKED:
		case REACHABLEADDRESSADMINISTRATIVESTATE_UNLOCKED:
		case REACHABLEADDRESSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressAdministrativeState;
		StorageTmp->reachableAddressAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressSNPAAddresses(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressSNPAAddresses(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressSNPAAddresses entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAAddresses: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAAddresses not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAAddresses: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressSNPAAddresses;
		old_length = StorageTmp->reachableAddressSNPAAddressesLen;
		StorageTmp->reachableAddressSNPAAddresses = string;
		StorageTmp->reachableAddressSNPAAddressesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressSNPAAddresses = old_value;
		StorageTmp->reachableAddressSNPAAddressesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressSNPAMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressSNPAMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressSNPAMask entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAMask: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAMask not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..20 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 20))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAMask: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressSNPAMask;
		old_length = StorageTmp->reachableAddressSNPAMaskLen;
		StorageTmp->reachableAddressSNPAMask = string;
		StorageTmp->reachableAddressSNPAMaskLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressSNPAMask = old_value;
		StorageTmp->reachableAddressSNPAMaskLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressSNPAPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressSNPAPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressSNPAPrefix entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAPrefix: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..21 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 21))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressSNPAPrefix;
		old_length = StorageTmp->reachableAddressSNPAPrefixLen;
		StorageTmp->reachableAddressSNPAPrefix = string;
		StorageTmp->reachableAddressSNPAPrefixLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressSNPAPrefix = old_value;
		StorageTmp->reachableAddressSNPAPrefixLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultInterfaceType entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value dTE */
		switch (set_value) {
		case SLPCONNECTIONDEFAULTINTERFACETYPE_DTE:
		case SLPCONNECTIONDEFAULTINTERFACETYPE_DCE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultInterfaceType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultInterfaceType;
		StorageTmp->sLPConnectionDefaultInterfaceType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultInterfaceType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultK entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultK;
		StorageTmp->sLPConnectionDefaultK = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultK = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultN1 entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultN1;
		StorageTmp->sLPConnectionDefaultN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultN2 entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultN2;
		StorageTmp->sLPConnectionDefaultN2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultN2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultSequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultSequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultSequenceModulus entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..8 128..128 */
		if (set_value != 8 && set_value != 128) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultSequenceModulus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultSequenceModulus;
		StorageTmp->sLPConnectionDefaultSequenceModulus = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultSequenceModulus = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT1Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT1Timer;
		StorageTmp->sLPConnectionDefaultT1Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT1Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT2Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT2Timer;
		StorageTmp->sLPConnectionDefaultT2Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT2Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT3Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT3Timer;
		StorageTmp->sLPConnectionDefaultT3Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT3Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultT4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultT4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT4Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT4Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT4Timer;
		StorageTmp->sLPConnectionDefaultT4Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT4Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultMaximumRetransmissions;
		StorageTmp->lLCConnection2DefaultMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultReceivedWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultReceivedWindowSize;
		StorageTmp->lLCConnection2DefaultReceivedWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultReceivedWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultSendWindowSize;
		StorageTmp->lLCConnection2DefaultSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultAcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultBusyStateTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue;
		StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultPBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultPBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultPBitTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultPBitTimeoutValue;
		StorageTmp->lLCConnection2DefaultPBitTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultPBitTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultRejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultRejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultRejectTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultRejectTimeoutValue;
		StorageTmp->lLCConnection2DefaultRejectTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultRejectTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultRoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultRoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dlMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultRoute entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRoute not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultRoute;
		old_length = StorageTmp->lLCConnection2DefaultRouteLen;
		StorageTmp->lLCConnection2DefaultRoute = string;
		StorageTmp->lLCConnection2DefaultRouteLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultRoute = old_value;
		StorageTmp->lLCConnection2DefaultRouteLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultKStep entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultKStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultKStep;
		StorageTmp->lLCConnection2DefaultKStep = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultKStep = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultMaxSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultMaxSendWindowSize;
		StorageTmp->lLCConnection2DefaultMaxSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultMaxSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultOptionalTolerationIPDUs entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs;
		StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckDefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnectionlessAckDefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckDefaultMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_physicalSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_physicalSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct physicalSAPTable_data *StorageTmp = NULL;
	static struct physicalSAPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(physicalSAPTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(physicalSAPTableStorage, NULL, &name[sizeof(physicalSAPTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalSAPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalSAPRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->physicalSAPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->physicalSAPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->physicalSAPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* sapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(physicalSAPTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = physicalSAPTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sapId, vp->val.string, vp->val_len);
			StorageNew->sapIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			physicalSAPTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			physicalSAPTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->physicalSAPRowStatus;
			StorageTmp->physicalSAPRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				physicalSAPTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			physicalSAPTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->physicalSAPRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			physicalSAPTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->physicalSAPRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->physicalSAPRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			physicalSAPTable_destroy(&StorageDel);
			/* physicalSAPTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dataCircuitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dataCircuitTable_data *StorageTmp = NULL;
	static struct dataCircuitTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(dataCircuitTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dataCircuitTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dataCircuitRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dataCircuitTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dataCircuitTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(dataCircuitTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = dataCircuitTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			dataCircuitTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			dataCircuitTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->dataCircuitRowStatus;
			StorageTmp->dataCircuitRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dataCircuitTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			dataCircuitTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->dataCircuitRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			dataCircuitTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dataCircuitRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dataCircuitRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			dataCircuitTable_destroy(&StorageDel);
			/* dataCircuitTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_physicalConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_physicalConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct physicalConnectionTable_data *StorageTmp = NULL;
	static struct physicalConnectionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(physicalConnectionTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(physicalConnectionTableStorage, NULL, &name[sizeof(physicalConnectionTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->physicalConnectionRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->physicalConnectionTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->physicalConnectionTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* connectionId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(physicalConnectionTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = physicalConnectionTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			physicalConnectionTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			physicalConnectionTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->physicalConnectionRowStatus;
			StorageTmp->physicalConnectionRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				physicalConnectionTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			physicalConnectionTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->physicalConnectionRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			physicalConnectionTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->physicalConnectionRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->physicalConnectionRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			physicalConnectionTable_destroy(&StorageDel);
			/* physicalConnectionTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_datalinkEntityRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_datalinkEntityRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct datalinkEntityTable_data *StorageTmp = NULL;
	static struct datalinkEntityTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(datalinkEntityTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(datalinkEntityTableStorage, NULL, &name[sizeof(datalinkEntityTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->datalinkEntityRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->datalinkEntityTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->datalinkEntityTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(datalinkEntityTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = datalinkEntityTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			datalinkEntityTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			datalinkEntityTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->datalinkEntityRowStatus;
			StorageTmp->datalinkEntityRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				datalinkEntityTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			datalinkEntityTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->datalinkEntityRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			datalinkEntityTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->datalinkEntityRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->datalinkEntityRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			datalinkEntityTable_destroy(&StorageDel);
			/* datalinkEntityTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dLSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dLSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dLSAPTable_data *StorageTmp = NULL;
	static struct dLSAPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(dLSAPTableStorage, NULL, &name[sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dLSAPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dLSAPRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dLSAPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dLSAPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dLSAPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* sapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = dLSAPTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sapId, vp->val.string, vp->val_len);
			StorageNew->sapIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			dLSAPTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			dLSAPTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->dLSAPRowStatus;
			StorageTmp->dLSAPRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dLSAPTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			dLSAPTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->dLSAPRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			dLSAPTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dLSAPRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dLSAPRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			dLSAPTable_destroy(&StorageDel);
			/* dLSAPTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_lAPBDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lAPBDLETable_data *StorageTmp = NULL;
	static struct lAPBDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lAPBDLETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(lAPBDLETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lAPBDLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lAPBDLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lAPBDLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lAPBDLETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = lAPBDLETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lAPBDLETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lAPBDLETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lAPBDLERowStatus;
			StorageTmp->lAPBDLERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				lAPBDLETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			lAPBDLETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lAPBDLERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lAPBDLETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lAPBDLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lAPBDLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lAPBDLETable_destroy(&StorageDel);
			/* lAPBDLETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sLPPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sLPPMTable_data *StorageTmp = NULL;
	static struct sLPPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sLPPMTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sLPPMTableStorage, NULL, &name[sizeof(sLPPMTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sLPPMRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sLPPMTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sLPPMTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sLPPMTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sLPPMTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sLPPMTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sLPPMTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sLPPMRowStatus;
			StorageTmp->sLPPMRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sLPPMTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sLPPMTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sLPPMRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sLPPMTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPPMRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPPMRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sLPPMTable_destroy(&StorageDel);
			/* sLPPMTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sLPConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static struct sLPConnectionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sLPConnectionTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(sLPConnectionTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sLPConnectionRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sLPConnectionTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sLPConnectionTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* connectionId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sLPConnectionTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sLPConnectionTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sLPConnectionTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sLPConnectionTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sLPConnectionRowStatus;
			StorageTmp->sLPConnectionRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sLPConnectionTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sLPConnectionTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sLPConnectionRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sLPConnectionTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPConnectionRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPConnectionRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sLPConnectionTable_destroy(&StorageDel);
			/* sLPConnectionTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sLPConnectionIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static struct sLPConnectionIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sLPConnectionIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(sLPConnectionIVMOTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMORowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sLPConnectionIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sLPConnectionIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sLPConnectionIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* connectionId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sLPConnectionIVMOTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sLPConnectionIVMOTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sLPConnectionIVMOTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sLPConnectionIVMOTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sLPConnectionIVMORowStatus;
			StorageTmp->sLPConnectionIVMORowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sLPConnectionIVMOTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sLPConnectionIVMOTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sLPConnectionIVMORowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sLPConnectionIVMOTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPConnectionIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPConnectionIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sLPConnectionIVMOTable_destroy(&StorageDel);
			/* sLPConnectionIVMOTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mACDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mACDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mACDLETable_data *StorageTmp = NULL;
	static struct mACDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mACDLETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mACDLETableStorage, NULL, &name[sizeof(mACDLETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACDLERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mACDLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mACDLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mACDLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mACDLETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mACDLETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mACDLETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mACDLETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mACDLERowStatus;
			StorageTmp->mACDLERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mACDLETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mACDLETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mACDLERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mACDLETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACDLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACDLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mACDLETable_destroy(&StorageDel);
			/* mACDLETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mACRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mACRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mACTable_data *StorageTmp = NULL;
	static struct mACTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mACTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(mACTableStorage, NULL, &name[sizeof(mACTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mACRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mACTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mACTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* mACId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mACTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = mACTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mACId, vp->val.string, vp->val_len);
			StorageNew->mACIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mACTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mACTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mACRowStatus;
			StorageTmp->mACRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mACTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			mACTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mACRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mACTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mACTable_destroy(&StorageDel);
			/* mACTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_lLCDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCDLETable_data *StorageTmp = NULL;
	static struct lLCDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCDLETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(lLCDLETableStorage, NULL, &name[sizeof(lLCDLETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCDLERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCDLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCDLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCDLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lLCDLETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = lLCDLETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCDLETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCDLETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCDLERowStatus;
			StorageTmp->lLCDLERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				lLCDLETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			lLCDLETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCDLERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCDLETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCDLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCDLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCDLETable_destroy(&StorageDel);
			/* lLCDLETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCCLPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_lLCCLPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCCLPMTable_data *StorageTmp = NULL;
	static struct lLCCLPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCCLPMTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(lLCCLPMTableStorage, NULL, &name[sizeof(lLCCLPMTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCLPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCLPMRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCCLPMRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCCLPMTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCCLPMTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* clProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lLCCLPMTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = lLCCLPMTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCCLPMTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCCLPMTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCCLPMRowStatus;
			StorageTmp->lLCCLPMRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				lLCCLPMTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			lLCCLPMTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCCLPMRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCCLPMTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCLPMRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCLPMRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCCLPMTable_destroy(&StorageDel);
			/* lLCCLPMTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCCOPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_lLCCOPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCCOPMTable_data *StorageTmp = NULL;
	static struct lLCCOPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCCOPMTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(lLCCOPMTableStorage, NULL, &name[sizeof(lLCCOPMTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCOPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCOPMRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCCOPMRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCCOPMTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCCOPMTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lLCCOPMTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = lLCCOPMTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCCOPMTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCCOPMTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCCOPMRowStatus;
			StorageTmp->lLCCOPMRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				lLCCOPMTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			lLCCOPMTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCCOPMRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCCOPMTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCOPMRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCOPMRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCCOPMTable_destroy(&StorageDel);
			/* lLCCOPMTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_lLCConnectionlessAckIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	static struct lLCConnectionlessAckIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCConnectionlessAckIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[sizeof(lLCConnectionlessAckIVMOTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMORowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCConnectionlessAckIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCConnectionlessAckIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCConnectionlessAckIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* lLCConnectionlessAckIVMOName */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lLCConnectionlessAckIVMOTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = lLCConnectionlessAckIVMOTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->lLCConnectionlessAckIVMOName, vp->val.string, vp->val_len);
			StorageNew->lLCConnectionlessAckIVMONameLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCConnectionlessAckIVMOTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCConnectionlessAckIVMOTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCConnectionlessAckIVMORowStatus;
			StorageTmp->lLCConnectionlessAckIVMORowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				lLCConnectionlessAckIVMOTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			lLCConnectionlessAckIVMOTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCConnectionlessAckIVMORowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCConnectionlessAckIVMOTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCConnectionlessAckIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCConnectionlessAckIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCConnectionlessAckIVMOTable_destroy(&StorageDel);
			/* lLCConnectionlessAckIVMOTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_networkEntityRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_networkEntityRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct networkEntityTable_data *StorageTmp = NULL;
	static struct networkEntityTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(networkEntityTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(networkEntityTableStorage, NULL, &name[sizeof(networkEntityTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->networkEntityRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->networkEntityTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->networkEntityTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(networkEntityTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = networkEntityTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			networkEntityTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			networkEntityTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->networkEntityRowStatus;
			StorageTmp->networkEntityRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				networkEntityTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			networkEntityTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->networkEntityRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			networkEntityTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->networkEntityRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->networkEntityRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			networkEntityTable_destroy(&StorageDel);
			/* networkEntityTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_nSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_nSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct nSAPTable_data *StorageTmp = NULL;
	static struct nSAPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(nSAPTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(nSAPTableStorage, NULL, &name[sizeof(nSAPTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to nSAPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to nSAPRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->nSAPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->nSAPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->nSAPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(nSAPTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = nSAPTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->sapId, vp->val.string, vp->val_len);
			StorageNew->sapIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			nSAPTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			nSAPTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->nSAPRowStatus;
			StorageTmp->nSAPRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				nSAPTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			nSAPTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->nSAPRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			nSAPTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->nSAPRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->nSAPRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			nSAPTable_destroy(&StorageDel);
			/* nSAPTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_cLNSRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cLNSTable_data *StorageTmp = NULL;
	static struct cLNSTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(cLNSTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(cLNSTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cLNSRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cLNSTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cLNSTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* clProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(cLNSTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = cLNSTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			cLNSTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			cLNSTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cLNSRowStatus;
			StorageTmp->cLNSRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				cLNSTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			cLNSTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cLNSRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			cLNSTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cLNSTable_destroy(&StorageDel);
			/* cLNSTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSISISRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_cLNSISISRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cLNSISISTable_data *StorageTmp = NULL;
	static struct cLNSISISTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(cLNSISISTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(cLNSISISTableStorage, NULL, &name[sizeof(cLNSISISTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSISISRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSISISRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cLNSISISRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cLNSISISTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cLNSISISTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* clProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(cLNSISISTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = cLNSISISTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			cLNSISISTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			cLNSISISTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cLNSISISRowStatus;
			StorageTmp->cLNSISISRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				cLNSISISTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			cLNSISISTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cLNSISISRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			cLNSISISTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSISISRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSISISRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cLNSISISTable_destroy(&StorageDel);
			/* cLNSISISTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSISISLevel2RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_cLNSISISLevel2RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cLNSISISLevel2Table_data *StorageTmp = NULL;
	static struct cLNSISISLevel2Table_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(cLNSISISLevel2Table_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(cLNSISISLevel2TableStorage, NULL, &name[sizeof(cLNSISISLevel2Table_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSISISLevel2RowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSISISLevel2RowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cLNSISISLevel2RowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cLNSISISLevel2Table_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cLNSISISLevel2Table_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(cLNSISISLevel2Table_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = cLNSISISLevel2Table_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			cLNSISISLevel2Table_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			cLNSISISLevel2Table_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cLNSISISLevel2RowStatus;
			StorageTmp->cLNSISISLevel2RowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				cLNSISISLevel2Table_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			cLNSISISLevel2Table_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cLNSISISLevel2RowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			cLNSISISLevel2Table_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSISISLevel2RowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSISISLevel2RowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cLNSISISLevel2Table_destroy(&StorageDel);
			/* cLNSISISLevel2Table_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_linkageRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_linkageRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct linkageTable_data *StorageTmp = NULL;
	static struct linkageTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(linkageTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(linkageTableStorage, NULL, &name[sizeof(linkageTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to linkageRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to linkageRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->linkageRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->linkageTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->linkageTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* protocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* linkageId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(linkageTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = linkageTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->protocolMachineId, vp->val.string, vp->val_len);
			StorageNew->protocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->linkageId, vp->val.string, vp->val_len);
			StorageNew->linkageIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			linkageTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			linkageTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->linkageRowStatus;
			StorageTmp->linkageRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				linkageTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			linkageTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->linkageRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			linkageTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->linkageRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->linkageRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			linkageTable_destroy(&StorageDel);
			/* linkageTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cONSRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_cONSRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cONSTable_data *StorageTmp = NULL;
	static struct cONSTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(cONSTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(cONSTableStorage, NULL, &name[sizeof(cONSTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cONSRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cONSTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cONSTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(cONSTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = cONSTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			cONSTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			cONSTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cONSRowStatus;
			StorageTmp->cONSRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				cONSTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			cONSTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cONSRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			cONSTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cONSRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cONSRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cONSTable_destroy(&StorageDel);
			/* cONSTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_networkConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_networkConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct networkConnectionTable_data *StorageTmp = NULL;
	static struct networkConnectionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(networkConnectionTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(networkConnectionTableStorage, NULL, &name[sizeof(networkConnectionTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkConnectionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkConnectionRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->networkConnectionRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->networkConnectionTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->networkConnectionTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* connectionId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(networkConnectionTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = networkConnectionTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			networkConnectionTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			networkConnectionTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->networkConnectionRowStatus;
			StorageTmp->networkConnectionRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				networkConnectionTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			networkConnectionTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->networkConnectionRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			networkConnectionTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->networkConnectionRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->networkConnectionRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			networkConnectionTable_destroy(&StorageDel);
			/* networkConnectionTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLETable_data *StorageTmp = NULL;
	static struct x25PLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(x25PLETableStorage, NULL, &name[sizeof(x25PLETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(x25PLETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PLETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLERowStatus;
			StorageTmp->x25PLERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PLETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLETable_destroy(&StorageDel);
			/* x25PLETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLEIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static struct x25PLEIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(x25PLEIVMOTableStorage, NULL, &name[sizeof(x25PLEIVMOTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMORowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(x25PLEIVMOTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PLEIVMOTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLEIVMOTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLEIVMOTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMORowStatus;
			StorageTmp->x25PLEIVMORowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLEIVMOTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PLEIVMOTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEIVMORowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLEIVMOTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEIVMOTable_destroy(&StorageDel);
			/* x25PLEIVMOTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMO_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLEIVMO_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMO_DTETable_data *StorageTmp = NULL;
	static struct x25PLEIVMO_DTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEIVMO_DTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(x25PLEIVMO_DTETableStorage, NULL, &name[sizeof(x25PLEIVMO_DTETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMO_DTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMO_DTERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEIVMO_DTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEIVMO_DTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEIVMO_DTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(x25PLEIVMO_DTETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PLEIVMO_DTETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLEIVMO_DTETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLEIVMO_DTETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMO_DTERowStatus;
			StorageTmp->x25PLEIVMO_DTERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLEIVMO_DTETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PLEIVMO_DTETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEIVMO_DTERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLEIVMO_DTETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMO_DTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMO_DTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEIVMO_DTETable_destroy(&StorageDel);
			/* x25PLEIVMO_DTETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMO_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLEIVMO_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMO_DCETable_data *StorageTmp = NULL;
	static struct x25PLEIVMO_DCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEIVMO_DCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(x25PLEIVMO_DCETableStorage, NULL, &name[sizeof(x25PLEIVMO_DCETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMO_DCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMO_DCERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEIVMO_DCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEIVMO_DCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEIVMO_DCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(x25PLEIVMO_DCETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PLEIVMO_DCETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLEIVMO_DCETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLEIVMO_DCETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMO_DCERowStatus;
			StorageTmp->x25PLEIVMO_DCERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLEIVMO_DCETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PLEIVMO_DCETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEIVMO_DCERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLEIVMO_DCETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMO_DCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMO_DCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEIVMO_DCETable_destroy(&StorageDel);
			/* x25PLEIVMO_DCETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_permanentVirtualCircuitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_permanentVirtualCircuitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct permanentVirtualCircuitTable_data *StorageTmp = NULL;
	static struct permanentVirtualCircuitTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(permanentVirtualCircuitTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(permanentVirtualCircuitTableStorage, NULL, &name[sizeof(permanentVirtualCircuitTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuitRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuitRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->permanentVirtualCircuitRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->permanentVirtualCircuitTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->permanentVirtualCircuitTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCallId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(permanentVirtualCircuitTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = permanentVirtualCircuitTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCallId, vp->val.string, vp->val_len);
			StorageNew->virtualCallIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			permanentVirtualCircuitTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			permanentVirtualCircuitTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->permanentVirtualCircuitRowStatus;
			StorageTmp->permanentVirtualCircuitRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				permanentVirtualCircuitTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			permanentVirtualCircuitTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->permanentVirtualCircuitRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			permanentVirtualCircuitTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuitRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuitRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			permanentVirtualCircuitTable_destroy(&StorageDel);
			/* permanentVirtualCircuitTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_permanentVirtualCircuit_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_permanentVirtualCircuit_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct permanentVirtualCircuit_DTETable_data *StorageTmp = NULL;
	static struct permanentVirtualCircuit_DTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(permanentVirtualCircuit_DTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(permanentVirtualCircuit_DTETableStorage, NULL, &name[sizeof(permanentVirtualCircuit_DTETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuit_DTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuit_DTERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->permanentVirtualCircuit_DTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->permanentVirtualCircuit_DTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->permanentVirtualCircuit_DTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCircuitId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(permanentVirtualCircuit_DTETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = permanentVirtualCircuit_DTETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			permanentVirtualCircuit_DTETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			permanentVirtualCircuit_DTETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->permanentVirtualCircuit_DTERowStatus;
			StorageTmp->permanentVirtualCircuit_DTERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				permanentVirtualCircuit_DTETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			permanentVirtualCircuit_DTETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->permanentVirtualCircuit_DTERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			permanentVirtualCircuit_DTETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuit_DTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuit_DTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			permanentVirtualCircuit_DTETable_destroy(&StorageDel);
			/* permanentVirtualCircuit_DTETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_permanentVirtualCircuit_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_permanentVirtualCircuit_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct permanentVirtualCircuit_DCETable_data *StorageTmp = NULL;
	static struct permanentVirtualCircuit_DCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(permanentVirtualCircuit_DCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(permanentVirtualCircuit_DCETableStorage, NULL, &name[sizeof(permanentVirtualCircuit_DCETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuit_DCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuit_DCERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->permanentVirtualCircuit_DCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->permanentVirtualCircuit_DCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->permanentVirtualCircuit_DCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCircuitId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(permanentVirtualCircuit_DCETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = permanentVirtualCircuit_DCETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			permanentVirtualCircuit_DCETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			permanentVirtualCircuit_DCETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->permanentVirtualCircuit_DCERowStatus;
			StorageTmp->permanentVirtualCircuit_DCERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				permanentVirtualCircuit_DCETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			permanentVirtualCircuit_DCETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->permanentVirtualCircuit_DCERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			permanentVirtualCircuit_DCETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuit_DCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuit_DCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			permanentVirtualCircuit_DCETable_destroy(&StorageDel);
			/* permanentVirtualCircuit_DCETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_virtualCallIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_virtualCallIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct virtualCallIVMOTable_data *StorageTmp = NULL;
	static struct virtualCallIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(virtualCallIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(virtualCallIVMOTableStorage, NULL, &name[sizeof(virtualCallIVMOTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCallIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCallIVMORowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->virtualCallIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->virtualCallIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->virtualCallIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCallIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(virtualCallIVMOTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = virtualCallIVMOTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCallIVMOId, vp->val.string, vp->val_len);
			StorageNew->virtualCallIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			virtualCallIVMOTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			virtualCallIVMOTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->virtualCallIVMORowStatus;
			StorageTmp->virtualCallIVMORowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				virtualCallIVMOTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			virtualCallIVMOTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->virtualCallIVMORowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			virtualCallIVMOTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCallIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCallIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			virtualCallIVMOTable_destroy(&StorageDel);
			/* virtualCallIVMOTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_switchedVirtualCallRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_switchedVirtualCallRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct switchedVirtualCallTable_data *StorageTmp = NULL;
	static struct switchedVirtualCallTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(switchedVirtualCallTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(switchedVirtualCallTableStorage, NULL, &name[sizeof(switchedVirtualCallTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to switchedVirtualCallRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to switchedVirtualCallRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->switchedVirtualCallRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->switchedVirtualCallTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->switchedVirtualCallTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCallId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(switchedVirtualCallTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = switchedVirtualCallTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCallId, vp->val.string, vp->val_len);
			StorageNew->virtualCallIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			switchedVirtualCallTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			switchedVirtualCallTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->switchedVirtualCallRowStatus;
			StorageTmp->switchedVirtualCallRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				switchedVirtualCallTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			switchedVirtualCallTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->switchedVirtualCallRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			switchedVirtualCallTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->switchedVirtualCallRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->switchedVirtualCallRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			switchedVirtualCallTable_destroy(&StorageDel);
			/* switchedVirtualCallTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_virtualCall_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_virtualCall_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct virtualCall_DTETable_data *StorageTmp = NULL;
	static struct virtualCall_DTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(virtualCall_DTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(virtualCall_DTETableStorage, NULL, &name[sizeof(virtualCall_DTETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCall_DTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCall_DTERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->virtualCall_DTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->virtualCall_DTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->virtualCall_DTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCircuitId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(virtualCall_DTETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = virtualCall_DTETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			virtualCall_DTETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			virtualCall_DTETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->virtualCall_DTERowStatus;
			StorageTmp->virtualCall_DTERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				virtualCall_DTETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			virtualCall_DTETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->virtualCall_DTERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			virtualCall_DTETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCall_DTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCall_DTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			virtualCall_DTETable_destroy(&StorageDel);
			/* virtualCall_DTETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_virtualCall_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_virtualCall_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct virtualCall_DCETable_data *StorageTmp = NULL;
	static struct virtualCall_DCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(virtualCall_DCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(virtualCall_DCETableStorage, NULL, &name[sizeof(virtualCall_DCETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCall_DCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCall_DCERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->virtualCall_DCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->virtualCall_DCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->virtualCall_DCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCircuitId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(virtualCall_DCETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = virtualCall_DCETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			virtualCall_DCETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			virtualCall_DCETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->virtualCall_DCERowStatus;
			StorageTmp->virtualCall_DCERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				virtualCall_DCETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			virtualCall_DCETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->virtualCall_DCERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			virtualCall_DCETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCall_DCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCall_DCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			virtualCall_DCETable_destroy(&StorageDel);
			/* virtualCall_DCETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dSeriesRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dSeriesRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dSeriesCountsTable_data *StorageTmp = NULL;
	static struct dSeriesCountsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(dSeriesCountsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(dSeriesCountsTableStorage, NULL, &name[sizeof(dSeriesCountsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dSeriesRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dSeriesRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dSeriesRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dSeriesCountsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dSeriesCountsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCircuitId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* dSeriesId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(dSeriesCountsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = dSeriesCountsTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->dSeriesId, vp->val.string, vp->val_len);
			StorageNew->dSeriesIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			dSeriesCountsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			dSeriesCountsTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->dSeriesRowStatus;
			StorageTmp->dSeriesRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dSeriesCountsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			dSeriesCountsTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->dSeriesRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			dSeriesCountsTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dSeriesRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dSeriesRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			dSeriesCountsTable_destroy(&StorageDel);
			/* dSeriesCountsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_adjacencyRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_adjacencyRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct adjacencyTable_data *StorageTmp = NULL;
	static struct adjacencyTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(adjacencyTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(adjacencyTableStorage, NULL, &name[sizeof(adjacencyTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to adjacencyRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to adjacencyRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->adjacencyRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->adjacencyTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->adjacencyTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* clProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* linkageId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* adjacencyId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(adjacencyTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = adjacencyTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->linkageId, vp->val.string, vp->val_len);
			StorageNew->linkageIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->adjacencyId, vp->val.string, vp->val_len);
			StorageNew->adjacencyIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			adjacencyTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			adjacencyTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->adjacencyRowStatus;
			StorageTmp->adjacencyRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				adjacencyTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			adjacencyTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->adjacencyRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			adjacencyTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->adjacencyRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->adjacencyRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			adjacencyTable_destroy(&StorageDel);
			/* adjacencyTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_reachableAddressRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct reachableAddressTable_data *StorageTmp = NULL;
	static struct reachableAddressTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(reachableAddressTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(reachableAddressTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->reachableAddressRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->reachableAddressTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->reachableAddressTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* reachableAddressId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(reachableAddressTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = reachableAddressTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->reachableAddressId, vp->val.string, vp->val_len);
			StorageNew->reachableAddressIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			reachableAddressTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			reachableAddressTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->reachableAddressRowStatus;
			StorageTmp->reachableAddressRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				reachableAddressTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			reachableAddressTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->reachableAddressRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			reachableAddressTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->reachableAddressRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->reachableAddressRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			reachableAddressTable_destroy(&StorageDel);
			/* reachableAddressTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

#if !defined MODULE
static void
sa_version(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
%2$s\n\
Copyright (c) 2008-2009  Monavacom Limited.  All Rights Reserved.\n\
Distributed under Affero GPL Version 3, included here by reference.\n\
See `%1$s --copying' for copying permissions.\n\
", argv[0], ident);
}
static void
sa_usage(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stderr, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-H|--help-directives}\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
", argv[0]);
}
static void
sa_help(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
Arguments:\n\
    None.\n\
Options:\n\
    -a, --log-addresses\n\
        log addresses of connecting management stations.\n\
    -A, --append\n\
        append to logfiles without truncating.\n\
    -c, --config-file CONFIGFILE\n\
        use configuration file CONFIGFILE.\n\
    -C, --config-only\n\
        only load configuration given by -c option.\n\
    -d, --dump\n\
        dump sent and received PDUs.\n\
    -D, --debug [LEVEL]\n\
        set debugging verbosity to LEVEL.\n\
    -D, --debug-tokens [TOKEN[,TOKEN]*]\n\
        debug specified TOKEN's.\n\
    -f, --dont-fork\n\
        run in the foreground.\n\
    -g, --gid, --groupid GID\n\
        become group GID after listening.\n\
    -h, --help, -?, --?\n\
        print usage information and exit.\n\
    -H, --help-directives\n\
        print config directives and exit.\n\
    -I, --initialize [-]MODULE[,MODULE]*\n\
        initialize (or not, '-') these MODULE's.\n\
    -k, --keep-open\n\
        keep system files open between requests.\n\
    -l, --log-file [LOGFILE]\n\
        log to log file name LOGFILE.  [default: /var/log/dlmib.log]\n\
    -L, --log-stderr\n\
        log to controlling terminal standard error.\n\
    -m, --mibs [+]MIB[,MIB]*\n\
        load these (additional '+') MIBs.\n\
    -M, --master\n\
        run as SNMP master instead of AgentX sub-agent.\n\
    -M, --mibdirs [+]MIBDIR[:MIBDIR]*\n\
        search these (additional, '+') colon separated directories for MIBs.\n\
    -n, --nodaemon\n\
        run in the foreground.\n\
    -n, --name NAME\n\
        use NAME for configuration file base.  [default: dlmib]\n\
    -p, --port PORTNUM\n\
        listen on port number PORTNUM.  [default: 161]\n\
    -p, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/dlmib.pid]\n\
    -P, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/dlmib.pid]\n\
    -q, --quiet\n\
        suppress normal output.\n\
    -q, --quick\n\
        abbreviate output for machine readability.\n\
    -r, --noroot\n\
        do not require root privilege.\n\
    -s, --log-syslog\n\
        log to system logs.\n\
    -S, --sysctl-file FILENAME\n\
        write sysctl config file FILENAME.  [default: /etc/streams.conf]\n\
    -t, --agent-alarms\n\
        agent blocks {SIGALARM}.\n\
    -T, --transport [TRANSPORT]\n\
        default transport TRANSPORT.  [default: udp]\n\
    -u, --uid, --userid UID\n\
        become user UID after listening.\n\
    -U, --dont-remove-pidfile\n\
        do not remove PIDFILE when shutting down.\n\
    -v, --version\n\
        print version information and exit.\n\
    -V, --verbose [LEVEL]\n\
        be verbose to LEVEL.  [default: 1]\n\
    -x, --agentx-socket [SOCKET]\n\
        master AgentX on SOCKET.  [default: /var/agentx/master]\n\
    -X, --agentx\n\
        run as AgentX sub-agent instead of master (the default).\n\
    -y, --copying\n\
        print copying information and exit.\n\
", argv[0]);
}
static void
sa_copying(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
--------------------------------------------------------------------------------\n\
%1$s\n\
--------------------------------------------------------------------------------\n\
Copyright (c) 2008-2009  Monavacom Limited <http://www.monavacom.com>\n\
Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com>\n\
Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>\n\
\n\
All Rights Reserved.\n\
--------------------------------------------------------------------------------\n\
This program is free software; you can  redistribute  it and/or modify  it under\n\
the terms of the GNU Affero General Public License as published by the Free\n\
Software Foundation; Version 3 of the License.\n\
\n\
This program is distributed in the hope that it will  be useful, but WITHOUT ANY\n\
WARRANTY; without even  the implied warranty of MERCHANTABILITY or FITNESS FOR A\n\
PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.\n\
\n\
You should have received a copy of the GNU  Affero  General Public License along\n\
with this program.   If not, see <http://www.gnu.org/licenses/>, or write to the\n\
Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
--------------------------------------------------------------------------------\n\
U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf\n\
of the U.S. Government (\"Government\"), the following provisions apply to you. If\n\
the Software is supplied by the  Department of Defense (\"DoD\"), it is classified\n\
as \"Commercial  Computer  Software\"  under  paragraph  252.227-7014  of the  DoD\n\
Supplement  to the  Federal Acquisition Regulations  (\"DFARS\") (or any successor\n\
regulations) and the  Government  is acquiring  only the  license rights granted\n\
herein (the license rights customarily provided to non-Government users). If the\n\
Software is supplied to any unit or agency of the Government  other than DoD, it\n\
is  classified as  \"Restricted Computer Software\" and the Government's rights in\n\
the Software  are defined  in  paragraph 52.227-19  of the  Federal  Acquisition\n\
Regulations (\"FAR\")  (or any successor regulations) or, in the cases of NASA, in\n\
paragraph  18.52.227-86 of  the  NASA  Supplement  to the FAR (or any  successor\n\
regulations).\n\
--------------------------------------------------------------------------------\n\
Commercial  licensing  and  support of this  software is  available from OpenSS7\n\
Corporation at a fee.  See http://www.openss7.com/\n\
--------------------------------------------------------------------------------\n\
", ident);
}

void
sa_help_directives(int argc, char *argv[])
{
	ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
	init_agent("dlMIB");
	// init_mib_modules();
	init_mib();
	init_snmp("dlMIB");
	snmp_log(MY_FACILITY(LOG_INFO), "Configuration directives understood:\n");
	/* Unfortunately, read_config_print_usage() uses snmp_log(), meaning that it can only be
	   writen to standard error and not standard output. */
	read_config_print_usage("    ");
}
static int
sa_sig_register(int signum, RETSIGTYPE(*handler) (int))
{
	sigset_t mask;
	struct sigaction act;

	act.sa_handler = handler ? handler : SIG_DFL;
	act.sa_flags = handler ? SA_RESTART : 0;
	sigemptyset(&act.sa_mask);
	if (sigaction(signum, &act, NULL))
		return (-1);
	sigemptyset(&mask);
	sigaddset(&mask, signum);
	sigprocmask(handler ? SIG_UNBLOCK : SIG_BLOCK, &mask, NULL);
	return (0);
}
static int sa_alm_signal = 0;
static int sa_pol_signal = 0;
static int sa_hup_signal = 0;
static int sa_int_signal = 0;
static int sa_trm_signal = 0;
static int sa_alm_handle = 0;
void
sa_alm_callback(uint req, void *arg)
{
	if (req == sa_alm_handle)
		sa_alm_handle = 0;
	sa_alm_signal = 1;
	return;
}

static RETSIGTYPE
sa_alm_handler(int signum)
{
	sa_alm_signal = 1;
	return (RETSIGTYPE) (0);
}
static void
sa_snmp_alm_handler(uint reg, void *clientarg)
{
	sa_alm_signal = 1;
	return;
}
static int
sa_alm_catch(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, &sa_alm_handler);
	return (-1);
}
static int
sa_alm_block(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, NULL);
	if (sa_alm_handle) {
		uint handle = sa_alm_handle;

		sa_alm_handle = 0;
		snmp_alarm_unregister(handle);
	}
	return (0);
}
static int
sa_alm_action(void)
{
	sa_alm_signal = 0;
	return (0);
}

static RETSIGTYPE
sa_pol_handler(int signum)
{
	sa_pol_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_pol_catch(void)
{
	return sa_sig_register(SIGPOLL, &sa_pol_handler);
}
static int
sa_pol_block(void)
{
	return sa_sig_register(SIGPOLL, NULL);
}

/*
 * Both the sc(4) module and sad(4) driver issue an M_PCSIG message with
 * SIGPOLL to the stream head whenever the STREAMS configuration or autopush
 * configuration changes, indicating to the agent which has the sc(4) or
 * sad(4) Stream open that it is necessary to reread information from the
 * kernel.  This fact is merely recorded, as this information is not read each
 * time that a configuration change occurs, but only after a request from some
 * portion of that information occurs. This condition is also set when the
 * sc(4) and sad(4) Streams are first opened. The SIGPOLL will also deliver in
 * siginfo the file descriptor issuing the signal, so we could distiguish
 * between sc(4) and sad(4) signals, but since one can be pushed over the
 * other, there is little point in distinguishing.
 *
 * sc(4) or sad(4) also should be modified to provide the general streams
 * statistics supported here; even though they are available through the /proc
 * filesystem on Linux Fast-STREAMS.
 */
static int
sa_pol_action(void)
{
	sa_pol_signal = 0;
	snmp_log(MY_FACILITY(LOG_INFO), "%s: Caught SIGPOLL, will re-read data structures", sa_program);
	sa_changed = 1;
	return (0);
}

static RETSIGTYPE
sa_hup_handler(int signum)
{
	sa_hup_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_hup_catch(void)
{
	if (sa_agentx)
		return sa_sig_register(SIGHUP, &sa_hup_handler);
	return (-1);
}
static int
sa_hup_block(void)
{
	return sa_sig_register(SIGHUP, NULL);
}
static int
sa_hup_action(void)
{
	/* There are several times that we might be sent a SIGHUP.  We might be sent a SIGHUP by
	   logrotate asking us to close and reopen our log files. */
	sa_hup_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "Caught SIGHUP, reopening files.");
	if (sa_output > 1)
		snmp_log(MY_FACILITY(LOG_NOTICE), "Reopening output file %s", sa_logfile);
	if (sa_logfillog != 0) {
		fflush(stdlog);
		fclose(stdlog);
		snmp_disable_filelog();
		if ((stdlog = freopen(sa_logfile, sa_appendlog ? "a" : "w", stdlog)) == NULL) {
			/* I hope we have another log sink. */
			snmp_log(MY_FACILITY(LOG_ERR), "%s", strerror(errno));
			snmp_log(MY_FACILITY(LOG_ERR), "Could not reopen log file %s", sa_logfile);
		}
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	return (0);
}

static RETSIGTYPE
sa_int_handler(int signum)
{
	sa_int_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_int_catch(void)
{
	return sa_sig_register(SIGINT, &sa_int_handler);
}
static int
sa_int_block(void)
{
	return sa_sig_register(SIGINT, NULL);
}
static void sa_exit(int retval);
static int
sa_int_action(void)
{
	sa_int_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGINT, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}

static RETSIGTYPE
sa_trm_handler(int signum)
{
	sa_trm_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_trm_catch(void)
{
	return sa_sig_register(SIGTERM, &sa_trm_handler);
}
static int
sa_trm_block(void)
{
	return sa_sig_register(SIGTERM, NULL);
}
static void sa_exit(int retval);
static int
sa_trm_action(void)
{
	sa_trm_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGTERM, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}
static void
sa_sig_catch(void)
{
	sa_alm_catch();
	sa_pol_catch();
	sa_hup_catch();
	sa_int_catch();
	sa_trm_catch();
}
static void
sa_sig_block(void)
{
	sa_alm_block();
	sa_pol_block();
	sa_hup_block();
	sa_int_block();
	sa_trm_block();
}

int
sa_start_timer(long duration)
{
	if (sa_alarms) {
		struct itimerval setting = {
			{0, 0},
			{duration / 1000, (duration % 1000) * 1000}
		};
		if (sa_alm_catch())
			return (-1);
		if (setitimer(ITIMER_REAL, &setting, NULL))
			return (-1);
		sa_alm_signal = 0;
		return (0);
	} else {
#if defined NETSNMP_DS_APPLICATION_ID
		struct timeval setting = {
			duration / 1000, (duration % 1000) * 1000
		};
		sa_alm_handle = snmp_alarm_register_hr(setting, 0, sa_snmp_alm_handler, NULL);
#else
		sa_alm_handle = snmp_alarm_register((duration + 999) / 1000, 0, sa_snmp_alm_handler, NULL);
#endif
		return (sa_alm_handle ? 0 : -1);
	}
}
static void
sa_exit(int retval)
{
	if (retval)
		snmp_log(MY_FACILITY(LOG_ERR), "%s: Exiting %d", sa_program, retval);
	else
		snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Exiting %d", sa_program, retval);
	fflush(stdout);
	fflush(stderr);
	sa_sig_block();
	closelog();
	exit(retval);
}
static void
sa_init_logging(int argc, char *argv[])
{
	static char progname[256];

	/* The purpose of this function is to bring logging up before forking (and while still in
	   the foreground) so that we can use the snmp_log() function before and during forking if
	   necessary.  Note that the default configuration for snmp_log() is to send all logs to
	   standard error. */
	strncpy(progname, basename(argv[0]), sizeof(progname));
	snmp_disable_log();
	if (sa_logfillog) {
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	if (sa_logstderr | sa_logstdout) {
#if defined LOG_PERROR
		/* Note that when we have Linux LOG_PERROR, and logs go both to syslog and stderr,
		   it is better to use the LOG_PERROR than to use snmp_log()'s print to stderr, as
		   the former is better formated. */
		if (!sa_logsyslog)
			snmp_enable_stderrlog();
#else				/* defined LOG_PERROR */
		snmp_enable_stderrlog();
#endif				/* defined LOG_PERROR */
	}
	if (sa_logsyslog) {
#if !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT
		snmp_enable_syslog();
#else				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		snmp_enable_syslog_ident("dlMIB", LOG_DAEMON);
#endif				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		/* Note that the way that snmp sets up the logger is not really the way we want it,
		   so close the log and reopen it the way we want. */
		closelog();
#if defined LOG_PERROR
		openlog("dlMIB", LOG_PID | LOG_CONS | LOG_NDELAY | (sa_logstderr ? LOG_PERROR : 0), MY_FACILITY(0));
#else				/* defined LOG_PERROR */
		openlog("dlMIB", LOG_PID | LOG_CONS | LOG_NDELAY, MY_FACILITY(0));
#endif				/* defined LOG_PERROR */
	}
	if (sa_logcallog) {
		snmp_enable_calllog();
	}
}
static void
sa_enter(int argc, char *argv[])
{
	if (sa_nomead) {
		pid_t pid;

		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent exits */
			exit(0);
		}
		setsid();	/* become a session leader */
		/* fork once more for SVR4 */
		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent responsible for writing pid file */
			if (sa_nomead || sa_pidfile[0] != '\0') {
				FILE *pidf;

				/* initialize default filename */
				if (sa_pidfile[0] == '\0')
					snprintf(sa_pidfile, sizeof(sa_pidfile), "/var/run/%s.pid", sa_program);
				if (sa_output > 1) {
					snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Writing daemon pid to file %s", sa_program, sa_pidfile);
				}
				if ((pidf = fopen(sa_pidfile, "w+"))) {
					fprintf(pidf, "%d", (int) pid);
					fflush(pidf);
					fclose(pidf);
				} else {
					snmp_log(MY_FACILITY(LOG_ERR), "%s: %m", sa_program);
					snmp_log(MY_FACILITY(LOG_ERR), "%s: Could not write pid to file %s", sa_program, sa_pidfile);
					sa_exit(2);
					/* no return */
				}
			}
			/* parent exits */
			exit(0);
		}
		/* child continues */
		/* release current directory */
		if (chdir("/") < 0) {
			perror(argv[0]);
			exit(2);
		}
		umask(0);	/* clear file creation mask */
		/* rearrange file streams */
		fclose(stdin);
	}
	/* continue as foreground or background */
	sa_init_logging(argc, argv);
	sa_sig_catch();
	snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Startup complete.", sa_program);
}
static void
sa_mloop(int argc, char *argv[])
{
	if (sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as AgentX client\n", argv[0]);
		/* run as an AgentX client */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
	} else {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master agent\n", argv[0]);
		/* run as SNMP master */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
	}
	if (sa_alarms) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using application alarms\n", argv[0]);
		/* use application alarms */
		ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
	}
	/* initialize agent */
	init_agent("dlMIB");
	/* initialize MIB */
	init_dlMIB();
	/* initialize SNMP */
	init_snmp("dlMIB");
	if (!sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master\n", argv[0]);
#if !defined NETSNMP_DS_APPLICATION_ID
		init_master_agent(710, NULL, NULL);
#else
		init_master_agent();
#endif
	}
	for (;;) {
		int retval;

		/* to use select or poll you need to use the snmp_select_info() to obtain the fd of
		   the agentx socket and add it to the fdset. */
		/* note that SIGALRM is used by snmp: use the snmp_alarm() api instead */
#if 0
		if (snmp_select() == 0) {
			if (sa_alarms == 0)
				run_alarms();
		}
#endif
		retval = agent_check_and_process(1);	/* 0 == don't block */
		if (retval == 0) {
			/* alarm occurred, alarm conditions checked */
		} else if (retval == -1) {
			/* error (or signal) ocurred */
			if (sa_alm_signal) {
				sa_alm_action();
			}
			if (sa_pol_signal) {
				sa_pol_action();
			}
			if (sa_hup_signal) {
				sa_hup_action();
			}
			if (sa_int_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("dlMIB");
				sa_int_action();	/* no return */
			}
			if (sa_trm_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("dlMIB");
				sa_trm_action();	/* no return */
			}
		} else if (retval > 0) {
			/* processed packets */
			if (sa_fclose) {
				/* close files after each request */
				if (sa_fd != 0) {
					int fd = sa_fd;

					sa_fd = 0;
					close(fd);
				}
			}
			sa_stats_refresh = 1;
			sa_request++;
		}
	}
	if (sa_debug)
		snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
	snmp_shutdown("dlMIB");
}

int
main(int argc, char *argv[])
{
	for (;;) {
		int c, val, fd;
		char *cptr;
		struct passwd *pw;
		struct group *gr;
		struct stat st;

#if defined _GNU_SOURCE
		int option_index = 0;
                /* *INDENT-OFF* */
                static struct option long_options[] = {
                        {"log-addresses",	no_argument,		NULL, 'a'},
                        {"append",		no_argument,		NULL, 'A'},
                        {"config-file",		required_argument,	NULL, 'c'},
                        {"no-configs",		no_argument,		NULL, 'C'},
                        {"dump",		no_argument,		NULL, 'd'},
                        {"debug",		optional_argument,	NULL, 'D'},
                        {"debug-tokens",	optional_argument,	NULL, 'D'},
                        {"dont-fork",		no_argument,		NULL, 'f'},
                        {"gid",			required_argument,	NULL, 'g'},
                        {"groupid",		required_argument,	NULL, 'g'},
                        {"help",		no_argument,		NULL, 'h'},
                        {"?",			no_argument,		NULL, 'h'},
                        {"help-directives",	no_argument,		NULL, 'H'},
                        {"initialize",		required_argument,	NULL, 'I'},
                        {"init-modules",	required_argument,	NULL, 'I'},
                        {"keep-open",		no_argument,		NULL, 'k'},
                        {"log-file",		optional_argument,	NULL, 'l'},
                        {"logfile",		optional_argument,	NULL, 'l'},
                        {"Lf",			optional_argument,	NULL, 'l'},
                        {"LF",			required_argument,	NULL, 'l'},
                        {"log-stderr",		no_argument,		NULL, 'L'},
                        {"Le",			no_argument,		NULL, 'L'},
                        {"LE",			required_argument,	NULL, 'L'},
                        {"mibs",		required_argument,	NULL, 'm'},
                        {"master",		no_argument,		NULL, 'M'},
                        {"mibdirs",		required_argument,	NULL, 'M'},
                        {"nodaemon",		no_argument,		NULL, 'n'},
                        {"name",		required_argument,	NULL, 'n'},
                        {"dry-run",		no_argument,		NULL, 'N'},
                        {"log-stdout",		no_argument,		NULL, 'o'},
                        {"Lo",			no_argument,		NULL, 'o'},
                        {"LO",			required_argument,	NULL, 'o'},
                        {"port",		required_argument,	NULL, 'p'},
                        {"pidfile",		required_argument,	NULL, 'P'},
                        {"quiet",		no_argument,		NULL, 'q'},
                        {"quick",		no_argument,		NULL, 'q'},
                        {"noroot",		no_argument,		NULL, 'r'},
                        {"log-syslog",		no_argument,		NULL, 's'},
                        {"Ls",			no_argument,		NULL, 's'},
                        {"LS",			required_argument,	NULL, 's'},
                        {"syslog",		no_argument,		NULL, 's'},
                        {"sysctl-file",		required_argument,	NULL, 'S'},
                        {"agent-alarms",	no_argument,		NULL, 't'},
                        {"transport",		optional_argument,	NULL, 'T'},
                        {"uid",			required_argument,	NULL, 'u'},
                        {"userid",		required_argument,	NULL, 'u'},
                        {"dont-remove-pidfile",	no_argument,		NULL, 'U'},
                        {"leave-pidfile",	no_argument,		NULL, 'U'},
                        {"version",		no_argument,		NULL, 'v'},
                        {"verbose",		optional_argument,	NULL, 'V'},
                        {"agentx-socket",	required_argument,	NULL, 'x'},
                        {"agentx",		no_argument,		NULL, 'X'},
                        {"copying",		no_argument,		NULL, 'y'},
#if 0
                        {"directory",		required_argument,	NULL, 'd'},
                        {"basename",		required_argument,	NULL, 'b'},
                        {"outfile",		required_argument,	NULL, 'o'},
                        {"errfile",		required_argument,	NULL, 'e'},
#endif
                        { 0, }
                };
                /* *INDENT-ON* */

		c = getopt_long_only(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy", long_options, &option_index);
#else				/* defined _GNU_SOURCE */
		c = getopt(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy");
#endif				/* defined _GNU_SOURCE */
		if (c == -1) {
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: done options processing\n", argv[0]);
			break;
		}
		switch (c) {
		case 0:
			goto bad_usage;
		case 'a':	/* -a, --log-addresses */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging addresses\n", argv[0]);
			sa_logaddr++;
			break;
		case 'A':	/* -A, --append */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will not truncate logfile\n", argv[0]);
#if defined NETSNMP_DS_LIB_APPEND_LOGFILES
			ds_set_boolean(DS_LIBRARY_ID, NETSNMP_DS_LIB_APPEND_LOGFILES, 1);
#endif				/* defined NETSNMP_DS_LIB_APPEND_LOGFILES */
			sa_appendlog = 1;
			break;
		case 'c':	/* -c, --config-file CONFIGFILE */
			if (optarg == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using configuration file %s\n", argv[0], optarg);
			ds_set_string(DS_LIBRARY_ID, DS_LIB_OPTIONALCONFIG, optarg);
			break;
		case 'C':	/* -C, --no-configs */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: not reading default config files\n", argv[0]);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DONT_READ_CONFIGS, 1);
			break;
		case 'd':	/* -d, --dump */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting packet dump\n", argv[0]);
			sa_dump = 1;
			// snmp_set_dump_packet(sa_dump);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DUMP_PACKET, sa_dump);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, sa_dump);
			break;
		case 'D':	/* -D, --debug [LEVEL], --debug-tokens [TOKENS] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing debug verbosity\n", argv[0]);
			if (optarg == NULL) {
				/* no option: must be -D, --debug */
				sa_debug++;
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging all tokens\n", argv[0]);
				if (sa_debug)
					debug_register_tokens("ALL");
			} else {
				cptr = optarg;
				if ((val = strtol(optarg, &cptr, 0)) < 0)
					goto bad_option;
				if (*cptr == '\0') {
					/* it is just a number, must be -D, --debug [LEVEL] */
					sa_debug = val;
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				} else {
					/* not a number, must be -D, --debug-tokens TOKENS */
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging tokens %s\n", argv[0], optarg);
					debug_register_tokens(optarg);
				}
			}
			break;
		case 'f':	/* -f, --dont-fork */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing daemon mode\n", argv[0]);
			sa_nomead = 0;
			break;
		case 'u':	/* -u, --uid, --userid UID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* UID can be name or number */
			if ((pw = (*cptr == '\0') ? getpwuid((uid_t) val) : getpwnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as uid %s(%d)\n", argv[0], pw->pw_name, pw->pw_uid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_USERID, pw->pw_uid);
			break;
		case 'g':	/* -g, --gid, --groupdid GID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* GID can be name or number */
			if ((gr = (*cptr == '\0') ? getgrgid((gid_t) val) : getgrnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as gid %s(%d)\n", argv[0], gr->gr_name, gr->gr_gid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_GROUPID, gr->gr_gid);
			break;
		case 'h':	/* -h, --help, -?, --? */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing help message\n", argv[0]);
			sa_help(argc, argv);
			exit(0);
		case 'H':	/* -H, --help-directives */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing config directives\n", argv[0]);
			sa_help_directives(argc, argv);
			exit(0);
		case 'I':	/* -I, --init-modules, --initialize MODULE[{,| |:}MODULE]* */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will initialize modules: %s\n", argv[0], optarg);
			add_to_init_list(optarg);
			break;
		case 'k':	/* -k, --keep-open */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: keeping files open\n", argv[0]);
			sa_fclose = 0;
			break;
		case 'l':	/* -l, --log-file, --logfile, -Lf, -LF p1[-p2] [LOGFILE] */
			if (optarg != NULL)
				strncpy(sa_logfile, optarg, sizeof(sa_logfile));
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will log to file %s\n", argv[0], sa_logfile);
			sa_logfillog = 1;
			break;
		case 'L':	/* -L, --log-stderr, -Le, -LE p1[-p2] */
			/* Note that the recent NET-SNMP version of this option is far more
			   complicated: -Le is the same as the old version of the option; -Lf
			   LOGFILE is like the -l option; -Ls is like the -s option; -Lo logs
			   messages to standard output; -LX p1[-p2] [LOGFILE], where X = E, F, S or
			   O, logs priority p1 and above to X, or p1 thru p2 to X. */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to standard error\n", argv[0]);
			sa_logstderr = 1;
			break;
		case 'm':	/* -m, --mibs MIBS */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBS %s\n", argv[0], optarg);
			break;
		case 'M':	/* -M, --master or -M, --mibdirs MIBDIRS */
			if (optarg) {
				/* -M, --mibdirs MIBDIRS */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBDIRS %s\n", argv[0], optarg);
			} else {
				/* -M, --master */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting SNMP master\n", argv[0]);
				sa_agentx = 0;
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
			}
			break;
		case 'n':	/* -n, --nodaemon or -n, --name NAME */
			if (optarg) {
				/* -n, --name NAME */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using name %s\n", argv[0], optarg);
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, optarg);
			} else {
				/* -n, --nodaemon */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing deamon mode\n", argv[0]);
				sa_nomead = 0;
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, basename(argv[0]));
			}
			break;
		case 'N':	/* -N, --dry-run */
#if defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for dry-runs startup\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_QUIT_IMMEDIATELY, 1);
			break;
#else				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -N option not supported\n", argv[0]);
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
		case 'o':	/* -o, --log-stdout, -Lo, -LO p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to stdout\n", argv[0]);
			sa_logstdout = 1;
			break;
		case 'p':	/* -p, --port PORTNUM or -p, --pidfile PIDFILE */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0 || val > 16383)
				goto bad_option;
			if (*cptr == '\0') {
				char buf[4096];

				/* -p, --port PORTNUM */
				if ((cptr = ds_get_string(DS_APPLICATION_ID, DS_AGENT_PORTS)))
					snprintf(buf, sizeof(buf), "%s,%s", cptr, optarg);
				else
					strncpy(buf, optarg, sizeof(buf));
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PORTS, buf);
				break;
			}
			/* fall through */
		case 'P':	/* -p, -P, --pidfile PIDFILE */
			if (optarg) {
				/* either it exists */
				if (stat(optarg, &st) == -1) {
					/* or we can create it */
					if ((fd = open(optarg, O_CREAT, 0600)) == -1) {
						perror(argv[0]);
						goto bad_option;
					}
					close(fd);
				}
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting pid file to %s\n", argv[0], optarg);
				strncpy(sa_pidfile, optarg, sizeof(sa_pidfile));
			}
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using pidfile %s\n", argv[0], sa_pidfile);
			break;
		case 'q':	/* -q, --quiet, --quick */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing normal output\n", argv[0]);
			sa_debug = 0;
			sa_output = 0;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			// snmp_set_quick_print();
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_QUICK_PRINT, 1);
			break;
		case 'r':	/* -r, --noroot */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for non-root access\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
			break;
		case 's':	/* -s, --log-syslog, -Ls, -LS p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to system logs\n", argv[0]);
			sa_logsyslog = 1;
			break;
		case 'S':	/* -S, -sysctl-file FILENAME */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using %s for backing\n", argv[0], optarg);
			strncpy(sa_sysctlf, optarg, sizeof(sa_sysctlf));
			break;
		case 't':	/* -t, --agent-alarms */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting agent alarms\n", argv[0]);
			sa_alarms = 0;
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
			break;
		case 'T':	/* -T, --transport [TRANSPORT] */
			if (optarg == NULL)
				goto udp_transport;
			if (!strcasecmp("TCP", optarg)) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to TCP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val |= SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else if (!strcasecmp("UDP", optarg)) {
			      udp_transport:
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to UDP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val &= ~SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else
				goto bad_option;
			break;
		case 'U':
#if defined NETSNMP_DS_AGENT_LEAVE_PIDFILE
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will leave pidfile after shutdown\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_LEAVE_PIDFILE, 1);
#else
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -U option not supported\n");
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_LEAVE_PIDFILE */
			break;
		case 'v':	/* -v, --version */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing version message\n", argv[0]);
			sa_version(argc, argv);
			exit(0);
		case 'V':	/* -V, --verbose [LEVEL] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing output verbosity\n", argv[0]);
			if (optarg == NULL) {
				sa_output++;
			} else {
				if ((val = strtol(optarg, NULL, 0)) < 0)
					goto bad_option;
				sa_output = val;
			}
			if (sa_output > 1)
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 1);
			else
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			break;
		case 'x':	/* -x, --agentx-socket SOCKET */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX socket to %s\n", argv[0], optarg);
			ds_set_string(DS_APPLICATION_ID, DS_AGENT_X_SOCKET, optarg);
			// ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_AGENTX_MASTER, 1);
			break;
		case 'X':	/* -X, --agentx */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX sub-agent\n", argv[0]);
			sa_agentx = 1;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
			break;
		case 'y':	/* -y, --copying */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing copying message\n", argv[0]);
			sa_copying(argc, argv);
			exit(0);
		case '?':
		case ':':
		default:
		      bad_option:
			optind--;
			goto bad_nonopt;
		      bad_nonopt:
			if (sa_output || sa_debug) {
				if (optind < argc) {
					fprintf(stderr, "%s: syntax error near '", argv[0]);
					while (optind < argc)
						fprintf(stderr, "%s ", argv[optind++]);
					fprintf(stderr, "'\n");
				} else {
					fprintf(stderr, "%s: missing option or argument", argv[0]);
					fprintf(stderr, "\n");
				}
				fflush(stderr);
			      bad_usage:
				sa_usage(argc, argv);
			}
			exit(2);
		}
	}
	if (optind < argc) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: excess non-option arguments\n", argv[0]);
		goto bad_nonopt;
	}
	sa_enter(argc, argv);	/* daemonize if necessary */
	sa_mloop(argc, argv);	/* execute main loop */
	exit(0);
}
#endif				/* !defined MODULE */
